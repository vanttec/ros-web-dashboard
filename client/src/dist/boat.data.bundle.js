/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EffectScope\": function() { return /* binding */ EffectScope; },\n/* harmony export */   \"ITERATE_KEY\": function() { return /* binding */ ITERATE_KEY; },\n/* harmony export */   \"ReactiveEffect\": function() { return /* binding */ ReactiveEffect; },\n/* harmony export */   \"computed\": function() { return /* binding */ computed; },\n/* harmony export */   \"customRef\": function() { return /* binding */ customRef; },\n/* harmony export */   \"deferredComputed\": function() { return /* binding */ deferredComputed; },\n/* harmony export */   \"effect\": function() { return /* binding */ effect; },\n/* harmony export */   \"effectScope\": function() { return /* binding */ effectScope; },\n/* harmony export */   \"enableTracking\": function() { return /* binding */ enableTracking; },\n/* harmony export */   \"getCurrentScope\": function() { return /* binding */ getCurrentScope; },\n/* harmony export */   \"isProxy\": function() { return /* binding */ isProxy; },\n/* harmony export */   \"isReactive\": function() { return /* binding */ isReactive; },\n/* harmony export */   \"isReadonly\": function() { return /* binding */ isReadonly; },\n/* harmony export */   \"isRef\": function() { return /* binding */ isRef; },\n/* harmony export */   \"isShallow\": function() { return /* binding */ isShallow; },\n/* harmony export */   \"markRaw\": function() { return /* binding */ markRaw; },\n/* harmony export */   \"onScopeDispose\": function() { return /* binding */ onScopeDispose; },\n/* harmony export */   \"pauseTracking\": function() { return /* binding */ pauseTracking; },\n/* harmony export */   \"proxyRefs\": function() { return /* binding */ proxyRefs; },\n/* harmony export */   \"reactive\": function() { return /* binding */ reactive; },\n/* harmony export */   \"readonly\": function() { return /* binding */ readonly; },\n/* harmony export */   \"ref\": function() { return /* binding */ ref; },\n/* harmony export */   \"resetTracking\": function() { return /* binding */ resetTracking; },\n/* harmony export */   \"shallowReactive\": function() { return /* binding */ shallowReactive; },\n/* harmony export */   \"shallowReadonly\": function() { return /* binding */ shallowReadonly; },\n/* harmony export */   \"shallowRef\": function() { return /* binding */ shallowRef; },\n/* harmony export */   \"stop\": function() { return /* binding */ stop; },\n/* harmony export */   \"toRaw\": function() { return /* binding */ toRaw; },\n/* harmony export */   \"toRef\": function() { return /* binding */ toRef; },\n/* harmony export */   \"toRefs\": function() { return /* binding */ toRefs; },\n/* harmony export */   \"track\": function() { return /* binding */ track; },\n/* harmony export */   \"trigger\": function() { return /* binding */ trigger; },\n/* harmony export */   \"triggerRef\": function() { return /* binding */ triggerRef; },\n/* harmony export */   \"unref\": function() { return /* binding */ unref; }\n/* harmony export */ });\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\nfunction warn(msg, ...args) {\r\n    console.warn(`[Vue warn] ${msg}`, ...args);\r\n}\n\nlet activeEffectScope;\r\nclass EffectScope {\r\n    constructor(detached = false) {\r\n        /**\r\n         * @internal\r\n         */\r\n        this.active = true;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.effects = [];\r\n        /**\r\n         * @internal\r\n         */\r\n        this.cleanups = [];\r\n        if (!detached && activeEffectScope) {\r\n            this.parent = activeEffectScope;\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    run(fn) {\r\n        if (this.active) {\r\n            const currentEffectScope = activeEffectScope;\r\n            try {\r\n                activeEffectScope = this;\r\n                return fn();\r\n            }\r\n            finally {\r\n                activeEffectScope = currentEffectScope;\r\n            }\r\n        }\r\n        else if ((true)) {\r\n            warn(`cannot run an inactive effect scope.`);\r\n        }\r\n    }\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    on() {\r\n        activeEffectScope = this;\r\n    }\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    off() {\r\n        activeEffectScope = this.parent;\r\n    }\r\n    stop(fromParent) {\r\n        if (this.active) {\r\n            let i, l;\r\n            for (i = 0, l = this.effects.length; i < l; i++) {\r\n                this.effects[i].stop();\r\n            }\r\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n                this.cleanups[i]();\r\n            }\r\n            if (this.scopes) {\r\n                for (i = 0, l = this.scopes.length; i < l; i++) {\r\n                    this.scopes[i].stop(true);\r\n                }\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                const last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\nfunction recordEffectScope(effect, scope = activeEffectScope) {\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else if ((true)) {\r\n        warn(`onScopeDispose() is called when there is no active effect scope` +\r\n            ` to be associated with.`);\r\n    }\r\n}\n\nconst createDep = (effects) => {\r\n    const dep = new Set(effects);\r\n    dep.w = 0;\r\n    dep.n = 0;\r\n    return dep;\r\n};\r\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\r\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\r\nconst initDepMarkers = ({ deps }) => {\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].w |= trackOpBit; // set was tracked\r\n        }\r\n    }\r\n};\r\nconst finalizeDepMarkers = (effect) => {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        let ptr = 0;\r\n        for (let i = 0; i < deps.length; i++) {\r\n            const dep = deps[i];\r\n            if (wasTracked(dep) && !newTracked(dep)) {\r\n                dep.delete(effect);\r\n            }\r\n            else {\r\n                deps[ptr++] = dep;\r\n            }\r\n            // clear bits\r\n            dep.w &= ~trackOpBit;\r\n            dep.n &= ~trackOpBit;\r\n        }\r\n        deps.length = ptr;\r\n    }\r\n};\n\nconst targetMap = new WeakMap();\r\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0;\r\nlet trackOpBit = 1;\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30;\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);\r\nconst MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);\r\nclass ReactiveEffect {\r\n    constructor(fn, scheduler = null, scope) {\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n        this.active = true;\r\n        this.deps = [];\r\n        this.parent = undefined;\r\n        recordEffectScope(this, scope);\r\n    }\r\n    run() {\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        let parent = activeEffect;\r\n        let lastShouldTrack = shouldTrack;\r\n        while (parent) {\r\n            if (parent === this) {\r\n                return;\r\n            }\r\n            parent = parent.parent;\r\n        }\r\n        try {\r\n            this.parent = activeEffect;\r\n            activeEffect = this;\r\n            shouldTrack = true;\r\n            trackOpBit = 1 << ++effectTrackDepth;\r\n            if (effectTrackDepth <= maxMarkerBits) {\r\n                initDepMarkers(this);\r\n            }\r\n            else {\r\n                cleanupEffect(this);\r\n            }\r\n            return this.fn();\r\n        }\r\n        finally {\r\n            if (effectTrackDepth <= maxMarkerBits) {\r\n                finalizeDepMarkers(this);\r\n            }\r\n            trackOpBit = 1 << --effectTrackDepth;\r\n            activeEffect = this.parent;\r\n            shouldTrack = lastShouldTrack;\r\n            this.parent = undefined;\r\n            if (this.deferStop) {\r\n                this.stop();\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        // stopped while running itself - defer the cleanup\r\n        if (activeEffect === this) {\r\n            this.deferStop = true;\r\n        }\r\n        else if (this.active) {\r\n            cleanupEffect(this);\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction cleanupEffect(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nfunction effect(fn, options) {\r\n    if (fn.effect) {\r\n        fn = fn.effect.fn;\r\n    }\r\n    const _effect = new ReactiveEffect(fn);\r\n    if (options) {\r\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(_effect, options);\r\n        if (options.scope)\r\n            recordEffectScope(_effect, options.scope);\r\n    }\r\n    if (!options || !options.lazy) {\r\n        _effect.run();\r\n    }\r\n    const runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\nfunction stop(runner) {\r\n    runner.effect.stop();\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (shouldTrack && activeEffect) {\r\n        let depsMap = targetMap.get(target);\r\n        if (!depsMap) {\r\n            targetMap.set(target, (depsMap = new Map()));\r\n        }\r\n        let dep = depsMap.get(key);\r\n        if (!dep) {\r\n            depsMap.set(key, (dep = createDep()));\r\n        }\r\n        const eventInfo = ( true)\r\n            ? { effect: activeEffect, target, type, key }\r\n            : 0;\r\n        trackEffects(dep, eventInfo);\r\n    }\r\n}\r\nfunction trackEffects(dep, debuggerEventExtraInfo) {\r\n    let shouldTrack = false;\r\n    if (effectTrackDepth <= maxMarkerBits) {\r\n        if (!newTracked(dep)) {\r\n            dep.n |= trackOpBit; // set newly tracked\r\n            shouldTrack = !wasTracked(dep);\r\n        }\r\n    }\r\n    else {\r\n        // Full cleanup mode.\r\n        shouldTrack = !dep.has(activeEffect);\r\n    }\r\n    if (shouldTrack) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if (( true) && activeEffect.onTrack) {\r\n            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    let deps = [];\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        deps = [...depsMap.values()];\r\n    }\r\n    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                deps.push(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            deps.push(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {\r\n                    // new index added to array -> length changes\r\n                    deps.push(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const eventInfo = ( true)\r\n        ? { target, type, key, newValue, oldValue, oldTarget }\r\n        : 0;\r\n    if (deps.length === 1) {\r\n        if (deps[0]) {\r\n            if ((true)) {\r\n                triggerEffects(deps[0], eventInfo);\r\n            }\r\n            else {}\r\n        }\r\n    }\r\n    else {\r\n        const effects = [];\r\n        for (const dep of deps) {\r\n            if (dep) {\r\n                effects.push(...dep);\r\n            }\r\n        }\r\n        if ((true)) {\r\n            triggerEffects(createDep(effects), eventInfo);\r\n        }\r\n        else {}\r\n    }\r\n}\r\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\r\n    // spread into array for stabilization\r\n    const effects = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep) ? dep : [...dep];\r\n    for (const effect of effects) {\r\n        if (effect.computed) {\r\n            triggerEffect(effect, debuggerEventExtraInfo);\r\n        }\r\n    }\r\n    for (const effect of effects) {\r\n        if (!effect.computed) {\r\n            triggerEffect(effect, debuggerEventExtraInfo);\r\n        }\r\n    }\r\n}\r\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\r\n    if (effect !== activeEffect || effect.allowRecurse) {\r\n        if (( true) && effect.onTrigger) {\r\n            effect.onTrigger((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({ effect }, debuggerEventExtraInfo));\r\n        }\r\n        if (effect.scheduler) {\r\n            effect.scheduler();\r\n        }\r\n        else {\r\n            effect.run();\r\n        }\r\n    }\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(\r\n/*#__PURE__*/\r\nObject.getOwnPropertyNames(Symbol)\r\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\r\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\r\n    // function\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => Symbol[key])\r\n    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\r\nfunction createArrayInstrumentations() {\r\n    const instrumentations = {};\r\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            const arr = toRaw(this);\r\n            for (let i = 0, l = this.length; i < l; i++) {\r\n                track(arr, \"get\" /* GET */, i + '');\r\n            }\r\n            // we run the method using the original args first (which may be reactive)\r\n            const res = arr[key](...args);\r\n            if (res === -1 || res === false) {\r\n                // if that didn't work, run it again using raw values.\r\n                return arr[key](...args.map(toRaw));\r\n            }\r\n            else {\r\n                return res;\r\n            }\r\n        };\r\n    });\r\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            pauseTracking();\r\n            const res = toRaw(this)[key].apply(this, args);\r\n            resetTracking();\r\n            return res;\r\n        };\r\n    });\r\n    return instrumentations;\r\n}\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_isShallow\" /* IS_SHALLOW */) {\r\n            return shallow;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);\r\n        if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - skip unwrap for Array + integer key.\r\n            return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? res : res.value;\r\n        }\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\r\n            return false;\r\n        }\r\n        if (!shallow && !isReadonly(value)) {\r\n            if (!isShallow(value)) {\r\n                value = toRaw(value);\r\n                oldValue = toRaw(oldValue);\r\n            }\r\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)\r\n            ? Number(key) < target.length\r\n            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((true)) {\r\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((true)) {\r\n            warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (!isReadonly) {\r\n        if (key !== rawKey) {\r\n            track(rawTarget, \"get\" /* GET */, key);\r\n        }\r\n        track(rawTarget, \"get\" /* GET */, rawKey);\r\n    }\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n    else if (target !== rawTarget) {\r\n        // #3602 readonly(reactive(Map))\r\n        // ensure that the nested reactive `Map` can do tracking for itself\r\n        target.get(key);\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (!isReadonly) {\r\n        if (key !== rawKey) {\r\n            track(rawTarget, \"has\" /* HAS */, key);\r\n        }\r\n        track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    }\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((true)) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((true)) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = ( true)\r\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : 0;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((true)) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nfunction createInstrumentations() {\r\n    const mutableInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, false)\r\n    };\r\n    const shallowInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, false, true);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, true)\r\n    };\r\n    const readonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, false)\r\n    };\r\n    const shallowReadonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, true)\r\n    };\r\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\n    iteratorMethods.forEach(method => {\r\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n    });\r\n    return [\r\n        mutableInstrumentations,\r\n        readonlyInstrumentations,\r\n        shallowInstrumentations,\r\n        shallowReadonlyInstrumentations\r\n    ];\r\n}\r\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (isReadonly(target)) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {\r\n        if ((true)) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only specific value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isShallow(value) {\r\n    return !!(value && value[\"__v_isShallow\" /* IS_SHALLOW */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    const raw = observed && observed[\"__v_raw\" /* RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\r\nconst toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\r\n    if (shouldTrack && activeEffect) {\r\n        ref = toRaw(ref);\r\n        if ((true)) {\r\n            trackEffects(ref.dep || (ref.dep = createDep()), {\r\n                target: ref,\r\n                type: \"get\" /* GET */,\r\n                key: 'value'\r\n            });\r\n        }\r\n        else {}\r\n    }\r\n}\r\nfunction triggerRefValue(ref, newVal) {\r\n    ref = toRaw(ref);\r\n    if (ref.dep) {\r\n        if ((true)) {\r\n            triggerEffects(ref.dep, {\r\n                target: ref,\r\n                type: \"set\" /* SET */,\r\n                key: 'value',\r\n                newValue: newVal\r\n            });\r\n        }\r\n        else {}\r\n    }\r\n}\r\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nclass RefImpl {\r\n    constructor(value, __v_isShallow) {\r\n        this.__v_isShallow = __v_isShallow;\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        this._rawValue = __v_isShallow ? value : toRaw(value);\r\n        this._value = __v_isShallow ? value : toReactive(value);\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        newVal = this.__v_isShallow ? newVal : toRaw(newVal);\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this.__v_isShallow ? newVal : toReactive(newVal);\r\n            triggerRefValue(this, newVal);\r\n        }\r\n    }\r\n}\r\nfunction triggerRef(ref) {\r\n    triggerRefValue(ref, ( true) ? ref.value : 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if (( true) && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key, _defaultValue) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this._defaultValue = _defaultValue;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        const val = this._object[this._key];\r\n        return val === undefined ? this._defaultValue : val;\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    const val = object[key];\r\n    return isRef(val)\r\n        ? val\r\n        : new ObjectRefImpl(object, key, defaultValue);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly, isSSR) {\r\n        this._setter = _setter;\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        this._dirty = true;\r\n        this.effect = new ReactiveEffect(getter, () => {\r\n            if (!this._dirty) {\r\n                this._dirty = true;\r\n                triggerRefValue(this);\r\n            }\r\n        });\r\n        this.effect.computed = this;\r\n        this.effect.active = this._cacheable = !isSSR;\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        trackRefValue(self);\r\n        if (self._dirty || !self._cacheable) {\r\n            self._dirty = false;\r\n            self._value = self.effect.run();\r\n        }\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\r\n    let getter;\r\n    let setter;\r\n    const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter = ( true)\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : 0;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\r\n    if (( true) && debugOptions && !isSSR) {\r\n        cRef.effect.onTrack = debugOptions.onTrack;\r\n        cRef.effect.onTrigger = debugOptions.onTrigger;\r\n    }\r\n    return cRef;\r\n}\n\nvar _a;\r\nconst tick = /*#__PURE__*/ Promise.resolve();\r\nconst queue = [];\r\nlet queued = false;\r\nconst scheduler = (fn) => {\r\n    queue.push(fn);\r\n    if (!queued) {\r\n        queued = true;\r\n        tick.then(flush);\r\n    }\r\n};\r\nconst flush = () => {\r\n    for (let i = 0; i < queue.length; i++) {\r\n        queue[i]();\r\n    }\r\n    queue.length = 0;\r\n    queued = false;\r\n};\r\nclass DeferredComputedRefImpl {\r\n    constructor(getter) {\r\n        this.dep = undefined;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this[_a] = true;\r\n        let compareTarget;\r\n        let hasCompareTarget = false;\r\n        let scheduled = false;\r\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\r\n            if (this.dep) {\r\n                if (computedTrigger) {\r\n                    compareTarget = this._value;\r\n                    hasCompareTarget = true;\r\n                }\r\n                else if (!scheduled) {\r\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\r\n                    scheduled = true;\r\n                    hasCompareTarget = false;\r\n                    scheduler(() => {\r\n                        if (this.effect.active && this._get() !== valueToCompare) {\r\n                            triggerRefValue(this);\r\n                        }\r\n                        scheduled = false;\r\n                    });\r\n                }\r\n                // chained upstream computeds are notified synchronously to ensure\r\n                // value invalidation in case of sync access; normal effects are\r\n                // deferred to be triggered in scheduler.\r\n                for (const e of this.dep) {\r\n                    if (e.computed instanceof DeferredComputedRefImpl) {\r\n                        e.scheduler(true /* computedTrigger */);\r\n                    }\r\n                }\r\n            }\r\n            this._dirty = true;\r\n        });\r\n        this.effect.computed = this;\r\n    }\r\n    _get() {\r\n        if (this._dirty) {\r\n            this._dirty = false;\r\n            return (this._value = this.effect.run());\r\n        }\r\n        return this._value;\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        return toRaw(this)._get();\r\n    }\r\n}\r\n_a = \"__v_isReadonly\" /* IS_READONLY */;\r\nfunction deferredComputed(getter) {\r\n    return new DeferredComputedRefImpl(getter);\r\n}\n\n\n\n\n//# sourceURL=webpack://web-dashboard/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTransition\": function() { return /* binding */ BaseTransition; },\n/* harmony export */   \"Comment\": function() { return /* binding */ Comment; },\n/* harmony export */   \"EffectScope\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },\n/* harmony export */   \"Fragment\": function() { return /* binding */ Fragment; },\n/* harmony export */   \"KeepAlive\": function() { return /* binding */ KeepAlive; },\n/* harmony export */   \"ReactiveEffect\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect; },\n/* harmony export */   \"Static\": function() { return /* binding */ Static; },\n/* harmony export */   \"Suspense\": function() { return /* binding */ Suspense; },\n/* harmony export */   \"Teleport\": function() { return /* binding */ Teleport; },\n/* harmony export */   \"Text\": function() { return /* binding */ Text; },\n/* harmony export */   \"callWithAsyncErrorHandling\": function() { return /* binding */ callWithAsyncErrorHandling; },\n/* harmony export */   \"callWithErrorHandling\": function() { return /* binding */ callWithErrorHandling; },\n/* harmony export */   \"camelize\": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize; },\n/* harmony export */   \"capitalize\": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize; },\n/* harmony export */   \"cloneVNode\": function() { return /* binding */ cloneVNode; },\n/* harmony export */   \"compatUtils\": function() { return /* binding */ compatUtils; },\n/* harmony export */   \"computed\": function() { return /* binding */ computed; },\n/* harmony export */   \"createBlock\": function() { return /* binding */ createBlock; },\n/* harmony export */   \"createCommentVNode\": function() { return /* binding */ createCommentVNode; },\n/* harmony export */   \"createElementBlock\": function() { return /* binding */ createElementBlock; },\n/* harmony export */   \"createElementVNode\": function() { return /* binding */ createBaseVNode; },\n/* harmony export */   \"createHydrationRenderer\": function() { return /* binding */ createHydrationRenderer; },\n/* harmony export */   \"createPropsRestProxy\": function() { return /* binding */ createPropsRestProxy; },\n/* harmony export */   \"createRenderer\": function() { return /* binding */ createRenderer; },\n/* harmony export */   \"createSlots\": function() { return /* binding */ createSlots; },\n/* harmony export */   \"createStaticVNode\": function() { return /* binding */ createStaticVNode; },\n/* harmony export */   \"createTextVNode\": function() { return /* binding */ createTextVNode; },\n/* harmony export */   \"createVNode\": function() { return /* binding */ createVNode; },\n/* harmony export */   \"customRef\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef; },\n/* harmony export */   \"defineAsyncComponent\": function() { return /* binding */ defineAsyncComponent; },\n/* harmony export */   \"defineComponent\": function() { return /* binding */ defineComponent; },\n/* harmony export */   \"defineEmits\": function() { return /* binding */ defineEmits; },\n/* harmony export */   \"defineExpose\": function() { return /* binding */ defineExpose; },\n/* harmony export */   \"defineProps\": function() { return /* binding */ defineProps; },\n/* harmony export */   \"devtools\": function() { return /* binding */ devtools; },\n/* harmony export */   \"effect\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect; },\n/* harmony export */   \"effectScope\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope; },\n/* harmony export */   \"getCurrentInstance\": function() { return /* binding */ getCurrentInstance; },\n/* harmony export */   \"getCurrentScope\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },\n/* harmony export */   \"getTransitionRawChildren\": function() { return /* binding */ getTransitionRawChildren; },\n/* harmony export */   \"guardReactiveProps\": function() { return /* binding */ guardReactiveProps; },\n/* harmony export */   \"h\": function() { return /* binding */ h; },\n/* harmony export */   \"handleError\": function() { return /* binding */ handleError; },\n/* harmony export */   \"initCustomFormatter\": function() { return /* binding */ initCustomFormatter; },\n/* harmony export */   \"inject\": function() { return /* binding */ inject; },\n/* harmony export */   \"isMemoSame\": function() { return /* binding */ isMemoSame; },\n/* harmony export */   \"isProxy\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy; },\n/* harmony export */   \"isReactive\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive; },\n/* harmony export */   \"isReadonly\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },\n/* harmony export */   \"isRef\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef; },\n/* harmony export */   \"isRuntimeOnly\": function() { return /* binding */ isRuntimeOnly; },\n/* harmony export */   \"isShallow\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow; },\n/* harmony export */   \"isVNode\": function() { return /* binding */ isVNode; },\n/* harmony export */   \"markRaw\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw; },\n/* harmony export */   \"mergeDefaults\": function() { return /* binding */ mergeDefaults; },\n/* harmony export */   \"mergeProps\": function() { return /* binding */ mergeProps; },\n/* harmony export */   \"nextTick\": function() { return /* binding */ nextTick; },\n/* harmony export */   \"normalizeClass\": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass; },\n/* harmony export */   \"normalizeProps\": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps; },\n/* harmony export */   \"normalizeStyle\": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle; },\n/* harmony export */   \"onActivated\": function() { return /* binding */ onActivated; },\n/* harmony export */   \"onBeforeMount\": function() { return /* binding */ onBeforeMount; },\n/* harmony export */   \"onBeforeUnmount\": function() { return /* binding */ onBeforeUnmount; },\n/* harmony export */   \"onBeforeUpdate\": function() { return /* binding */ onBeforeUpdate; },\n/* harmony export */   \"onDeactivated\": function() { return /* binding */ onDeactivated; },\n/* harmony export */   \"onErrorCaptured\": function() { return /* binding */ onErrorCaptured; },\n/* harmony export */   \"onMounted\": function() { return /* binding */ onMounted; },\n/* harmony export */   \"onRenderTracked\": function() { return /* binding */ onRenderTracked; },\n/* harmony export */   \"onRenderTriggered\": function() { return /* binding */ onRenderTriggered; },\n/* harmony export */   \"onScopeDispose\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },\n/* harmony export */   \"onServerPrefetch\": function() { return /* binding */ onServerPrefetch; },\n/* harmony export */   \"onUnmounted\": function() { return /* binding */ onUnmounted; },\n/* harmony export */   \"onUpdated\": function() { return /* binding */ onUpdated; },\n/* harmony export */   \"openBlock\": function() { return /* binding */ openBlock; },\n/* harmony export */   \"popScopeId\": function() { return /* binding */ popScopeId; },\n/* harmony export */   \"provide\": function() { return /* binding */ provide; },\n/* harmony export */   \"proxyRefs\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },\n/* harmony export */   \"pushScopeId\": function() { return /* binding */ pushScopeId; },\n/* harmony export */   \"queuePostFlushCb\": function() { return /* binding */ queuePostFlushCb; },\n/* harmony export */   \"reactive\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive; },\n/* harmony export */   \"readonly\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly; },\n/* harmony export */   \"ref\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref; },\n/* harmony export */   \"registerRuntimeCompiler\": function() { return /* binding */ registerRuntimeCompiler; },\n/* harmony export */   \"renderList\": function() { return /* binding */ renderList; },\n/* harmony export */   \"renderSlot\": function() { return /* binding */ renderSlot; },\n/* harmony export */   \"resolveComponent\": function() { return /* binding */ resolveComponent; },\n/* harmony export */   \"resolveDirective\": function() { return /* binding */ resolveDirective; },\n/* harmony export */   \"resolveDynamicComponent\": function() { return /* binding */ resolveDynamicComponent; },\n/* harmony export */   \"resolveFilter\": function() { return /* binding */ resolveFilter; },\n/* harmony export */   \"resolveTransitionHooks\": function() { return /* binding */ resolveTransitionHooks; },\n/* harmony export */   \"setBlockTracking\": function() { return /* binding */ setBlockTracking; },\n/* harmony export */   \"setDevtoolsHook\": function() { return /* binding */ setDevtoolsHook; },\n/* harmony export */   \"setTransitionHooks\": function() { return /* binding */ setTransitionHooks; },\n/* harmony export */   \"shallowReactive\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },\n/* harmony export */   \"shallowReadonly\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },\n/* harmony export */   \"shallowRef\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },\n/* harmony export */   \"ssrContextKey\": function() { return /* binding */ ssrContextKey; },\n/* harmony export */   \"ssrUtils\": function() { return /* binding */ ssrUtils; },\n/* harmony export */   \"stop\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop; },\n/* harmony export */   \"toDisplayString\": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString; },\n/* harmony export */   \"toHandlerKey\": function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey; },\n/* harmony export */   \"toHandlers\": function() { return /* binding */ toHandlers; },\n/* harmony export */   \"toRaw\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw; },\n/* harmony export */   \"toRef\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef; },\n/* harmony export */   \"toRefs\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs; },\n/* harmony export */   \"transformVNodeArgs\": function() { return /* binding */ transformVNodeArgs; },\n/* harmony export */   \"triggerRef\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },\n/* harmony export */   \"unref\": function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref; },\n/* harmony export */   \"useAttrs\": function() { return /* binding */ useAttrs; },\n/* harmony export */   \"useSSRContext\": function() { return /* binding */ useSSRContext; },\n/* harmony export */   \"useSlots\": function() { return /* binding */ useSlots; },\n/* harmony export */   \"useTransitionState\": function() { return /* binding */ useTransitionState; },\n/* harmony export */   \"version\": function() { return /* binding */ version; },\n/* harmony export */   \"warn\": function() { return /* binding */ warn; },\n/* harmony export */   \"watch\": function() { return /* binding */ watch; },\n/* harmony export */   \"watchEffect\": function() { return /* binding */ watchEffect; },\n/* harmony export */   \"watchPostEffect\": function() { return /* binding */ watchPostEffect; },\n/* harmony export */   \"watchSyncEffect\": function() { return /* binding */ watchSyncEffect; },\n/* harmony export */   \"withAsyncContext\": function() { return /* binding */ withAsyncContext; },\n/* harmony export */   \"withCtx\": function() { return /* binding */ withCtx; },\n/* harmony export */   \"withDefaults\": function() { return /* binding */ withDefaults; },\n/* harmony export */   \"withDirectives\": function() { return /* binding */ withDirectives; },\n/* harmony export */   \"withMemo\": function() { return /* binding */ withMemo; },\n/* harmony export */   \"withScopeId\": function() { return /* binding */ withScopeId; }\n/* harmony export */ });\n/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ \"./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\n\n\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {\r\n        value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"sp\" /* SERVER_PREFETCH */]: 'serverPrefetch hook',\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((true)) {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n    else {}\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job's id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(id) {\r\n    // the start index should be `flushIndex + 1`\r\n    let start = flushIndex + 1;\r\n    let end = queue.length;\r\n    while (start < end) {\r\n        const middle = (start + end) >>> 1;\r\n        const middleJobId = getId(queue[middle]);\r\n        middleJobId < id ? (start = middle + 1) : (end = middle);\r\n    }\r\n    return start;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        if (job.id == null) {\r\n            queue.push(job);\r\n        }\r\n        else {\r\n            queue.splice(findInsertionIndex(job.id), 0, job);\r\n        }\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction invalidateJob(job) {\r\n    const i = queue.indexOf(job);\r\n    if (i > flushIndex) {\r\n        queue.splice(i, 1);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((true)) {\r\n            seen = seen || new Map();\r\n        }\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if (( true) &&\r\n                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {\r\n                continue;\r\n            }\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    // flush any pre cbs queued during the flush (e.g. pre watchers)\r\n    flushPreFlushCbs();\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((true)) {\r\n            seen = seen || new Map();\r\n        }\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if (( true) &&\r\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {\r\n                continue;\r\n            }\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((true)) {\r\n        seen = seen || new Map();\r\n    }\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    // conditional usage of checkRecursiveUpdate must be determined out of\r\n    // try ... catch block since Rollup by default de-optimizes treeshaking\r\n    // inside try-catch. This can leave all warning code unshaked. Although\r\n    // they would get eventually shaken by a minifier like terser, some minifiers\r\n    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\r\n    const check = ( true)\r\n        ? (job) => checkRecursiveUpdates(seen, job)\r\n        : 0;\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job && job.active !== false) {\r\n                if (( true) && check(job)) {\r\n                    continue;\r\n                }\r\n                // console.log(`running:`, job.id)\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length ||\r\n            pendingPreFlushCbs.length ||\r\n            pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            const instance = fn.ownerInstance;\r\n            const componentName = instance && getComponentName(instance.type);\r\n            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n            return true;\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\n\n/* eslint-disable no-restricted-globals */\r\nlet isHmrUpdating = false;\r\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((true)) {\r\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {\r\n        createRecord: tryWrap(createRecord),\r\n        rerender: tryWrap(rerender),\r\n        reload: tryWrap(reload)\r\n    };\r\n}\r\nconst map = new Map();\r\nfunction registerHMR(instance) {\r\n    const id = instance.type.__hmrId;\r\n    let record = map.get(id);\r\n    if (!record) {\r\n        createRecord(id, instance.type);\r\n        record = map.get(id);\r\n    }\r\n    record.instances.add(instance);\r\n}\r\nfunction unregisterHMR(instance) {\r\n    map.get(instance.type.__hmrId).instances.delete(instance);\r\n}\r\nfunction createRecord(id, initialDef) {\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        initialDef: normalizeClassComponent(initialDef),\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction normalizeClassComponent(component) {\r\n    return isClassComponent(component) ? component.__vccOpts : component;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record) {\r\n        return;\r\n    }\r\n    // update initial record (for not-yet-rendered component)\r\n    record.initialDef.render = newRender;\r\n    [...record.instances].forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n            normalizeClassComponent(instance.type).render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        // this flag forces child components with slot content to update\r\n        isHmrUpdating = true;\r\n        instance.update();\r\n        isHmrUpdating = false;\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    newComp = normalizeClassComponent(newComp);\r\n    // update initial def (for not-yet-rendered components)\r\n    updateComponentDef(record.initialDef, newComp);\r\n    // create a snapshot which avoids the set being mutated during updates\r\n    const instances = [...record.instances];\r\n    for (const instance of instances) {\r\n        const oldComp = normalizeClassComponent(instance.type);\r\n        if (!hmrDirtyComponents.has(oldComp)) {\r\n            // 1. Update existing comp definition to match new one\r\n            if (oldComp !== record.initialDef) {\r\n                updateComponentDef(oldComp, newComp);\r\n            }\r\n            // 2. mark definition dirty. This forces the renderer to replace the\r\n            // component on patch.\r\n            hmrDirtyComponents.add(oldComp);\r\n        }\r\n        // 3. invalidate options resolution cache\r\n        instance.appContext.optionsCache.delete(instance.type);\r\n        // 4. actually update\r\n        if (instance.ceReload) {\r\n            // custom element\r\n            hmrDirtyComponents.add(oldComp);\r\n            instance.ceReload(newComp.styles);\r\n            hmrDirtyComponents.delete(oldComp);\r\n        }\r\n        else if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n            // instance is the inner component of an async custom element\r\n            // invoke to reset styles\r\n            if (instance.parent.type.__asyncLoader &&\r\n                instance.parent.ceReload) {\r\n                instance.parent.ceReload(newComp.styles);\r\n            }\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    }\r\n    // 5. make sure to cleanup dirty hmr components after update\r\n    queuePostFlushCb(() => {\r\n        for (const instance of instances) {\r\n            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));\r\n        }\r\n    });\r\n}\r\nfunction updateComponentDef(oldComp, newComp) {\r\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);\r\n    for (const key in oldComp) {\r\n        if (key !== '__file' && !(key in newComp)) {\r\n            delete oldComp[key];\r\n        }\r\n    }\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\n\nlet devtools;\r\nlet buffer = [];\r\nlet devtoolsNotInstalled = false;\r\nfunction emit(event, ...args) {\r\n    if (devtools) {\r\n        devtools.emit(event, ...args);\r\n    }\r\n    else if (!devtoolsNotInstalled) {\r\n        buffer.push({ event, args });\r\n    }\r\n}\r\nfunction setDevtoolsHook(hook, target) {\r\n    var _a, _b;\r\n    devtools = hook;\r\n    if (devtools) {\r\n        devtools.enabled = true;\r\n        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));\r\n        buffer = [];\r\n    }\r\n    else if (\r\n    // handle late devtools injection - only do this if we are in an actual\r\n    // browser environment to avoid the timer handle stalling test runner exit\r\n    // (#4815)\r\n    typeof window !== 'undefined' &&\r\n        // some envs mock window but not fully\r\n        window.HTMLElement &&\r\n        // also exclude jsdom\r\n        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {\r\n        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =\r\n            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);\r\n        replay.push((newHook) => {\r\n            setDevtoolsHook(newHook, target);\r\n        });\r\n        // clear buffer after 3s - the user probably doesn't have devtools installed\r\n        // at all, and keeping the buffer will cause memory leaks (#4738)\r\n        setTimeout(() => {\r\n            if (!devtools) {\r\n                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\r\n                devtoolsNotInstalled = true;\r\n                buffer = [];\r\n            }\r\n        }, 3000);\r\n    }\r\n    else {\r\n        // non-browser env, assume not installed\r\n        devtoolsNotInstalled = true;\r\n        buffer = [];\r\n    }\r\n}\r\nfunction devtoolsInitApp(app, version) {\r\n    emit(\"app:init\" /* APP_INIT */, app, version, {\r\n        Fragment,\r\n        Text,\r\n        Comment,\r\n        Static\r\n    });\r\n}\r\nfunction devtoolsUnmountApp(app) {\r\n    emit(\"app:unmount\" /* APP_UNMOUNT */, app);\r\n}\r\nconst devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(\"component:added\" /* COMPONENT_ADDED */);\r\nconst devtoolsComponentUpdated = \r\n/*#__PURE__*/ createDevtoolsComponentHook(\"component:updated\" /* COMPONENT_UPDATED */);\r\nconst devtoolsComponentRemoved = \r\n/*#__PURE__*/ createDevtoolsComponentHook(\"component:removed\" /* COMPONENT_REMOVED */);\r\nfunction createDevtoolsComponentHook(hook) {\r\n    return (component) => {\r\n        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);\r\n    };\r\n}\r\nconst devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook(\"perf:start\" /* PERFORMANCE_START */);\r\nconst devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook(\"perf:end\" /* PERFORMANCE_END */);\r\nfunction createDevtoolsPerformanceHook(hook) {\r\n    return (component, type, time) => {\r\n        emit(hook, component.appContext.app, component.uid, component, type, time);\r\n    };\r\n}\r\nfunction devtoolsComponentEmit(component, event, params) {\r\n    emit(\"component:emit\" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\r\n}\n\nfunction emit$1(instance, event, ...rawArgs) {\r\n    if (instance.isUnmounted)\r\n        return;\r\n    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n    if ((true)) {\r\n        const { emitsOptions, propsOptions: [propsOptions] } = instance;\r\n        if (emitsOptions) {\r\n            if (!(event in emitsOptions) &&\r\n                !(false )) {\r\n                if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {\r\n                    warn(`Component emitted event \"${event}\" but it is neither declared in ` +\r\n                        `the emits option nor as an \"${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}\" prop.`);\r\n                }\r\n            }\r\n            else {\r\n                const validator = emitsOptions[event];\r\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {\r\n                    const isValid = validator(...rawArgs);\r\n                    if (!isValid) {\r\n                        warn(`Invalid event arguments: event validation failed for event \"${event}\".`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    let args = rawArgs;\r\n    const isModelListener = event.startsWith('update:');\r\n    // for v-model update:xxx events, apply modifiers on args\r\n    const modelArg = isModelListener && event.slice(7);\r\n    if (modelArg && modelArg in props) {\r\n        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;\r\n        const { number, trim } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n        if (trim) {\r\n            args = rawArgs.map(a => a.trim());\r\n        }\r\n        if (number) {\r\n            args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);\r\n        }\r\n    }\r\n    if (true) {\r\n        devtoolsComponentEmit(instance, event, args);\r\n    }\r\n    if ((true)) {\r\n        const lowerCaseEvent = event.toLowerCase();\r\n        if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {\r\n            warn(`Event \"${lowerCaseEvent}\" is emitted in component ` +\r\n                `${formatComponentName(instance, instance.type)} but the handler is registered for \"${event}\". ` +\r\n                `Note that HTML attributes are case-insensitive and you cannot use ` +\r\n                `v-on to listen to camelCase events when using in-DOM templates. ` +\r\n                `You should probably use \"${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}\" instead of \"${event}\".`);\r\n        }\r\n    }\r\n    let handlerName;\r\n    let handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event))] ||\r\n        // also try camelCase event handler (#2249)\r\n        props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)))];\r\n    // for v-model update:xxx events, also trigger kebab-case equivalent\r\n    // for props passed via kebab-case\r\n    if (!handler && isModelListener) {\r\n        handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)))];\r\n    }\r\n    if (handler) {\r\n        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n    const onceHandler = props[handlerName + `Once`];\r\n    if (onceHandler) {\r\n        if (!instance.emitted) {\r\n            instance.emitted = {};\r\n        }\r\n        else if (instance.emitted[handlerName]) {\r\n            return;\r\n        }\r\n        instance.emitted[handlerName] = true;\r\n        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n}\r\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\r\n    const cache = appContext.emitsCache;\r\n    const cached = cache.get(comp);\r\n    if (cached !== undefined) {\r\n        return cached;\r\n    }\r\n    const raw = comp.emits;\r\n    let normalized = {};\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\r\n        const extendEmits = (raw) => {\r\n            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);\r\n            if (normalizedFromExtend) {\r\n                hasExtends = true;\r\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);\r\n            }\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendEmits);\r\n        }\r\n        if (comp.extends) {\r\n            extendEmits(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendEmits);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        cache.set(comp, null);\r\n        return null;\r\n    }\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\r\n        raw.forEach(key => (normalized[key] = null));\r\n    }\r\n    else {\r\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);\r\n    }\r\n    cache.set(comp, normalized);\r\n    return normalized;\r\n}\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nfunction isEmitListener(options, key) {\r\n    if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\r\n        return false;\r\n    }\r\n    key = key.slice(2).replace(/Once$/, '');\r\n    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) ||\r\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ||\r\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key));\r\n}\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nlet currentScopeId = null;\r\n/**\r\n * Note: rendering calls maybe nested. The function returns the parent rendering\r\n * instance if present, which should be restored after the render is done:\r\n *\r\n * ```js\r\n * const prev = setCurrentRenderingInstance(i)\r\n * // ...render\r\n * setCurrentRenderingInstance(prev)\r\n * ```\r\n */\r\nfunction setCurrentRenderingInstance(instance) {\r\n    const prev = currentRenderingInstance;\r\n    currentRenderingInstance = instance;\r\n    currentScopeId = (instance && instance.type.__scopeId) || null;\r\n    return prev;\r\n}\r\n/**\r\n * Set scope id when creating hoisted vnodes.\r\n * @private compiler helper\r\n */\r\nfunction pushScopeId(id) {\r\n    currentScopeId = id;\r\n}\r\n/**\r\n * Technically we no longer need this after 3.0.8 but we need to keep the same\r\n * API for backwards compat w/ code generated by compilers.\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    currentScopeId = null;\r\n}\r\n/**\r\n * Only for backwards compat\r\n * @private\r\n */\r\nconst withScopeId = (_id) => withCtx;\r\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private compiler helper\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only\r\n) {\r\n    if (!ctx)\r\n        return fn;\r\n    // already normalized\r\n    if (fn._n) {\r\n        return fn;\r\n    }\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we disable block tracking and\r\n        // force bail out when invoking a compiled slot (indicated by the ._d flag).\r\n        // This isn't necessary if rendering a compiled `<slot>`, so we flip the\r\n        // ._d flag off when invoking the wrapped fn inside `renderSlot`.\r\n        if (renderFnWithContext._d) {\r\n            setBlockTracking(-1);\r\n        }\r\n        const prevInstance = setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(prevInstance);\r\n        if (renderFnWithContext._d) {\r\n            setBlockTracking(1);\r\n        }\r\n        if (true) {\r\n            devtoolsComponentUpdated(ctx);\r\n        }\r\n        return res;\r\n    };\r\n    // mark normalized to avoid duplicated wrapping\r\n    renderFnWithContext._n = true;\r\n    // mark this as compiled by default\r\n    // this is used in vnode.ts -> normalizeChildren() to set the slot\r\n    // rendering flag.\r\n    renderFnWithContext._c = true;\r\n    // disable block tracking by default\r\n    renderFnWithContext._d = true;\r\n    return renderFnWithContext;\r\n}\n\n/**\r\n * dev only flag to track whether $attrs was used during render.\r\n * If $attrs was used during render then the warning for failed attrs\r\n * fallthrough can be suppressed.\r\n */\r\nlet accessedAttrs = false;\r\nfunction markAttrsAccessed() {\r\n    accessedAttrs = true;\r\n}\r\nfunction renderComponentRoot(instance) {\r\n    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;\r\n    let result;\r\n    let fallthroughAttrs;\r\n    const prev = setCurrentRenderingInstance(instance);\r\n    if ((true)) {\r\n        accessedAttrs = false;\r\n    }\r\n    try {\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            // withProxy is a proxy with a different `has` trap only for\r\n            // runtime-compiled render functions using `with` block.\r\n            const proxyToUse = withProxy || proxy;\r\n            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\r\n            fallthroughAttrs = attrs;\r\n        }\r\n        else {\r\n            // functional\r\n            const render = Component;\r\n            // in dev, mark attrs accessed if optional props (attrs === props)\r\n            if (( true) && attrs === props) {\r\n                markAttrsAccessed();\r\n            }\r\n            result = normalizeVNode(render.length > 1\r\n                ? render(props, ( true)\r\n                    ? {\r\n                        get attrs() {\r\n                            markAttrsAccessed();\r\n                            return attrs;\r\n                        },\r\n                        slots,\r\n                        emit\r\n                    }\r\n                    : 0)\r\n                : render(props, null /* we know it doesn't need it */));\r\n            fallthroughAttrs = Component.props\r\n                ? attrs\r\n                : getFunctionalFallthrough(attrs);\r\n        }\r\n    }\r\n    catch (err) {\r\n        blockStack.length = 0;\r\n        handleError(err, instance, 1 /* RENDER_FUNCTION */);\r\n        result = createVNode(Comment);\r\n    }\r\n    // attr merging\r\n    // in dev mode, comments are preserved, and it's possible for a template\r\n    // to have comments along side the root element which makes it a fragment\r\n    let root = result;\r\n    let setRoot = undefined;\r\n    if (( true) &&\r\n        result.patchFlag > 0 &&\r\n        result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {\r\n        [root, setRoot] = getChildRoot(result);\r\n    }\r\n    if (fallthroughAttrs && inheritAttrs !== false) {\r\n        const keys = Object.keys(fallthroughAttrs);\r\n        const { shapeFlag } = root;\r\n        if (keys.length) {\r\n            if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {\r\n                if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {\r\n                    // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n                    // prop, it indicates this component expects to handle v-model and\r\n                    // it should not fallthrough.\r\n                    // related: #1543, #1643, #1989\r\n                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\r\n                }\r\n                root = cloneVNode(root, fallthroughAttrs);\r\n            }\r\n            else if (( true) && !accessedAttrs && root.type !== Comment) {\r\n                const allAttrs = Object.keys(attrs);\r\n                const eventAttrs = [];\r\n                const extraAttrs = [];\r\n                for (let i = 0, l = allAttrs.length; i < l; i++) {\r\n                    const key = allAttrs[i];\r\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\r\n                        // ignore v-model handlers when they fail to fallthrough\r\n                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {\r\n                            // remove `on`, lowercase first letter to reflect event casing\r\n                            // accurately\r\n                            eventAttrs.push(key[2].toLowerCase() + key.slice(3));\r\n                        }\r\n                    }\r\n                    else {\r\n                        extraAttrs.push(key);\r\n                    }\r\n                }\r\n                if (extraAttrs.length) {\r\n                    warn(`Extraneous non-props attributes (` +\r\n                        `${extraAttrs.join(', ')}) ` +\r\n                        `were passed to component but could not be automatically inherited ` +\r\n                        `because component renders fragment or text root nodes.`);\r\n                }\r\n                if (eventAttrs.length) {\r\n                    warn(`Extraneous non-emits event listeners (` +\r\n                        `${eventAttrs.join(', ')}) ` +\r\n                        `were passed to component but could not be automatically inherited ` +\r\n                        `because component renders fragment or text root nodes. ` +\r\n                        `If the listener is intended to be a component custom event listener only, ` +\r\n                        `declare it using the \"emits\" option.`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // inherit directives\r\n    if (vnode.dirs) {\r\n        if (( true) && !isElementRoot(root)) {\r\n            warn(`Runtime directive used on component with non-element root node. ` +\r\n                `The directives will not function as intended.`);\r\n        }\r\n        // clone before mutating since the root may be a hoisted vnode\r\n        root = cloneVNode(root);\r\n        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\r\n    }\r\n    // inherit transition data\r\n    if (vnode.transition) {\r\n        if (( true) && !isElementRoot(root)) {\r\n            warn(`Component inside <Transition> renders non-element root node ` +\r\n                `that cannot be animated.`);\r\n        }\r\n        root.transition = vnode.transition;\r\n    }\r\n    if (( true) && setRoot) {\r\n        setRoot(root);\r\n    }\r\n    else {\r\n        result = root;\r\n    }\r\n    setCurrentRenderingInstance(prev);\r\n    return result;\r\n}\r\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\r\nconst getChildRoot = (vnode) => {\r\n    const rawChildren = vnode.children;\r\n    const dynamicChildren = vnode.dynamicChildren;\r\n    const childRoot = filterSingleRoot(rawChildren);\r\n    if (!childRoot) {\r\n        return [vnode, undefined];\r\n    }\r\n    const index = rawChildren.indexOf(childRoot);\r\n    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\r\n    const setRoot = (updatedRoot) => {\r\n        rawChildren[index] = updatedRoot;\r\n        if (dynamicChildren) {\r\n            if (dynamicIndex > -1) {\r\n                dynamicChildren[dynamicIndex] = updatedRoot;\r\n            }\r\n            else if (updatedRoot.patchFlag > 0) {\r\n                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\r\n            }\r\n        }\r\n    };\r\n    return [normalizeVNode(childRoot), setRoot];\r\n};\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\nconst getFunctionalFallthrough = (attrs) => {\r\n    let res;\r\n    for (const key in attrs) {\r\n        if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\r\n            (res || (res = {}))[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst filterModelListeners = (attrs, props) => {\r\n    const res = {};\r\n    for (const key in attrs) {\r\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {\r\n            res[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst isElementRoot = (vnode) => {\r\n    return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||\r\n        vnode.type === Comment // potential v-if branch switch\r\n    );\r\n};\r\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\r\n    const { props: prevProps, children: prevChildren, component } = prevVNode;\r\n    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\r\n    const emits = component.emitsOptions;\r\n    // Parent component's render function was hot-updated. Since this may have\r\n    // caused the child component's slots content to have changed, we need to\r\n    // force the child to update as well.\r\n    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {\r\n        return true;\r\n    }\r\n    // force child update for runtime directive or transition on component vnode.\r\n    if (nextVNode.dirs || nextVNode.transition) {\r\n        return true;\r\n    }\r\n    if (optimized && patchFlag >= 0) {\r\n        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n            // slot content that references values that might have changed,\r\n            // e.g. in a v-for\r\n            return true;\r\n        }\r\n        if (patchFlag & 16 /* FULL_PROPS */) {\r\n            if (!prevProps) {\r\n                return !!nextProps;\r\n            }\r\n            // presence of this flag indicates props are always non-null\r\n            return hasPropsChanged(prevProps, nextProps, emits);\r\n        }\r\n        else if (patchFlag & 8 /* PROPS */) {\r\n            const dynamicProps = nextVNode.dynamicProps;\r\n            for (let i = 0; i < dynamicProps.length; i++) {\r\n                const key = dynamicProps[i];\r\n                if (nextProps[key] !== prevProps[key] &&\r\n                    !isEmitListener(emits, key)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // this path is only taken by manually written render functions\r\n        // so presence of any children leads to a forced update\r\n        if (prevChildren || nextChildren) {\r\n            if (!nextChildren || !nextChildren.$stable) {\r\n                return true;\r\n            }\r\n        }\r\n        if (prevProps === nextProps) {\r\n            return false;\r\n        }\r\n        if (!prevProps) {\r\n            return !!nextProps;\r\n        }\r\n        if (!nextProps) {\r\n            return true;\r\n        }\r\n        return hasPropsChanged(prevProps, nextProps, emits);\r\n    }\r\n    return false;\r\n}\r\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\r\n    const nextKeys = Object.keys(nextProps);\r\n    if (nextKeys.length !== Object.keys(prevProps).length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < nextKeys.length; i++) {\r\n        const key = nextKeys[i];\r\n        if (nextProps[key] !== prevProps[key] &&\r\n            !isEmitListener(emitsOptions, key)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction updateHOCHostEl({ vnode, parent }, el // HostNode\r\n) {\r\n    while (parent && parent.subTree === vnode) {\r\n        (vnode = parent.vnode).el = el;\r\n        parent = parent.parent;\r\n    }\r\n}\n\nconst isSuspense = (type) => type.__isSuspense;\r\n// Suspense exposes a component-like API, and is treated like a component\r\n// in the compiler, but internally it's a special built-in type that hooks\r\n// directly into the renderer.\r\nconst SuspenseImpl = {\r\n    name: 'Suspense',\r\n    // In order to make Suspense tree-shakable, we need to avoid importing it\r\n    // directly in the renderer. The renderer checks for the __isSuspense flag\r\n    // on a vnode's type and calls the `process` method, passing in renderer\r\n    // internals.\r\n    __isSuspense: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, \r\n    // platform-specific impl passed from renderer\r\n    rendererInternals) {\r\n        if (n1 == null) {\r\n            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);\r\n        }\r\n        else {\r\n            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);\r\n        }\r\n    },\r\n    hydrate: hydrateSuspense,\r\n    create: createSuspenseBoundary,\r\n    normalize: normalizeSuspenseChildren\r\n};\r\n// Force-casted public typing for h and TSX props inference\r\nconst Suspense = (SuspenseImpl );\r\nfunction triggerEvent(vnode, name) {\r\n    const eventListener = vnode.props && vnode.props[name];\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {\r\n        eventListener();\r\n    }\r\n}\r\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\r\n    const { p: patch, o: { createElement } } = rendererInternals;\r\n    const hiddenContainer = createElement('div');\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));\r\n    // start mounting the content subtree in an off-dom container\r\n    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);\r\n    // now check if we have encountered any async deps\r\n    if (suspense.deps > 0) {\r\n        // has async\r\n        // invoke @fallback event\r\n        triggerEvent(vnode, 'onPending');\r\n        triggerEvent(vnode, 'onFallback');\r\n        // mount the fallback tree\r\n        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n        isSVG, slotScopeIds);\r\n        setActiveBranch(suspense, vnode.ssFallback);\r\n    }\r\n    else {\r\n        // Suspense has no async deps. Just resolve.\r\n        suspense.resolve();\r\n    }\r\n}\r\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\r\n    const suspense = (n2.suspense = n1.suspense);\r\n    suspense.vnode = n2;\r\n    n2.el = n1.el;\r\n    const newBranch = n2.ssContent;\r\n    const newFallback = n2.ssFallback;\r\n    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\r\n    if (pendingBranch) {\r\n        suspense.pendingBranch = newBranch;\r\n        if (isSameVNodeType(newBranch, pendingBranch)) {\r\n            // same root type but content may have changed.\r\n            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            if (suspense.deps <= 0) {\r\n                suspense.resolve();\r\n            }\r\n            else if (isInFallback) {\r\n                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, slotScopeIds, optimized);\r\n                setActiveBranch(suspense, newFallback);\r\n            }\r\n        }\r\n        else {\r\n            // toggled before pending tree is resolved\r\n            suspense.pendingId++;\r\n            if (isHydrating) {\r\n                // if toggled before hydration is finished, the current DOM tree is\r\n                // no longer valid. set it as the active branch so it will be unmounted\r\n                // when resolved\r\n                suspense.isHydrating = false;\r\n                suspense.activeBranch = pendingBranch;\r\n            }\r\n            else {\r\n                unmount(pendingBranch, parentComponent, suspense);\r\n            }\r\n            // increment pending ID. this is used to invalidate async callbacks\r\n            // reset suspense state\r\n            suspense.deps = 0;\r\n            // discard effects from pending branch\r\n            suspense.effects.length = 0;\r\n            // discard previous container\r\n            suspense.hiddenContainer = createElement('div');\r\n            if (isInFallback) {\r\n                // already in fallback state\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n                else {\r\n                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                    isSVG, slotScopeIds, optimized);\r\n                    setActiveBranch(suspense, newFallback);\r\n                }\r\n            }\r\n            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n                // toggled \"back\" to current active branch\r\n                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                // force resolve\r\n                suspense.resolve(true);\r\n            }\r\n            else {\r\n                // switched to a 3rd branch\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n            // root did not change, just normal patch\r\n            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            setActiveBranch(suspense, newBranch);\r\n        }\r\n        else {\r\n            // root node toggled\r\n            // invoke @pending event\r\n            triggerEvent(n2, 'onPending');\r\n            // mount pending branch in off-dom container\r\n            suspense.pendingBranch = newBranch;\r\n            suspense.pendingId++;\r\n            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            if (suspense.deps <= 0) {\r\n                // incoming branch has no async deps, resolve now.\r\n                suspense.resolve();\r\n            }\r\n            else {\r\n                const { timeout, pendingId } = suspense;\r\n                if (timeout > 0) {\r\n                    setTimeout(() => {\r\n                        if (suspense.pendingId === pendingId) {\r\n                            suspense.fallback(newFallback);\r\n                        }\r\n                    }, timeout);\r\n                }\r\n                else if (timeout === 0) {\r\n                    suspense.fallback(newFallback);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nlet hasWarned = false;\r\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\r\n    /* istanbul ignore if */\r\n    if ( true && !hasWarned) {\r\n        hasWarned = true;\r\n        // @ts-ignore `console.info` cannot be null error\r\n        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);\r\n    }\r\n    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\r\n    const timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);\r\n    const suspense = {\r\n        vnode,\r\n        parent,\r\n        parentComponent,\r\n        isSVG,\r\n        container,\r\n        hiddenContainer,\r\n        anchor,\r\n        deps: 0,\r\n        pendingId: 0,\r\n        timeout: typeof timeout === 'number' ? timeout : -1,\r\n        activeBranch: null,\r\n        pendingBranch: null,\r\n        isInFallback: true,\r\n        isHydrating,\r\n        isUnmounted: false,\r\n        effects: [],\r\n        resolve(resume = false) {\r\n            if ((true)) {\r\n                if (!resume && !suspense.pendingBranch) {\r\n                    throw new Error(`suspense.resolve() is called without a pending branch.`);\r\n                }\r\n                if (suspense.isUnmounted) {\r\n                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);\r\n                }\r\n            }\r\n            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\r\n            if (suspense.isHydrating) {\r\n                suspense.isHydrating = false;\r\n            }\r\n            else if (!resume) {\r\n                const delayEnter = activeBranch &&\r\n                    pendingBranch.transition &&\r\n                    pendingBranch.transition.mode === 'out-in';\r\n                if (delayEnter) {\r\n                    activeBranch.transition.afterLeave = () => {\r\n                        if (pendingId === suspense.pendingId) {\r\n                            move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                        }\r\n                    };\r\n                }\r\n                // this is initial anchor on mount\r\n                let { anchor } = suspense;\r\n                // unmount current active tree\r\n                if (activeBranch) {\r\n                    // if the fallback tree was mounted, it may have been moved\r\n                    // as part of a parent suspense. get the latest anchor for insertion\r\n                    anchor = next(activeBranch);\r\n                    unmount(activeBranch, parentComponent, suspense, true);\r\n                }\r\n                if (!delayEnter) {\r\n                    // move content from off-dom container to actual container\r\n                    move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                }\r\n            }\r\n            setActiveBranch(suspense, pendingBranch);\r\n            suspense.pendingBranch = null;\r\n            suspense.isInFallback = false;\r\n            // flush buffered effects\r\n            // check if there is a pending parent suspense\r\n            let parent = suspense.parent;\r\n            let hasUnresolvedAncestor = false;\r\n            while (parent) {\r\n                if (parent.pendingBranch) {\r\n                    // found a pending parent suspense, merge buffered post jobs\r\n                    // into that parent\r\n                    parent.effects.push(...effects);\r\n                    hasUnresolvedAncestor = true;\r\n                    break;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n            // no pending parent suspense, flush all jobs\r\n            if (!hasUnresolvedAncestor) {\r\n                queuePostFlushCb(effects);\r\n            }\r\n            suspense.effects = [];\r\n            // invoke @resolve event\r\n            triggerEvent(vnode, 'onResolve');\r\n        },\r\n        fallback(fallbackVNode) {\r\n            if (!suspense.pendingBranch) {\r\n                return;\r\n            }\r\n            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;\r\n            // invoke @fallback event\r\n            triggerEvent(vnode, 'onFallback');\r\n            const anchor = next(activeBranch);\r\n            const mountFallback = () => {\r\n                if (!suspense.isInFallback) {\r\n                    return;\r\n                }\r\n                // mount the fallback tree\r\n                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, slotScopeIds, optimized);\r\n                setActiveBranch(suspense, fallbackVNode);\r\n            };\r\n            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\r\n            if (delayEnter) {\r\n                activeBranch.transition.afterLeave = mountFallback;\r\n            }\r\n            suspense.isInFallback = true;\r\n            // unmount current active branch\r\n            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\r\n            true // shouldRemove\r\n            );\r\n            if (!delayEnter) {\r\n                mountFallback();\r\n            }\r\n        },\r\n        move(container, anchor, type) {\r\n            suspense.activeBranch &&\r\n                move(suspense.activeBranch, container, anchor, type);\r\n            suspense.container = container;\r\n        },\r\n        next() {\r\n            return suspense.activeBranch && next(suspense.activeBranch);\r\n        },\r\n        registerDep(instance, setupRenderEffect) {\r\n            const isInPendingSuspense = !!suspense.pendingBranch;\r\n            if (isInPendingSuspense) {\r\n                suspense.deps++;\r\n            }\r\n            const hydratedEl = instance.vnode.el;\r\n            instance\r\n                .asyncDep.catch(err => {\r\n                handleError(err, instance, 0 /* SETUP_FUNCTION */);\r\n            })\r\n                .then(asyncSetupResult => {\r\n                // retry when the setup() promise resolves.\r\n                // component may have been unmounted before resolve.\r\n                if (instance.isUnmounted ||\r\n                    suspense.isUnmounted ||\r\n                    suspense.pendingId !== instance.suspenseId) {\r\n                    return;\r\n                }\r\n                // retry from this component\r\n                instance.asyncResolved = true;\r\n                const { vnode } = instance;\r\n                if ((true)) {\r\n                    pushWarningContext(vnode);\r\n                }\r\n                handleSetupResult(instance, asyncSetupResult, false);\r\n                if (hydratedEl) {\r\n                    // vnode may have been replaced if an update happened before the\r\n                    // async dep is resolved.\r\n                    vnode.el = hydratedEl;\r\n                }\r\n                const placeholder = !hydratedEl && instance.subTree.el;\r\n                setupRenderEffect(instance, vnode, \r\n                // component may have been moved before resolve.\r\n                // if this is not a hydration, instance.subTree will be the comment\r\n                // placeholder.\r\n                parentNode(hydratedEl || instance.subTree.el), \r\n                // anchor will not be used if this is hydration, so only need to\r\n                // consider the comment placeholder case.\r\n                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\r\n                if (placeholder) {\r\n                    remove(placeholder);\r\n                }\r\n                updateHOCHostEl(instance, vnode.el);\r\n                if ((true)) {\r\n                    popWarningContext();\r\n                }\r\n                // only decrease deps count if suspense is not already resolved\r\n                if (isInPendingSuspense && --suspense.deps === 0) {\r\n                    suspense.resolve();\r\n                }\r\n            });\r\n        },\r\n        unmount(parentSuspense, doRemove) {\r\n            suspense.isUnmounted = true;\r\n            if (suspense.activeBranch) {\r\n                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n            if (suspense.pendingBranch) {\r\n                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n        }\r\n    };\r\n    return suspense;\r\n}\r\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\r\n    /* eslint-disable no-restricted-globals */\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));\r\n    // there are two possible scenarios for server-rendered suspense:\r\n    // - success: ssr content should be fully resolved\r\n    // - failure: ssr content should be the fallback branch.\r\n    // however, on the client we don't really know if it has failed or not\r\n    // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n    // need to construct a suspense boundary first\r\n    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);\r\n    if (suspense.deps === 0) {\r\n        suspense.resolve();\r\n    }\r\n    return result;\r\n    /* eslint-enable no-restricted-globals */\r\n}\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;\r\n    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);\r\n    vnode.ssFallback = isSlotChildren\r\n        ? normalizeSuspenseSlot(children.fallback)\r\n        : createVNode(Comment);\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    let block;\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {\r\n        const trackBlock = isBlockTreeEnabled && s._c;\r\n        if (trackBlock) {\r\n            // disableTracking: false\r\n            // allow block tracking for compiled slots\r\n            // (see ./componentRenderContext.ts)\r\n            s._d = false;\r\n            openBlock();\r\n        }\r\n        s = s();\r\n        if (trackBlock) {\r\n            s._d = true;\r\n            block = currentBlock;\r\n            closeBlock();\r\n        }\r\n    }\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if (( true) && !singleChild) {\r\n            warn(`<Suspense> slots expect a single root node.`);\r\n        }\r\n        s = singleChild;\r\n    }\r\n    s = normalizeVNode(s);\r\n    if (block && !s.dynamicChildren) {\r\n        s.dynamicChildren = block.filter(c => c !== s);\r\n    }\r\n    return s;\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\nfunction setActiveBranch(suspense, branch) {\r\n    suspense.activeBranch = branch;\r\n    const { vnode, parentComponent } = suspense;\r\n    const el = (vnode.el = branch.el);\r\n    // in case suspense is the root node of a component,\r\n    // recursively update the HOC el\r\n    if (parentComponent && parentComponent.subTree === vnode) {\r\n        parentComponent.vnode.el = el;\r\n        updateHOCHostEl(parentComponent, el);\r\n    }\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if ((true)) {\r\n            warn(`provide() can only be used inside setup().`);\r\n        }\r\n    }\r\n    else {\r\n        let provides = currentInstance.provides;\r\n        // by default an instance inherits its parent's provides object\r\n        // but when it needs to provide values of its own, it creates its\r\n        // own provides object using parent provides object as prototype.\r\n        // this way in `inject` we can simply look up injections from direct\r\n        // parent and let the prototype chain do the work.\r\n        const parentProvides = currentInstance.parent && currentInstance.parent.provides;\r\n        if (parentProvides === provides) {\r\n            provides = currentInstance.provides = Object.create(parentProvides);\r\n        }\r\n        // TS doesn't allow symbol as index type\r\n        provides[key] = value;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    const instance = currentInstance || currentRenderingInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext's `provides` if the instance is at root\r\n        const provides = instance.parent == null\r\n            ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n            : instance.parent.provides;\r\n        if (provides && key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)\r\n                ? defaultValue.call(instance.proxy)\r\n                : defaultValue;\r\n        }\r\n        else if ((true)) {\r\n            warn(`injection \"${String(key)}\" not found.`);\r\n        }\r\n    }\r\n    else if ((true)) {\r\n        warn(`inject() can only be used inside setup() or functional components.`);\r\n    }\r\n}\n\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\nfunction watchPostEffect(effect, options) {\r\n    return doWatch(effect, null, (( true)\r\n        ? Object.assign(Object.assign({}, options), { flush: 'post' }) : 0));\r\n}\r\nfunction watchSyncEffect(effect, options) {\r\n    return doWatch(effect, null, (( true)\r\n        ? Object.assign(Object.assign({}, options), { flush: 'sync' }) : 0));\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {\r\n        warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\r\n            `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\r\n            `supports \\`watch(source, cb, options?) signature.`);\r\n    }\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\r\n    if (( true) && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn(`watch() \"immediate\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n        if (deep !== undefined) {\r\n            warn(`watch() \"deep\" option is only respected when using the ` +\r\n                `watch(source, callback, options?) signature.`);\r\n        }\r\n    }\r\n    const warnInvalidSource = (s) => {\r\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    const instance = currentInstance;\r\n    let getter;\r\n    let forceTrigger = false;\r\n    let isMultiSource = false;\r\n    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);\r\n    }\r\n    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {\r\n        isMultiSource = true;\r\n        forceTrigger = source.some(s => (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(s));\r\n        getter = () => source.map(s => {\r\n            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {\r\n                return s.value;\r\n            }\r\n            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                ( true) && warnInvalidSource(s);\r\n            }\r\n        });\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\r\n        ( true) && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    let onCleanup = (fn) => {\r\n        cleanup = effect.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    // in SSR there is no need to setup an actual effect, and it should be noop\r\n    // unless it's eager\r\n    if (isInSSRComponentSetup) {\r\n        // we will also not call the invalidate callback (+ runner is not set up)\r\n        onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\r\n        if (!cb) {\r\n            getter();\r\n        }\r\n        else if (immediate) {\r\n            callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                getter(),\r\n                isMultiSource ? [] : undefined,\r\n                onCleanup\r\n            ]);\r\n        }\r\n        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\r\n    }\r\n    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!effect.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = effect.run();\r\n            if (deep ||\r\n                forceTrigger ||\r\n                (isMultiSource\r\n                    ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]))\r\n                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) ||\r\n                (false  )) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onCleanup\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            effect.run();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job; // the scheduler function gets called directly\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => queuePreFlushCb(job);\r\n    }\r\n    const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(getter, scheduler);\r\n    if ((true)) {\r\n        effect.onTrack = onTrack;\r\n        effect.onTrigger = onTrigger;\r\n    }\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = effect.run();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\r\n    }\r\n    else {\r\n        effect.run();\r\n    }\r\n    return () => {\r\n        effect.stop();\r\n        if (instance && instance.scope) {\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.scope.effects, effect);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, value, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)\r\n        ? source.includes('.')\r\n            ? createPathGetter(publicThis, source)\r\n            : () => publicThis[source]\r\n        : source.bind(publicThis, publicThis);\r\n    let cb;\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\r\n        cb = value;\r\n    }\r\n    else {\r\n        cb = value.handler;\r\n        options = value;\r\n    }\r\n    const cur = currentInstance;\r\n    setCurrentInstance(this);\r\n    const res = doWatch(getter, cb.bind(publicThis), options);\r\n    if (cur) {\r\n        setCurrentInstance(cur);\r\n    }\r\n    else {\r\n        unsetCurrentInstance();\r\n    }\r\n    return res;\r\n}\r\nfunction createPathGetter(ctx, path) {\r\n    const segments = path.split('.');\r\n    return () => {\r\n        let cur = ctx;\r\n        for (let i = 0; i < segments.length && cur; i++) {\r\n            cur = cur[segments[i]];\r\n        }\r\n        return cur;\r\n    };\r\n}\r\nfunction traverse(value, seen) {\r\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value[\"__v_skip\" /* SKIP */]) {\r\n        return value;\r\n    }\r\n    seen = seen || new Set();\r\n    if (seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\n\nfunction useTransitionState() {\r\n    const state = {\r\n        isMounted: false,\r\n        isLeaving: false,\r\n        isUnmounting: false,\r\n        leavingVNodes: new Map()\r\n    };\r\n    onMounted(() => {\r\n        state.isMounted = true;\r\n    });\r\n    onBeforeUnmount(() => {\r\n        state.isUnmounting = true;\r\n    });\r\n    return state;\r\n}\r\nconst TransitionHookValidator = [Function, Array];\r\nconst BaseTransitionImpl = {\r\n    name: `BaseTransition`,\r\n    props: {\r\n        mode: String,\r\n        appear: Boolean,\r\n        persisted: Boolean,\r\n        // enter\r\n        onBeforeEnter: TransitionHookValidator,\r\n        onEnter: TransitionHookValidator,\r\n        onAfterEnter: TransitionHookValidator,\r\n        onEnterCancelled: TransitionHookValidator,\r\n        // leave\r\n        onBeforeLeave: TransitionHookValidator,\r\n        onLeave: TransitionHookValidator,\r\n        onAfterLeave: TransitionHookValidator,\r\n        onLeaveCancelled: TransitionHookValidator,\r\n        // appear\r\n        onBeforeAppear: TransitionHookValidator,\r\n        onAppear: TransitionHookValidator,\r\n        onAfterAppear: TransitionHookValidator,\r\n        onAppearCancelled: TransitionHookValidator\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevTransitionKey;\r\n        return () => {\r\n            const children = slots.default && getTransitionRawChildren(slots.default(), true);\r\n            if (!children || !children.length) {\r\n                return;\r\n            }\r\n            let child = children[0];\r\n            if (children.length > 1) {\r\n                let hasFound = false;\r\n                // locate first non-comment child\r\n                for (const c of children) {\r\n                    if (c.type !== Comment) {\r\n                        if (( true) && hasFound) {\r\n                            // warn more than one non-comment child\r\n                            warn('<transition> can only be used on a single element or component. ' +\r\n                                'Use <transition-group> for lists.');\r\n                            break;\r\n                        }\r\n                        child = c;\r\n                        hasFound = true;\r\n                        if (false)\r\n                            {}\r\n                    }\r\n                }\r\n            }\r\n            // there's no need to track reactivity for these props so use the raw\r\n            // props for a bit better perf\r\n            const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\r\n            const { mode } = rawProps;\r\n            // check mode\r\n            if (( true) &&\r\n                mode &&\r\n                mode !== 'in-out' &&\r\n                mode !== 'out-in' &&\r\n                mode !== 'default') {\r\n                warn(`invalid <transition> mode: ${mode}`);\r\n            }\r\n            if (state.isLeaving) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            // in the case of <transition><keep-alive/></transition>, we need to\r\n            // compare the type of the kept-alive children.\r\n            const innerChild = getKeepAliveChild(child);\r\n            if (!innerChild) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\r\n            setTransitionHooks(innerChild, enterHooks);\r\n            const oldChild = instance.subTree;\r\n            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\r\n            let transitionKeyChanged = false;\r\n            const { getTransitionKey } = innerChild.type;\r\n            if (getTransitionKey) {\r\n                const key = getTransitionKey();\r\n                if (prevTransitionKey === undefined) {\r\n                    prevTransitionKey = key;\r\n                }\r\n                else if (key !== prevTransitionKey) {\r\n                    prevTransitionKey = key;\r\n                    transitionKeyChanged = true;\r\n                }\r\n            }\r\n            // handle mode\r\n            if (oldInnerChild &&\r\n                oldInnerChild.type !== Comment &&\r\n                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\r\n                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\r\n                // update old tree's hooks in case of dynamic transition\r\n                setTransitionHooks(oldInnerChild, leavingHooks);\r\n                // switching between different views\r\n                if (mode === 'out-in') {\r\n                    state.isLeaving = true;\r\n                    // return placeholder node and queue update when leave finishes\r\n                    leavingHooks.afterLeave = () => {\r\n                        state.isLeaving = false;\r\n                        instance.update();\r\n                    };\r\n                    return emptyPlaceholder(child);\r\n                }\r\n                else if (mode === 'in-out' && innerChild.type !== Comment) {\r\n                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\r\n                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\r\n                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\r\n                        // early removal callback\r\n                        el._leaveCb = () => {\r\n                            earlyRemove();\r\n                            el._leaveCb = undefined;\r\n                            delete enterHooks.delayedLeave;\r\n                        };\r\n                        enterHooks.delayedLeave = delayedLeave;\r\n                    };\r\n                }\r\n            }\r\n            return child;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst BaseTransition = BaseTransitionImpl;\r\nfunction getLeavingNodesForType(state, vnode) {\r\n    const { leavingVNodes } = state;\r\n    let leavingVNodesCache = leavingVNodes.get(vnode.type);\r\n    if (!leavingVNodesCache) {\r\n        leavingVNodesCache = Object.create(null);\r\n        leavingVNodes.set(vnode.type, leavingVNodesCache);\r\n    }\r\n    return leavingVNodesCache;\r\n}\r\n// The transition hooks are attached to the vnode as vnode.transition\r\n// and will be called at appropriate timing in the renderer.\r\nfunction resolveTransitionHooks(vnode, props, state, instance) {\r\n    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\r\n    const key = String(vnode.key);\r\n    const leavingVNodesCache = getLeavingNodesForType(state, vnode);\r\n    const callHook = (hook, args) => {\r\n        hook &&\r\n            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);\r\n    };\r\n    const callAsyncHook = (hook, args) => {\r\n        const done = args[1];\r\n        callHook(hook, args);\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\r\n            if (hook.every(hook => hook.length <= 1))\r\n                done();\r\n        }\r\n        else if (hook.length <= 1) {\r\n            done();\r\n        }\r\n    };\r\n    const hooks = {\r\n        mode,\r\n        persisted,\r\n        beforeEnter(el) {\r\n            let hook = onBeforeEnter;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onBeforeAppear || onBeforeEnter;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            // for same element (v-show)\r\n            if (el._leaveCb) {\r\n                el._leaveCb(true /* cancelled */);\r\n            }\r\n            // for toggled element with same key (v-if)\r\n            const leavingVNode = leavingVNodesCache[key];\r\n            if (leavingVNode &&\r\n                isSameVNodeType(vnode, leavingVNode) &&\r\n                leavingVNode.el._leaveCb) {\r\n                // force early removal (not cancelled)\r\n                leavingVNode.el._leaveCb();\r\n            }\r\n            callHook(hook, [el]);\r\n        },\r\n        enter(el) {\r\n            let hook = onEnter;\r\n            let afterHook = onAfterEnter;\r\n            let cancelHook = onEnterCancelled;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onAppear || onEnter;\r\n                    afterHook = onAfterAppear || onAfterEnter;\r\n                    cancelHook = onAppearCancelled || onEnterCancelled;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            let called = false;\r\n            const done = (el._enterCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                if (cancelled) {\r\n                    callHook(cancelHook, [el]);\r\n                }\r\n                else {\r\n                    callHook(afterHook, [el]);\r\n                }\r\n                if (hooks.delayedLeave) {\r\n                    hooks.delayedLeave();\r\n                }\r\n                el._enterCb = undefined;\r\n            });\r\n            if (hook) {\r\n                callAsyncHook(hook, [el, done]);\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        leave(el, remove) {\r\n            const key = String(vnode.key);\r\n            if (el._enterCb) {\r\n                el._enterCb(true /* cancelled */);\r\n            }\r\n            if (state.isUnmounting) {\r\n                return remove();\r\n            }\r\n            callHook(onBeforeLeave, [el]);\r\n            let called = false;\r\n            const done = (el._leaveCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                remove();\r\n                if (cancelled) {\r\n                    callHook(onLeaveCancelled, [el]);\r\n                }\r\n                else {\r\n                    callHook(onAfterLeave, [el]);\r\n                }\r\n                el._leaveCb = undefined;\r\n                if (leavingVNodesCache[key] === vnode) {\r\n                    delete leavingVNodesCache[key];\r\n                }\r\n            });\r\n            leavingVNodesCache[key] = vnode;\r\n            if (onLeave) {\r\n                callAsyncHook(onLeave, [el, done]);\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        clone(vnode) {\r\n            return resolveTransitionHooks(vnode, props, state, instance);\r\n        }\r\n    };\r\n    return hooks;\r\n}\r\n// the placeholder really only handles one special case: KeepAlive\r\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\r\n// placeholder with empty content to avoid the KeepAlive instance from being\r\n// unmounted.\r\nfunction emptyPlaceholder(vnode) {\r\n    if (isKeepAlive(vnode)) {\r\n        vnode = cloneVNode(vnode);\r\n        vnode.children = null;\r\n        return vnode;\r\n    }\r\n}\r\nfunction getKeepAliveChild(vnode) {\r\n    return isKeepAlive(vnode)\r\n        ? vnode.children\r\n            ? vnode.children[0]\r\n            : undefined\r\n        : vnode;\r\n}\r\nfunction setTransitionHooks(vnode, hooks) {\r\n    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {\r\n        setTransitionHooks(vnode.component.subTree, hooks);\r\n    }\r\n    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        vnode.ssContent.transition = hooks.clone(vnode.ssContent);\r\n        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\r\n    }\r\n    else {\r\n        vnode.transition = hooks;\r\n    }\r\n}\r\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\r\n    let ret = [];\r\n    let keyedFragmentCount = 0;\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        // #5360 inherit parent key in case of <template v-for>\r\n        const key = parentKey == null\r\n            ? child.key\r\n            : String(parentKey) + String(child.key != null ? child.key : i);\r\n        // handle fragment children case, e.g. v-for\r\n        if (child.type === Fragment) {\r\n            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)\r\n                keyedFragmentCount++;\r\n            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));\r\n        }\r\n        // comment placeholders should be skipped, e.g. v-if\r\n        else if (keepComment || child.type !== Comment) {\r\n            ret.push(key != null ? cloneVNode(child, { key }) : child);\r\n        }\r\n    }\r\n    // #1126 if a transition children list contains multiple sub fragments, these\r\n    // fragments will be merged into a flat children array. Since each v-for\r\n    // fragment may contain different static bindings inside, we need to de-op\r\n    // these children to force full diffs to ensure correct behavior.\r\n    if (keyedFragmentCount > 1) {\r\n        for (let i = 0; i < ret.length; i++) {\r\n            ret[i].patchFlag = -2 /* BAIL */;\r\n        }\r\n    }\r\n    return ret;\r\n}\n\n// implementation, close to no-op\r\nfunction defineComponent(options) {\r\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? { setup: options, name: options.name } : options;\r\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\r\nfunction defineAsyncComponent(source) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {\r\n        source = { loader: source };\r\n    }\r\n    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\r\n    suspensible = true, onError: userOnError } = source;\r\n    let pendingRequest = null;\r\n    let resolvedComp;\r\n    let retries = 0;\r\n    const retry = () => {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    const load = () => {\r\n        let thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest =\r\n                loader()\r\n                    .catch(err => {\r\n                    err = err instanceof Error ? err : new Error(String(err));\r\n                    if (userOnError) {\r\n                        return new Promise((resolve, reject) => {\r\n                            const userRetry = () => resolve(retry());\r\n                            const userFail = () => reject(err);\r\n                            userOnError(err, userRetry, userFail, retries + 1);\r\n                        });\r\n                    }\r\n                    else {\r\n                        throw err;\r\n                    }\r\n                })\r\n                    .then((comp) => {\r\n                    if (thisRequest !== pendingRequest && pendingRequest) {\r\n                        return pendingRequest;\r\n                    }\r\n                    if (( true) && !comp) {\r\n                        warn(`Async component loader resolved to undefined. ` +\r\n                            `If you are using retry(), make sure to return its return value.`);\r\n                    }\r\n                    // interop module default\r\n                    if (comp &&\r\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                        comp = comp.default;\r\n                    }\r\n                    if (( true) && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\r\n                        throw new Error(`Invalid async component load result: ${comp}`);\r\n                    }\r\n                    resolvedComp = comp;\r\n                    return comp;\r\n                })));\r\n    };\r\n    return defineComponent({\r\n        name: 'AsyncComponentWrapper',\r\n        __asyncLoader: load,\r\n        get __asyncResolved() {\r\n            return resolvedComp;\r\n        },\r\n        setup() {\r\n            const instance = currentInstance;\r\n            // already resolved\r\n            if (resolvedComp) {\r\n                return () => createInnerComp(resolvedComp, instance);\r\n            }\r\n            const onError = (err) => {\r\n                pendingRequest = null;\r\n                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\r\n            };\r\n            // suspense-controlled or SSR.\r\n            if ((suspensible && instance.suspense) ||\r\n                (isInSSRComponentSetup)) {\r\n                return load()\r\n                    .then(comp => {\r\n                    return () => createInnerComp(comp, instance);\r\n                })\r\n                    .catch(err => {\r\n                    onError(err);\r\n                    return () => errorComponent\r\n                        ? createVNode(errorComponent, {\r\n                            error: err\r\n                        })\r\n                        : null;\r\n                });\r\n            }\r\n            const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\r\n            const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();\r\n            const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);\r\n            if (delay) {\r\n                setTimeout(() => {\r\n                    delayed.value = false;\r\n                }, delay);\r\n            }\r\n            if (timeout != null) {\r\n                setTimeout(() => {\r\n                    if (!loaded.value && !error.value) {\r\n                        const err = new Error(`Async component timed out after ${timeout}ms.`);\r\n                        onError(err);\r\n                        error.value = err;\r\n                    }\r\n                }, timeout);\r\n            }\r\n            load()\r\n                .then(() => {\r\n                loaded.value = true;\r\n                if (instance.parent && isKeepAlive(instance.parent.vnode)) {\r\n                    // parent is keep-alive, force update so the loaded component's\r\n                    // name is taken into account\r\n                    queueJob(instance.parent.update);\r\n                }\r\n            })\r\n                .catch(err => {\r\n                onError(err);\r\n                error.value = err;\r\n            });\r\n            return () => {\r\n                if (loaded.value && resolvedComp) {\r\n                    return createInnerComp(resolvedComp, instance);\r\n                }\r\n                else if (error.value && errorComponent) {\r\n                    return createVNode(errorComponent, {\r\n                        error: error.value\r\n                    });\r\n                }\r\n                else if (loadingComponent && !delayed.value) {\r\n                    return createVNode(loadingComponent);\r\n                }\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction createInnerComp(comp, { vnode: { ref, props, children, shapeFlag }, parent }) {\r\n    const vnode = createVNode(comp, props, children);\r\n    // ensure inner component inherits the async wrapper's ref owner\r\n    vnode.ref = ref;\r\n    return vnode;\r\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\r\nconst KeepAliveImpl = {\r\n    name: `KeepAlive`,\r\n    // Marker for special handling inside the renderer. We are not using a ===\r\n    // check directly on KeepAlive in the renderer, because importing it directly\r\n    // would prevent it from being tree-shaken.\r\n    __isKeepAlive: true,\r\n    props: {\r\n        include: [String, RegExp, Array],\r\n        exclude: [String, RegExp, Array],\r\n        max: [String, Number]\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        // KeepAlive communicates with the instantiated renderer via the\r\n        // ctx where the renderer passes in its internals,\r\n        // and the KeepAlive instance exposes activate/deactivate implementations.\r\n        // The whole point of this is to avoid importing KeepAlive directly in the\r\n        // renderer to facilitate tree-shaking.\r\n        const sharedContext = instance.ctx;\r\n        // if the internal renderer is not registered, it indicates that this is server-side rendering,\r\n        // for KeepAlive, we just need to render its children\r\n        if (!sharedContext.renderer) {\r\n            return () => {\r\n                const children = slots.default && slots.default();\r\n                return children && children.length === 1 ? children[0] : children;\r\n            };\r\n        }\r\n        const cache = new Map();\r\n        const keys = new Set();\r\n        let current = null;\r\n        if (true) {\r\n            instance.__v_cache = cache;\r\n        }\r\n        const parentSuspense = instance.suspense;\r\n        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\r\n        const storageContainer = createElement('div');\r\n        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\r\n            const instance = vnode.component;\r\n            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);\r\n            // in case props have changed\r\n            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);\r\n            queuePostRenderEffect(() => {\r\n                instance.isDeactivated = false;\r\n                if (instance.a) {\r\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n            }, parentSuspense);\r\n            if (true) {\r\n                // Update components tree\r\n                devtoolsComponentAdded(instance);\r\n            }\r\n        };\r\n        sharedContext.deactivate = (vnode) => {\r\n            const instance = vnode.component;\r\n            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);\r\n            queuePostRenderEffect(() => {\r\n                if (instance.da) {\r\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n                instance.isDeactivated = true;\r\n            }, parentSuspense);\r\n            if (true) {\r\n                // Update components tree\r\n                devtoolsComponentAdded(instance);\r\n            }\r\n        };\r\n        function unmount(vnode) {\r\n            // reset the shapeFlag so it can be properly unmounted\r\n            resetShapeFlag(vnode);\r\n            _unmount(vnode, instance, parentSuspense, true);\r\n        }\r\n        function pruneCache(filter) {\r\n            cache.forEach((vnode, key) => {\r\n                const name = getComponentName(vnode.type);\r\n                if (name && (!filter || !filter(name))) {\r\n                    pruneCacheEntry(key);\r\n                }\r\n            });\r\n        }\r\n        function pruneCacheEntry(key) {\r\n            const cached = cache.get(key);\r\n            if (!current || cached.type !== current.type) {\r\n                unmount(cached);\r\n            }\r\n            else if (current) {\r\n                // current active instance should no longer be kept-alive.\r\n                // we can't unmount it now but it might be later, so reset its flag now.\r\n                resetShapeFlag(current);\r\n            }\r\n            cache.delete(key);\r\n            keys.delete(key);\r\n        }\r\n        // prune cache on include/exclude prop change\r\n        watch(() => [props.include, props.exclude], ([include, exclude]) => {\r\n            include && pruneCache(name => matches(include, name));\r\n            exclude && pruneCache(name => !matches(exclude, name));\r\n        }, \r\n        // prune post-render after `current` has been updated\r\n        { flush: 'post', deep: true });\r\n        // cache sub tree after render\r\n        let pendingCacheKey = null;\r\n        const cacheSubtree = () => {\r\n            // fix #1621, the pendingCacheKey could be 0\r\n            if (pendingCacheKey != null) {\r\n                cache.set(pendingCacheKey, getInnerChild(instance.subTree));\r\n            }\r\n        };\r\n        onMounted(cacheSubtree);\r\n        onUpdated(cacheSubtree);\r\n        onBeforeUnmount(() => {\r\n            cache.forEach(cached => {\r\n                const { subTree, suspense } = instance;\r\n                const vnode = getInnerChild(subTree);\r\n                if (cached.type === vnode.type) {\r\n                    // current instance will be unmounted as part of keep-alive's unmount\r\n                    resetShapeFlag(vnode);\r\n                    // but invoke its deactivated hook here\r\n                    const da = vnode.component.da;\r\n                    da && queuePostRenderEffect(da, suspense);\r\n                    return;\r\n                }\r\n                unmount(cached);\r\n            });\r\n        });\r\n        return () => {\r\n            pendingCacheKey = null;\r\n            if (!slots.default) {\r\n                return null;\r\n            }\r\n            const children = slots.default();\r\n            const rawVNode = children[0];\r\n            if (children.length > 1) {\r\n                if ((true)) {\r\n                    warn(`KeepAlive should contain exactly one component child.`);\r\n                }\r\n                current = null;\r\n                return children;\r\n            }\r\n            else if (!isVNode(rawVNode) ||\r\n                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&\r\n                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {\r\n                current = null;\r\n                return rawVNode;\r\n            }\r\n            let vnode = getInnerChild(rawVNode);\r\n            const comp = vnode.type;\r\n            // for async components, name check should be based in its loaded\r\n            // inner component if available\r\n            const name = getComponentName(isAsyncWrapper(vnode)\r\n                ? vnode.type.__asyncResolved || {}\r\n                : comp);\r\n            const { include, exclude, max } = props;\r\n            if ((include && (!name || !matches(include, name))) ||\r\n                (exclude && name && matches(exclude, name))) {\r\n                current = vnode;\r\n                return rawVNode;\r\n            }\r\n            const key = vnode.key == null ? comp : vnode.key;\r\n            const cachedVNode = cache.get(key);\r\n            // clone vnode if it's reused because we are going to mutate it\r\n            if (vnode.el) {\r\n                vnode = cloneVNode(vnode);\r\n                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {\r\n                    rawVNode.ssContent = vnode;\r\n                }\r\n            }\r\n            // #1513 it's possible for the returned vnode to be cloned due to attr\r\n            // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n            // that is mounted. Instead of caching it directly, we store the pending\r\n            // key and cache `instance.subTree` (the normalized vnode) in\r\n            // beforeMount/beforeUpdate hooks.\r\n            pendingCacheKey = key;\r\n            if (cachedVNode) {\r\n                // copy over mounted state\r\n                vnode.el = cachedVNode.el;\r\n                vnode.component = cachedVNode.component;\r\n                if (vnode.transition) {\r\n                    // recursively update transition hooks on subTree\r\n                    setTransitionHooks(vnode, vnode.transition);\r\n                }\r\n                // avoid vnode being mounted as fresh\r\n                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;\r\n                // make this key the freshest\r\n                keys.delete(key);\r\n                keys.add(key);\r\n            }\r\n            else {\r\n                keys.add(key);\r\n                // prune oldest entry\r\n                if (max && keys.size > parseInt(max, 10)) {\r\n                    pruneCacheEntry(keys.values().next().value);\r\n                }\r\n            }\r\n            // avoid vnode being unmounted\r\n            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n            current = vnode;\r\n            return isSuspense(rawVNode.type) ? rawVNode : vnode;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst KeepAlive = KeepAliveImpl;\r\nfunction matches(pattern, name) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {\r\n        return pattern.some((p) => matches(p, name));\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {\r\n        return pattern.split(',').includes(name);\r\n    }\r\n    else if (pattern.test) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction onActivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"a\" /* ACTIVATED */, target);\r\n}\r\nfunction onDeactivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"da\" /* DEACTIVATED */, target);\r\n}\r\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\r\n    // cache the deactivate branch check wrapper for injected hooks so the same\r\n    // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\r\n    // deactivation check\".\r\n    const wrappedHook = hook.__wdc ||\r\n        (hook.__wdc = () => {\r\n            // only fire the hook if the target instance is NOT in a deactivated branch.\r\n            let current = target;\r\n            while (current) {\r\n                if (current.isDeactivated) {\r\n                    return;\r\n                }\r\n                current = current.parent;\r\n            }\r\n            return hook();\r\n        });\r\n    injectHook(type, wrappedHook, target);\r\n    // In addition to registering it on the target instance, we walk up the parent\r\n    // chain and register it on all ancestor instances that are keep-alive roots.\r\n    // This avoids the need to walk the entire component tree when invoking these\r\n    // hooks, and more importantly, avoids the need to track child components in\r\n    // arrays.\r\n    if (target) {\r\n        let current = target.parent;\r\n        while (current && current.parent) {\r\n            if (isKeepAlive(current.parent.vnode)) {\r\n                injectToKeepAliveRoot(wrappedHook, type, target, current);\r\n            }\r\n            current = current.parent;\r\n        }\r\n    }\r\n}\r\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\r\n    // injectHook wraps the original for error handling, so make sure to remove\r\n    // the wrapped version.\r\n    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\r\n    onUnmounted(() => {\r\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);\r\n    }, target);\r\n}\r\nfunction resetShapeFlag(vnode) {\r\n    let shapeFlag = vnode.shapeFlag;\r\n    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n    }\r\n    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;\r\n    }\r\n    vnode.shapeFlag = shapeFlag;\r\n}\r\nfunction getInnerChild(vnode) {\r\n    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;\r\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\r\n    if (target) {\r\n        const hooks = target[type] || (target[type] = []);\r\n        // cache the error handling wrapper for injected hooks so the same hook\r\n        // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\r\n        // handling\".\r\n        const wrappedHook = hook.__weh ||\r\n            (hook.__weh = (...args) => {\r\n                if (target.isUnmounted) {\r\n                    return;\r\n                }\r\n                // disable tracking inside all lifecycle hooks\r\n                // since they can potentially be called inside effects.\r\n                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\r\n                // Set currentInstance during hook invocation.\r\n                // This assumes the hook does not synchronously trigger other hooks, which\r\n                // can only be false when the user does something really funky.\r\n                setCurrentInstance(target);\r\n                const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n                unsetCurrentInstance();\r\n                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\r\n                return res;\r\n            });\r\n        if (prepend) {\r\n            hooks.unshift(wrappedHook);\r\n        }\r\n        else {\r\n            hooks.push(wrappedHook);\r\n        }\r\n        return wrappedHook;\r\n    }\r\n    else if ((true)) {\r\n        const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));\r\n        warn(`${apiName} is called when there is no active component instance to be ` +\r\n            `associated with. ` +\r\n            `Lifecycle injection APIs can only be used during execution of setup().` +\r\n            (` If you are using async setup(), make sure to register lifecycle ` +\r\n                    `hooks before the first await statement.`\r\n                ));\r\n    }\r\n}\r\nconst createHook = (lifecycle) => (hook, target = currentInstance) => \r\n// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\r\n(!isInSSRComponentSetup || lifecycle === \"sp\" /* SERVER_PREFETCH */) &&\r\n    injectHook(lifecycle, hook, target);\r\nconst onBeforeMount = createHook(\"bm\" /* BEFORE_MOUNT */);\r\nconst onMounted = createHook(\"m\" /* MOUNTED */);\r\nconst onBeforeUpdate = createHook(\"bu\" /* BEFORE_UPDATE */);\r\nconst onUpdated = createHook(\"u\" /* UPDATED */);\r\nconst onBeforeUnmount = createHook(\"bum\" /* BEFORE_UNMOUNT */);\r\nconst onUnmounted = createHook(\"um\" /* UNMOUNTED */);\r\nconst onServerPrefetch = createHook(\"sp\" /* SERVER_PREFETCH */);\r\nconst onRenderTriggered = createHook(\"rtg\" /* RENDER_TRIGGERED */);\r\nconst onRenderTracked = createHook(\"rtc\" /* RENDER_TRACKED */);\r\nfunction onErrorCaptured(hook, target = currentInstance) {\r\n    injectHook(\"ec\" /* ERROR_CAPTURED */, hook, target);\r\n}\n\n/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\nfunction validateDirectiveName(name) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {\r\n        warn('Do not use built-in directive ids as custom directive id: ' + name);\r\n    }\r\n}\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nfunction withDirectives(vnode, directives) {\r\n    const internalInstance = currentRenderingInstance;\r\n    if (internalInstance === null) {\r\n        ( true) && warn(`withDirectives can only be used inside render functions.`);\r\n        return vnode;\r\n    }\r\n    const instance = getExposeProxy(internalInstance) ||\r\n        internalInstance.proxy;\r\n    const bindings = vnode.dirs || (vnode.dirs = []);\r\n    for (let i = 0; i < directives.length; i++) {\r\n        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {\r\n            dir = {\r\n                mounted: dir,\r\n                updated: dir\r\n            };\r\n        }\r\n        if (dir.deep) {\r\n            traverse(value);\r\n        }\r\n        bindings.push({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: void 0,\r\n            arg,\r\n            modifiers\r\n        });\r\n    }\r\n    return vnode;\r\n}\r\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\r\n    const bindings = vnode.dirs;\r\n    const oldBindings = prevVNode && prevVNode.dirs;\r\n    for (let i = 0; i < bindings.length; i++) {\r\n        const binding = bindings[i];\r\n        if (oldBindings) {\r\n            binding.oldValue = oldBindings[i].value;\r\n        }\r\n        let hook = binding.dir[name];\r\n        if (hook) {\r\n            // disable tracking inside all lifecycle hooks\r\n            // since they can potentially be called inside effects.\r\n            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\r\n            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [\r\n                vnode.el,\r\n                binding,\r\n                vnode,\r\n                prevVNode\r\n            ]);\r\n            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\r\n        }\r\n    }\r\n}\n\nconst COMPONENTS = 'components';\r\nconst DIRECTIVES = 'directives';\r\n/**\r\n * @private\r\n */\r\nfunction resolveComponent(name, maybeSelfReference) {\r\n    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\r\n}\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n/**\r\n * @private\r\n */\r\nfunction resolveDynamicComponent(component) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {\r\n        return resolveAsset(COMPONENTS, component, false) || component;\r\n    }\r\n    else {\r\n        // invalid types will fallthrough to createVNode and raise warning\r\n        return (component || NULL_DYNAMIC_COMPONENT);\r\n    }\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction resolveDirective(name) {\r\n    return resolveAsset(DIRECTIVES, name);\r\n}\r\n// implementation\r\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\r\n    const instance = currentRenderingInstance || currentInstance;\r\n    if (instance) {\r\n        const Component = instance.type;\r\n        // explicit self name has highest priority\r\n        if (type === COMPONENTS) {\r\n            const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);\r\n            if (selfName &&\r\n                (selfName === name ||\r\n                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) ||\r\n                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {\r\n                return Component;\r\n            }\r\n        }\r\n        const res = \r\n        // local registration\r\n        // check instance[type] first which is resolved for options API\r\n        resolve(instance[type] || Component[type], name) ||\r\n            // global registration\r\n            resolve(instance.appContext[type], name);\r\n        if (!res && maybeSelfReference) {\r\n            // fallback to implicit self-reference\r\n            return Component;\r\n        }\r\n        if (( true) && warnMissing && !res) {\r\n            const extra = type === COMPONENTS\r\n                ? `\\nIf this is a native custom element, make sure to exclude it from ` +\r\n                    `component resolution via compilerOptions.isCustomElement.`\r\n                : ``;\r\n            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);\r\n        }\r\n        return res;\r\n    }\r\n    else if ((true)) {\r\n        warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` +\r\n            `can only be used in render() or setup().`);\r\n    }\r\n}\r\nfunction resolve(registry, name) {\r\n    return (registry &&\r\n        (registry[name] ||\r\n            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] ||\r\n            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]));\r\n}\n\n/**\r\n * Actual implementation\r\n */\r\nfunction renderList(source, renderItem, cache, index) {\r\n    let ret;\r\n    const cached = (cache && cache[index]);\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {\r\n        ret = new Array(source.length);\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);\r\n        }\r\n    }\r\n    else if (typeof source === 'number') {\r\n        if (( true) && !Number.isInteger(source)) {\r\n            warn(`The v-for range expect an integer value but got ${source}.`);\r\n        }\r\n        ret = new Array(source);\r\n        for (let i = 0; i < source; i++) {\r\n            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);\r\n        }\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            ret = new Array(keys.length);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                ret[i] = renderItem(source[key], key, i, cached && cached[i]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        ret = [];\r\n    }\r\n    if (cache) {\r\n        cache[index] = ret;\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Compiler runtime helper for creating dynamic slots object\r\n * @private\r\n */\r\nfunction createSlots(slots, dynamicSlots) {\r\n    for (let i = 0; i < dynamicSlots.length; i++) {\r\n        const slot = dynamicSlots[i];\r\n        // array of dynamic slot generated by <template v-for=\"...\" #[...]>\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {\r\n            for (let j = 0; j < slot.length; j++) {\r\n                slots[slot[j].name] = slot[j].fn;\r\n            }\r\n        }\r\n        else if (slot) {\r\n            // conditional single slot generated by <template v-if=\"...\" #foo>\r\n            slots[slot.name] = slot.fn;\r\n        }\r\n    }\r\n    return slots;\r\n}\n\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * @private\r\n */\r\nfunction renderSlot(slots, name, props = {}, \r\n// this is not a user-facing function, so the fallback is always generated by\r\n// the compiler and guaranteed to be a function returning an array\r\nfallback, noSlotted) {\r\n    if (currentRenderingInstance.isCE ||\r\n        (currentRenderingInstance.parent &&\r\n            isAsyncWrapper(currentRenderingInstance.parent) &&\r\n            currentRenderingInstance.parent.isCE)) {\r\n        return createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());\r\n    }\r\n    let slot = slots[name];\r\n    if (( true) && slot && slot.length > 1) {\r\n        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +\r\n            `function. You need to mark this component with $dynamic-slots in the ` +\r\n            `parent template.`);\r\n        slot = () => [];\r\n    }\r\n    // a compiled slot disables block tracking by default to avoid manual\r\n    // invocation interfering with template-based block tracking, but in\r\n    // `renderSlot` we can be sure that it's template-based so we can force\r\n    // enable it.\r\n    if (slot && slot._c) {\r\n        slot._d = false;\r\n    }\r\n    openBlock();\r\n    const validSlotContent = slot && ensureValidVNode(slot(props));\r\n    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */\r\n        ? 64 /* STABLE_FRAGMENT */\r\n        : -2 /* BAIL */);\r\n    if (!noSlotted && rendered.scopeId) {\r\n        rendered.slotScopeIds = [rendered.scopeId + '-s'];\r\n    }\r\n    if (slot && slot._c) {\r\n        slot._d = true;\r\n    }\r\n    return rendered;\r\n}\r\nfunction ensureValidVNode(vnodes) {\r\n    return vnodes.some(child => {\r\n        if (!isVNode(child))\r\n            return true;\r\n        if (child.type === Comment)\r\n            return false;\r\n        if (child.type === Fragment &&\r\n            !ensureValidVNode(child.children))\r\n            return false;\r\n        return true;\r\n    })\r\n        ? vnodes\r\n        : null;\r\n}\n\n/**\r\n * For prefixing keys in v-on=\"obj\" with \"on\"\r\n * @private\r\n */\r\nfunction toHandlers(obj) {\r\n    const ret = {};\r\n    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {\r\n        warn(`v-on with no argument expects an object value.`);\r\n        return ret;\r\n    }\r\n    for (const key in obj) {\r\n        ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => {\r\n    if (!i)\r\n        return null;\r\n    if (isStatefulComponent(i))\r\n        return getExposeProxy(i) || i.proxy;\r\n    return getPublicInstance(i.parent);\r\n};\r\nconst publicPropertiesMap = \r\n// Move PURE marker to new line to workaround compiler discarding it\r\n// due to type annotation\r\n/*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0),\r\n    $attrs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0),\r\n    $slots: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0),\r\n    $refs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),\r\n    $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP)\r\n});\r\nconst isReservedPrefix = (key) => key === '_' || key === '$';\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // for internal formatters to know that this is a Vue instance\r\n        if (( true) && key === '__isVue') {\r\n            return true;\r\n        }\r\n        // prioritize <script setup> bindings during dev.\r\n        // this allows even properties that start with _ or $ to be used - so that\r\n        // it aligns with the production behavior where the render fn is inlined and\r\n        // indeed has access to all declared variables.\r\n        if (( true) &&\r\n            setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&\r\n            setupState.__isScriptSetup &&\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {\r\n            return setupState[key];\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 1 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 2 /* DATA */:\r\n                        return data[key];\r\n                    case 4 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 3 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {\r\n                accessCache[key] = 1 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\r\n                accessCache[key] = 2 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {\r\n                accessCache[key] = 3 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {\r\n                accessCache[key] = 4 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {\r\n                accessCache[key] = 0 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, \"get\" /* GET */, key);\r\n                ( true) && markAttrsAccessed();\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 4 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key))) {\r\n            {\r\n                return globalProperties[key];\r\n            }\r\n        }\r\n        else if (( true) &&\r\n            currentRenderingInstance &&\r\n            (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||\r\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                // to infinite warning loop\r\n                key.indexOf('__v') !== 0)) {\r\n            if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\r\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n            }\r\n            else if (instance === currentRenderingInstance) {\r\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                    `but is not defined on instance.`);\r\n            }\r\n        }\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {\r\n            setupState[key] = value;\r\n            return true;\r\n        }\r\n        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\r\n            data[key] = value;\r\n            return true;\r\n        }\r\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {\r\n            ( true) &&\r\n                warn(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            ( true) &&\r\n                warn(`Attempting to mutate public property \"${key}\". ` +\r\n                    `Properties starting with $ are reserved and readonly.`, instance);\r\n            return false;\r\n        }\r\n        else {\r\n            if (( true) && key in instance.appContext.config.globalProperties) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    value\r\n                });\r\n            }\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (!!accessCache[key] ||\r\n            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) ||\r\n            (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) ||\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) ||\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key));\r\n    },\r\n    defineProperty(target, key, descriptor) {\r\n        if (descriptor.get != null) {\r\n            // invalidate key cache of a getter based property #5417\r\n            target._.accessCache[key] = 0;\r\n        }\r\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(descriptor, 'value')) {\r\n            this.set(target, key, descriptor.value, null);\r\n        }\r\n        return Reflect.defineProperty(target, key, descriptor);\r\n    }\r\n};\r\nif (true) {\r\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n            `The keys will be empty in production mode to avoid performance overhead.`);\r\n        return Reflect.ownKeys(target);\r\n    };\r\n}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);\r\n        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {\r\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n        }\r\n        return has;\r\n    }\r\n});\r\n// dev only\r\n// In dev mode, the proxy target exposes the same properties as seen on `this`\r\n// for easier console inspection. In prod mode it will be an empty object so\r\n// these properties definitions can be skipped.\r\nfunction createDevRenderContext(instance) {\r\n    const target = {};\r\n    // expose internal instance for proxy handlers\r\n    Object.defineProperty(target, `_`, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        get: () => instance\r\n    });\r\n    // expose public properties\r\n    Object.keys(publicPropertiesMap).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => publicPropertiesMap[key](instance),\r\n            // intercepted by the proxy so no need for implementation,\r\n            // but needed to prevent set errors\r\n            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\r\n        });\r\n    });\r\n    return target;\r\n}\r\n// dev only\r\nfunction exposePropsOnRenderContext(instance) {\r\n    const { ctx, propsOptions: [propsOptions] } = instance;\r\n    if (propsOptions) {\r\n        Object.keys(propsOptions).forEach(key => {\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => instance.props[key],\r\n                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\r\n            });\r\n        });\r\n    }\r\n}\r\n// dev only\r\nfunction exposeSetupStateOnRenderContext(instance) {\r\n    const { ctx, setupState } = instance;\r\n    Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {\r\n        if (!setupState.__isScriptSetup) {\r\n            if (isReservedPrefix(key[0])) {\r\n                warn(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` +\r\n                    `which are reserved prefixes for Vue internals.`);\r\n                return;\r\n            }\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => setupState[key],\r\n                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\r\n            });\r\n        }\r\n    });\r\n}\n\nfunction createDuplicateChecker() {\r\n    const cache = Object.create(null);\r\n    return (type, key) => {\r\n        if (cache[key]) {\r\n            warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\r\n        }\r\n        else {\r\n            cache[key] = type;\r\n        }\r\n    };\r\n}\r\nlet shouldCacheAccess = true;\r\nfunction applyOptions(instance) {\r\n    const options = resolveMergedOptions(instance);\r\n    const publicThis = instance.proxy;\r\n    const ctx = instance.ctx;\r\n    // do not cache property access on public proxy during state initialization\r\n    shouldCacheAccess = false;\r\n    // call beforeCreate first before accessing other options since\r\n    // the hook may mutate resolved options (#2791)\r\n    if (options.beforeCreate) {\r\n        callHook(options.beforeCreate, instance, \"bc\" /* BEFORE_CREATE */);\r\n    }\r\n    const { \r\n    // state\r\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n    // lifecycle\r\n    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, \r\n    // public API\r\n    expose, inheritAttrs, \r\n    // assets\r\n    components, directives, filters } = options;\r\n    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;\r\n    if ((true)) {\r\n        const [propsOptions] = instance.propsOptions;\r\n        if (propsOptions) {\r\n            for (const key in propsOptions) {\r\n                checkDuplicateProperties(\"Props\" /* PROPS */, key);\r\n            }\r\n        }\r\n    }\r\n    // options initialization order (to be consistent with Vue 2):\r\n    // - props (already done outside of this function)\r\n    // - inject\r\n    // - methods\r\n    // - data (deferred since it relies on `this` access)\r\n    // - computed\r\n    // - watch (deferred since it relies on `this` access)\r\n    if (injectOptions) {\r\n        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);\r\n    }\r\n    if (methods) {\r\n        for (const key in methods) {\r\n            const methodHandler = methods[key];\r\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {\r\n                // In dev mode, we use the `createRenderContext` function to define\r\n                // methods to the proxy target, and those are read-only but\r\n                // reconfigurable, so it needs to be redefined here\r\n                if ((true)) {\r\n                    Object.defineProperty(ctx, key, {\r\n                        value: methodHandler.bind(publicThis),\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        writable: true\r\n                    });\r\n                }\r\n                else {}\r\n                if ((true)) {\r\n                    checkDuplicateProperties(\"Methods\" /* METHODS */, key);\r\n                }\r\n            }\r\n            else if ((true)) {\r\n                warn(`Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` +\r\n                    `Did you reference the function correctly?`);\r\n            }\r\n        }\r\n    }\r\n    if (dataOptions) {\r\n        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {\r\n            warn(`The data option must be a function. ` +\r\n                `Plain object usage is no longer supported.`);\r\n        }\r\n        const data = dataOptions.call(publicThis, publicThis);\r\n        if (( true) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {\r\n            warn(`data() returned a Promise - note data() cannot be async; If you ` +\r\n                `intend to perform data fetching before component renders, use ` +\r\n                `async setup() + <Suspense>.`);\r\n        }\r\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {\r\n            ( true) && warn(`data() should return an object.`);\r\n        }\r\n        else {\r\n            instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);\r\n            if ((true)) {\r\n                for (const key in data) {\r\n                    checkDuplicateProperties(\"Data\" /* DATA */, key);\r\n                    // expose data on ctx during dev\r\n                    if (!isReservedPrefix(key[0])) {\r\n                        Object.defineProperty(ctx, key, {\r\n                            configurable: true,\r\n                            enumerable: true,\r\n                            get: () => data[key],\r\n                            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // state initialization complete at this point - start caching access\r\n    shouldCacheAccess = true;\r\n    if (computedOptions) {\r\n        for (const key in computedOptions) {\r\n            const opt = computedOptions[key];\r\n            const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)\r\n                ? opt.bind(publicThis, publicThis)\r\n                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get)\r\n                    ? opt.get.bind(publicThis, publicThis)\r\n                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\r\n            if (( true) && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {\r\n                warn(`Computed property \"${key}\" has no getter.`);\r\n            }\r\n            const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set)\r\n                ? opt.set.bind(publicThis)\r\n                : ( true)\r\n                    ? () => {\r\n                        warn(`Write operation failed: computed property \"${key}\" is readonly.`);\r\n                    }\r\n                    : 0;\r\n            const c = computed({\r\n                get,\r\n                set\r\n            });\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => c.value,\r\n                set: v => (c.value = v)\r\n            });\r\n            if ((true)) {\r\n                checkDuplicateProperties(\"Computed\" /* COMPUTED */, key);\r\n            }\r\n        }\r\n    }\r\n    if (watchOptions) {\r\n        for (const key in watchOptions) {\r\n            createWatcher(watchOptions[key], ctx, publicThis, key);\r\n        }\r\n    }\r\n    if (provideOptions) {\r\n        const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)\r\n            ? provideOptions.call(publicThis)\r\n            : provideOptions;\r\n        Reflect.ownKeys(provides).forEach(key => {\r\n            provide(key, provides[key]);\r\n        });\r\n    }\r\n    if (created) {\r\n        callHook(created, instance, \"c\" /* CREATED */);\r\n    }\r\n    function registerLifecycleHook(register, hook) {\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\r\n            hook.forEach(_hook => register(_hook.bind(publicThis)));\r\n        }\r\n        else if (hook) {\r\n            register(hook.bind(publicThis));\r\n        }\r\n    }\r\n    registerLifecycleHook(onBeforeMount, beforeMount);\r\n    registerLifecycleHook(onMounted, mounted);\r\n    registerLifecycleHook(onBeforeUpdate, beforeUpdate);\r\n    registerLifecycleHook(onUpdated, updated);\r\n    registerLifecycleHook(onActivated, activated);\r\n    registerLifecycleHook(onDeactivated, deactivated);\r\n    registerLifecycleHook(onErrorCaptured, errorCaptured);\r\n    registerLifecycleHook(onRenderTracked, renderTracked);\r\n    registerLifecycleHook(onRenderTriggered, renderTriggered);\r\n    registerLifecycleHook(onBeforeUnmount, beforeUnmount);\r\n    registerLifecycleHook(onUnmounted, unmounted);\r\n    registerLifecycleHook(onServerPrefetch, serverPrefetch);\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {\r\n        if (expose.length) {\r\n            const exposed = instance.exposed || (instance.exposed = {});\r\n            expose.forEach(key => {\r\n                Object.defineProperty(exposed, key, {\r\n                    get: () => publicThis[key],\r\n                    set: val => (publicThis[key] = val)\r\n                });\r\n            });\r\n        }\r\n        else if (!instance.exposed) {\r\n            instance.exposed = {};\r\n        }\r\n    }\r\n    // options that are handled when creating the instance but also need to be\r\n    // applied from mixins\r\n    if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {\r\n        instance.render = render;\r\n    }\r\n    if (inheritAttrs != null) {\r\n        instance.inheritAttrs = inheritAttrs;\r\n    }\r\n    // asset options.\r\n    if (components)\r\n        instance.components = components;\r\n    if (directives)\r\n        instance.directives = directives;\r\n}\r\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, unwrapRef = false) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {\r\n        injectOptions = normalizeInject(injectOptions);\r\n    }\r\n    for (const key in injectOptions) {\r\n        const opt = injectOptions[key];\r\n        let injected;\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {\r\n            if ('default' in opt) {\r\n                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);\r\n            }\r\n            else {\r\n                injected = inject(opt.from || key);\r\n            }\r\n        }\r\n        else {\r\n            injected = inject(opt);\r\n        }\r\n        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {\r\n            // TODO remove the check in 3.3\r\n            if (unwrapRef) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    get: () => injected.value,\r\n                    set: v => (injected.value = v)\r\n                });\r\n            }\r\n            else {\r\n                if ((true)) {\r\n                    warn(`injected property \"${key}\" is a ref and will be auto-unwrapped ` +\r\n                        `and no longer needs \\`.value\\` in the next minor release. ` +\r\n                        `To opt-in to the new behavior now, ` +\r\n                        `set \\`app.config.unwrapInjectedRef = true\\` (this config is ` +\r\n                        `temporary and will not be needed in the future.)`);\r\n                }\r\n                ctx[key] = injected;\r\n            }\r\n        }\r\n        else {\r\n            ctx[key] = injected;\r\n        }\r\n        if ((true)) {\r\n            checkDuplicateProperties(\"Inject\" /* INJECT */, key);\r\n        }\r\n    }\r\n}\r\nfunction callHook(hook, instance, type) {\r\n    callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)\r\n        ? hook.map(h => h.bind(instance.proxy))\r\n        : hook.bind(instance.proxy), instance, type);\r\n}\r\nfunction createWatcher(raw, ctx, publicThis, key) {\r\n    const getter = key.includes('.')\r\n        ? createPathGetter(publicThis, key)\r\n        : () => publicThis[key];\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {\r\n        const handler = ctx[raw];\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {\r\n            watch(getter, handler);\r\n        }\r\n        else if ((true)) {\r\n            warn(`Invalid watch handler specified by key \"${raw}\"`, handler);\r\n        }\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {\r\n        watch(getter, raw.bind(publicThis));\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\r\n            raw.forEach(r => createWatcher(r, ctx, publicThis, key));\r\n        }\r\n        else {\r\n            const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)\r\n                ? raw.handler.bind(publicThis)\r\n                : ctx[raw.handler];\r\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {\r\n                watch(getter, handler, raw);\r\n            }\r\n            else if ((true)) {\r\n                warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\r\n            }\r\n        }\r\n    }\r\n    else if ((true)) {\r\n        warn(`Invalid watch option: \"${key}\"`, raw);\r\n    }\r\n}\r\n/**\r\n * Resolve merged options and cache it on the component.\r\n * This is done only once per-component since the merging does not involve\r\n * instances.\r\n */\r\nfunction resolveMergedOptions(instance) {\r\n    const base = instance.type;\r\n    const { mixins, extends: extendsOptions } = base;\r\n    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;\r\n    const cached = cache.get(base);\r\n    let resolved;\r\n    if (cached) {\r\n        resolved = cached;\r\n    }\r\n    else if (!globalMixins.length && !mixins && !extendsOptions) {\r\n        {\r\n            resolved = base;\r\n        }\r\n    }\r\n    else {\r\n        resolved = {};\r\n        if (globalMixins.length) {\r\n            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\r\n        }\r\n        mergeOptions(resolved, base, optionMergeStrategies);\r\n    }\r\n    cache.set(base, resolved);\r\n    return resolved;\r\n}\r\nfunction mergeOptions(to, from, strats, asMixin = false) {\r\n    const { mixins, extends: extendsOptions } = from;\r\n    if (extendsOptions) {\r\n        mergeOptions(to, extendsOptions, strats, true);\r\n    }\r\n    if (mixins) {\r\n        mixins.forEach((m) => mergeOptions(to, m, strats, true));\r\n    }\r\n    for (const key in from) {\r\n        if (asMixin && key === 'expose') {\r\n            ( true) &&\r\n                warn(`\"expose\" option is ignored when declared in mixins or extends. ` +\r\n                    `It should only be declared in the base component itself.`);\r\n        }\r\n        else {\r\n            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);\r\n            to[key] = strat ? strat(to[key], from[key]) : from[key];\r\n        }\r\n    }\r\n    return to;\r\n}\r\nconst internalOptionMergeStrats = {\r\n    data: mergeDataFn,\r\n    props: mergeObjectOptions,\r\n    emits: mergeObjectOptions,\r\n    // objects\r\n    methods: mergeObjectOptions,\r\n    computed: mergeObjectOptions,\r\n    // lifecycle\r\n    beforeCreate: mergeAsArray,\r\n    created: mergeAsArray,\r\n    beforeMount: mergeAsArray,\r\n    mounted: mergeAsArray,\r\n    beforeUpdate: mergeAsArray,\r\n    updated: mergeAsArray,\r\n    beforeDestroy: mergeAsArray,\r\n    beforeUnmount: mergeAsArray,\r\n    destroyed: mergeAsArray,\r\n    unmounted: mergeAsArray,\r\n    activated: mergeAsArray,\r\n    deactivated: mergeAsArray,\r\n    errorCaptured: mergeAsArray,\r\n    serverPrefetch: mergeAsArray,\r\n    // assets\r\n    components: mergeObjectOptions,\r\n    directives: mergeObjectOptions,\r\n    // watch\r\n    watch: mergeWatchOptions,\r\n    // provide / inject\r\n    provide: mergeDataFn,\r\n    inject: mergeInject\r\n};\r\nfunction mergeDataFn(to, from) {\r\n    if (!from) {\r\n        return to;\r\n    }\r\n    if (!to) {\r\n        return from;\r\n    }\r\n    return function mergedDataFn() {\r\n        return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);\r\n    };\r\n}\r\nfunction mergeInject(to, from) {\r\n    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\r\n}\r\nfunction normalizeInject(raw) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\r\n        const res = {};\r\n        for (let i = 0; i < raw.length; i++) {\r\n            res[raw[i]] = raw[i];\r\n        }\r\n        return res;\r\n    }\r\n    return raw;\r\n}\r\nfunction mergeAsArray(to, from) {\r\n    return to ? [...new Set([].concat(to, from))] : from;\r\n}\r\nfunction mergeObjectOptions(to, from) {\r\n    return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;\r\n}\r\nfunction mergeWatchOptions(to, from) {\r\n    if (!to)\r\n        return from;\r\n    if (!from)\r\n        return to;\r\n    const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);\r\n    for (const key in from) {\r\n        merged[key] = mergeAsArray(to[key], from[key]);\r\n    }\r\n    return merged;\r\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\r\nisSSR = false) {\r\n    const props = {};\r\n    const attrs = {};\r\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);\r\n    instance.propsDefaults = Object.create(null);\r\n    setFullProps(instance, rawProps, props, attrs);\r\n    // ensure all declared prop keys are present\r\n    for (const key in instance.propsOptions[0]) {\r\n        if (!(key in props)) {\r\n            props[key] = undefined;\r\n        }\r\n    }\r\n    // validation\r\n    if ((true)) {\r\n        validateProps(rawProps || {}, props, instance);\r\n    }\r\n    if (isStateful) {\r\n        // stateful\r\n        instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);\r\n    }\r\n    else {\r\n        if (!instance.type.props) {\r\n            // functional w/ optional props, props === attrs\r\n            instance.props = attrs;\r\n        }\r\n        else {\r\n            // functional w/ declared props\r\n            instance.props = props;\r\n        }\r\n    }\r\n    instance.attrs = attrs;\r\n}\r\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\r\n    const { props, attrs, vnode: { patchFlag } } = instance;\r\n    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\r\n    const [options] = instance.propsOptions;\r\n    let hasAttrsChanged = false;\r\n    if (\r\n    // always force full diff in dev\r\n    // - #1942 if hmr is enabled with sfc component\r\n    // - vite#872 non-sfc component used by sfc component\r\n    !(( true) &&\r\n        (instance.type.__hmrId ||\r\n            (instance.parent && instance.parent.type.__hmrId))) &&\r\n        (optimized || patchFlag > 0) &&\r\n        !(patchFlag & 16 /* FULL_PROPS */)) {\r\n        if (patchFlag & 8 /* PROPS */) {\r\n            // Compiler-generated props & no keys change, just set the updated\r\n            // the props.\r\n            const propsToUpdate = instance.vnode.dynamicProps;\r\n            for (let i = 0; i < propsToUpdate.length; i++) {\r\n                let key = propsToUpdate[i];\r\n                // skip if the prop key is a declared emit event listener\r\n                if (isEmitListener(instance.emitsOptions, key)) {\r\n                    continue;\r\n                }\r\n                // PROPS flag guarantees rawProps to be non-null\r\n                const value = rawProps[key];\r\n                if (options) {\r\n                    // attr / props separation was done on init and will be consistent\r\n                    // in this code path, so just check if attrs have it.\r\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {\r\n                        if (value !== attrs[key]) {\r\n                            attrs[key] = value;\r\n                            hasAttrsChanged = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);\r\n                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);\r\n                    }\r\n                }\r\n                else {\r\n                    if (value !== attrs[key]) {\r\n                        attrs[key] = value;\r\n                        hasAttrsChanged = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // full props update.\r\n        if (setFullProps(instance, rawProps, props, attrs)) {\r\n            hasAttrsChanged = true;\r\n        }\r\n        // in case of dynamic props, check if we need to delete keys from\r\n        // the props object\r\n        let kebabKey;\r\n        for (const key in rawCurrentProps) {\r\n            if (!rawProps ||\r\n                // for camelCase\r\n                (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&\r\n                    // it's possible the original props was passed in as kebab-case\r\n                    // and converted to camelCase (#955)\r\n                    ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey)))) {\r\n                if (options) {\r\n                    if (rawPrevProps &&\r\n                        // for camelCase\r\n                        (rawPrevProps[key] !== undefined ||\r\n                            // for kebab-case\r\n                            rawPrevProps[kebabKey] !== undefined)) {\r\n                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);\r\n                    }\r\n                }\r\n                else {\r\n                    delete props[key];\r\n                }\r\n            }\r\n        }\r\n        // in the case of functional component w/o props declaration, props and\r\n        // attrs point to the same object so it should already have been updated.\r\n        if (attrs !== rawCurrentProps) {\r\n            for (const key in attrs) {\r\n                if (!rawProps ||\r\n                    (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&\r\n                        (!false ))) {\r\n                    delete attrs[key];\r\n                    hasAttrsChanged = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // trigger updates for $attrs in case it's used in component slots\r\n    if (hasAttrsChanged) {\r\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, \"set\" /* SET */, '$attrs');\r\n    }\r\n    if ((true)) {\r\n        validateProps(rawProps || {}, props, instance);\r\n    }\r\n}\r\nfunction setFullProps(instance, rawProps, props, attrs) {\r\n    const [options, needCastKeys] = instance.propsOptions;\r\n    let hasAttrsChanged = false;\r\n    let rawCastValues;\r\n    if (rawProps) {\r\n        for (let key in rawProps) {\r\n            // key, ref are reserved and never passed down\r\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {\r\n                continue;\r\n            }\r\n            const value = rawProps[key];\r\n            // prop option names are camelized during normalization, so to support\r\n            // kebab -> camel conversion here we need to camelize the key.\r\n            let camelKey;\r\n            if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)))) {\r\n                if (!needCastKeys || !needCastKeys.includes(camelKey)) {\r\n                    props[camelKey] = value;\r\n                }\r\n                else {\r\n                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;\r\n                }\r\n            }\r\n            else if (!isEmitListener(instance.emitsOptions, key)) {\r\n                if (!(key in attrs) || value !== attrs[key]) {\r\n                    attrs[key] = value;\r\n                    hasAttrsChanged = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (needCastKeys) {\r\n        const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\r\n        const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n        for (let i = 0; i < needCastKeys.length; i++) {\r\n            const key = needCastKeys[i];\r\n            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));\r\n        }\r\n    }\r\n    return hasAttrsChanged;\r\n}\r\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\r\n    const opt = options[key];\r\n    if (opt != null) {\r\n        const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');\r\n        // default values\r\n        if (hasDefault && value === undefined) {\r\n            const defaultValue = opt.default;\r\n            if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {\r\n                const { propsDefaults } = instance;\r\n                if (key in propsDefaults) {\r\n                    value = propsDefaults[key];\r\n                }\r\n                else {\r\n                    setCurrentInstance(instance);\r\n                    value = propsDefaults[key] = defaultValue.call(null, props);\r\n                    unsetCurrentInstance();\r\n                }\r\n            }\r\n            else {\r\n                value = defaultValue;\r\n            }\r\n        }\r\n        // boolean casting\r\n        if (opt[0 /* shouldCast */]) {\r\n            if (isAbsent && !hasDefault) {\r\n                value = false;\r\n            }\r\n            else if (opt[1 /* shouldCastTrue */] &&\r\n                (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\r\n    const cache = appContext.propsCache;\r\n    const cached = cache.get(comp);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    const raw = comp.props;\r\n    const normalized = {};\r\n    const needCastKeys = [];\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\r\n        const extendProps = (raw) => {\r\n            hasExtends = true;\r\n            const [props, keys] = normalizePropsOptions(raw, appContext, true);\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);\r\n            if (keys)\r\n                needCastKeys.push(...keys);\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendProps);\r\n        }\r\n        if (comp.extends) {\r\n            extendProps(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendProps);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);\r\n        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\r\n    }\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\r\n        for (let i = 0; i < raw.length; i++) {\r\n            if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {\r\n                warn(`props must be strings when using array syntax.`, raw[i]);\r\n            }\r\n            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);\r\n            if (validatePropName(normalizedKey)) {\r\n                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n            }\r\n        }\r\n    }\r\n    else if (raw) {\r\n        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {\r\n            warn(`invalid props options`, raw);\r\n        }\r\n        for (const key in raw) {\r\n            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);\r\n            if (validatePropName(normalizedKey)) {\r\n                const opt = raw[key];\r\n                const prop = (normalized[normalizedKey] =\r\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : opt);\r\n                if (prop) {\r\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                    const stringIndex = getTypeIndex(String, prop.type);\r\n                    prop[0 /* shouldCast */] = booleanIndex > -1;\r\n                    prop[1 /* shouldCastTrue */] =\r\n                        stringIndex < 0 || booleanIndex < stringIndex;\r\n                    // if the prop needs boolean casting or default value\r\n                    if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {\r\n                        needCastKeys.push(normalizedKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const res = [normalized, needCastKeys];\r\n    cache.set(comp, res);\r\n    return res;\r\n}\r\nfunction validatePropName(key) {\r\n    if (key[0] !== '$') {\r\n        return true;\r\n    }\r\n    else if ((true)) {\r\n        warn(`Invalid prop name: \"${key}\" is a reserved property.`);\r\n    }\r\n    return false;\r\n}\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor) {\r\n    const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n    return match ? match[1] : ctor === null ? 'null' : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {\r\n        return expectedTypes.findIndex(t => isSameType(t, type));\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProps(rawProps, props, instance) {\r\n    const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\r\n    const options = instance.propsOptions[0];\r\n    for (const key in options) {\r\n        let opt = options[key];\r\n        if (opt == null)\r\n            continue;\r\n        validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProp(name, value, prop, isAbsent) {\r\n    const { type, required, validator } = prop;\r\n    // required!\r\n    if (required && isAbsent) {\r\n        warn('Missing required prop: \"' + name + '\"');\r\n        return;\r\n    }\r\n    // missing but optional\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    // type check\r\n    if (type != null && type !== true) {\r\n        let isValid = false;\r\n        const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];\r\n        const expectedTypes = [];\r\n        // value is valid as long as one of the specified types match\r\n        for (let i = 0; i < types.length && !isValid; i++) {\r\n            const { valid, expectedType } = assertType(value, types[i]);\r\n            expectedTypes.push(expectedType || '');\r\n            isValid = valid;\r\n        }\r\n        if (!isValid) {\r\n            warn(getInvalidTypeMessage(name, value, expectedTypes));\r\n            return;\r\n        }\r\n    }\r\n    // custom validator\r\n    if (validator && !validator(value)) {\r\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\r\n    }\r\n}\r\nconst isSimpleType = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');\r\n/**\r\n * dev only\r\n */\r\nfunction assertType(value, type) {\r\n    let valid;\r\n    const expectedType = getType(type);\r\n    if (isSimpleType(expectedType)) {\r\n        const t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);\r\n    }\r\n    else if (expectedType === 'null') {\r\n        valid = value === null;\r\n    }\r\n    else {\r\n        valid = value instanceof type;\r\n    }\r\n    return {\r\n        valid,\r\n        expectedType\r\n    };\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\r\n        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(' | ')}`;\r\n    const expectedType = expectedTypes[0];\r\n    const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);\r\n    const expectedValue = styleValue(value, expectedType);\r\n    const receivedValue = styleValue(value, receivedType);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += ` with value ${expectedValue}`;\r\n    }\r\n    message += `, got ${receivedType} `;\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += `with value ${receivedValue}.`;\r\n    }\r\n    return message;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return `\"${value}\"`;\r\n    }\r\n    else if (type === 'Number') {\r\n        return `${Number(value)}`;\r\n    }\r\n    else {\r\n        return `${value}`;\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isExplicable(type) {\r\n    const explicitTypes = ['string', 'number', 'boolean'];\r\n    return explicitTypes.some(elem => type.toLowerCase() === elem);\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isBoolean(...args) {\r\n    return args.some(elem => elem.toLowerCase() === 'boolean');\r\n}\n\nconst isInternalKey = (key) => key[0] === '_' || key === '$stable';\r\nconst normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)\r\n    ? value.map(normalizeVNode)\r\n    : [normalizeVNode(value)];\r\nconst normalizeSlot = (key, rawSlot, ctx) => {\r\n    if (rawSlot._n) {\r\n        // already normalized - #5353\r\n        return rawSlot;\r\n    }\r\n    const normalized = withCtx((...args) => {\r\n        if (( true) && currentInstance) {\r\n            warn(`Slot \"${key}\" invoked outside of the render function: ` +\r\n                `this will not track dependencies used in the slot. ` +\r\n                `Invoke the slot function inside the render function instead.`);\r\n        }\r\n        return normalizeSlotValue(rawSlot(...args));\r\n    }, ctx);\r\n    normalized._c = false;\r\n    return normalized;\r\n};\r\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\r\n    const ctx = rawSlots._ctx;\r\n    for (const key in rawSlots) {\r\n        if (isInternalKey(key))\r\n            continue;\r\n        const value = rawSlots[key];\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\r\n            slots[key] = normalizeSlot(key, value, ctx);\r\n        }\r\n        else if (value != null) {\r\n            if (true) {\r\n                warn(`Non-function value encountered for slot \"${key}\". ` +\r\n                    `Prefer function slots for better performance.`);\r\n            }\r\n            const normalized = normalizeSlotValue(value);\r\n            slots[key] = () => normalized;\r\n        }\r\n    }\r\n};\r\nconst normalizeVNodeSlots = (instance, children) => {\r\n    if (( true) &&\r\n        !isKeepAlive(instance.vnode) &&\r\n        !(false )) {\r\n        warn(`Non-function value encountered for default slot. ` +\r\n            `Prefer function slots for better performance.`);\r\n    }\r\n    const normalized = normalizeSlotValue(children);\r\n    instance.slots.default = () => normalized;\r\n};\r\nconst initSlots = (instance, children) => {\r\n    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            // users can get the shallow readonly version of the slots object through `this.$slots`,\r\n            // we should avoid the proxy object polluting the slots of the internal instance\r\n            instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);\r\n            // make compiler marker non-enumerable\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);\r\n        }\r\n        else {\r\n            normalizeObjectSlots(children, (instance.slots = {}));\r\n        }\r\n    }\r\n    else {\r\n        instance.slots = {};\r\n        if (children) {\r\n            normalizeVNodeSlots(instance, children);\r\n        }\r\n    }\r\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);\r\n};\r\nconst updateSlots = (instance, children, optimized) => {\r\n    const { vnode, slots } = instance;\r\n    let needDeletionCheck = true;\r\n    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            // compiled slots.\r\n            if (( true) && isHmrUpdating) {\r\n                // Parent was HMR updated so slot content may have changed.\r\n                // force update slots and mark instance for hmr as well\r\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);\r\n            }\r\n            else if (optimized && type === 1 /* STABLE */) {\r\n                // compiled AND stable.\r\n                // no need to update, and skip stale slots removal.\r\n                needDeletionCheck = false;\r\n            }\r\n            else {\r\n                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n                // normalization.\r\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);\r\n                // #2893\r\n                // when rendering the optimized slots by manually written render function,\r\n                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\r\n                // i.e. let the `renderSlot` create the bailed Fragment\r\n                if (!optimized && type === 1 /* STABLE */) {\r\n                    delete slots._;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            needDeletionCheck = !children.$stable;\r\n            normalizeObjectSlots(children, slots);\r\n        }\r\n        deletionComparisonTarget = children;\r\n    }\r\n    else if (children) {\r\n        // non slot object children (direct value) passed to a component\r\n        normalizeVNodeSlots(instance, children);\r\n        deletionComparisonTarget = { default: 1 };\r\n    }\r\n    // delete stale slots\r\n    if (needDeletionCheck) {\r\n        for (const key in slots) {\r\n            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\r\n                delete slots[key];\r\n            }\r\n        }\r\n    }\r\n};\n\nfunction createAppContext() {\r\n    return {\r\n        app: null,\r\n        config: {\r\n            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,\r\n            performance: false,\r\n            globalProperties: {},\r\n            optionMergeStrategies: {},\r\n            errorHandler: undefined,\r\n            warnHandler: undefined,\r\n            compilerOptions: {}\r\n        },\r\n        mixins: [],\r\n        components: {},\r\n        directives: {},\r\n        provides: Object.create(null),\r\n        optionsCache: new WeakMap(),\r\n        propsCache: new WeakMap(),\r\n        emitsCache: new WeakMap()\r\n    };\r\n}\r\nlet uid = 0;\r\nfunction createAppAPI(render, hydrate) {\r\n    return function createApp(rootComponent, rootProps = null) {\r\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rootComponent)) {\r\n            rootComponent = Object.assign({}, rootComponent);\r\n        }\r\n        if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {\r\n            ( true) && warn(`root props passed to app.mount() must be an object.`);\r\n            rootProps = null;\r\n        }\r\n        const context = createAppContext();\r\n        const installedPlugins = new Set();\r\n        let isMounted = false;\r\n        const app = (context.app = {\r\n            _uid: uid++,\r\n            _component: rootComponent,\r\n            _props: rootProps,\r\n            _container: null,\r\n            _context: context,\r\n            _instance: null,\r\n            version,\r\n            get config() {\r\n                return context.config;\r\n            },\r\n            set config(v) {\r\n                if ((true)) {\r\n                    warn(`app.config cannot be replaced. Modify individual options instead.`);\r\n                }\r\n            },\r\n            use(plugin, ...options) {\r\n                if (installedPlugins.has(plugin)) {\r\n                    ( true) && warn(`Plugin has already been applied to target app.`);\r\n                }\r\n                else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin.install(app, ...options);\r\n                }\r\n                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin(app, ...options);\r\n                }\r\n                else if ((true)) {\r\n                    warn(`A plugin must either be a function or an object with an \"install\" ` +\r\n                        `function.`);\r\n                }\r\n                return app;\r\n            },\r\n            mixin(mixin) {\r\n                if (__VUE_OPTIONS_API__) {\r\n                    if (!context.mixins.includes(mixin)) {\r\n                        context.mixins.push(mixin);\r\n                    }\r\n                    else if ((true)) {\r\n                        warn('Mixin has already been applied to target app' +\r\n                            (mixin.name ? `: ${mixin.name}` : ''));\r\n                    }\r\n                }\r\n                else if ((true)) {\r\n                    warn('Mixins are only available in builds supporting Options API');\r\n                }\r\n                return app;\r\n            },\r\n            component(name, component) {\r\n                if ((true)) {\r\n                    validateComponentName(name, context.config);\r\n                }\r\n                if (!component) {\r\n                    return context.components[name];\r\n                }\r\n                if (( true) && context.components[name]) {\r\n                    warn(`Component \"${name}\" has already been registered in target app.`);\r\n                }\r\n                context.components[name] = component;\r\n                return app;\r\n            },\r\n            directive(name, directive) {\r\n                if ((true)) {\r\n                    validateDirectiveName(name);\r\n                }\r\n                if (!directive) {\r\n                    return context.directives[name];\r\n                }\r\n                if (( true) && context.directives[name]) {\r\n                    warn(`Directive \"${name}\" has already been registered in target app.`);\r\n                }\r\n                context.directives[name] = directive;\r\n                return app;\r\n            },\r\n            mount(rootContainer, isHydrate, isSVG) {\r\n                if (!isMounted) {\r\n                    // #5571\r\n                    if (( true) && rootContainer.__vue_app__) {\r\n                        warn(`There is already an app instance mounted on the host container.\\n` +\r\n                            ` If you want to mount another app on the same host container,` +\r\n                            ` you need to unmount the previous app by calling \\`app.unmount()\\` first.`);\r\n                    }\r\n                    const vnode = createVNode(rootComponent, rootProps);\r\n                    // store app context on the root VNode.\r\n                    // this will be set on the root instance on initial mount.\r\n                    vnode.appContext = context;\r\n                    // HMR root reload\r\n                    if ((true)) {\r\n                        context.reload = () => {\r\n                            render(cloneVNode(vnode), rootContainer, isSVG);\r\n                        };\r\n                    }\r\n                    if (isHydrate && hydrate) {\r\n                        hydrate(vnode, rootContainer);\r\n                    }\r\n                    else {\r\n                        render(vnode, rootContainer, isSVG);\r\n                    }\r\n                    isMounted = true;\r\n                    app._container = rootContainer;\r\n                    rootContainer.__vue_app__ = app;\r\n                    if (true) {\r\n                        app._instance = vnode.component;\r\n                        devtoolsInitApp(app, version);\r\n                    }\r\n                    return getExposeProxy(vnode.component) || vnode.component.proxy;\r\n                }\r\n                else if ((true)) {\r\n                    warn(`App has already been mounted.\\n` +\r\n                        `If you want to remount the same app, move your app creation logic ` +\r\n                        `into a factory function and create fresh app instances for each ` +\r\n                        `mount - e.g. \\`const createMyApp = () => createApp(App)\\``);\r\n                }\r\n            },\r\n            unmount() {\r\n                if (isMounted) {\r\n                    render(null, app._container);\r\n                    if (true) {\r\n                        app._instance = null;\r\n                        devtoolsUnmountApp(app);\r\n                    }\r\n                    delete app._container.__vue_app__;\r\n                }\r\n                else if ((true)) {\r\n                    warn(`Cannot unmount an app that is not mounted.`);\r\n                }\r\n            },\r\n            provide(key, value) {\r\n                if (( true) && key in context.provides) {\r\n                    warn(`App already provides property with key \"${String(key)}\". ` +\r\n                        `It will be overwritten with the new value.`);\r\n                }\r\n                context.provides[key] = value;\r\n                return app;\r\n            }\r\n        });\r\n        return app;\r\n    };\r\n}\n\n/**\r\n * Function for handling a template ref\r\n */\r\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {\r\n        rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\r\n        return;\r\n    }\r\n    if (isAsyncWrapper(vnode) && !isUnmount) {\r\n        // when mounting async components, nothing needs to be done,\r\n        // because the template ref is forwarded to inner component\r\n        return;\r\n    }\r\n    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */\r\n        ? getExposeProxy(vnode.component) || vnode.component.proxy\r\n        : vnode.el;\r\n    const value = isUnmount ? null : refValue;\r\n    const { i: owner, r: ref } = rawRef;\r\n    if (( true) && !owner) {\r\n        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\r\n            `A vnode with ref must be created inside the render function.`);\r\n        return;\r\n    }\r\n    const oldRef = oldRawRef && oldRawRef.r;\r\n    const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;\r\n    const setupState = owner.setupState;\r\n    // dynamic ref changed. unset old ref\r\n    if (oldRef != null && oldRef !== ref) {\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {\r\n            refs[oldRef] = null;\r\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {\r\n                setupState[oldRef] = null;\r\n            }\r\n        }\r\n        else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {\r\n            oldRef.value = null;\r\n        }\r\n    }\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {\r\n        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);\r\n    }\r\n    else {\r\n        const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);\r\n        const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);\r\n        if (_isString || _isRef) {\r\n            const doSet = () => {\r\n                if (rawRef.f) {\r\n                    const existing = _isString ? refs[ref] : ref.value;\r\n                    if (isUnmount) {\r\n                        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);\r\n                    }\r\n                    else {\r\n                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {\r\n                            if (_isString) {\r\n                                refs[ref] = [refValue];\r\n                                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {\r\n                                    setupState[ref] = refs[ref];\r\n                                }\r\n                            }\r\n                            else {\r\n                                ref.value = [refValue];\r\n                                if (rawRef.k)\r\n                                    refs[rawRef.k] = ref.value;\r\n                            }\r\n                        }\r\n                        else if (!existing.includes(refValue)) {\r\n                            existing.push(refValue);\r\n                        }\r\n                    }\r\n                }\r\n                else if (_isString) {\r\n                    refs[ref] = value;\r\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {\r\n                        setupState[ref] = value;\r\n                    }\r\n                }\r\n                else if (_isRef) {\r\n                    ref.value = value;\r\n                    if (rawRef.k)\r\n                        refs[rawRef.k] = value;\r\n                }\r\n                else if ((true)) {\r\n                    warn('Invalid template ref type:', ref, `(${typeof ref})`);\r\n                }\r\n            };\r\n            if (value) {\r\n                doSet.id = -1;\r\n                queuePostRenderEffect(doSet, parentSuspense);\r\n            }\r\n            else {\r\n                doSet();\r\n            }\r\n        }\r\n        else if ((true)) {\r\n            warn('Invalid template ref type:', ref, `(${typeof ref})`);\r\n        }\r\n    }\r\n}\n\nlet hasMismatch = false;\r\nconst isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\r\nconst isComment = (node) => node.nodeType === 8 /* COMMENT */;\r\n// Note: hydration is DOM-specific\r\n// But we have to place it in core due to tight coupling with core - splitting\r\n// it out creates a ton of unnecessary complexity.\r\n// Hydration also depends on some renderer internal logic which needs to be\r\n// passed in via arguments.\r\nfunction createHydrationFunctions(rendererInternals) {\r\n    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\r\n    const hydrate = (vnode, container) => {\r\n        if (!container.hasChildNodes()) {\r\n            ( true) &&\r\n                warn(`Attempting to hydrate existing markup but container is empty. ` +\r\n                    `Performing full mount instead.`);\r\n            patch(null, vnode, container);\r\n            flushPostFlushCbs();\r\n            container._vnode = vnode;\r\n            return;\r\n        }\r\n        hasMismatch = false;\r\n        hydrateNode(container.firstChild, vnode, null, null, null);\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n        if (hasMismatch && !false) {\r\n            // this error should show up in production\r\n            console.error(`Hydration completed but contains mismatches.`);\r\n        }\r\n    };\r\n    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\r\n        const isFragmentStart = isComment(node) && node.data === '[';\r\n        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\r\n        const { type, ref, shapeFlag, patchFlag } = vnode;\r\n        const domType = node.nodeType;\r\n        vnode.el = node;\r\n        if (patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            vnode.dynamicChildren = null;\r\n        }\r\n        let nextNode = null;\r\n        switch (type) {\r\n            case Text:\r\n                if (domType !== 3 /* TEXT */) {\r\n                    // #5728 empty text node inside a slot can cause hydration failure\r\n                    // because the server rendered HTML won't contain a text node\r\n                    if (vnode.children === '') {\r\n                        insert((vnode.el = createText('')), parentNode(node), node);\r\n                        nextNode = node;\r\n                    }\r\n                    else {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                }\r\n                else {\r\n                    if (node.data !== vnode.children) {\r\n                        hasMismatch = true;\r\n                        ( true) &&\r\n                            warn(`Hydration text mismatch:` +\r\n                                `\\n- Client: ${JSON.stringify(node.data)}` +\r\n                                `\\n- Server: ${JSON.stringify(vnode.children)}`);\r\n                        node.data = vnode.children;\r\n                    }\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Comment:\r\n                if (domType !== 8 /* COMMENT */ || isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Static:\r\n                if (domType !== 1 /* ELEMENT */ && domType !== 3 /* TEXT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    // determine anchor, adopt content\r\n                    nextNode = node;\r\n                    // if the static vnode has its content stripped during build,\r\n                    // adopt it from the server-rendered HTML.\r\n                    const needToAdoptContent = !vnode.children.length;\r\n                    for (let i = 0; i < vnode.staticCount; i++) {\r\n                        if (needToAdoptContent)\r\n                            vnode.children +=\r\n                                nextNode.nodeType === 1 /* ELEMENT */\r\n                                    ? nextNode.outerHTML\r\n                                    : nextNode.data;\r\n                        if (i === vnode.staticCount - 1) {\r\n                            vnode.anchor = nextNode;\r\n                        }\r\n                        nextNode = nextSibling(nextNode);\r\n                    }\r\n                    return nextNode;\r\n                }\r\n                break;\r\n            case Fragment:\r\n                if (!isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                }\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    if (domType !== 1 /* ELEMENT */ ||\r\n                        vnode.type.toLowerCase() !==\r\n                            node.tagName.toLowerCase()) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    // when setting up the render effect, if the initial vnode already\r\n                    // has .el set, the component will perform hydration instead of mount\r\n                    // on its sub-tree.\r\n                    vnode.slotScopeIds = slotScopeIds;\r\n                    const container = parentNode(node);\r\n                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\r\n                    // component may be async, so in the case of fragments we cannot rely\r\n                    // on component's rendered output to determine the end of the fragment\r\n                    // instead, we do a lookahead to find the end anchor node.\r\n                    nextNode = isFragmentStart\r\n                        ? locateClosingAsyncAnchor(node)\r\n                        : nextSibling(node);\r\n                    // #4293 teleport as component root\r\n                    if (nextNode &&\r\n                        isComment(nextNode) &&\r\n                        nextNode.data === 'teleport end') {\r\n                        nextNode = nextSibling(nextNode);\r\n                    }\r\n                    // #3787\r\n                    // if component is async, it may get moved / unmounted before its\r\n                    // inner component is loaded, so we need to give it a placeholder\r\n                    // vnode that matches its adopted DOM.\r\n                    if (isAsyncWrapper(vnode)) {\r\n                        let subTree;\r\n                        if (isFragmentStart) {\r\n                            subTree = createVNode(Fragment);\r\n                            subTree.anchor = nextNode\r\n                                ? nextNode.previousSibling\r\n                                : container.lastChild;\r\n                        }\r\n                        else {\r\n                            subTree =\r\n                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');\r\n                        }\r\n                        subTree.el = node;\r\n                        vnode.component.subTree = subTree;\r\n                    }\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    if (domType !== 8 /* COMMENT */) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\r\n                }\r\n                else if ((true)) {\r\n                    warn('Invalid HostVNode type:', type, `(${typeof type})`);\r\n                }\r\n        }\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, vnode);\r\n        }\r\n        return nextNode;\r\n    };\r\n    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        optimized = optimized || !!vnode.dynamicChildren;\r\n        const { type, props, patchFlag, shapeFlag, dirs } = vnode;\r\n        // #4006 for form elements with non-string v-model value bindings\r\n        // e.g. <option :value=\"obj\">, <input type=\"checkbox\" :true-value=\"1\">\r\n        const forcePatchValue = (type === 'input' && dirs) || type === 'option';\r\n        // skip props & children if this is hoisted static nodes\r\n        // #5405 in dev, always hydrate children for HMR\r\n        if (true /* HOISTED */) {\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                if (forcePatchValue ||\r\n                    !optimized ||\r\n                    patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {\r\n                    for (const key in props) {\r\n                        if ((forcePatchValue && key.endsWith('value')) ||\r\n                            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))) {\r\n                            patchProp(el, key, null, props[key], false, undefined, parentComponent);\r\n                        }\r\n                    }\r\n                }\r\n                else if (props.onClick) {\r\n                    // Fast path for click listeners (which is most often) to avoid\r\n                    // iterating through props.\r\n                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);\r\n                }\r\n            }\r\n            // vnode / directive hooks\r\n            let vnodeHooks;\r\n            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\r\n                invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n            }\r\n            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\r\n                queueEffectWithSuspense(() => {\r\n                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n                }, parentSuspense);\r\n            }\r\n            // children\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&\r\n                // skip if element has innerHTML / textContent\r\n                !(props && (props.innerHTML || props.textContent))) {\r\n                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                let hasWarned = false;\r\n                while (next) {\r\n                    hasMismatch = true;\r\n                    if (( true) && !hasWarned) {\r\n                        warn(`Hydration children mismatch in <${vnode.type}>: ` +\r\n                            `server rendered element contains more child nodes than client vdom.`);\r\n                        hasWarned = true;\r\n                    }\r\n                    // The SSRed DOM contains more nodes than it should. Remove them.\r\n                    const cur = next;\r\n                    next = next.nextSibling;\r\n                    remove(cur);\r\n                }\r\n            }\r\n            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                if (el.textContent !== vnode.children) {\r\n                    hasMismatch = true;\r\n                    ( true) &&\r\n                        warn(`Hydration text content mismatch in <${vnode.type}>:\\n` +\r\n                            `- Client: ${el.textContent}\\n` +\r\n                            `- Server: ${vnode.children}`);\r\n                    el.textContent = vnode.children;\r\n                }\r\n            }\r\n        }\r\n        return el.nextSibling;\r\n    };\r\n    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        optimized = optimized || !!parentVNode.dynamicChildren;\r\n        const children = parentVNode.children;\r\n        const l = children.length;\r\n        let hasWarned = false;\r\n        for (let i = 0; i < l; i++) {\r\n            const vnode = optimized\r\n                ? children[i]\r\n                : (children[i] = normalizeVNode(children[i]));\r\n            if (node) {\r\n                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n            }\r\n            else if (vnode.type === Text && !vnode.children) {\r\n                continue;\r\n            }\r\n            else {\r\n                hasMismatch = true;\r\n                if (( true) && !hasWarned) {\r\n                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +\r\n                        `server rendered element contains fewer child nodes than client vdom.`);\r\n                    hasWarned = true;\r\n                }\r\n                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\r\n                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        const { slotScopeIds: fragmentSlotScopeIds } = vnode;\r\n        if (fragmentSlotScopeIds) {\r\n            slotScopeIds = slotScopeIds\r\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                : fragmentSlotScopeIds;\r\n        }\r\n        const container = parentNode(node);\r\n        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n        if (next && isComment(next) && next.data === ']') {\r\n            return nextSibling((vnode.anchor = next));\r\n        }\r\n        else {\r\n            // fragment didn't hydrate successfully, since we didn't get a end anchor\r\n            // back. This should have led to node/children mismatch warnings.\r\n            hasMismatch = true;\r\n            // since the anchor is missing, we need to create one and insert it\r\n            insert((vnode.anchor = createComment(`]`)), container, next);\r\n            return next;\r\n        }\r\n    };\r\n    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\r\n        hasMismatch = true;\r\n        ( true) &&\r\n            warn(`Hydration node mismatch:\\n- Client vnode:`, vnode.type, `\\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */\r\n                ? `(text)`\r\n                : isComment(node) && node.data === '['\r\n                    ? `(start of fragment)`\r\n                    : ``);\r\n        vnode.el = null;\r\n        if (isFragment) {\r\n            // remove excessive fragment nodes\r\n            const end = locateClosingAsyncAnchor(node);\r\n            while (true) {\r\n                const next = nextSibling(node);\r\n                if (next && next !== end) {\r\n                    remove(next);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const next = nextSibling(node);\r\n        const container = parentNode(node);\r\n        remove(node);\r\n        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\r\n        return next;\r\n    };\r\n    const locateClosingAsyncAnchor = (node) => {\r\n        let match = 0;\r\n        while (node) {\r\n            node = nextSibling(node);\r\n            if (node && isComment(node)) {\r\n                if (node.data === '[')\r\n                    match++;\r\n                if (node.data === ']') {\r\n                    if (match === 0) {\r\n                        return nextSibling(node);\r\n                    }\r\n                    else {\r\n                        match--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    return [hydrate, hydrateNode];\r\n}\n\n/* eslint-disable no-restricted-globals */\r\nlet supported;\r\nlet perf;\r\nfunction startMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        perf.mark(`vue-${type}-${instance.uid}`);\r\n    }\r\n    if (true) {\r\n        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\r\n    }\r\n}\r\nfunction endMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        const startTag = `vue-${type}-${instance.uid}`;\r\n        const endTag = startTag + `:end`;\r\n        perf.mark(endTag);\r\n        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\r\n        perf.clearMarks(startTag);\r\n        perf.clearMarks(endTag);\r\n    }\r\n    if (true) {\r\n        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\r\n    }\r\n}\r\nfunction isSupported() {\r\n    if (supported !== undefined) {\r\n        return supported;\r\n    }\r\n    if (typeof window !== 'undefined' && window.performance) {\r\n        supported = true;\r\n        perf = window.performance;\r\n    }\r\n    else {\r\n        supported = false;\r\n    }\r\n    return supported;\r\n}\n\n/**\r\n * This is only called in esm-bundler builds.\r\n * It is called when a renderer is created, in `baseCreateRenderer` so that\r\n * importing runtime-core is side-effects free.\r\n *\r\n * istanbul-ignore-next\r\n */\r\nfunction initFeatureFlags() {\r\n    const needWarn = [];\r\n    if (typeof __VUE_OPTIONS_API__ !== 'boolean') {\r\n        ( true) && needWarn.push(`__VUE_OPTIONS_API__`);\r\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;\r\n    }\r\n    if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {\r\n        ( true) && needWarn.push(`__VUE_PROD_DEVTOOLS__`);\r\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;\r\n    }\r\n    if (( true) && needWarn.length) {\r\n        const multi = needWarn.length > 1;\r\n        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` +\r\n            `which expects these compile-time feature flags to be globally injected ` +\r\n            `via the bundler config in order to get better tree-shaking in the ` +\r\n            `production bundle.\\n\\n` +\r\n            `For more details, see https://link.vuejs.org/feature-flags.`);\r\n    }\r\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense\r\n    ;\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nfunction createRenderer(options) {\r\n    return baseCreateRenderer(options);\r\n}\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nfunction createHydrationRenderer(options) {\r\n    return baseCreateRenderer(options, createHydrationFunctions);\r\n}\r\n// implementation\r\nfunction baseCreateRenderer(options, createHydrationFns) {\r\n    // compile-time feature flags check\r\n    {\r\n        initFeatureFlags();\r\n    }\r\n    const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();\r\n    target.__VUE__ = true;\r\n    if (true) {\r\n        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\r\n    }\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\r\n    // Note: functions inside this closure should use `const xxx = () => {}`\r\n    // style in order to prevent being inlined by minifiers.\r\n    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = ( true) && isHmrUpdating ? false : !!n2.dynamicChildren) => {\r\n        if (n1 === n2) {\r\n            return;\r\n        }\r\n        // patching & not same type, unmount old tree\r\n        if (n1 && !isSameVNodeType(n1, n2)) {\r\n            anchor = getNextHostNode(n1);\r\n            unmount(n1, parentComponent, parentSuspense, true);\r\n            n1 = null;\r\n        }\r\n        if (n2.patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            n2.dynamicChildren = null;\r\n        }\r\n        const { type, ref, shapeFlag } = n2;\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container, anchor);\r\n                break;\r\n            case Comment:\r\n                processCommentNode(n1, n2, container, anchor);\r\n                break;\r\n            case Static:\r\n                if (n1 == null) {\r\n                    mountStaticNode(n2, container, anchor, isSVG);\r\n                }\r\n                else if ((true)) {\r\n                    patchStaticNode(n1, n2, container, isSVG);\r\n                }\r\n                break;\r\n            case Fragment:\r\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                }\r\n                else if ((true)) {\r\n                    warn('Invalid VNode type:', type, `(${typeof type})`);\r\n                }\r\n        }\r\n        // set ref\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\r\n        }\r\n    };\r\n    const processText = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n        }\r\n        else {\r\n            const el = (n2.el = n1.el);\r\n            if (n2.children !== n1.children) {\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    };\r\n    const processCommentNode = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);\r\n        }\r\n        else {\r\n            // there's no support for dynamic comments\r\n            n2.el = n1.el;\r\n        }\r\n    };\r\n    const mountStaticNode = (n2, container, anchor, isSVG) => {\r\n        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);\r\n    };\r\n    /**\r\n     * Dev / HMR only\r\n     */\r\n    const patchStaticNode = (n1, n2, container, isSVG) => {\r\n        // static nodes are only patched during dev for HMR\r\n        if (n2.children !== n1.children) {\r\n            const anchor = hostNextSibling(n1.anchor);\r\n            // remove existing\r\n            removeStaticNode(n1);\r\n            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n        }\r\n        else {\r\n            n2.el = n1.el;\r\n            n2.anchor = n1.anchor;\r\n        }\r\n    };\r\n    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostInsert(el, container, nextSibling);\r\n            el = next;\r\n        }\r\n        hostInsert(anchor, container, nextSibling);\r\n    };\r\n    const removeStaticNode = ({ el, anchor }) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostRemove(el);\r\n            el = next;\r\n        }\r\n        hostRemove(anchor);\r\n    };\r\n    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        isSVG = isSVG || n2.type === 'svg';\r\n        if (n1 == null) {\r\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        else {\r\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n    };\r\n    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        let el;\r\n        let vnodeHook;\r\n        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;\r\n        if (false /* HOISTED */) {}\r\n        else {\r\n            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\r\n            // mount children first, since some props may rely on child content\r\n            // being already rendered, e.g. `<select value>`\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                hostSetElementText(el, vnode.children);\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                for (const key in props) {\r\n                    if (key !== 'value' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {\r\n                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n                /**\r\n                 * Special case for setting value on DOM elements:\r\n                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\r\n                 * - it needs to be forced (#1471)\r\n                 * #2353 proposes adding another renderer option to configure this, but\r\n                 * the properties affects are so finite it is worth special casing it\r\n                 * here to reduce the complexity. (Special casing it also should not\r\n                 * affect non-DOM renderers)\r\n                 */\r\n                if ('value' in props) {\r\n                    hostPatchProp(el, 'value', null, props.value);\r\n                }\r\n                if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                }\r\n            }\r\n            // scopeId\r\n            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\r\n        }\r\n        if (true) {\r\n            Object.defineProperty(el, '__vnode', {\r\n                value: vnode,\r\n                enumerable: false\r\n            });\r\n            Object.defineProperty(el, '__vueParentComponent', {\r\n                value: parentComponent,\r\n                enumerable: false\r\n            });\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n        }\r\n        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n        // #1689 For inside suspense + suspense resolved case, just call it\r\n        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n            transition &&\r\n            !transition.persisted;\r\n        if (needCallTransitionHooks) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n        if ((vnodeHook = props && props.onVnodeMounted) ||\r\n            needCallTransitionHooks ||\r\n            dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                needCallTransitionHooks && transition.enter(el);\r\n                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\r\n        if (scopeId) {\r\n            hostSetScopeId(el, scopeId);\r\n        }\r\n        if (slotScopeIds) {\r\n            for (let i = 0; i < slotScopeIds.length; i++) {\r\n                hostSetScopeId(el, slotScopeIds[i]);\r\n            }\r\n        }\r\n        if (parentComponent) {\r\n            let subTree = parentComponent.subTree;\r\n            if (( true) &&\r\n                subTree.patchFlag > 0 &&\r\n                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {\r\n                subTree =\r\n                    filterSingleRoot(subTree.children) || subTree;\r\n            }\r\n            if (vnode === subTree) {\r\n                const parentVNode = parentComponent.vnode;\r\n                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\r\n            }\r\n        }\r\n    };\r\n    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            const child = (children[i] = optimized\r\n                ? cloneIfMounted(children[i])\r\n                : normalizeVNode(children[i]));\r\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n    };\r\n    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        const el = (n2.el = n1.el);\r\n        let { patchFlag, dynamicChildren, dirs } = n2;\r\n        // #1426 take the old vnode's patch flag into account since user may clone a\r\n        // compiler-generated vnode, which de-opts to FULL_PROPS\r\n        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\r\n        const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n        let vnodeHook;\r\n        // disable recurse in beforeUpdate hooks\r\n        parentComponent && toggleRecurse(parentComponent, false);\r\n        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\r\n        }\r\n        parentComponent && toggleRecurse(parentComponent, true);\r\n        if (( true) && isHmrUpdating) {\r\n            // HMR updated, force full diff\r\n            patchFlag = 0;\r\n            optimized = false;\r\n            dynamicChildren = null;\r\n        }\r\n        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\r\n        if (dynamicChildren) {\r\n            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\r\n            if (( true) && parentComponent && parentComponent.type.__hmrId) {\r\n                traverseStaticChildren(n1, n2);\r\n            }\r\n        }\r\n        else if (!optimized) {\r\n            // full diff\r\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\r\n        }\r\n        if (patchFlag > 0) {\r\n            // the presence of a patchFlag means this element's render code was\r\n            // generated by the compiler and can take the fast path.\r\n            // in this path old node and new node are guaranteed to have the same shape\r\n            // (i.e. at the exact same position in the source template)\r\n            if (patchFlag & 16 /* FULL_PROPS */) {\r\n                // element props contain dynamic keys, full diff needed\r\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            else {\r\n                // class\r\n                // this flag is matched when the element has dynamic class bindings.\r\n                if (patchFlag & 2 /* CLASS */) {\r\n                    if (oldProps.class !== newProps.class) {\r\n                        hostPatchProp(el, 'class', null, newProps.class, isSVG);\r\n                    }\r\n                }\r\n                // style\r\n                // this flag is matched when the element has dynamic style bindings\r\n                if (patchFlag & 4 /* STYLE */) {\r\n                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\r\n                }\r\n                // props\r\n                // This flag is matched when the element has dynamic prop/attr bindings\r\n                // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                // faster iteration.\r\n                // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n                // bail out and go through a full diff because we need to unset the old key\r\n                if (patchFlag & 8 /* PROPS */) {\r\n                    // if the flag is present then dynamicProps must be non-null\r\n                    const propsToUpdate = n2.dynamicProps;\r\n                    for (let i = 0; i < propsToUpdate.length; i++) {\r\n                        const key = propsToUpdate[i];\r\n                        const prev = oldProps[key];\r\n                        const next = newProps[key];\r\n                        // #1471 force patch value\r\n                        if (next !== prev || key === 'value') {\r\n                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // text\r\n            // This flag is matched when the element has only dynamic text children.\r\n            if (patchFlag & 1 /* TEXT */) {\r\n                if (n1.children !== n2.children) {\r\n                    hostSetElementText(el, n2.children);\r\n                }\r\n            }\r\n        }\r\n        else if (!optimized && dynamicChildren == null) {\r\n            // unoptimized, full diff\r\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    // The fast path for blocks.\r\n    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\r\n        for (let i = 0; i < newChildren.length; i++) {\r\n            const oldVNode = oldChildren[i];\r\n            const newVNode = newChildren[i];\r\n            // Determine the container (parent element) for the patch.\r\n            const container = \r\n            // oldVNode may be an errored async setup() component inside Suspense\r\n            // which will not have a mounted element\r\n            oldVNode.el &&\r\n                // - In the case of a Fragment, we need to provide the actual parent\r\n                // of the Fragment itself so it can move its children.\r\n                (oldVNode.type === Fragment ||\r\n                    // - In the case of different nodes, there is going to be a replacement\r\n                    // which also requires the correct parent container\r\n                    !isSameVNodeType(oldVNode, newVNode) ||\r\n                    // - In the case of a component, it could contain anything.\r\n                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))\r\n                ? hostParentNode(oldVNode.el)\r\n                : // In other cases, the parent container is not actually used so we\r\n                    // just pass the block element here to avoid a DOM parentNode call.\r\n                    fallbackContainer;\r\n            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\r\n        }\r\n    };\r\n    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                // empty string is not valid prop\r\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))\r\n                    continue;\r\n                const next = newProps[key];\r\n                const prev = oldProps[key];\r\n                // defer patching value\r\n                if (next !== prev && key !== 'value') {\r\n                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                }\r\n            }\r\n            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\r\n                for (const key in oldProps) {\r\n                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {\r\n                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n            }\r\n            if ('value' in newProps) {\r\n                hostPatchProp(el, 'value', oldProps.value, newProps.value);\r\n            }\r\n        }\r\n    };\r\n    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));\r\n        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));\r\n        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\r\n        if (( true) &&\r\n            // #5523 dev root fragment may inherit directives\r\n            (isHmrUpdating || patchFlag & 2048 /* DEV_ROOT_FRAGMENT */)) {\r\n            // HMR updated / Dev root fragment (w/ comments), force full diff\r\n            patchFlag = 0;\r\n            optimized = false;\r\n            dynamicChildren = null;\r\n        }\r\n        // check if this is a slot fragment with :slotted scope ids\r\n        if (fragmentSlotScopeIds) {\r\n            slotScopeIds = slotScopeIds\r\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                : fragmentSlotScopeIds;\r\n        }\r\n        if (n1 == null) {\r\n            hostInsert(fragmentStartAnchor, container, anchor);\r\n            hostInsert(fragmentEndAnchor, container, anchor);\r\n            // a fragment can only have array children\r\n            // since they are either generated by the compiler, or implicitly created\r\n            // from arrays.\r\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        else {\r\n            if (patchFlag > 0 &&\r\n                patchFlag & 64 /* STABLE_FRAGMENT */ &&\r\n                dynamicChildren &&\r\n                // #2715 the previous fragment could've been a BAILed one as a result\r\n                // of renderSlot() with no valid children\r\n                n1.dynamicChildren) {\r\n                // a stable fragment (template root or <template v-for>) doesn't need to\r\n                // patch children order, but it may contain dynamicChildren.\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                if (( true) && parentComponent && parentComponent.type.__hmrId) {\r\n                    traverseStaticChildren(n1, n2);\r\n                }\r\n                else if (\r\n                // #2080 if the stable fragment has a key, it's a <template v-for> that may\r\n                //  get moved around. Make sure all root level vnodes inherit el.\r\n                // #2134 or if it's a component root, it may also get moved around\r\n                // as the component is being moved.\r\n                n2.key != null ||\r\n                    (parentComponent && n2 === parentComponent.subTree)) {\r\n                    traverseStaticChildren(n1, n2, true /* shallow */);\r\n                }\r\n            }\r\n            else {\r\n                // keyed / unkeyed, or manual fragments.\r\n                // for keyed & unkeyed, since they are compiler generated from v-for,\r\n                // each child is guaranteed to be a block so the fragment will never\r\n                // have dynamicChildren.\r\n                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n        }\r\n    };\r\n    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        n2.slotScopeIds = slotScopeIds;\r\n        if (n1 == null) {\r\n            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\r\n            }\r\n            else {\r\n                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n        else {\r\n            updateComponent(n1, n2, optimized);\r\n        }\r\n    };\r\n    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\r\n        if (( true) && instance.type.__hmrId) {\r\n            registerHMR(instance);\r\n        }\r\n        if ((true)) {\r\n            pushWarningContext(initialVNode);\r\n            startMeasure(instance, `mount`);\r\n        }\r\n        // inject renderer internals for keepAlive\r\n        if (isKeepAlive(initialVNode)) {\r\n            instance.ctx.renderer = internals;\r\n        }\r\n        // resolve props and slots for setup context\r\n        {\r\n            if ((true)) {\r\n                startMeasure(instance, `init`);\r\n            }\r\n            setupComponent(instance);\r\n            if ((true)) {\r\n                endMeasure(instance, `init`);\r\n            }\r\n        }\r\n        // setup() is async. This component relies on async logic to be resolved\r\n        // before proceeding\r\n        if (instance.asyncDep) {\r\n            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\r\n            // Give it a placeholder if this is not hydration\r\n            // TODO handle self-defined fallback\r\n            if (!initialVNode.el) {\r\n                const placeholder = (instance.subTree = createVNode(Comment));\r\n                processCommentNode(null, placeholder, container, anchor);\r\n            }\r\n            return;\r\n        }\r\n        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\r\n        if ((true)) {\r\n            popWarningContext();\r\n            endMeasure(instance, `mount`);\r\n        }\r\n    };\r\n    const updateComponent = (n1, n2, optimized) => {\r\n        const instance = (n2.component = n1.component);\r\n        if (shouldUpdateComponent(n1, n2, optimized)) {\r\n            if (instance.asyncDep &&\r\n                !instance.asyncResolved) {\r\n                // async & still pending - just update props and slots\r\n                // since the component's reactive effect for render isn't set-up yet\r\n                if ((true)) {\r\n                    pushWarningContext(n2);\r\n                }\r\n                updateComponentPreRender(instance, n2, optimized);\r\n                if ((true)) {\r\n                    popWarningContext();\r\n                }\r\n                return;\r\n            }\r\n            else {\r\n                // normal update\r\n                instance.next = n2;\r\n                // in case the child component is also queued, remove it to avoid\r\n                // double updating the same child component in the same flush.\r\n                invalidateJob(instance.update);\r\n                // instance.update is the reactive effect.\r\n                instance.update();\r\n            }\r\n        }\r\n        else {\r\n            // no update needed. just copy over properties\r\n            n2.el = n1.el;\r\n            instance.vnode = n2;\r\n        }\r\n    };\r\n    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\r\n        const componentUpdateFn = () => {\r\n            if (!instance.isMounted) {\r\n                let vnodeHook;\r\n                const { el, props } = initialVNode;\r\n                const { bm, m, parent } = instance;\r\n                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\r\n                toggleRecurse(instance, false);\r\n                // beforeMount hook\r\n                if (bm) {\r\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);\r\n                }\r\n                // onVnodeBeforeMount\r\n                if (!isAsyncWrapperVNode &&\r\n                    (vnodeHook = props && props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                }\r\n                toggleRecurse(instance, true);\r\n                if (el && hydrateNode) {\r\n                    // vnode has adopted host node - perform hydration instead of mount.\r\n                    const hydrateSubTree = () => {\r\n                        if ((true)) {\r\n                            startMeasure(instance, `render`);\r\n                        }\r\n                        instance.subTree = renderComponentRoot(instance);\r\n                        if ((true)) {\r\n                            endMeasure(instance, `render`);\r\n                        }\r\n                        if ((true)) {\r\n                            startMeasure(instance, `hydrate`);\r\n                        }\r\n                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);\r\n                        if ((true)) {\r\n                            endMeasure(instance, `hydrate`);\r\n                        }\r\n                    };\r\n                    if (isAsyncWrapperVNode) {\r\n                        initialVNode.type.__asyncLoader().then(\r\n                        // note: we are moving the render call into an async callback,\r\n                        // which means it won't track dependencies - but it's ok because\r\n                        // a server-rendered async wrapper is already in resolved state\r\n                        // and it will never need to change.\r\n                        () => !instance.isUnmounted && hydrateSubTree());\r\n                    }\r\n                    else {\r\n                        hydrateSubTree();\r\n                    }\r\n                }\r\n                else {\r\n                    if ((true)) {\r\n                        startMeasure(instance, `render`);\r\n                    }\r\n                    const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                    if ((true)) {\r\n                        endMeasure(instance, `render`);\r\n                    }\r\n                    if ((true)) {\r\n                        startMeasure(instance, `patch`);\r\n                    }\r\n                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                    if ((true)) {\r\n                        endMeasure(instance, `patch`);\r\n                    }\r\n                    initialVNode.el = subTree.el;\r\n                }\r\n                // mounted hook\r\n                if (m) {\r\n                    queuePostRenderEffect(m, parentSuspense);\r\n                }\r\n                // onVnodeMounted\r\n                if (!isAsyncWrapperVNode &&\r\n                    (vnodeHook = props && props.onVnodeMounted)) {\r\n                    const scopedInitialVNode = initialVNode;\r\n                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\r\n                }\r\n                // activated hook for keep-alive roots.\r\n                // #1742 activated hook must be accessed after first render\r\n                // since the hook may be injected by a child keep-alive\r\n                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ||\r\n                    (parent &&\r\n                        isAsyncWrapper(parent.vnode) &&\r\n                        parent.vnode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */)) {\r\n                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);\r\n                }\r\n                instance.isMounted = true;\r\n                if (true) {\r\n                    devtoolsComponentAdded(instance);\r\n                }\r\n                // #2458: deference mount-only object parameters to prevent memleaks\r\n                initialVNode = container = anchor = null;\r\n            }\r\n            else {\r\n                // updateComponent\r\n                // This is triggered by mutation of component's own state (next: null)\r\n                // OR parent calling processComponent (next: VNode)\r\n                let { next, bu, u, parent, vnode } = instance;\r\n                let originNext = next;\r\n                let vnodeHook;\r\n                if ((true)) {\r\n                    pushWarningContext(next || instance.vnode);\r\n                }\r\n                // Disallow component effect recursion during pre-lifecycle hooks.\r\n                toggleRecurse(instance, false);\r\n                if (next) {\r\n                    next.el = vnode.el;\r\n                    updateComponentPreRender(instance, next, optimized);\r\n                }\r\n                else {\r\n                    next = vnode;\r\n                }\r\n                // beforeUpdate hook\r\n                if (bu) {\r\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);\r\n                }\r\n                // onVnodeBeforeUpdate\r\n                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n                    invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                }\r\n                toggleRecurse(instance, true);\r\n                // render\r\n                if ((true)) {\r\n                    startMeasure(instance, `render`);\r\n                }\r\n                const nextTree = renderComponentRoot(instance);\r\n                if ((true)) {\r\n                    endMeasure(instance, `render`);\r\n                }\r\n                const prevTree = instance.subTree;\r\n                instance.subTree = nextTree;\r\n                if ((true)) {\r\n                    startMeasure(instance, `patch`);\r\n                }\r\n                patch(prevTree, nextTree, \r\n                // parent may have changed if it's in a teleport\r\n                hostParentNode(prevTree.el), \r\n                // anchor may have changed if it's in a fragment\r\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                if ((true)) {\r\n                    endMeasure(instance, `patch`);\r\n                }\r\n                next.el = nextTree.el;\r\n                if (originNext === null) {\r\n                    // self-triggered update. In case of HOC, update parent component\r\n                    // vnode el. HOC is indicated by parent instance's subTree pointing\r\n                    // to child component's vnode\r\n                    updateHOCHostEl(instance, nextTree.el);\r\n                }\r\n                // updated hook\r\n                if (u) {\r\n                    queuePostRenderEffect(u, parentSuspense);\r\n                }\r\n                // onVnodeUpdated\r\n                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\r\n                }\r\n                if (true) {\r\n                    devtoolsComponentUpdated(instance);\r\n                }\r\n                if ((true)) {\r\n                    popWarningContext();\r\n                }\r\n            }\r\n        };\r\n        // create reactive effect for rendering\r\n        const effect = (instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope\r\n        ));\r\n        const update = (instance.update = () => effect.run());\r\n        update.id = instance.uid;\r\n        // allowRecurse\r\n        // #1801, #2043 component render effects should allow recursive updates\r\n        toggleRecurse(instance, true);\r\n        if ((true)) {\r\n            effect.onTrack = instance.rtc\r\n                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e)\r\n                : void 0;\r\n            effect.onTrigger = instance.rtg\r\n                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e)\r\n                : void 0;\r\n            update.ownerInstance = instance;\r\n        }\r\n        update();\r\n    };\r\n    const updateComponentPreRender = (instance, nextVNode, optimized) => {\r\n        nextVNode.component = instance;\r\n        const prevProps = instance.vnode.props;\r\n        instance.vnode = nextVNode;\r\n        instance.next = null;\r\n        updateProps(instance, nextVNode.props, prevProps, optimized);\r\n        updateSlots(instance, nextVNode.children, optimized);\r\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\r\n        // props update may have triggered pre-flush watchers.\r\n        // flush them before the render update.\r\n        flushPreFlushCbs(undefined, instance.update);\r\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\r\n    };\r\n    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\r\n        const c1 = n1 && n1.children;\r\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n        const c2 = n2.children;\r\n        const { patchFlag, shapeFlag } = n2;\r\n        // fast path\r\n        if (patchFlag > 0) {\r\n            if (patchFlag & 128 /* KEYED_FRAGMENT */) {\r\n                // this could be either fully-keyed or mixed (some keyed some not)\r\n                // presence of patchFlag means children are guaranteed to be arrays\r\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                return;\r\n            }\r\n            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\r\n                // unkeyed\r\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                return;\r\n            }\r\n        }\r\n        // children has 3 possibilities: text, array or no children.\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            // text children fast path\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(c1, parentComponent, parentSuspense);\r\n            }\r\n            if (c2 !== c1) {\r\n                hostSetElementText(container, c2);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                // prev children was array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    // two arrays, cannot assume anything, do full diff\r\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else {\r\n                    // no new children, just unmount old\r\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                }\r\n            }\r\n            else {\r\n                // prev children was text OR null\r\n                // new children is array OR null\r\n                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(container, '');\r\n                }\r\n                // mount new if array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\r\n        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\r\n        const oldLength = c1.length;\r\n        const newLength = c2.length;\r\n        const commonLength = Math.min(oldLength, newLength);\r\n        let i;\r\n        for (i = 0; i < commonLength; i++) {\r\n            const nextChild = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        if (oldLength > newLength) {\r\n            // remove old\r\n            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\r\n        }\r\n        else {\r\n            // mount new\r\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\r\n        }\r\n    };\r\n    // can be all-keyed or mixed\r\n    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        let i = 0;\r\n        const l2 = c2.length;\r\n        let e1 = c1.length - 1; // prev ending index\r\n        let e2 = l2 - 1; // next ending index\r\n        // 1. sync from start\r\n        // (a b) c\r\n        // (a b) d e\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[i];\r\n            const n2 = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 2. sync from end\r\n        // a (b c)\r\n        // d e (b c)\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[e1];\r\n            const n2 = (c2[e2] = optimized\r\n                ? cloneIfMounted(c2[e2])\r\n                : normalizeVNode(c2[e2]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        // 3. common sequence + mount\r\n        // (a b)\r\n        // (a b) c\r\n        // i = 2, e1 = 1, e2 = 2\r\n        // (a b)\r\n        // c (a b)\r\n        // i = 0, e1 = -1, e2 = 0\r\n        if (i > e1) {\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                while (i <= e2) {\r\n                    patch(null, (c2[i] = optimized\r\n                        ? cloneIfMounted(c2[i])\r\n                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // 4. common sequence + unmount\r\n        // (a b) c\r\n        // (a b)\r\n        // i = 2, e1 = 2, e2 = 1\r\n        // a (b c)\r\n        // (b c)\r\n        // i = 0, e1 = 0, e2 = -1\r\n        else if (i > e2) {\r\n            while (i <= e1) {\r\n                unmount(c1[i], parentComponent, parentSuspense, true);\r\n                i++;\r\n            }\r\n        }\r\n        // 5. unknown sequence\r\n        // [i ... e1 + 1]: a b [c d e] f g\r\n        // [i ... e2 + 1]: a b [e d c h] f g\r\n        // i = 2, e1 = 4, e2 = 5\r\n        else {\r\n            const s1 = i; // prev starting index\r\n            const s2 = i; // next starting index\r\n            // 5.1 build key:index map for newChildren\r\n            const keyToNewIndexMap = new Map();\r\n            for (i = s2; i <= e2; i++) {\r\n                const nextChild = (c2[i] = optimized\r\n                    ? cloneIfMounted(c2[i])\r\n                    : normalizeVNode(c2[i]));\r\n                if (nextChild.key != null) {\r\n                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {\r\n                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\r\n                    }\r\n                    keyToNewIndexMap.set(nextChild.key, i);\r\n                }\r\n            }\r\n            // 5.2 loop through old children left to be patched and try to patch\r\n            // matching nodes & remove nodes that are no longer present\r\n            let j;\r\n            let patched = 0;\r\n            const toBePatched = e2 - s2 + 1;\r\n            let moved = false;\r\n            // used to track whether any node has moved\r\n            let maxNewIndexSoFar = 0;\r\n            // works as Map<newIndex, oldIndex>\r\n            // Note that oldIndex is offset by +1\r\n            // and oldIndex = 0 is a special value indicating the new node has\r\n            // no corresponding old node.\r\n            // used for determining longest stable subsequence\r\n            const newIndexToOldIndexMap = new Array(toBePatched);\r\n            for (i = 0; i < toBePatched; i++)\r\n                newIndexToOldIndexMap[i] = 0;\r\n            for (i = s1; i <= e1; i++) {\r\n                const prevChild = c1[i];\r\n                if (patched >= toBePatched) {\r\n                    // all new children have been patched so this can only be a removal\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key != null) {\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    // key-less node, try to locate a key-less node of the same type\r\n                    for (j = s2; j <= e2; j++) {\r\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                            isSameVNodeType(prevChild, c2[j])) {\r\n                            newIndex = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex === undefined) {\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                }\r\n                else {\r\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                    patched++;\r\n                }\r\n            }\r\n            // 5.3 move and mount\r\n            // generate longest stable subsequence only when nodes have moved\r\n            const increasingNewIndexSequence = moved\r\n                ? getSequence(newIndexToOldIndexMap)\r\n                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\r\n            j = increasingNewIndexSequence.length - 1;\r\n            // looping backwards so that we can use last patched node as anchor\r\n            for (i = toBePatched - 1; i >= 0; i--) {\r\n                const nextIndex = s2 + i;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\r\n                if (newIndexToOldIndexMap[i] === 0) {\r\n                    // mount new\r\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (moved) {\r\n                    // move if:\r\n                    // There is no stable subsequence (e.g. a reverse)\r\n                    // OR current node is not among the stable sequence\r\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                        move(nextChild, container, anchor, 2 /* REORDER */);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\r\n        const { el, type, transition, children, shapeFlag } = vnode;\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            move(vnode.component.subTree, container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 128 /* SUSPENSE */) {\r\n            vnode.suspense.move(container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type.move(vnode, container, anchor, internals);\r\n            return;\r\n        }\r\n        if (type === Fragment) {\r\n            hostInsert(el, container, anchor);\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, anchor, moveType);\r\n            }\r\n            hostInsert(vnode.anchor, container, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            moveStaticNode(vnode, container, anchor);\r\n            return;\r\n        }\r\n        // single nodes\r\n        const needTransition = moveType !== 2 /* REORDER */ &&\r\n            shapeFlag & 1 /* ELEMENT */ &&\r\n            transition;\r\n        if (needTransition) {\r\n            if (moveType === 0 /* ENTER */) {\r\n                transition.beforeEnter(el);\r\n                hostInsert(el, container, anchor);\r\n                queuePostRenderEffect(() => transition.enter(el), parentSuspense);\r\n            }\r\n            else {\r\n                const { leave, delayLeave, afterLeave } = transition;\r\n                const remove = () => hostInsert(el, container, anchor);\r\n                const performLeave = () => {\r\n                    leave(el, () => {\r\n                        remove();\r\n                        afterLeave && afterLeave();\r\n                    });\r\n                };\r\n                if (delayLeave) {\r\n                    delayLeave(el, remove, performLeave);\r\n                }\r\n                else {\r\n                    performLeave();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            hostInsert(el, container, anchor);\r\n        }\r\n    };\r\n    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\r\n        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\r\n        // unset ref\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, vnode, true);\r\n        }\r\n        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n            parentComponent.ctx.deactivate(vnode);\r\n            return;\r\n        }\r\n        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\r\n        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\r\n        let vnodeHook;\r\n        if (shouldInvokeVnodeHook &&\r\n            (vnodeHook = props && props.onVnodeBeforeUnmount)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n        }\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            unmountComponent(vnode.component, parentSuspense, doRemove);\r\n        }\r\n        else {\r\n            if (shapeFlag & 128 /* SUSPENSE */) {\r\n                vnode.suspense.unmount(parentSuspense, doRemove);\r\n                return;\r\n            }\r\n            if (shouldInvokeDirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\r\n            }\r\n            if (shapeFlag & 64 /* TELEPORT */) {\r\n                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\r\n            }\r\n            else if (dynamicChildren &&\r\n                // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n                (type !== Fragment ||\r\n                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\r\n                // fast path for block nodes: only need to unmount dynamic children.\r\n                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\r\n            }\r\n            else if ((type === Fragment &&\r\n                patchFlag &\r\n                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||\r\n                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {\r\n                unmountChildren(children, parentComponent, parentSuspense);\r\n            }\r\n            if (doRemove) {\r\n                remove(vnode);\r\n            }\r\n        }\r\n        if ((shouldInvokeVnodeHook &&\r\n            (vnodeHook = props && props.onVnodeUnmounted)) ||\r\n            shouldInvokeDirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                shouldInvokeDirs &&\r\n                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const remove = vnode => {\r\n        const { type, el, anchor, transition } = vnode;\r\n        if (type === Fragment) {\r\n            if (( true) &&\r\n                vnode.patchFlag > 0 &&\r\n                vnode.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */ &&\r\n                transition &&\r\n                !transition.persisted) {\r\n                vnode.children.forEach(child => {\r\n                    if (child.type === Comment) {\r\n                        hostRemove(child.el);\r\n                    }\r\n                    else {\r\n                        remove(child);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                removeFragment(el, anchor);\r\n            }\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            removeStaticNode(vnode);\r\n            return;\r\n        }\r\n        const performRemove = () => {\r\n            hostRemove(el);\r\n            if (transition && !transition.persisted && transition.afterLeave) {\r\n                transition.afterLeave();\r\n            }\r\n        };\r\n        if (vnode.shapeFlag & 1 /* ELEMENT */ &&\r\n            transition &&\r\n            !transition.persisted) {\r\n            const { leave, delayLeave } = transition;\r\n            const performLeave = () => leave(el, performRemove);\r\n            if (delayLeave) {\r\n                delayLeave(vnode.el, performRemove, performLeave);\r\n            }\r\n            else {\r\n                performLeave();\r\n            }\r\n        }\r\n        else {\r\n            performRemove();\r\n        }\r\n    };\r\n    const removeFragment = (cur, end) => {\r\n        // For fragments, directly remove all contained DOM nodes.\r\n        // (fragment child nodes cannot have transition)\r\n        let next;\r\n        while (cur !== end) {\r\n            next = hostNextSibling(cur);\r\n            hostRemove(cur);\r\n            cur = next;\r\n        }\r\n        hostRemove(end);\r\n    };\r\n    const unmountComponent = (instance, parentSuspense, doRemove) => {\r\n        if (( true) && instance.type.__hmrId) {\r\n            unregisterHMR(instance);\r\n        }\r\n        const { bum, scope, update, subTree, um } = instance;\r\n        // beforeUnmount hook\r\n        if (bum) {\r\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);\r\n        }\r\n        // stop effects in component scope\r\n        scope.stop();\r\n        // update may be null if a component is unmounted before its async\r\n        // setup has resolved.\r\n        if (update) {\r\n            // so that scheduler will no longer invoke it\r\n            update.active = false;\r\n            unmount(subTree, instance, parentSuspense, doRemove);\r\n        }\r\n        // unmounted hook\r\n        if (um) {\r\n            queuePostRenderEffect(um, parentSuspense);\r\n        }\r\n        queuePostRenderEffect(() => {\r\n            instance.isUnmounted = true;\r\n        }, parentSuspense);\r\n        // A component with async dep inside a pending suspense is unmounted before\r\n        // its async dep resolves. This should remove the dep from the suspense, and\r\n        // cause the suspense to resolve immediately if that was the last dep.\r\n        if (parentSuspense &&\r\n            parentSuspense.pendingBranch &&\r\n            !parentSuspense.isUnmounted &&\r\n            instance.asyncDep &&\r\n            !instance.asyncResolved &&\r\n            instance.suspenseId === parentSuspense.pendingId) {\r\n            parentSuspense.deps--;\r\n            if (parentSuspense.deps === 0) {\r\n                parentSuspense.resolve();\r\n            }\r\n        }\r\n        if (true) {\r\n            devtoolsComponentRemoved(instance);\r\n        }\r\n    };\r\n    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\r\n        }\r\n    };\r\n    const getNextHostNode = vnode => {\r\n        if (vnode.shapeFlag & 6 /* COMPONENT */) {\r\n            return getNextHostNode(vnode.component.subTree);\r\n        }\r\n        if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n            return vnode.suspense.next();\r\n        }\r\n        return hostNextSibling((vnode.anchor || vnode.el));\r\n    };\r\n    const render = (vnode, container, isSVG) => {\r\n        if (vnode == null) {\r\n            if (container._vnode) {\r\n                unmount(container._vnode, null, null, true);\r\n            }\r\n        }\r\n        else {\r\n            patch(container._vnode || null, vnode, container, null, null, null, isSVG);\r\n        }\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n    };\r\n    const internals = {\r\n        p: patch,\r\n        um: unmount,\r\n        m: move,\r\n        r: remove,\r\n        mt: mountComponent,\r\n        mc: mountChildren,\r\n        pc: patchChildren,\r\n        pbc: patchBlockChildren,\r\n        n: getNextHostNode,\r\n        o: options\r\n    };\r\n    let hydrate;\r\n    let hydrateNode;\r\n    if (createHydrationFns) {\r\n        [hydrate, hydrateNode] = createHydrationFns(internals);\r\n    }\r\n    return {\r\n        render,\r\n        hydrate,\r\n        createApp: createAppAPI(render, hydrate)\r\n    };\r\n}\r\nfunction toggleRecurse({ effect, update }, allowed) {\r\n    effect.allowRecurse = update.allowRecurse = allowed;\r\n}\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always be moved. Therefore, in order to ensure correct move\r\n * position, el should be inherited from previous nodes.\r\n */\r\nfunction traverseStaticChildren(n1, n2, shallow = false) {\r\n    const ch1 = n1.children;\r\n    const ch2 = n2.children;\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {\r\n        for (let i = 0; i < ch1.length; i++) {\r\n            // this is only called in the optimized path so array children are\r\n            // guaranteed to be vnodes\r\n            const c1 = ch1[i];\r\n            let c2 = ch2[i];\r\n            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\r\n                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\r\n                    c2 = ch2[i] = cloneIfMounted(ch2[i]);\r\n                    c2.el = c1.el;\r\n                }\r\n                if (!shallow)\r\n                    traverseStaticChildren(c1, c2);\r\n            }\r\n            // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n            // would have received .el during block patch)\r\n            if (( true) && c2.type === Comment && !c2.el) {\r\n                c2.el = c1.el;\r\n            }\r\n        }\r\n    }\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr) {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        const arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = (u + v) >> 1;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');\r\nconst isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;\r\nconst resolveTarget = (props, select) => {\r\n    const targetSelector = props && props.to;\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {\r\n        if (!select) {\r\n            ( true) &&\r\n                warn(`Current renderer does not support string target for Teleports. ` +\r\n                    `(missing querySelector renderer option)`);\r\n            return null;\r\n        }\r\n        else {\r\n            const target = select(targetSelector);\r\n            if (!target) {\r\n                ( true) &&\r\n                    warn(`Failed to locate Teleport target with selector \"${targetSelector}\". ` +\r\n                        `Note the target element must exist before the component is mounted - ` +\r\n                        `i.e. the target cannot be rendered by the component itself, and ` +\r\n                        `ideally should be outside of the entire Vue component tree.`);\r\n            }\r\n            return target;\r\n        }\r\n    }\r\n    else {\r\n        if (( true) && !targetSelector && !isTeleportDisabled(props)) {\r\n            warn(`Invalid Teleport target: ${targetSelector}`);\r\n        }\r\n        return targetSelector;\r\n    }\r\n};\r\nconst TeleportImpl = {\r\n    __isTeleport: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\r\n        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\r\n        const disabled = isTeleportDisabled(n2.props);\r\n        let { shapeFlag, children, dynamicChildren } = n2;\r\n        // #3302\r\n        // HMR updated, force full diff\r\n        if (( true) && isHmrUpdating) {\r\n            optimized = false;\r\n            dynamicChildren = null;\r\n        }\r\n        if (n1 == null) {\r\n            // insert anchors in the main view\r\n            const placeholder = (n2.el = ( true)\r\n                ? createComment('teleport start')\r\n                : 0);\r\n            const mainAnchor = (n2.anchor = ( true)\r\n                ? createComment('teleport end')\r\n                : 0);\r\n            insert(placeholder, container, anchor);\r\n            insert(mainAnchor, container, anchor);\r\n            const target = (n2.target = resolveTarget(n2.props, querySelector));\r\n            const targetAnchor = (n2.targetAnchor = createText(''));\r\n            if (target) {\r\n                insert(targetAnchor, target);\r\n                // #2652 we could be teleporting from a non-SVG tree into an SVG tree\r\n                isSVG = isSVG || isTargetSVG(target);\r\n            }\r\n            else if (( true) && !disabled) {\r\n                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);\r\n            }\r\n            const mount = (container, anchor) => {\r\n                // Teleport *always* has Array children. This is enforced in both the\r\n                // compiler and vnode children normalization.\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n            };\r\n            if (disabled) {\r\n                mount(container, mainAnchor);\r\n            }\r\n            else if (target) {\r\n                mount(target, targetAnchor);\r\n            }\r\n        }\r\n        else {\r\n            // update content\r\n            n2.el = n1.el;\r\n            const mainAnchor = (n2.anchor = n1.anchor);\r\n            const target = (n2.target = n1.target);\r\n            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\r\n            const wasDisabled = isTeleportDisabled(n1.props);\r\n            const currentContainer = wasDisabled ? container : target;\r\n            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\r\n            isSVG = isSVG || isTargetSVG(target);\r\n            if (dynamicChildren) {\r\n                // fast path when the teleport happens to be a block root\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                // even in block tree mode we need to make sure all root-level nodes\r\n                // in the teleport inherit previous DOM references so that they can\r\n                // be moved in future patches.\r\n                traverseStaticChildren(n1, n2, true);\r\n            }\r\n            else if (!optimized) {\r\n                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);\r\n            }\r\n            if (disabled) {\r\n                if (!wasDisabled) {\r\n                    // enabled -> disabled\r\n                    // move into main container\r\n                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n            else {\r\n                // target changed\r\n                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\r\n                    if (nextTarget) {\r\n                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);\r\n                    }\r\n                    else if ((true)) {\r\n                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);\r\n                    }\r\n                }\r\n                else if (wasDisabled) {\r\n                    // disabled -> enabled\r\n                    // move into teleport target\r\n                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {\r\n        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;\r\n        if (target) {\r\n            hostRemove(targetAnchor);\r\n        }\r\n        // an unmounted teleport should always remove its children if not disabled\r\n        if (doRemove || !isTeleportDisabled(props)) {\r\n            hostRemove(anchor);\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                for (let i = 0; i < children.length; i++) {\r\n                    const child = children[i];\r\n                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    move: moveTeleport,\r\n    hydrate: hydrateTeleport\r\n};\r\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {\r\n    // move target anchor if this is a target change.\r\n    if (moveType === 0 /* TARGET_CHANGE */) {\r\n        insert(vnode.targetAnchor, container, parentAnchor);\r\n    }\r\n    const { el, anchor, shapeFlag, children, props } = vnode;\r\n    const isReorder = moveType === 2 /* REORDER */;\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(el, container, parentAnchor);\r\n    }\r\n    // if this is a re-order and teleport is enabled (content is in target)\r\n    // do not move children. So the opposite is: only move children if this\r\n    // is not a reorder, or the teleport is disabled\r\n    if (!isReorder || isTeleportDisabled(props)) {\r\n        // Teleport has either Array children or no children.\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, parentAnchor, 2 /* REORDER */);\r\n            }\r\n        }\r\n    }\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(anchor, container, parentAnchor);\r\n    }\r\n}\r\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\r\n    const target = (vnode.target = resolveTarget(vnode.props, querySelector));\r\n    if (target) {\r\n        // if multiple teleports rendered to the same target element, we need to\r\n        // pick up from where the last teleport finished instead of the first node\r\n        const targetNode = target._lpa || target.firstChild;\r\n        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            if (isTeleportDisabled(vnode.props)) {\r\n                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                vnode.targetAnchor = targetNode;\r\n            }\r\n            else {\r\n                vnode.anchor = nextSibling(node);\r\n                // lookahead until we find the target anchor\r\n                // we cannot rely on return value of hydrateChildren() because there\r\n                // could be nested teleports\r\n                let targetAnchor = targetNode;\r\n                while (targetAnchor) {\r\n                    targetAnchor = nextSibling(targetAnchor);\r\n                    if (targetAnchor &&\r\n                        targetAnchor.nodeType === 8 &&\r\n                        targetAnchor.data === 'teleport anchor') {\r\n                        vnode.targetAnchor = targetAnchor;\r\n                        target._lpa =\r\n                            vnode.targetAnchor && nextSibling(vnode.targetAnchor);\r\n                        break;\r\n                    }\r\n                }\r\n                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n            }\r\n        }\r\n    }\r\n    return vnode.anchor && nextSibling(vnode.anchor);\r\n}\r\n// Force-casted public typing for h and TSX props inference\r\nconst Teleport = TeleportImpl;\n\nconst Fragment = Symbol(( true) ? 'Fragment' : 0);\r\nconst Text = Symbol(( true) ? 'Text' : 0);\r\nconst Comment = Symbol(( true) ? 'Comment' : 0);\r\nconst Static = Symbol(( true) ? 'Static' : 0);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet isBlockTreeEnabled = 1;\r\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\r\nfunction setBlockTracking(value) {\r\n    isBlockTreeEnabled += value;\r\n}\r\nfunction setupBlock(vnode) {\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren =\r\n        isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if (isBlockTreeEnabled > 0 && currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\r\n    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nfunction isSameVNodeType(n1, n2) {\r\n    if (( true) &&\r\n        n2.shapeFlag & 6 /* COMPONENT */ &&\r\n        hmrDirtyComponents.has(n2.type)) {\r\n        // HMR only: if the component has been hot-updated, force a reload.\r\n        return false;\r\n    }\r\n    return n1.type === n2.type && n1.key === n2.key;\r\n}\r\nlet vnodeArgsTransformer;\r\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\r\nfunction transformVNodeArgs(transformer) {\r\n    vnodeArgsTransformer = transformer;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(vnodeArgsTransformer\r\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n        : args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref, ref_key, ref_for }) => {\r\n    return (ref != null\r\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)\r\n            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }\r\n            : ref\r\n        : null);\r\n};\r\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        __v_skip: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        slotScopeIds: null,\r\n        children,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    if (needFullChildrenNormalization) {\r\n        normalizeChildren(vnode, children);\r\n        // normalize suspense children\r\n        if (shapeFlag & 128 /* SUSPENSE */) {\r\n            type.normalize(vnode);\r\n        }\r\n    }\r\n    else if (children) {\r\n        // compiled element vnode - if children is passed, only possible types are\r\n        // string or Array.\r\n        vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children)\r\n            ? 8 /* TEXT_CHILDREN */\r\n            : 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    // validate key\r\n    if (( true) && vnode.key !== vnode.key) {\r\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n    }\r\n    // track vnode for block tree\r\n    if (isBlockTreeEnabled > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nconst createVNode = (( true) ? createVNodeWithArgsTransform : 0);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if (( true) && !type) {\r\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\r\n        }\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\r\n            if (cloned.shapeFlag & 6 /* COMPONENT */) {\r\n                currentBlock[currentBlock.indexOf(type)] = cloned;\r\n            }\r\n            else {\r\n                currentBlock.push(cloned);\r\n            }\r\n        }\r\n        cloned.patchFlag |= -2 /* BAIL */;\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        props = guardReactiveProps(props);\r\n        let { class: klass, style } = props;\r\n        if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {\r\n            props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);\r\n        }\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {\r\n                style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);\r\n            }\r\n            props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)\r\n        ? 1 /* ELEMENT */\r\n        : isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if (( true) && shapeFlag & 4 /* STATEFUL_COMPONENT */ && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {\r\n        type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);\r\n        warn(`Vue received a Component which was made a reactive object. This can ` +\r\n            `lead to unnecessary performance overhead, and should be avoided by ` +\r\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n    }\r\n    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\r\n}\r\nfunction guardReactiveProps(props) {\r\n    if (!props)\r\n        return null;\r\n    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props\r\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props)\r\n        : props;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag, children } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    const cloned = {\r\n        __v_isVNode: true,\r\n        __v_skip: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        slotScopeIds: vnode.slotScopeIds,\r\n        children: ( true) && patchFlag === -1 /* HOISTED */ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)\r\n            ? children.map(deepCloneVNode)\r\n            : children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: preserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n    return cloned;\r\n}\r\n/**\r\n * Dev only, for HMR of hoisted vnodes reused in v-for\r\n * https://github.com/vitejs/vite/issues/2022\r\n */\r\nfunction deepCloneVNode(vnode) {\r\n    const cloned = cloneVNode(vnode);\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {\r\n        cloned.children = vnode.children.map(deepCloneVNode);\r\n    }\r\n    return cloned;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createStaticVNode(content, numberOfNodes) {\r\n    // A static vnode can contain multiple stringified elements, and the number\r\n    // of elements is necessary for hydration.\r\n    const vnode = createVNode(Static, null, content);\r\n    vnode.staticCount = numberOfNodes;\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createCommentVNode(text = '', \r\n// when used as the v-else branch, the comment node must be created as a\r\n// block to ensure correct updates.\r\nasBlock = false) {\r\n    return asBlock\r\n        ? (openBlock(), createBlock(Comment, null, text))\r\n        : createVNode(Comment, null, text);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, \r\n        // #3666, avoid reference pollution when reusing vnode\r\n        child.slice());\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return cloneIfMounted(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\n// optimized normalization for template-compiled render fns\r\nfunction cloneIfMounted(child) {\r\n    return child.el === null || child.memo ? child : cloneVNode(child);\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && (slot._d = false);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && (slot._d = true);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n                else {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = {};\r\n    for (let i = 0; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);\r\n            }\r\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (incoming &&\r\n                    existing !== incoming &&\r\n                    !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, incoming)\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\r\n    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\r\n        vnode,\r\n        prevVNode\r\n    ]);\r\n}\n\nconst emptyAppContext = createAppContext();\r\nlet uid$1 = 0;\r\nfunction createComponentInstance(vnode, parent, suspense) {\r\n    const type = vnode.type;\r\n    // inherit parent app context - or - if root, adopt from root vnode\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n    const instance = {\r\n        uid: uid$1++,\r\n        vnode,\r\n        type,\r\n        parent,\r\n        appContext,\r\n        root: null,\r\n        next: null,\r\n        subTree: null,\r\n        effect: null,\r\n        update: null,\r\n        scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(true /* detached */),\r\n        render: null,\r\n        proxy: null,\r\n        exposed: null,\r\n        exposeProxy: null,\r\n        withProxy: null,\r\n        provides: parent ? parent.provides : Object.create(appContext.provides),\r\n        accessCache: null,\r\n        renderCache: [],\r\n        // local resolved assets\r\n        components: null,\r\n        directives: null,\r\n        // resolved props and emits options\r\n        propsOptions: normalizePropsOptions(type, appContext),\r\n        emitsOptions: normalizeEmitsOptions(type, appContext),\r\n        // emit\r\n        emit: null,\r\n        emitted: null,\r\n        // props default value\r\n        propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\r\n        // inheritAttrs\r\n        inheritAttrs: type.inheritAttrs,\r\n        // state\r\n        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\r\n        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\r\n        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\r\n        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\r\n        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\r\n        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\r\n        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\r\n        setupContext: null,\r\n        // suspense related\r\n        suspense,\r\n        suspenseId: suspense ? suspense.pendingId : 0,\r\n        asyncDep: null,\r\n        asyncResolved: false,\r\n        // lifecycle hooks\r\n        // not using enums here because it results in computed properties\r\n        isMounted: false,\r\n        isUnmounted: false,\r\n        isDeactivated: false,\r\n        bc: null,\r\n        c: null,\r\n        bm: null,\r\n        m: null,\r\n        bu: null,\r\n        u: null,\r\n        um: null,\r\n        bum: null,\r\n        da: null,\r\n        a: null,\r\n        rtg: null,\r\n        rtc: null,\r\n        ec: null,\r\n        sp: null\r\n    };\r\n    if ((true)) {\r\n        instance.ctx = createDevRenderContext(instance);\r\n    }\r\n    else {}\r\n    instance.root = parent ? parent.root : instance;\r\n    instance.emit = emit$1.bind(null, instance);\r\n    // apply custom element special handling\r\n    if (vnode.ce) {\r\n        vnode.ce(instance);\r\n    }\r\n    return instance;\r\n}\r\nlet currentInstance = null;\r\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\r\nconst setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n    instance.scope.on();\r\n};\r\nconst unsetCurrentInstance = () => {\r\n    currentInstance && currentInstance.scope.off();\r\n    currentInstance = null;\r\n};\r\nconst isBuiltInTag = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');\r\nfunction validateComponentName(name, config) {\r\n    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;\r\n    if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n        warn('Do not use built-in or reserved HTML elements as component id: ' + name);\r\n    }\r\n}\r\nfunction isStatefulComponent(instance) {\r\n    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n}\r\nlet isInSSRComponentSetup = false;\r\nfunction setupComponent(instance, isSSR = false) {\r\n    isInSSRComponentSetup = isSSR;\r\n    const { props, children } = instance.vnode;\r\n    const isStateful = isStatefulComponent(instance);\r\n    initProps(instance, props, isStateful, isSSR);\r\n    initSlots(instance, children);\r\n    const setupResult = isStateful\r\n        ? setupStatefulComponent(instance, isSSR)\r\n        : undefined;\r\n    isInSSRComponentSetup = false;\r\n    return setupResult;\r\n}\r\nfunction setupStatefulComponent(instance, isSSR) {\r\n    var _a;\r\n    const Component = instance.type;\r\n    if ((true)) {\r\n        if (Component.name) {\r\n            validateComponentName(Component.name, instance.appContext.config);\r\n        }\r\n        if (Component.components) {\r\n            const names = Object.keys(Component.components);\r\n            for (let i = 0; i < names.length; i++) {\r\n                validateComponentName(names[i], instance.appContext.config);\r\n            }\r\n        }\r\n        if (Component.directives) {\r\n            const names = Object.keys(Component.directives);\r\n            for (let i = 0; i < names.length; i++) {\r\n                validateDirectiveName(names[i]);\r\n            }\r\n        }\r\n        if (Component.compilerOptions && isRuntimeOnly()) {\r\n            warn(`\"compilerOptions\" is only supported when using a build of Vue that ` +\r\n                `includes the runtime compiler. Since you are using a runtime-only ` +\r\n                `build, the options should be passed via your build tool config instead.`);\r\n        }\r\n    }\r\n    // 0. create render proxy property access cache\r\n    instance.accessCache = Object.create(null);\r\n    // 1. create public instance / render proxy\r\n    // also mark it raw so it's never observed\r\n    instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\r\n    if ((true)) {\r\n        exposePropsOnRenderContext(instance);\r\n    }\r\n    // 2. call setup()\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        const setupContext = (instance.setupContext =\r\n            setup.length > 1 ? createSetupContext(instance) : null);\r\n        setCurrentInstance(instance);\r\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\r\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);\r\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\r\n        unsetCurrentInstance();\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {\r\n            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\r\n            if (isSSR) {\r\n                // return the promise so server-renderer can wait on it\r\n                return setupResult\r\n                    .then((resolvedResult) => {\r\n                    handleSetupResult(instance, resolvedResult, isSSR);\r\n                })\r\n                    .catch(e => {\r\n                    handleError(e, instance, 0 /* SETUP_FUNCTION */);\r\n                });\r\n            }\r\n            else {\r\n                // async setup returned Promise.\r\n                // bail here and wait for re-entry.\r\n                instance.asyncDep = setupResult;\r\n                if (( true) && !instance.suspense) {\r\n                    const name = (_a = Component.name) !== null && _a !== void 0 ? _a : 'Anonymous';\r\n                    warn(`Component <${name}>: setup function returned a promise, but no ` +\r\n                        `<Suspense> boundary was found in the parent component tree. ` +\r\n                        `A component with async setup() must be nested in a <Suspense> ` +\r\n                        `in order to be rendered.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            handleSetupResult(instance, setupResult, isSSR);\r\n        }\r\n    }\r\n    else {\r\n        finishComponentSetup(instance, isSSR);\r\n    }\r\n}\r\nfunction handleSetupResult(instance, setupResult, isSSR) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {\r\n        // setup returned an inline render function\r\n        if (instance.type.__ssrInlineRender) {\r\n            // when the function's name is `ssrRender` (compiled by SFC inline mode),\r\n            // set it as ssrRender instead.\r\n            instance.ssrRender = setupResult;\r\n        }\r\n        else {\r\n            instance.render = setupResult;\r\n        }\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {\r\n        if (( true) && isVNode(setupResult)) {\r\n            warn(`setup() should not return VNodes directly - ` +\r\n                `return a render function instead.`);\r\n        }\r\n        // setup returned bindings.\r\n        // assuming a render function compiled from template is present.\r\n        if (true) {\r\n            instance.devtoolsRawSetupState = setupResult;\r\n        }\r\n        instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);\r\n        if ((true)) {\r\n            exposeSetupStateOnRenderContext(instance);\r\n        }\r\n    }\r\n    else if (( true) && setupResult !== undefined) {\r\n        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\r\n    }\r\n    finishComponentSetup(instance, isSSR);\r\n}\r\nlet compile;\r\nlet installWithProxy;\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nfunction registerRuntimeCompiler(_compile) {\r\n    compile = _compile;\r\n    installWithProxy = i => {\r\n        if (i.render._rc) {\r\n            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\r\n        }\r\n    };\r\n}\r\n// dev only\r\nconst isRuntimeOnly = () => !compile;\r\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\r\n    const Component = instance.type;\r\n    // template / render function normalization\r\n    // could be already set when returned from setup()\r\n    if (!instance.render) {\r\n        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\r\n        // is done by server-renderer\r\n        if (!isSSR && compile && !Component.render) {\r\n            const template = Component.template;\r\n            if (template) {\r\n                if ((true)) {\r\n                    startMeasure(instance, `compile`);\r\n                }\r\n                const { isCustomElement, compilerOptions } = instance.appContext.config;\r\n                const { delimiters, compilerOptions: componentCompilerOptions } = Component;\r\n                const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({\r\n                    isCustomElement,\r\n                    delimiters\r\n                }, compilerOptions), componentCompilerOptions);\r\n                Component.render = compile(template, finalCompilerOptions);\r\n                if ((true)) {\r\n                    endMeasure(instance, `compile`);\r\n                }\r\n            }\r\n        }\r\n        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP);\r\n        // for runtime-compiled render functions using `with` blocks, the render\r\n        // proxy used needs a different `has` handler which is more performant and\r\n        // also only allows a whitelist of globals to fallthrough.\r\n        if (installWithProxy) {\r\n            installWithProxy(instance);\r\n        }\r\n    }\r\n    // support for 2.x options\r\n    if (__VUE_OPTIONS_API__ && !(false )) {\r\n        setCurrentInstance(instance);\r\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\r\n        applyOptions(instance);\r\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\r\n        unsetCurrentInstance();\r\n    }\r\n    // warn missing template/render\r\n    // the runtime compilation of template in SSR is done by server-render\r\n    if (( true) && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {\r\n        /* istanbul ignore if */\r\n        if (!compile && Component.template) {\r\n            warn(`Component provided template option but ` +\r\n                `runtime compilation is not supported in this build of Vue.` +\r\n                (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\r\n                    ) /* should not happen */);\r\n        }\r\n        else {\r\n            warn(`Component is missing template or render function.`);\r\n        }\r\n    }\r\n}\r\nfunction createAttrsProxy(instance) {\r\n    return new Proxy(instance.attrs, ( true)\r\n        ? {\r\n            get(target, key) {\r\n                markAttrsAccessed();\r\n                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, \"get\" /* GET */, '$attrs');\r\n                return target[key];\r\n            },\r\n            set() {\r\n                warn(`setupContext.attrs is readonly.`);\r\n                return false;\r\n            },\r\n            deleteProperty() {\r\n                warn(`setupContext.attrs is readonly.`);\r\n                return false;\r\n            }\r\n        }\r\n        : 0);\r\n}\r\nfunction createSetupContext(instance) {\r\n    const expose = exposed => {\r\n        if (( true) && instance.exposed) {\r\n            warn(`expose() should be called only once per setup().`);\r\n        }\r\n        instance.exposed = exposed || {};\r\n    };\r\n    let attrs;\r\n    if ((true)) {\r\n        // We use getters in dev in case libs like test-utils overwrite instance\r\n        // properties (overwrites should not be done in prod)\r\n        return Object.freeze({\r\n            get attrs() {\r\n                return attrs || (attrs = createAttrsProxy(instance));\r\n            },\r\n            get slots() {\r\n                return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);\r\n            },\r\n            get emit() {\r\n                return (event, ...args) => instance.emit(event, ...args);\r\n            },\r\n            expose\r\n        });\r\n    }\r\n    else {}\r\n}\r\nfunction getExposeProxy(instance) {\r\n    if (instance.exposed) {\r\n        return (instance.exposeProxy ||\r\n            (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {\r\n                get(target, key) {\r\n                    if (key in target) {\r\n                        return target[key];\r\n                    }\r\n                    else if (key in publicPropertiesMap) {\r\n                        return publicPropertiesMap[key](instance);\r\n                    }\r\n                }\r\n            })));\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\nfunction getComponentName(Component, includeInferred = true) {\r\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name || (includeInferred && Component.__name);\r\n}\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = getComponentName(Component);\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;\r\n}\n\nconst computed = ((getterOrOptions, debugOptions) => {\r\n    // @ts-ignore\r\n    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);\r\n});\n\n// dev only\r\nconst warnRuntimeUsage = (method) => warn(`${method}() is a compiler-hint helper that is only usable inside ` +\r\n    `<script setup> of a single file component. Its arguments should be ` +\r\n    `compiled away and passing it at runtime has no effect.`);\r\n// implementation\r\nfunction defineProps() {\r\n    if ((true)) {\r\n        warnRuntimeUsage(`defineProps`);\r\n    }\r\n    return null;\r\n}\r\n// implementation\r\nfunction defineEmits() {\r\n    if ((true)) {\r\n        warnRuntimeUsage(`defineEmits`);\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a component's exposed\r\n * instance properties when it is accessed by a parent component via template\r\n * refs.\r\n *\r\n * `<script setup>` components are closed by default - i.e. variables inside\r\n * the `<script setup>` scope is not exposed to parent unless explicitly exposed\r\n * via `defineExpose`.\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the\r\n * output and should **not** be actually called at runtime.\r\n */\r\nfunction defineExpose(exposed) {\r\n    if ((true)) {\r\n        warnRuntimeUsage(`defineExpose`);\r\n    }\r\n}\r\n/**\r\n * Vue `<script setup>` compiler macro for providing props default values when\r\n * using type-based `defineProps` declaration.\r\n *\r\n * Example usage:\r\n * ```ts\r\n * withDefaults(defineProps<{\r\n *   size?: number\r\n *   labels?: string[]\r\n * }>(), {\r\n *   size: 3,\r\n *   labels: () => ['default label']\r\n * })\r\n * ```\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the output\r\n * and should **not** be actually called at runtime.\r\n */\r\nfunction withDefaults(props, defaults) {\r\n    if ((true)) {\r\n        warnRuntimeUsage(`withDefaults`);\r\n    }\r\n    return null;\r\n}\r\nfunction useSlots() {\r\n    return getContext().slots;\r\n}\r\nfunction useAttrs() {\r\n    return getContext().attrs;\r\n}\r\nfunction getContext() {\r\n    const i = getCurrentInstance();\r\n    if (( true) && !i) {\r\n        warn(`useContext() called without active instance.`);\r\n    }\r\n    return i.setupContext || (i.setupContext = createSetupContext(i));\r\n}\r\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\r\nfunction mergeDefaults(raw, defaults) {\r\n    const props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)\r\n        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})\r\n        : raw;\r\n    for (const key in defaults) {\r\n        const opt = props[key];\r\n        if (opt) {\r\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {\r\n                props[key] = { type: opt, default: defaults[key] };\r\n            }\r\n            else {\r\n                opt.default = defaults[key];\r\n            }\r\n        }\r\n        else if (opt === null) {\r\n            props[key] = { default: defaults[key] };\r\n        }\r\n        else if ((true)) {\r\n            warn(`props default key \"${key}\" has no corresponding declaration.`);\r\n        }\r\n    }\r\n    return props;\r\n}\r\n/**\r\n * Used to create a proxy for the rest element when destructuring props with\r\n * defineProps().\r\n * @internal\r\n */\r\nfunction createPropsRestProxy(props, excludedKeys) {\r\n    const ret = {};\r\n    for (const key in props) {\r\n        if (!excludedKeys.includes(key)) {\r\n            Object.defineProperty(ret, key, {\r\n                enumerable: true,\r\n                get: () => props[key]\r\n            });\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * `<script setup>` helper for persisting the current instance context over\r\n * async/await flows.\r\n *\r\n * `@vue/compiler-sfc` converts the following:\r\n *\r\n * ```ts\r\n * const x = await foo()\r\n * ```\r\n *\r\n * into:\r\n *\r\n * ```ts\r\n * let __temp, __restore\r\n * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\r\n * ```\r\n * @internal\r\n */\r\nfunction withAsyncContext(getAwaitable) {\r\n    const ctx = getCurrentInstance();\r\n    if (( true) && !ctx) {\r\n        warn(`withAsyncContext called without active current instance. ` +\r\n            `This is likely a bug.`);\r\n    }\r\n    let awaitable = getAwaitable();\r\n    unsetCurrentInstance();\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {\r\n        awaitable = awaitable.catch(e => {\r\n            setCurrentInstance(ctx);\r\n            throw e;\r\n        });\r\n    }\r\n    return [awaitable, () => setCurrentInstance(ctx)];\r\n}\n\n// Actual implementation\r\nfunction h(type, propsOrChildren, children) {\r\n    const l = arguments.length;\r\n    if (l === 2) {\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {\r\n            // single vnode without props\r\n            if (isVNode(propsOrChildren)) {\r\n                return createVNode(type, null, [propsOrChildren]);\r\n            }\r\n            // props without children\r\n            return createVNode(type, propsOrChildren);\r\n        }\r\n        else {\r\n            // omit props\r\n            return createVNode(type, null, propsOrChildren);\r\n        }\r\n    }\r\n    else {\r\n        if (l > 3) {\r\n            children = Array.prototype.slice.call(arguments, 2);\r\n        }\r\n        else if (l === 3 && isVNode(children)) {\r\n            children = [children];\r\n        }\r\n        return createVNode(type, propsOrChildren, children);\r\n    }\r\n}\n\nconst ssrContextKey = Symbol(( true) ? `ssrContext` : 0);\r\nconst useSSRContext = () => {\r\n    {\r\n        const ctx = inject(ssrContextKey);\r\n        if (!ctx) {\r\n            warn(`Server rendering context not provided. Make sure to only call ` +\r\n                `useSSRContext() conditionally in the server build.`);\r\n        }\r\n        return ctx;\r\n    }\r\n};\n\nfunction isShallow(value) {\r\n    return !!(value && value[\"__v_isShallow\" /* IS_SHALLOW */]);\r\n}\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if ( false || typeof window === 'undefined') {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));\r\n        }\r\n        if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {\r\n            return ['object', { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if (((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key)) ||\r\n            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (isShallow(v)) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\nfunction withMemo(memo, render, cache, index) {\r\n    const cached = cache[index];\r\n    if (cached && isMemoSame(cached, memo)) {\r\n        return cached;\r\n    }\r\n    const ret = render();\r\n    // shallow clone\r\n    ret.memo = memo.slice();\r\n    return (cache[index] = ret);\r\n}\r\nfunction isMemoSame(cached, memo) {\r\n    const prev = cached.memo;\r\n    if (prev.length != memo.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < prev.length; i++) {\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(prev[i], memo[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    // make sure to let parent block track it when returning cached\r\n    if (isBlockTreeEnabled > 0 && currentBlock) {\r\n        currentBlock.push(cached);\r\n    }\r\n    return true;\r\n}\n\n// Core API ------------------------------------------------------------------\r\nconst version = \"3.2.37\";\r\nconst _ssrUtils = {\r\n    createComponentInstance,\r\n    setupComponent,\r\n    renderComponentRoot,\r\n    setCurrentRenderingInstance,\r\n    isVNode,\r\n    normalizeVNode\r\n};\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in ssr-possible builds.\r\n * @internal\r\n */\r\nconst ssrUtils = (_ssrUtils );\r\n/**\r\n * @internal only exposed in compat builds\r\n */\r\nconst resolveFilter = null;\r\n/**\r\n * @internal only exposed in compat builds.\r\n */\r\nconst compatUtils = (null);\n\n\n\n\n//# sourceURL=webpack://web-dashboard/./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTransition\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition; },\n/* harmony export */   \"Comment\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment; },\n/* harmony export */   \"EffectScope\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },\n/* harmony export */   \"Fragment\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment; },\n/* harmony export */   \"KeepAlive\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive; },\n/* harmony export */   \"ReactiveEffect\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect; },\n/* harmony export */   \"Static\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static; },\n/* harmony export */   \"Suspense\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense; },\n/* harmony export */   \"Teleport\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport; },\n/* harmony export */   \"Text\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text; },\n/* harmony export */   \"Transition\": function() { return /* binding */ Transition; },\n/* harmony export */   \"TransitionGroup\": function() { return /* binding */ TransitionGroup; },\n/* harmony export */   \"VueElement\": function() { return /* binding */ VueElement; },\n/* harmony export */   \"callWithAsyncErrorHandling\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling; },\n/* harmony export */   \"callWithErrorHandling\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling; },\n/* harmony export */   \"camelize\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize; },\n/* harmony export */   \"capitalize\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize; },\n/* harmony export */   \"cloneVNode\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode; },\n/* harmony export */   \"compatUtils\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils; },\n/* harmony export */   \"computed\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed; },\n/* harmony export */   \"createApp\": function() { return /* binding */ createApp; },\n/* harmony export */   \"createBlock\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock; },\n/* harmony export */   \"createCommentVNode\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode; },\n/* harmony export */   \"createElementBlock\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock; },\n/* harmony export */   \"createElementVNode\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode; },\n/* harmony export */   \"createHydrationRenderer\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer; },\n/* harmony export */   \"createPropsRestProxy\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy; },\n/* harmony export */   \"createRenderer\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer; },\n/* harmony export */   \"createSSRApp\": function() { return /* binding */ createSSRApp; },\n/* harmony export */   \"createSlots\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots; },\n/* harmony export */   \"createStaticVNode\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode; },\n/* harmony export */   \"createTextVNode\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode; },\n/* harmony export */   \"createVNode\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode; },\n/* harmony export */   \"customRef\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef; },\n/* harmony export */   \"defineAsyncComponent\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent; },\n/* harmony export */   \"defineComponent\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent; },\n/* harmony export */   \"defineCustomElement\": function() { return /* binding */ defineCustomElement; },\n/* harmony export */   \"defineEmits\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits; },\n/* harmony export */   \"defineExpose\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose; },\n/* harmony export */   \"defineProps\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps; },\n/* harmony export */   \"defineSSRCustomElement\": function() { return /* binding */ defineSSRCustomElement; },\n/* harmony export */   \"devtools\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools; },\n/* harmony export */   \"effect\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect; },\n/* harmony export */   \"effectScope\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope; },\n/* harmony export */   \"getCurrentInstance\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance; },\n/* harmony export */   \"getCurrentScope\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },\n/* harmony export */   \"getTransitionRawChildren\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren; },\n/* harmony export */   \"guardReactiveProps\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps; },\n/* harmony export */   \"h\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h; },\n/* harmony export */   \"handleError\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError; },\n/* harmony export */   \"hydrate\": function() { return /* binding */ hydrate; },\n/* harmony export */   \"initCustomFormatter\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter; },\n/* harmony export */   \"initDirectivesForSSR\": function() { return /* binding */ initDirectivesForSSR; },\n/* harmony export */   \"inject\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject; },\n/* harmony export */   \"isMemoSame\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame; },\n/* harmony export */   \"isProxy\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy; },\n/* harmony export */   \"isReactive\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive; },\n/* harmony export */   \"isReadonly\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },\n/* harmony export */   \"isRef\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef; },\n/* harmony export */   \"isRuntimeOnly\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly; },\n/* harmony export */   \"isShallow\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow; },\n/* harmony export */   \"isVNode\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode; },\n/* harmony export */   \"markRaw\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw; },\n/* harmony export */   \"mergeDefaults\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults; },\n/* harmony export */   \"mergeProps\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps; },\n/* harmony export */   \"nextTick\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick; },\n/* harmony export */   \"normalizeClass\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass; },\n/* harmony export */   \"normalizeProps\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps; },\n/* harmony export */   \"normalizeStyle\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle; },\n/* harmony export */   \"onActivated\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated; },\n/* harmony export */   \"onBeforeMount\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount; },\n/* harmony export */   \"onBeforeUnmount\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount; },\n/* harmony export */   \"onBeforeUpdate\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate; },\n/* harmony export */   \"onDeactivated\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated; },\n/* harmony export */   \"onErrorCaptured\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured; },\n/* harmony export */   \"onMounted\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted; },\n/* harmony export */   \"onRenderTracked\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked; },\n/* harmony export */   \"onRenderTriggered\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered; },\n/* harmony export */   \"onScopeDispose\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },\n/* harmony export */   \"onServerPrefetch\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch; },\n/* harmony export */   \"onUnmounted\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted; },\n/* harmony export */   \"onUpdated\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated; },\n/* harmony export */   \"openBlock\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock; },\n/* harmony export */   \"popScopeId\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId; },\n/* harmony export */   \"provide\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide; },\n/* harmony export */   \"proxyRefs\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },\n/* harmony export */   \"pushScopeId\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId; },\n/* harmony export */   \"queuePostFlushCb\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb; },\n/* harmony export */   \"reactive\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive; },\n/* harmony export */   \"readonly\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly; },\n/* harmony export */   \"ref\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref; },\n/* harmony export */   \"registerRuntimeCompiler\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler; },\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"renderList\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList; },\n/* harmony export */   \"renderSlot\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot; },\n/* harmony export */   \"resolveComponent\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent; },\n/* harmony export */   \"resolveDirective\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective; },\n/* harmony export */   \"resolveDynamicComponent\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent; },\n/* harmony export */   \"resolveFilter\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter; },\n/* harmony export */   \"resolveTransitionHooks\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks; },\n/* harmony export */   \"setBlockTracking\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking; },\n/* harmony export */   \"setDevtoolsHook\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook; },\n/* harmony export */   \"setTransitionHooks\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks; },\n/* harmony export */   \"shallowReactive\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },\n/* harmony export */   \"shallowReadonly\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },\n/* harmony export */   \"shallowRef\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },\n/* harmony export */   \"ssrContextKey\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey; },\n/* harmony export */   \"ssrUtils\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils; },\n/* harmony export */   \"stop\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop; },\n/* harmony export */   \"toDisplayString\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString; },\n/* harmony export */   \"toHandlerKey\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey; },\n/* harmony export */   \"toHandlers\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers; },\n/* harmony export */   \"toRaw\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw; },\n/* harmony export */   \"toRef\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef; },\n/* harmony export */   \"toRefs\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs; },\n/* harmony export */   \"transformVNodeArgs\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs; },\n/* harmony export */   \"triggerRef\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },\n/* harmony export */   \"unref\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref; },\n/* harmony export */   \"useAttrs\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs; },\n/* harmony export */   \"useCssModule\": function() { return /* binding */ useCssModule; },\n/* harmony export */   \"useCssVars\": function() { return /* binding */ useCssVars; },\n/* harmony export */   \"useSSRContext\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext; },\n/* harmony export */   \"useSlots\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots; },\n/* harmony export */   \"useTransitionState\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState; },\n/* harmony export */   \"vModelCheckbox\": function() { return /* binding */ vModelCheckbox; },\n/* harmony export */   \"vModelDynamic\": function() { return /* binding */ vModelDynamic; },\n/* harmony export */   \"vModelRadio\": function() { return /* binding */ vModelRadio; },\n/* harmony export */   \"vModelSelect\": function() { return /* binding */ vModelSelect; },\n/* harmony export */   \"vModelText\": function() { return /* binding */ vModelText; },\n/* harmony export */   \"vShow\": function() { return /* binding */ vShow; },\n/* harmony export */   \"version\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version; },\n/* harmony export */   \"warn\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn; },\n/* harmony export */   \"watch\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch; },\n/* harmony export */   \"watchEffect\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect; },\n/* harmony export */   \"watchPostEffect\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect; },\n/* harmony export */   \"watchSyncEffect\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect; },\n/* harmony export */   \"withAsyncContext\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext; },\n/* harmony export */   \"withCtx\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx; },\n/* harmony export */   \"withDefaults\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults; },\n/* harmony export */   \"withDirectives\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives; },\n/* harmony export */   \"withKeys\": function() { return /* binding */ withKeys; },\n/* harmony export */   \"withMemo\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo; },\n/* harmony export */   \"withModifiers\": function() { return /* binding */ withModifiers; },\n/* harmony export */   \"withScopeId\": function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId; }\n/* harmony export */ });\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\n\n\n\n\nconst svgNS = 'http://www.w3.org/2000/svg';\r\nconst doc = (typeof document !== 'undefined' ? document : null);\r\nconst templateContainer = doc && /*#__PURE__*/ doc.createElement('template');\r\nconst nodeOps = {\r\n    insert: (child, parent, anchor) => {\r\n        parent.insertBefore(child, anchor || null);\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: (tag, isSVG, is, props) => {\r\n        const el = isSVG\r\n            ? doc.createElementNS(svgNS, tag)\r\n            : doc.createElement(tag, is ? { is } : undefined);\r\n        if (tag === 'select' && props && props.multiple != null) {\r\n            el.setAttribute('multiple', props.multiple);\r\n        }\r\n        return el;\r\n    },\r\n    createText: text => doc.createTextNode(text),\r\n    createComment: text => doc.createComment(text),\r\n    setText: (node, text) => {\r\n        node.nodeValue = text;\r\n    },\r\n    setElementText: (el, text) => {\r\n        el.textContent = text;\r\n    },\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => doc.querySelector(selector),\r\n    setScopeId(el, id) {\r\n        el.setAttribute(id, '');\r\n    },\r\n    cloneNode(el) {\r\n        const cloned = el.cloneNode(true);\r\n        // #3072\r\n        // - in `patchDOMProp`, we store the actual value in the `el._value` property.\r\n        // - normally, elements using `:value` bindings will not be hoisted, but if\r\n        //   the bound value is a constant, e.g. `:value=\"true\"` - they do get\r\n        //   hoisted.\r\n        // - in production, hoisted nodes are cloned when subsequent inserts, but\r\n        //   cloneNode() does not copy the custom property we attached.\r\n        // - This may need to account for other custom DOM properties we attach to\r\n        //   elements in addition to `_value` in the future.\r\n        if (`_value` in el) {\r\n            cloned._value = el._value;\r\n        }\r\n        return cloned;\r\n    },\r\n    // __UNSAFE__\r\n    // Reason: innerHTML.\r\n    // Static content here can only come from compiled templates.\r\n    // As long as the user only uses trusted templates, this is safe.\r\n    insertStaticContent(content, parent, anchor, isSVG, start, end) {\r\n        // <parent> before | first ... last | anchor </parent>\r\n        const before = anchor ? anchor.previousSibling : parent.lastChild;\r\n        // #5308 can only take cached path if:\r\n        // - has a single root node\r\n        // - nextSibling info is still available\r\n        if (start && (start === end || start.nextSibling)) {\r\n            // cached\r\n            while (true) {\r\n                parent.insertBefore(start.cloneNode(true), anchor);\r\n                if (start === end || !(start = start.nextSibling))\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            // fresh insert\r\n            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\r\n            const template = templateContainer.content;\r\n            if (isSVG) {\r\n                // remove outer svg wrapper\r\n                const wrapper = template.firstChild;\r\n                while (wrapper.firstChild) {\r\n                    template.appendChild(wrapper.firstChild);\r\n                }\r\n                template.removeChild(wrapper);\r\n            }\r\n            parent.insertBefore(template, anchor);\r\n        }\r\n        return [\r\n            // first\r\n            before ? before.nextSibling : parent.firstChild,\r\n            // last\r\n            anchor ? anchor.previousSibling : parent.lastChild\r\n        ];\r\n    }\r\n};\n\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding ['staticClass', dynamic]\r\nfunction patchClass(el, value, isSVG) {\r\n    // directly setting className should be faster than setAttribute in theory\r\n    // if this is an element during a transition, take the temporary transition\r\n    // classes into account.\r\n    const transitionClasses = el._vtc;\r\n    if (transitionClasses) {\r\n        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');\r\n    }\r\n    if (value == null) {\r\n        el.removeAttribute('class');\r\n    }\r\n    else if (isSVG) {\r\n        el.setAttribute('class', value);\r\n    }\r\n    else {\r\n        el.className = value;\r\n    }\r\n}\n\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style;\r\n    const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);\r\n    if (next && !isCssString) {\r\n        for (const key in next) {\r\n            setStyle(style, key, next[key]);\r\n        }\r\n        if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {\r\n            for (const key in prev) {\r\n                if (next[key] == null) {\r\n                    setStyle(style, key, '');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const currentDisplay = style.display;\r\n        if (isCssString) {\r\n            if (prev !== next) {\r\n                style.cssText = next;\r\n            }\r\n        }\r\n        else if (prev) {\r\n            el.removeAttribute('style');\r\n        }\r\n        // indicates that the `display` of the element is controlled by `v-show`,\r\n        // so we always keep the current `display` value regardless of the `style`\r\n        // value, thus handing over control to `v-show`.\r\n        if ('_vod' in el) {\r\n            style.display = currentDisplay;\r\n        }\r\n    }\r\n}\r\nconst importantRE = /\\s*!important$/;\r\nfunction setStyle(style, name, val) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {\r\n        val.forEach(v => setStyle(style, name, v));\r\n    }\r\n    else {\r\n        if (val == null)\r\n            val = '';\r\n        if (name.startsWith('--')) {\r\n            // custom property definition\r\n            style.setProperty(name, val);\r\n        }\r\n        else {\r\n            const prefixed = autoPrefix(style, name);\r\n            if (importantRE.test(val)) {\r\n                // !important\r\n                style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');\r\n            }\r\n            else {\r\n                style[prefixed] = val;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst prefixes = ['Webkit', 'Moz', 'ms'];\r\nconst prefixCache = {};\r\nfunction autoPrefix(style, rawName) {\r\n    const cached = prefixCache[rawName];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);\r\n    if (name !== 'filter' && name in style) {\r\n        return (prefixCache[rawName] = name);\r\n    }\r\n    name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);\r\n    for (let i = 0; i < prefixes.length; i++) {\r\n        const prefixed = prefixes[i] + name;\r\n        if (prefixed in style) {\r\n            return (prefixCache[rawName] = prefixed);\r\n        }\r\n    }\r\n    return rawName;\r\n}\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\r\nfunction patchAttr(el, key, value, isSVG, instance) {\r\n    if (isSVG && key.startsWith('xlink:')) {\r\n        if (value == null) {\r\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        // note we are only checking boolean attributes that don't have a\r\n        // corresponding dom prop of the same name here.\r\n        const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);\r\n        if (value == null || (isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value))) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, isBoolean ? '' : value);\r\n        }\r\n    }\r\n}\n\n// __UNSAFE__\r\n// functions. The user is responsible for using them with only trusted content.\r\nfunction patchDOMProp(el, key, value, \r\n// the following args are passed only due to potential innerHTML/textContent\r\n// overriding existing VNodes, in which case the old tree must be properly\r\n// unmounted.\r\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n    if (key === 'innerHTML' || key === 'textContent') {\r\n        if (prevChildren) {\r\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n        }\r\n        el[key] = value == null ? '' : value;\r\n        return;\r\n    }\r\n    if (key === 'value' &&\r\n        el.tagName !== 'PROGRESS' &&\r\n        // custom elements may use _value internally\r\n        !el.tagName.includes('-')) {\r\n        // store value as _value as well since\r\n        // non-string values will be stringified.\r\n        el._value = value;\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue ||\r\n            // #4956: always set for OPTION elements because its value falls back to\r\n            // textContent if no value attribute is present. And setting .value for\r\n            // OPTION has no side effect\r\n            el.tagName === 'OPTION') {\r\n            el.value = newValue;\r\n        }\r\n        if (value == null) {\r\n            el.removeAttribute(key);\r\n        }\r\n        return;\r\n    }\r\n    let needRemove = false;\r\n    if (value === '' || value == null) {\r\n        const type = typeof el[key];\r\n        if (type === 'boolean') {\r\n            // e.g. <select multiple> compiles to { multiple: '' }\r\n            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);\r\n        }\r\n        else if (value == null && type === 'string') {\r\n            // e.g. <div :id=\"null\">\r\n            value = '';\r\n            needRemove = true;\r\n        }\r\n        else if (type === 'number') {\r\n            // e.g. <img :width=\"null\">\r\n            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error\r\n            value = 0;\r\n            needRemove = true;\r\n        }\r\n    }\r\n    // some properties perform value validation and throw,\r\n    // some properties has getter, no setter, will error in 'use strict'\r\n    // eg. <select :type=\"null\"></select> <select :willValidate=\"null\"></select>\r\n    try {\r\n        el[key] = value;\r\n    }\r\n    catch (e) {\r\n        if ((true)) {\r\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` +\r\n                `value ${value} is invalid.`, e);\r\n        }\r\n    }\r\n    needRemove && el.removeAttribute(key);\r\n}\n\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nconst [_getNow, skipTimestampCheck] = /*#__PURE__*/ (() => {\r\n    let _getNow = Date.now;\r\n    let skipTimestampCheck = false;\r\n    if (typeof window !== 'undefined') {\r\n        // Determine what event timestamp the browser is using. Annoyingly, the\r\n        // timestamp can either be hi-res (relative to page load) or low-res\r\n        // (relative to UNIX epoch), so in order to compare time we have to use the\r\n        // same timestamp type when saving the flush timestamp.\r\n        if (Date.now() > document.createEvent('Event').timeStamp) {\r\n            // if the low-res timestamp which is bigger than the event timestamp\r\n            // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n            // and we need to use the hi-res version for event listeners as well.\r\n            _getNow = performance.now.bind(performance);\r\n        }\r\n        // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation\r\n        // and does not fire microtasks in between event propagation, so safe to exclude.\r\n        const ffMatch = navigator.userAgent.match(/firefox\\/(\\d+)/i);\r\n        skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);\r\n    }\r\n    return [_getNow, skipTimestampCheck];\r\n})();\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst p = /*#__PURE__*/ Promise.resolve();\r\nconst reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));\r\nfunction addEventListener(el, event, handler, options) {\r\n    el.addEventListener(event, handler, options);\r\n}\r\nfunction removeEventListener(el, event, handler, options) {\r\n    el.removeEventListener(event, handler, options);\r\n}\r\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n    // vei = vue event invokers\r\n    const invokers = el._vei || (el._vei = {});\r\n    const existingInvoker = invokers[rawName];\r\n    if (nextValue && existingInvoker) {\r\n        // patch\r\n        existingInvoker.value = nextValue;\r\n    }\r\n    else {\r\n        const [name, options] = parseName(rawName);\r\n        if (nextValue) {\r\n            // add\r\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n            addEventListener(el, name, invoker, options);\r\n        }\r\n        else if (existingInvoker) {\r\n            // remove\r\n            removeEventListener(el, name, existingInvoker, options);\r\n            invokers[rawName] = undefined;\r\n        }\r\n    }\r\n}\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\nfunction parseName(name) {\r\n    let options;\r\n    if (optionsModifierRE.test(name)) {\r\n        options = {};\r\n        let m;\r\n        while ((m = name.match(optionsModifierRE))) {\r\n            name = name.slice(0, name.length - m[0].length);\r\n            options[m[0].toLowerCase()] = true;\r\n        }\r\n    }\r\n    return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = (e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        const timeStamp = e.timeStamp || _getNow();\r\n        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {\r\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n        }\r\n    };\r\n    invoker.value = initialValue;\r\n    invoker.attached = getNow();\r\n    return invoker;\r\n}\r\nfunction patchStopImmediatePropagation(e, value) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\r\n        const originalStop = e.stopImmediatePropagation;\r\n        e.stopImmediatePropagation = () => {\r\n            originalStop.call(e);\r\n            e._stopped = true;\r\n        };\r\n        return value.map(fn => (e) => !e._stopped && fn && fn(e));\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\n\nconst nativeOnRE = /^on[a-z]/;\r\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n    if (key === 'class') {\r\n        patchClass(el, nextValue, isSVG);\r\n    }\r\n    else if (key === 'style') {\r\n        patchStyle(el, prevValue, nextValue);\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\r\n        // ignore v-model listeners\r\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {\r\n            patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n        }\r\n    }\r\n    else if (key[0] === '.'\r\n        ? ((key = key.slice(1)), true)\r\n        : key[0] === '^'\r\n            ? ((key = key.slice(1)), false)\r\n            : shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n    }\r\n    else {\r\n        // special case for <input v-model type=\"checkbox\"> with\r\n        // :true-value & :false-value\r\n        // store value as dom properties since non-string values will be\r\n        // stringified.\r\n        if (key === 'true-value') {\r\n            el._trueValue = nextValue;\r\n        }\r\n        else if (key === 'false-value') {\r\n            el._falseValue = nextValue;\r\n        }\r\n        patchAttr(el, key, nextValue, isSVG);\r\n    }\r\n};\r\nfunction shouldSetAsProp(el, key, value, isSVG) {\r\n    if (isSVG) {\r\n        // most keys must be set as attribute on svg elements to work\r\n        // ...except innerHTML & textContent\r\n        if (key === 'innerHTML' || key === 'textContent') {\r\n            return true;\r\n        }\r\n        // or native onclick with function values\r\n        if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // these are enumerated attrs, however their corresponding DOM properties\r\n    // are actually booleans - this leads to setting it with a string \"false\"\r\n    // value leading it to be coerced to `true`, so we need to always treat\r\n    // them as attributes.\r\n    // Note that `contentEditable` doesn't have this problem: its DOM\r\n    // property is also enumerated string values.\r\n    if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {\r\n        return false;\r\n    }\r\n    // #1787, #2840 form property on form elements is readonly and must be set as\r\n    // attribute.\r\n    if (key === 'form') {\r\n        return false;\r\n    }\r\n    // #1526 <input list> must be set as attribute\r\n    if (key === 'list' && el.tagName === 'INPUT') {\r\n        return false;\r\n    }\r\n    // #2766 <textarea type> must be set as attribute\r\n    if (key === 'type' && el.tagName === 'TEXTAREA') {\r\n        return false;\r\n    }\r\n    // native onclick with string value, must be set as attribute\r\n    if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {\r\n        return false;\r\n    }\r\n    return key in el;\r\n}\n\nfunction defineCustomElement(options, hydrate) {\r\n    const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options);\r\n    class VueCustomElement extends VueElement {\r\n        constructor(initialProps) {\r\n            super(Comp, initialProps, hydrate);\r\n        }\r\n    }\r\n    VueCustomElement.def = Comp;\r\n    return VueCustomElement;\r\n}\r\nconst defineSSRCustomElement = ((options) => {\r\n    // @ts-ignore\r\n    return defineCustomElement(options, hydrate);\r\n});\r\nconst BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {\r\n});\r\nclass VueElement extends BaseClass {\r\n    constructor(_def, _props = {}, hydrate) {\r\n        super();\r\n        this._def = _def;\r\n        this._props = _props;\r\n        /**\r\n         * @internal\r\n         */\r\n        this._instance = null;\r\n        this._connected = false;\r\n        this._resolved = false;\r\n        this._numberProps = null;\r\n        if (this.shadowRoot && hydrate) {\r\n            hydrate(this._createVNode(), this.shadowRoot);\r\n        }\r\n        else {\r\n            if (( true) && this.shadowRoot) {\r\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Custom element has pre-rendered declarative shadow root but is not ` +\r\n                    `defined as hydratable. Use \\`defineSSRCustomElement\\`.`);\r\n            }\r\n            this.attachShadow({ mode: 'open' });\r\n        }\r\n    }\r\n    connectedCallback() {\r\n        this._connected = true;\r\n        if (!this._instance) {\r\n            this._resolveDef();\r\n        }\r\n    }\r\n    disconnectedCallback() {\r\n        this._connected = false;\r\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\r\n            if (!this._connected) {\r\n                render(null, this.shadowRoot);\r\n                this._instance = null;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * resolve inner component definition (handle possible async component)\r\n     */\r\n    _resolveDef() {\r\n        if (this._resolved) {\r\n            return;\r\n        }\r\n        this._resolved = true;\r\n        // set initial attrs\r\n        for (let i = 0; i < this.attributes.length; i++) {\r\n            this._setAttr(this.attributes[i].name);\r\n        }\r\n        // watch future attr changes\r\n        new MutationObserver(mutations => {\r\n            for (const m of mutations) {\r\n                this._setAttr(m.attributeName);\r\n            }\r\n        }).observe(this, { attributes: true });\r\n        const resolve = (def) => {\r\n            const { props, styles } = def;\r\n            const hasOptions = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props);\r\n            const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];\r\n            // cast Number-type props set before resolve\r\n            let numberProps;\r\n            if (hasOptions) {\r\n                for (const key in this._props) {\r\n                    const opt = props[key];\r\n                    if (opt === Number || (opt && opt.type === Number)) {\r\n                        this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);\r\n                        (numberProps || (numberProps = Object.create(null)))[key] = true;\r\n                    }\r\n                }\r\n            }\r\n            this._numberProps = numberProps;\r\n            // check if there are props set pre-upgrade or connect\r\n            for (const key of Object.keys(this)) {\r\n                if (key[0] !== '_') {\r\n                    this._setProp(key, this[key], true, false);\r\n                }\r\n            }\r\n            // defining getter/setters on prototype\r\n            for (const key of rawKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {\r\n                Object.defineProperty(this, key, {\r\n                    get() {\r\n                        return this._getProp(key);\r\n                    },\r\n                    set(val) {\r\n                        this._setProp(key, val);\r\n                    }\r\n                });\r\n            }\r\n            // apply CSS\r\n            this._applyStyles(styles);\r\n            // initial render\r\n            this._update();\r\n        };\r\n        const asyncDef = this._def.__asyncLoader;\r\n        if (asyncDef) {\r\n            asyncDef().then(resolve);\r\n        }\r\n        else {\r\n            resolve(this._def);\r\n        }\r\n    }\r\n    _setAttr(key) {\r\n        let value = this.getAttribute(key);\r\n        if (this._numberProps && this._numberProps[key]) {\r\n            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);\r\n        }\r\n        this._setProp((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key), value, false);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _getProp(key) {\r\n        return this._props[key];\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\r\n        if (val !== this._props[key]) {\r\n            this._props[key] = val;\r\n            if (shouldUpdate && this._instance) {\r\n                this._update();\r\n            }\r\n            // reflect\r\n            if (shouldReflect) {\r\n                if (val === true) {\r\n                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), '');\r\n                }\r\n                else if (typeof val === 'string' || typeof val === 'number') {\r\n                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + '');\r\n                }\r\n                else if (!val) {\r\n                    this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _update() {\r\n        render(this._createVNode(), this.shadowRoot);\r\n    }\r\n    _createVNode() {\r\n        const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, this._props));\r\n        if (!this._instance) {\r\n            vnode.ce = instance => {\r\n                this._instance = instance;\r\n                instance.isCE = true;\r\n                // HMR\r\n                if ((true)) {\r\n                    instance.ceReload = newStyles => {\r\n                        // always reset styles\r\n                        if (this._styles) {\r\n                            this._styles.forEach(s => this.shadowRoot.removeChild(s));\r\n                            this._styles.length = 0;\r\n                        }\r\n                        this._applyStyles(newStyles);\r\n                        // if this is an async component, ceReload is called from the inner\r\n                        // component so no need to reload the async wrapper\r\n                        if (!this._def.__asyncLoader) {\r\n                            // reload\r\n                            this._instance = null;\r\n                            this._update();\r\n                        }\r\n                    };\r\n                }\r\n                // intercept emit\r\n                instance.emit = (event, ...args) => {\r\n                    this.dispatchEvent(new CustomEvent(event, {\r\n                        detail: args\r\n                    }));\r\n                };\r\n                // locate nearest Vue custom element parent for provide/inject\r\n                let parent = this;\r\n                while ((parent =\r\n                    parent && (parent.parentNode || parent.host))) {\r\n                    if (parent instanceof VueElement) {\r\n                        instance.parent = parent._instance;\r\n                        break;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        return vnode;\r\n    }\r\n    _applyStyles(styles) {\r\n        if (styles) {\r\n            styles.forEach(css => {\r\n                const s = document.createElement('style');\r\n                s.textContent = css;\r\n                this.shadowRoot.appendChild(s);\r\n                // record for HMR\r\n                if ((true)) {\r\n                    (this._styles || (this._styles = [])).push(s);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\n\nfunction useCssModule(name = '$style') {\r\n    /* istanbul ignore else */\r\n    {\r\n        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\r\n        if (!instance) {\r\n            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);\r\n            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n        }\r\n        const modules = instance.type.__cssModules;\r\n        if (!modules) {\r\n            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);\r\n            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n        }\r\n        const mod = modules[name];\r\n        if (!mod) {\r\n            ( true) &&\r\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named \"${name}\".`);\r\n            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\r\n        }\r\n        return mod;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\r\n    /* istanbul ignore next */\r\n    if (!instance) {\r\n        ( true) &&\r\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);\r\n        return;\r\n    }\r\n    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));\r\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(setVars);\r\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\r\n        const ob = new MutationObserver(setVars);\r\n        ob.observe(instance.subTree.el.parentNode, { childList: true });\r\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());\r\n    });\r\n}\r\nfunction setVarsOnVNode(vnode, vars) {\r\n    if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        const suspense = vnode.suspense;\r\n        vnode = suspense.activeBranch;\r\n        if (suspense.pendingBranch && !suspense.isHydrating) {\r\n            suspense.effects.push(() => {\r\n                setVarsOnVNode(suspense.activeBranch, vars);\r\n            });\r\n        }\r\n    }\r\n    // drill down HOCs until it's a non-component vnode\r\n    while (vnode.component) {\r\n        vnode = vnode.component.subTree;\r\n    }\r\n    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {\r\n        setVarsOnNode(vnode.el, vars);\r\n    }\r\n    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\r\n        vnode.children.forEach(c => setVarsOnVNode(c, vars));\r\n    }\r\n    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {\r\n        let { el, anchor } = vnode;\r\n        while (el) {\r\n            setVarsOnNode(el, vars);\r\n            if (el === anchor)\r\n                break;\r\n            el = el.nextSibling;\r\n        }\r\n    }\r\n}\r\nfunction setVarsOnNode(el, vars) {\r\n    if (el.nodeType === 1) {\r\n        const style = el.style;\r\n        for (const key in vars) {\r\n            style.setProperty(`--${key}`, vars[key]);\r\n        }\r\n    }\r\n}\n\nconst TRANSITION = 'transition';\r\nconst ANIMATION = 'animation';\r\n// DOM Transition is a higher-order-component based on the platform-agnostic\r\n// base Transition component, with DOM-specific logic.\r\nconst Transition = (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);\r\nTransition.displayName = 'Transition';\r\nconst DOMTransitionPropsValidators = {\r\n    name: String,\r\n    type: String,\r\n    css: {\r\n        type: Boolean,\r\n        default: true\r\n    },\r\n    duration: [String, Number, Object],\r\n    enterFromClass: String,\r\n    enterActiveClass: String,\r\n    enterToClass: String,\r\n    appearFromClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    leaveFromClass: String,\r\n    leaveActiveClass: String,\r\n    leaveToClass: String\r\n};\r\nconst TransitionPropsValidators = (Transition.props =\r\n    /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators));\r\n/**\r\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\r\n * with custom HOCs.\r\n */\r\nconst callHook = (hook, args = []) => {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\r\n        hook.forEach(h => h(...args));\r\n    }\r\n    else if (hook) {\r\n        hook(...args);\r\n    }\r\n};\r\n/**\r\n * Check if a hook expects a callback (2nd arg), which means the user\r\n * intends to explicitly control the end of the transition.\r\n */\r\nconst hasExplicitCallback = (hook) => {\r\n    return hook\r\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)\r\n            ? hook.some(h => h.length > 1)\r\n            : hook.length > 1\r\n        : false;\r\n};\r\nfunction resolveTransitionProps(rawProps) {\r\n    const baseProps = {};\r\n    for (const key in rawProps) {\r\n        if (!(key in DOMTransitionPropsValidators)) {\r\n            baseProps[key] = rawProps[key];\r\n        }\r\n    }\r\n    if (rawProps.css === false) {\r\n        return baseProps;\r\n    }\r\n    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\r\n    const durations = normalizeDuration(duration);\r\n    const enterDuration = durations && durations[0];\r\n    const leaveDuration = durations && durations[1];\r\n    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\r\n    const finishEnter = (el, isAppear, done) => {\r\n        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\r\n        done && done();\r\n    };\r\n    const finishLeave = (el, done) => {\r\n        el._isLeaving = false;\r\n        removeTransitionClass(el, leaveFromClass);\r\n        removeTransitionClass(el, leaveToClass);\r\n        removeTransitionClass(el, leaveActiveClass);\r\n        done && done();\r\n    };\r\n    const makeEnterHook = (isAppear) => {\r\n        return (el, done) => {\r\n            const hook = isAppear ? onAppear : onEnter;\r\n            const resolve = () => finishEnter(el, isAppear, done);\r\n            callHook(hook, [el, resolve]);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\r\n                addTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n                if (!hasExplicitCallback(hook)) {\r\n                    whenTransitionEnds(el, type, enterDuration, resolve);\r\n                }\r\n            });\r\n        };\r\n    };\r\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {\r\n        onBeforeEnter(el) {\r\n            callHook(onBeforeEnter, [el]);\r\n            addTransitionClass(el, enterFromClass);\r\n            addTransitionClass(el, enterActiveClass);\r\n        },\r\n        onBeforeAppear(el) {\r\n            callHook(onBeforeAppear, [el]);\r\n            addTransitionClass(el, appearFromClass);\r\n            addTransitionClass(el, appearActiveClass);\r\n        },\r\n        onEnter: makeEnterHook(false),\r\n        onAppear: makeEnterHook(true),\r\n        onLeave(el, done) {\r\n            el._isLeaving = true;\r\n            const resolve = () => finishLeave(el, done);\r\n            addTransitionClass(el, leaveFromClass);\r\n            // force reflow so *-leave-from classes immediately take effect (#2593)\r\n            forceReflow();\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(() => {\r\n                if (!el._isLeaving) {\r\n                    // cancelled\r\n                    return;\r\n                }\r\n                removeTransitionClass(el, leaveFromClass);\r\n                addTransitionClass(el, leaveToClass);\r\n                if (!hasExplicitCallback(onLeave)) {\r\n                    whenTransitionEnds(el, type, leaveDuration, resolve);\r\n                }\r\n            });\r\n            callHook(onLeave, [el, resolve]);\r\n        },\r\n        onEnterCancelled(el) {\r\n            finishEnter(el, false);\r\n            callHook(onEnterCancelled, [el]);\r\n        },\r\n        onAppearCancelled(el) {\r\n            finishEnter(el, true);\r\n            callHook(onAppearCancelled, [el]);\r\n        },\r\n        onLeaveCancelled(el) {\r\n            finishLeave(el);\r\n            callHook(onLeaveCancelled, [el]);\r\n        }\r\n    });\r\n}\r\nfunction normalizeDuration(duration) {\r\n    if (duration == null) {\r\n        return null;\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {\r\n        return [NumberOf(duration.enter), NumberOf(duration.leave)];\r\n    }\r\n    else {\r\n        const n = NumberOf(duration);\r\n        return [n, n];\r\n    }\r\n}\r\nfunction NumberOf(val) {\r\n    const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);\r\n    if ((true))\r\n        validateDuration(res);\r\n    return res;\r\n}\r\nfunction validateDuration(val) {\r\n    if (typeof val !== 'number') {\r\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is not a valid number - ` +\r\n            `got ${JSON.stringify(val)}.`);\r\n    }\r\n    else if (isNaN(val)) {\r\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is NaN - ` +\r\n            'the duration expression might be incorrect.');\r\n    }\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\r\n    (el._vtc ||\r\n        (el._vtc = new Set())).add(cls);\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\r\n    const { _vtc } = el;\r\n    if (_vtc) {\r\n        _vtc.delete(cls);\r\n        if (!_vtc.size) {\r\n            el._vtc = undefined;\r\n        }\r\n    }\r\n}\r\nfunction nextFrame(cb) {\r\n    requestAnimationFrame(() => {\r\n        requestAnimationFrame(cb);\r\n    });\r\n}\r\nlet endId = 0;\r\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\r\n    const id = (el._endId = ++endId);\r\n    const resolveIfNotStale = () => {\r\n        if (id === el._endId) {\r\n            resolve();\r\n        }\r\n    };\r\n    if (explicitTimeout) {\r\n        return setTimeout(resolveIfNotStale, explicitTimeout);\r\n    }\r\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\r\n    if (!type) {\r\n        return resolve();\r\n    }\r\n    const endEvent = type + 'end';\r\n    let ended = 0;\r\n    const end = () => {\r\n        el.removeEventListener(endEvent, onEnd);\r\n        resolveIfNotStale();\r\n    };\r\n    const onEnd = (e) => {\r\n        if (e.target === el && ++ended >= propCount) {\r\n            end();\r\n        }\r\n    };\r\n    setTimeout(() => {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(endEvent, onEnd);\r\n}\r\nfunction getTransitionInfo(el, expectedType) {\r\n    const styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    const getStyleProperties = (key) => (styles[key] || '').split(', ');\r\n    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');\r\n    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');\r\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    const animationDelays = getStyleProperties(ANIMATION + 'Delay');\r\n    const animationDurations = getStyleProperties(ANIMATION + 'Duration');\r\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    let type = null;\r\n    let timeout = 0;\r\n    let propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    const hasTransform = type === TRANSITION &&\r\n        /\\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);\r\n    return {\r\n        type,\r\n        timeout,\r\n        propCount,\r\n        hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\r\n// numbers in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down\r\n// (i.e. acting as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\r\n}\r\n// synchronously force layout to put elements into a certain state\r\nfunction forceReflow() {\r\n    return document.body.offsetHeight;\r\n}\n\nconst positionMap = new WeakMap();\r\nconst newPositionMap = new WeakMap();\r\nconst TransitionGroupImpl = {\r\n    name: 'TransitionGroup',\r\n    props: /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {\r\n        tag: String,\r\n        moveClass: String\r\n    }),\r\n    setup(props, { slots }) {\r\n        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\r\n        const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();\r\n        let prevChildren;\r\n        let children;\r\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {\r\n            // children is guaranteed to exist after initial render\r\n            if (!prevChildren.length) {\r\n                return;\r\n            }\r\n            const moveClass = props.moveClass || `${props.name || 'v'}-move`;\r\n            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\r\n                return;\r\n            }\r\n            // we divide the work into three loops to avoid mixing DOM reads and writes\r\n            // in each iteration - which helps prevent layout thrashing.\r\n            prevChildren.forEach(callPendingCbs);\r\n            prevChildren.forEach(recordPosition);\r\n            const movedChildren = prevChildren.filter(applyTranslation);\r\n            // force reflow to put everything in position\r\n            forceReflow();\r\n            movedChildren.forEach(c => {\r\n                const el = c.el;\r\n                const style = el.style;\r\n                addTransitionClass(el, moveClass);\r\n                style.transform = style.webkitTransform = style.transitionDuration = '';\r\n                const cb = (el._moveCb = (e) => {\r\n                    if (e && e.target !== el) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el.removeEventListener('transitionend', cb);\r\n                        el._moveCb = null;\r\n                        removeTransitionClass(el, moveClass);\r\n                    }\r\n                });\r\n                el.addEventListener('transitionend', cb);\r\n            });\r\n        });\r\n        return () => {\r\n            const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);\r\n            const cssTransitionProps = resolveTransitionProps(rawProps);\r\n            let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;\r\n            prevChildren = children;\r\n            children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (child.key != null) {\r\n                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));\r\n                }\r\n                else if ((true)) {\r\n                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);\r\n                }\r\n            }\r\n            if (prevChildren) {\r\n                for (let i = 0; i < prevChildren.length; i++) {\r\n                    const child = prevChildren[i];\r\n                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));\r\n                    positionMap.set(child, child.el.getBoundingClientRect());\r\n                }\r\n            }\r\n            return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);\r\n        };\r\n    }\r\n};\r\nconst TransitionGroup = TransitionGroupImpl;\r\nfunction callPendingCbs(c) {\r\n    const el = c.el;\r\n    if (el._moveCb) {\r\n        el._moveCb();\r\n    }\r\n    if (el._enterCb) {\r\n        el._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    newPositionMap.set(c, c.el.getBoundingClientRect());\r\n}\r\nfunction applyTranslation(c) {\r\n    const oldPos = positionMap.get(c);\r\n    const newPos = newPositionMap.get(c);\r\n    const dx = oldPos.left - newPos.left;\r\n    const dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        const s = c.el.style;\r\n        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\r\n        s.transitionDuration = '0s';\r\n        return c;\r\n    }\r\n}\r\nfunction hasCSSTransform(el, root, moveClass) {\r\n    // Detect whether an element with the move class applied has\r\n    // CSS transitions. Since the element may be inside an entering\r\n    // transition at this very moment, we make a clone of it and remove\r\n    // all other transition classes applied to ensure only the move class\r\n    // is applied.\r\n    const clone = el.cloneNode();\r\n    if (el._vtc) {\r\n        el._vtc.forEach(cls => {\r\n            cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\r\n        });\r\n    }\r\n    moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\r\n    clone.style.display = 'none';\r\n    const container = (root.nodeType === 1 ? root : root.parentNode);\r\n    container.appendChild(clone);\r\n    const { hasTransform } = getTransitionInfo(clone);\r\n    container.removeChild(clone);\r\n    return hasTransform;\r\n}\n\nconst getModelAssigner = (vnode) => {\r\n    const fn = vnode.props['onUpdate:modelValue'] ||\r\n        (false );\r\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;\r\n};\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    const target = e.target;\r\n    if (target.composing) {\r\n        target.composing = false;\r\n        target.dispatchEvent(new Event('input'));\r\n    }\r\n}\r\n// We are exporting the v-model runtime directly as vnode hooks so that it can\r\n// be tree-shaken in case v-model is never used.\r\nconst vModelText = {\r\n    created(el, { modifiers: { lazy, trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        const castToNumber = number || (vnode.props && vnode.props.type === 'number');\r\n        addEventListener(el, lazy ? 'change' : 'input', e => {\r\n            if (e.target.composing)\r\n                return;\r\n            let domValue = el.value;\r\n            if (trim) {\r\n                domValue = domValue.trim();\r\n            }\r\n            if (castToNumber) {\r\n                domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);\r\n            }\r\n            el._assign(domValue);\r\n        });\r\n        if (trim) {\r\n            addEventListener(el, 'change', () => {\r\n                el.value = el.value.trim();\r\n            });\r\n        }\r\n        if (!lazy) {\r\n            addEventListener(el, 'compositionstart', onCompositionStart);\r\n            addEventListener(el, 'compositionend', onCompositionEnd);\r\n            // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n            // switching focus before confirming composition choice\r\n            // this also fixes the issue where some browsers e.g. iOS Chrome\r\n            // fires \"change\" instead of \"input\" on autocomplete.\r\n            addEventListener(el, 'change', onCompositionEnd);\r\n        }\r\n    },\r\n    // set value on mounted so it's after min/max for type=\"range\"\r\n    mounted(el, { value }) {\r\n        el.value = value == null ? '' : value;\r\n    },\r\n    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        // avoid clearing unresolved text. #2302\r\n        if (el.composing)\r\n            return;\r\n        if (document.activeElement === el && el.type !== 'range') {\r\n            if (lazy) {\r\n                return;\r\n            }\r\n            if (trim && el.value.trim() === value) {\r\n                return;\r\n            }\r\n            if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {\r\n                return;\r\n            }\r\n        }\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n    }\r\n};\r\nconst vModelCheckbox = {\r\n    // #4096 array checkboxes need to be deep traversed\r\n    deep: true,\r\n    created(el, _, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, 'change', () => {\r\n            const modelValue = el._modelValue;\r\n            const elementValue = getValue(el);\r\n            const checked = el.checked;\r\n            const assign = el._assign;\r\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {\r\n                const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);\r\n                const found = index !== -1;\r\n                if (checked && !found) {\r\n                    assign(modelValue.concat(elementValue));\r\n                }\r\n                else if (!checked && found) {\r\n                    const filtered = [...modelValue];\r\n                    filtered.splice(index, 1);\r\n                    assign(filtered);\r\n                }\r\n            }\r\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {\r\n                const cloned = new Set(modelValue);\r\n                if (checked) {\r\n                    cloned.add(elementValue);\r\n                }\r\n                else {\r\n                    cloned.delete(elementValue);\r\n                }\r\n                assign(cloned);\r\n            }\r\n            else {\r\n                assign(getCheckboxValue(el, checked));\r\n            }\r\n        });\r\n    },\r\n    // set initial checked on mount to wait for true-value/false-value\r\n    mounted: setChecked,\r\n    beforeUpdate(el, binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        setChecked(el, binding, vnode);\r\n    }\r\n};\r\nfunction setChecked(el, { value, oldValue }, vnode) {\r\n    el._modelValue = value;\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\r\n        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;\r\n    }\r\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\r\n        el.checked = value.has(vnode.props.value);\r\n    }\r\n    else if (value !== oldValue) {\r\n        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));\r\n    }\r\n}\r\nconst vModelRadio = {\r\n    created(el, { value }, vnode) {\r\n        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, 'change', () => {\r\n            el._assign(getValue(el));\r\n        });\r\n    },\r\n    beforeUpdate(el, { value, oldValue }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        if (value !== oldValue) {\r\n            el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);\r\n        }\r\n    }\r\n};\r\nconst vModelSelect = {\r\n    // <select multiple> value need to be deep traversed\r\n    deep: true,\r\n    created(el, { value, modifiers: { number } }, vnode) {\r\n        const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);\r\n        addEventListener(el, 'change', () => {\r\n            const selectedVal = Array.prototype.filter\r\n                .call(el.options, (o) => o.selected)\r\n                .map((o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o));\r\n            el._assign(el.multiple\r\n                ? isSetModel\r\n                    ? new Set(selectedVal)\r\n                    : selectedVal\r\n                : selectedVal[0]);\r\n        });\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    // set value in mounted & updated because <select> relies on its children\r\n    // <option>s.\r\n    mounted(el, { value }) {\r\n        setSelected(el, value);\r\n    },\r\n    beforeUpdate(el, _binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    updated(el, { value }) {\r\n        setSelected(el, value);\r\n    }\r\n};\r\nfunction setSelected(el, value) {\r\n    const isMultiple = el.multiple;\r\n    if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\r\n        ( true) &&\r\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` +\r\n                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);\r\n        return;\r\n    }\r\n    for (let i = 0, l = el.options.length; i < l; i++) {\r\n        const option = el.options[i];\r\n        const optionValue = getValue(option);\r\n        if (isMultiple) {\r\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\r\n                option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;\r\n            }\r\n            else {\r\n                option.selected = value.has(optionValue);\r\n            }\r\n        }\r\n        else {\r\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {\r\n                if (el.selectedIndex !== i)\r\n                    el.selectedIndex = i;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple && el.selectedIndex !== -1) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\n// retrieve raw value set via :value bindings\r\nfunction getValue(el) {\r\n    return '_value' in el ? el._value : el.value;\r\n}\r\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\r\nfunction getCheckboxValue(el, checked) {\r\n    const key = checked ? '_trueValue' : '_falseValue';\r\n    return key in el ? el[key] : checked;\r\n}\r\nconst vModelDynamic = {\r\n    created(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, 'created');\r\n    },\r\n    mounted(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, 'mounted');\r\n    },\r\n    beforeUpdate(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');\r\n    },\r\n    updated(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, 'updated');\r\n    }\r\n};\r\nfunction resolveDynamicModel(tagName, type) {\r\n    switch (tagName) {\r\n        case 'SELECT':\r\n            return vModelSelect;\r\n        case 'TEXTAREA':\r\n            return vModelText;\r\n        default:\r\n            switch (type) {\r\n                case 'checkbox':\r\n                    return vModelCheckbox;\r\n                case 'radio':\r\n                    return vModelRadio;\r\n                default:\r\n                    return vModelText;\r\n            }\r\n    }\r\n}\r\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\r\n    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);\r\n    const fn = modelToUse[hook];\r\n    fn && fn(el, binding, vnode, prevVNode);\r\n}\r\n// SSR vnode transforms, only used when user includes client-oriented render\r\n// function in SSR\r\nfunction initVModelForSSR() {\r\n    vModelText.getSSRProps = ({ value }) => ({ value });\r\n    vModelRadio.getSSRProps = ({ value }, vnode) => {\r\n        if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {\r\n            return { checked: true };\r\n        }\r\n    };\r\n    vModelCheckbox.getSSRProps = ({ value }, vnode) => {\r\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\r\n            if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {\r\n                return { checked: true };\r\n            }\r\n        }\r\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\r\n            if (vnode.props && value.has(vnode.props.value)) {\r\n                return { checked: true };\r\n            }\r\n        }\r\n        else if (value) {\r\n            return { checked: true };\r\n        }\r\n    };\r\n    vModelDynamic.getSSRProps = (binding, vnode) => {\r\n        if (typeof vnode.type !== 'string') {\r\n            return;\r\n        }\r\n        const modelToUse = resolveDynamicModel(\r\n        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\r\n        vnode.type.toUpperCase(), vnode.props && vnode.props.type);\r\n        if (modelToUse.getSSRProps) {\r\n            return modelToUse.getSSRProps(binding, vnode);\r\n        }\r\n    };\r\n}\n\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];\r\nconst modifierGuards = {\r\n    stop: e => e.stopPropagation(),\r\n    prevent: e => e.preventDefault(),\r\n    self: e => e.target !== e.currentTarget,\r\n    ctrl: e => !e.ctrlKey,\r\n    shift: e => !e.shiftKey,\r\n    alt: e => !e.altKey,\r\n    meta: e => !e.metaKey,\r\n    left: e => 'button' in e && e.button !== 0,\r\n    middle: e => 'button' in e && e.button !== 1,\r\n    right: e => 'button' in e && e.button !== 2,\r\n    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withModifiers = (fn, modifiers) => {\r\n    return (event, ...args) => {\r\n        for (let i = 0; i < modifiers.length; i++) {\r\n            const guard = modifierGuards[modifiers[i]];\r\n            if (guard && guard(event, modifiers))\r\n                return;\r\n        }\r\n        return fn(event, ...args);\r\n    };\r\n};\r\n// Kept for 2.x compat.\r\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\r\nconst keyNames = {\r\n    esc: 'escape',\r\n    space: ' ',\r\n    up: 'arrow-up',\r\n    left: 'arrow-left',\r\n    right: 'arrow-right',\r\n    down: 'arrow-down',\r\n    delete: 'backspace'\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withKeys = (fn, modifiers) => {\r\n    return (event) => {\r\n        if (!('key' in event)) {\r\n            return;\r\n        }\r\n        const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);\r\n        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\r\n            return fn(event);\r\n        }\r\n    };\r\n};\n\nconst vShow = {\r\n    beforeMount(el, { value }, { transition }) {\r\n        el._vod = el.style.display === 'none' ? '' : el.style.display;\r\n        if (transition && value) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    mounted(el, { value }, { transition }) {\r\n        if (transition && value) {\r\n            transition.enter(el);\r\n        }\r\n    },\r\n    updated(el, { value, oldValue }, { transition }) {\r\n        if (!value === !oldValue)\r\n            return;\r\n        if (transition) {\r\n            if (value) {\r\n                transition.beforeEnter(el);\r\n                setDisplay(el, true);\r\n                transition.enter(el);\r\n            }\r\n            else {\r\n                transition.leave(el, () => {\r\n                    setDisplay(el, false);\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    beforeUnmount(el, { value }) {\r\n        setDisplay(el, value);\r\n    }\r\n};\r\nfunction setDisplay(el, value) {\r\n    el.style.display = value ? el._vod : 'none';\r\n}\r\n// SSR vnode transforms, only used when user includes client-oriented render\r\n// function in SSR\r\nfunction initVShowForSSR() {\r\n    vShow.getSSRProps = ({ value }) => {\r\n        if (!value) {\r\n            return { style: { display: 'none' } };\r\n        }\r\n    };\r\n}\n\nconst rendererOptions = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp }, nodeOps);\r\n// lazy create the renderer - this makes core renderer logic tree-shakable\r\n// in case the user only imports reactivity utilities from Vue.\r\nlet renderer;\r\nlet enabledHydration = false;\r\nfunction ensureRenderer() {\r\n    return (renderer ||\r\n        (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions)));\r\n}\r\nfunction ensureHydrationRenderer() {\r\n    renderer = enabledHydration\r\n        ? renderer\r\n        : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);\r\n    enabledHydration = true;\r\n    return renderer;\r\n}\r\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\r\nconst render = ((...args) => {\r\n    ensureRenderer().render(...args);\r\n});\r\nconst hydrate = ((...args) => {\r\n    ensureHydrationRenderer().hydrate(...args);\r\n});\r\nconst createApp = ((...args) => {\r\n    const app = ensureRenderer().createApp(...args);\r\n    if ((true)) {\r\n        injectNativeTagCheck(app);\r\n        injectCompilerOptionsCheck(app);\r\n    }\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (!container)\r\n            return;\r\n        const component = app._component;\r\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {\r\n            // __UNSAFE__\r\n            // Reason: potential execution of JS expressions in in-DOM template.\r\n            // The user must make sure the in-DOM template is trusted. If it's\r\n            // rendered by the server, the template should not contain any user data.\r\n            component.template = container.innerHTML;\r\n        }\r\n        // clear content before mounting\r\n        container.innerHTML = '';\r\n        const proxy = mount(container, false, container instanceof SVGElement);\r\n        if (container instanceof Element) {\r\n            container.removeAttribute('v-cloak');\r\n            container.setAttribute('data-v-app', '');\r\n        }\r\n        return proxy;\r\n    };\r\n    return app;\r\n});\r\nconst createSSRApp = ((...args) => {\r\n    const app = ensureHydrationRenderer().createApp(...args);\r\n    if ((true)) {\r\n        injectNativeTagCheck(app);\r\n        injectCompilerOptionsCheck(app);\r\n    }\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (container) {\r\n            return mount(container, true, container instanceof SVGElement);\r\n        }\r\n    };\r\n    return app;\r\n});\r\nfunction injectNativeTagCheck(app) {\r\n    // Inject `isNativeTag`\r\n    // this is used for component name validation (dev only)\r\n    Object.defineProperty(app.config, 'isNativeTag', {\r\n        value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),\r\n        writable: false\r\n    });\r\n}\r\n// dev only\r\nfunction injectCompilerOptionsCheck(app) {\r\n    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {\r\n        const isCustomElement = app.config.isCustomElement;\r\n        Object.defineProperty(app.config, 'isCustomElement', {\r\n            get() {\r\n                return isCustomElement;\r\n            },\r\n            set() {\r\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \\`isCustomElement\\` config option is deprecated. Use ` +\r\n                    `\\`compilerOptions.isCustomElement\\` instead.`);\r\n            }\r\n        });\r\n        const compilerOptions = app.config.compilerOptions;\r\n        const msg = `The \\`compilerOptions\\` config option is only respected when using ` +\r\n            `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` +\r\n            `Since you are using the runtime-only build, \\`compilerOptions\\` ` +\r\n            `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` +\r\n            `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` +\r\n            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` +\r\n            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;\r\n        Object.defineProperty(app.config, 'compilerOptions', {\r\n            get() {\r\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);\r\n                return compilerOptions;\r\n            },\r\n            set() {\r\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction normalizeContainer(container) {\r\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {\r\n        const res = document.querySelector(container);\r\n        if (( true) && !res) {\r\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector \"${container}\" returned null.`);\r\n        }\r\n        return res;\r\n    }\r\n    if (( true) &&\r\n        window.ShadowRoot &&\r\n        container instanceof window.ShadowRoot &&\r\n        container.mode === 'closed') {\r\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`);\r\n    }\r\n    return container;\r\n}\r\nlet ssrDirectiveInitialized = false;\r\n/**\r\n * @internal\r\n */\r\nconst initDirectivesForSSR = () => {\r\n        if (!ssrDirectiveInitialized) {\r\n            ssrDirectiveInitialized = true;\r\n            initVModelForSSR();\r\n            initVShowForSSR();\r\n        }\r\n    }\r\n    ;\n\n\n\n\n//# sourceURL=webpack://web-dashboard/./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_ARR\": function() { return /* binding */ EMPTY_ARR; },\n/* harmony export */   \"EMPTY_OBJ\": function() { return /* binding */ EMPTY_OBJ; },\n/* harmony export */   \"NO\": function() { return /* binding */ NO; },\n/* harmony export */   \"NOOP\": function() { return /* binding */ NOOP; },\n/* harmony export */   \"PatchFlagNames\": function() { return /* binding */ PatchFlagNames; },\n/* harmony export */   \"camelize\": function() { return /* binding */ camelize; },\n/* harmony export */   \"capitalize\": function() { return /* binding */ capitalize; },\n/* harmony export */   \"def\": function() { return /* binding */ def; },\n/* harmony export */   \"escapeHtml\": function() { return /* binding */ escapeHtml; },\n/* harmony export */   \"escapeHtmlComment\": function() { return /* binding */ escapeHtmlComment; },\n/* harmony export */   \"extend\": function() { return /* binding */ extend; },\n/* harmony export */   \"genPropsAccessExp\": function() { return /* binding */ genPropsAccessExp; },\n/* harmony export */   \"generateCodeFrame\": function() { return /* binding */ generateCodeFrame; },\n/* harmony export */   \"getGlobalThis\": function() { return /* binding */ getGlobalThis; },\n/* harmony export */   \"hasChanged\": function() { return /* binding */ hasChanged; },\n/* harmony export */   \"hasOwn\": function() { return /* binding */ hasOwn; },\n/* harmony export */   \"hyphenate\": function() { return /* binding */ hyphenate; },\n/* harmony export */   \"includeBooleanAttr\": function() { return /* binding */ includeBooleanAttr; },\n/* harmony export */   \"invokeArrayFns\": function() { return /* binding */ invokeArrayFns; },\n/* harmony export */   \"isArray\": function() { return /* binding */ isArray; },\n/* harmony export */   \"isBooleanAttr\": function() { return /* binding */ isBooleanAttr; },\n/* harmony export */   \"isBuiltInDirective\": function() { return /* binding */ isBuiltInDirective; },\n/* harmony export */   \"isDate\": function() { return /* binding */ isDate; },\n/* harmony export */   \"isFunction\": function() { return /* binding */ isFunction; },\n/* harmony export */   \"isGloballyWhitelisted\": function() { return /* binding */ isGloballyWhitelisted; },\n/* harmony export */   \"isHTMLTag\": function() { return /* binding */ isHTMLTag; },\n/* harmony export */   \"isIntegerKey\": function() { return /* binding */ isIntegerKey; },\n/* harmony export */   \"isKnownHtmlAttr\": function() { return /* binding */ isKnownHtmlAttr; },\n/* harmony export */   \"isKnownSvgAttr\": function() { return /* binding */ isKnownSvgAttr; },\n/* harmony export */   \"isMap\": function() { return /* binding */ isMap; },\n/* harmony export */   \"isModelListener\": function() { return /* binding */ isModelListener; },\n/* harmony export */   \"isNoUnitNumericStyleProp\": function() { return /* binding */ isNoUnitNumericStyleProp; },\n/* harmony export */   \"isObject\": function() { return /* binding */ isObject; },\n/* harmony export */   \"isOn\": function() { return /* binding */ isOn; },\n/* harmony export */   \"isPlainObject\": function() { return /* binding */ isPlainObject; },\n/* harmony export */   \"isPromise\": function() { return /* binding */ isPromise; },\n/* harmony export */   \"isReservedProp\": function() { return /* binding */ isReservedProp; },\n/* harmony export */   \"isSSRSafeAttrName\": function() { return /* binding */ isSSRSafeAttrName; },\n/* harmony export */   \"isSVGTag\": function() { return /* binding */ isSVGTag; },\n/* harmony export */   \"isSet\": function() { return /* binding */ isSet; },\n/* harmony export */   \"isSpecialBooleanAttr\": function() { return /* binding */ isSpecialBooleanAttr; },\n/* harmony export */   \"isString\": function() { return /* binding */ isString; },\n/* harmony export */   \"isSymbol\": function() { return /* binding */ isSymbol; },\n/* harmony export */   \"isVoidTag\": function() { return /* binding */ isVoidTag; },\n/* harmony export */   \"looseEqual\": function() { return /* binding */ looseEqual; },\n/* harmony export */   \"looseIndexOf\": function() { return /* binding */ looseIndexOf; },\n/* harmony export */   \"makeMap\": function() { return /* binding */ makeMap; },\n/* harmony export */   \"normalizeClass\": function() { return /* binding */ normalizeClass; },\n/* harmony export */   \"normalizeProps\": function() { return /* binding */ normalizeProps; },\n/* harmony export */   \"normalizeStyle\": function() { return /* binding */ normalizeStyle; },\n/* harmony export */   \"objectToString\": function() { return /* binding */ objectToString; },\n/* harmony export */   \"parseStringStyle\": function() { return /* binding */ parseStringStyle; },\n/* harmony export */   \"propsToAttrMap\": function() { return /* binding */ propsToAttrMap; },\n/* harmony export */   \"remove\": function() { return /* binding */ remove; },\n/* harmony export */   \"slotFlagsText\": function() { return /* binding */ slotFlagsText; },\n/* harmony export */   \"stringifyStyle\": function() { return /* binding */ stringifyStyle; },\n/* harmony export */   \"toDisplayString\": function() { return /* binding */ toDisplayString; },\n/* harmony export */   \"toHandlerKey\": function() { return /* binding */ toHandlerKey; },\n/* harmony export */   \"toNumber\": function() { return /* binding */ toNumber; },\n/* harmony export */   \"toRawType\": function() { return /* binding */ toRawType; },\n/* harmony export */   \"toTypeString\": function() { return /* binding */ toTypeString; }\n/* harmony export */ });\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    // Split the content into individual lines but capture the newline sequence\r\n    // that separated each line. This is important because the actual sequence is\r\n    // needed to properly take into account the full line length for offset\r\n    // comparison\r\n    let lines = source.split(/(\\r?\\n)/);\r\n    // Separate the lines and newline sequences into separate arrays for easier referencing\r\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\r\n    lines = lines.filter((_, idx) => idx % 2 === 0);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count +=\r\n            lines[i].length +\r\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - (lineLength + newLineSeqLength));\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + newLineSeqLength;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\n/**\r\n * Boolean attributes should be included if the value is truthy or ''.\r\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\r\n */\r\nfunction includeBooleanAttr(value) {\r\n    return !!value || value === '';\r\n}\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\r\n/**\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\r\n */\r\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\r\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\r\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\r\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\r\n    `color-interpolation-filters,color-profile,color-rendering,` +\r\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\r\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\r\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\r\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\r\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\r\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\r\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\r\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\r\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\r\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\r\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\r\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\r\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\r\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\r\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\r\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\r\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\r\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\r\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\r\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\r\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\r\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\r\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\r\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\r\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\r\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\r\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\r\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\r\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\r\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\r\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\r\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\r\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = isString(item)\r\n                ? parseStringStyle(item)\r\n                : normalizeStyle(item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isString(value)) {\r\n        return value;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles || isString(styles)) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\r\nfunction normalizeProps(props) {\r\n    if (!props)\r\n        return null;\r\n    let { class: klass, style } = props;\r\n    if (klass && !isString(klass)) {\r\n        props.class = normalizeClass(klass);\r\n    }\r\n    if (style) {\r\n        props.style = normalizeStyle(style);\r\n    }\r\n    return props;\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.slice(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isSymbol(a);\r\n    bValidType = isSymbol(b);\r\n    if (aValidType || bValidType) {\r\n        return a === b;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return isString(val)\r\n        ? val\r\n        : val == null\r\n            ? ''\r\n            : isArray(val) ||\r\n                (isObject(val) &&\r\n                    (val.toString === objectToString || !isFunction(val.toString)))\r\n                ? JSON.stringify(val, replacer, 2)\r\n                : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    // can't use isRef here since @vue/shared has no deps\r\n    if (val && val.__v_isRef) {\r\n        return replacer(_key, val.value);\r\n    }\r\n    else if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\nconst EMPTY_OBJ = ( true)\r\n    ? Object.freeze({})\r\n    : 0;\r\nconst EMPTY_ARR = ( true) ? Object.freeze([]) : 0;\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => toTypeString(val) === '[object Date]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof __webpack_require__.g !== 'undefined'\r\n                            ? __webpack_require__.g\r\n                            : {}));\r\n};\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\r\nfunction genPropsAccessExp(name) {\r\n    return identRE.test(name)\r\n        ? `__props.${name}`\r\n        : `__props[${JSON.stringify(name)}]`;\r\n}\n\n\n\n\n//# sourceURL=webpack://web-dashboard/./node_modules/@vue/shared/dist/shared.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/openlayers3.vue?vue&type=script&lang=js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/openlayers3.vue?vue&type=script&lang=js ***!
  \*****************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

<<<<<<< HEAD
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setup: function setup() {\n    var center = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)([116.54875, 40.45064]);\n    var projection = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)('EPSG:4326');\n    var zoom = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(17);\n    var rotation = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n    var radius = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(40);\n    var strokeWidth = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(10);\n    var strokeColor = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)('red');\n    return {\n      center: center,\n      projection: projection,\n      zoom: zoom,\n      rotation: rotation,\n      radius: radius,\n      strokeWidth: strokeWidth,\n      strokeColor: strokeColor\n    };\n  }\n});\n\n//# sourceURL=webpack://web-dashboard/./src/components/openlayers3.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B4%5D.use%5B0%5D");
=======
eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Vehicle = /*#__PURE__*/_createClass( // Por si una tarea tiene muchos campos, nos ahorramos escribir una por una\nfunction Vehicle(vehicle_type, vehicle_name, description, dimensions, mass, thruster_name, max_thrust, sensors, power_system, processor, comms, software) {\n  _classCallCheck(this, Vehicle);\n\n  this.vehicle_type = vehicle_type, this.vehicle_name = vehicle_name, this.description = description, this.dimensions = dimensions, this.mass = mass, this.thruster_name = thruster_name, this.max_thrust = max_thrust, this.sensors = sensors, this.power_system = power_system, this.processor = processor, this.communications = comms, this.software = software;\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      vehicle: new Vehicle(),\n      vehicles: [],\n      update: false,\n      vehicle_to_update: '',\n      vehicleId: '',\n      show: false,\n      verif: false,\n      show2: true,\n      urlBase: 'http://localhost:3000'\n    };\n  },\n  created: function created() {\n    // This method executes as soon as the application is loaded\n    // this.getTasks();\n    this.getVehicles();\n  },\n  methods: {\n    CallApi: function CallApi(url, method, data) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var header, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                header = data == null ? {\n                  method: method,\n                  headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                  }\n                } : {\n                  method: method,\n                  body: JSON.stringify(data),\n                  headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                  }\n                };\n                _context.prev = 1;\n                _context.next = 4;\n                return fetch(url, header);\n\n              case 4:\n                response = _context.sent;\n                _context.next = 7;\n                return response.json();\n\n              case 7:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](1);\n                alert('Error. Contact admin. \\n' + _context.t0);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 10]]);\n      }))();\n    },\n    getVehicles: function getVehicles() {\n      var _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _this.CallApi(_this.urlBase + '/api/vehicles/', 'GET', null);\n\n              case 2:\n                _this.vehicles = _context2.sent;\n                console.log(_this.vehicles); // this.vehicleId = '';\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    updateVehicle: function updateVehicle(id) {\n      var _this2 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _this2.CallApi(_this2.urlBase + '/api/vehicles/' + id, 'GET', null);\n\n              case 2:\n                _this2.vehicle = _context3.sent;\n                _this2.update = true;\n                _this2.vehicle_to_update = _this2.vehicle._id;\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n    sendVehicle: function sendVehicle() {\n      var _this3 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!_this3.update) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 3;\n                return _this3.CallApi(_this3.urlBase + '/api/vehicles/' + _this3.vehicle_to_update, 'PUT', _this3.vehicle);\n\n              case 3:\n                _this3.getVehicles();\n\n                _this3.update = false;\n                _context4.next = 13;\n                break;\n\n              case 7:\n                console.log(_this3.vehicle);\n                _context4.next = 10;\n                return _this3.CallApi(_this3.urlBase + '/api/vehicles/', 'POST', _this3.vehicle);\n\n              case 10:\n                res = _context4.sent;\n                console.log(res);\n\n                _this3.getVehicles();\n\n              case 13:\n                _this3.vehicle = new Vehicle();\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n    deleteVehicle: function deleteVehicle(id) {\n      var _this4 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _this4.CallApi(_this4.urlBase + '/api/vehicles/' + id, 'DELETE', null);\n\n              case 2:\n                _this4.getVehicles();\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n    showPass: function showPass() {\n      this.show = true;\n      this.show2 = false;\n    },\n    verify: function verify() {\n      var x = document.getElementById(\"myPsw\").value;\n\n      if (x == 'admin') {\n        this.verif = true;\n        this.show = false;\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://web-dashboard/./src/components/boat_info.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B4%5D.use%5B0%5D");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/car_info.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/car_info.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Vehicle = /*#__PURE__*/_createClass( // Por si una tarea tiene muchos campos, nos ahorramos escribir una por una\nfunction Vehicle(vehicle_type, vehicle_name, description, dimensions, mass, thruster_name, max_thrust, sensors, power_system, processor, comms, software) {\n  _classCallCheck(this, Vehicle);\n\n  this.vehicle_type = vehicle_type, this.vehicle_name = vehicle_name, this.description = description, this.dimensions = dimensions, this.mass = mass, this.thruster_name = thruster_name, this.max_thrust = max_thrust, this.sensors = sensors, this.power_system = power_system, this.processor = processor, this.communications = comms, this.software = software;\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      vehicle: new Vehicle(),\n      vehicles: [],\n      update: false,\n      vehicle_to_update: '',\n      vehicleId: '',\n      show: false,\n      verif: false,\n      show2: true,\n      urlBase: 'http://localhost:3000'\n    };\n  },\n  created: function created() {\n    // This method executes as soon as the application is loaded\n    // this.getTasks();\n    this.getVehicles();\n  },\n  methods: {\n    CallApi: function CallApi(url, method, data) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var header, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                header = data == null ? {\n                  method: method,\n                  headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                  }\n                } : {\n                  method: method,\n                  body: JSON.stringify(data),\n                  headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                  }\n                };\n                _context.prev = 1;\n                _context.next = 4;\n                return fetch(url, header);\n\n              case 4:\n                response = _context.sent;\n                _context.next = 7;\n                return response.json();\n\n              case 7:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](1);\n                alert('Error. Contact admin. \\n' + _context.t0);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 10]]);\n      }))();\n    },\n    getVehicles: function getVehicles() {\n      var _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _this.CallApi(_this.urlBase + '/api/vehicles/', 'GET', null);\n\n              case 2:\n                _this.vehicles = _context2.sent;\n                console.log(_this.vehicles); // this.vehicleId = '';\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    updateVehicle: function updateVehicle(id) {\n      var _this2 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _this2.CallApi(_this2.urlBase + '/api/vehicles/' + id, 'GET', null);\n\n              case 2:\n                _this2.vehicle = _context3.sent;\n                _this2.update = true;\n                _this2.vehicle_to_update = _this2.vehicle._id;\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n    sendVehicle: function sendVehicle() {\n      var _this3 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!_this3.update) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 3;\n                return _this3.CallApi(_this3.urlBase + '/api/vehicles/' + _this3.vehicle_to_update, 'PUT', _this3.vehicle);\n\n              case 3:\n                _this3.getVehicles();\n\n                _this3.update = false;\n                _context4.next = 13;\n                break;\n\n              case 7:\n                console.log(_this3.vehicle);\n                _context4.next = 10;\n                return _this3.CallApi(_this3.urlBase + '/api/vehicles/', 'POST', _this3.vehicle);\n\n              case 10:\n                res = _context4.sent;\n                console.log(res);\n\n                _this3.getVehicles();\n\n              case 13:\n                _this3.vehicle = new Vehicle();\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n    deleteVehicle: function deleteVehicle(id) {\n      var _this4 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _this4.CallApi(_this4.urlBase + '/api/vehicles/' + id, 'DELETE', null);\n\n              case 2:\n                _this4.getVehicles();\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n    showPass: function showPass() {\n      this.show = true;\n      this.show2 = false;\n    },\n    verify: function verify() {\n      var x = document.getElementById(\"myPsw\").value;\n\n      if (x == 'admin') {\n        this.verif = true;\n        this.show = false;\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://web-dashboard/./src/components/car_info.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B4%5D.use%5B0%5D");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/sub_info.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/sub_info.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Vehicle = /*#__PURE__*/_createClass( // Por si una tarea tiene muchos campos, nos ahorramos escribir una por una\nfunction Vehicle(vehicle_type, vehicle_name, description, dimensions, mass, thruster_name, max_thrust, sensors, power_system, processor, comms, software) {\n  _classCallCheck(this, Vehicle);\n\n  this.vehicle_type = vehicle_type, this.vehicle_name = vehicle_name, this.description = description, this.dimensions = dimensions, this.mass = mass, this.thruster_name = thruster_name, this.max_thrust = max_thrust, this.sensors = sensors, this.power_system = power_system, this.processor = processor, this.communications = comms, this.software = software;\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      vehicle: new Vehicle(),\n      vehicles: [],\n      update: false,\n      vehicle_to_update: '',\n      vehicleId: '',\n      show: false,\n      verif: false,\n      show2: true,\n      urlBase: 'http://localhost:3000'\n    };\n  },\n  created: function created() {\n    // This method executes as soon as the application is loaded\n    // this.getTasks();\n    this.getVehicles();\n  },\n  methods: {\n    CallApi: function CallApi(url, method, data) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var header, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                header = data == null ? {\n                  method: method,\n                  headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                  }\n                } : {\n                  method: method,\n                  body: JSON.stringify(data),\n                  headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                  }\n                };\n                _context.prev = 1;\n                _context.next = 4;\n                return fetch(url, header);\n\n              case 4:\n                response = _context.sent;\n                _context.next = 7;\n                return response.json();\n\n              case 7:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](1);\n                alert('Error. Contact admin. \\n' + _context.t0);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 10]]);\n      }))();\n    },\n    getVehicles: function getVehicles() {\n      var _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _this.CallApi(_this.urlBase + '/api/vehicles/', 'GET', null);\n\n              case 2:\n                _this.vehicles = _context2.sent;\n                console.log(_this.vehicles); // this.vehicleId = '';\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    updateVehicle: function updateVehicle(id) {\n      var _this2 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _this2.CallApi(_this2.urlBase + '/api/vehicles/' + id, 'GET', null);\n\n              case 2:\n                _this2.vehicle = _context3.sent;\n                _this2.update = true;\n                _this2.vehicle_to_update = _this2.vehicle._id;\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n    sendVehicle: function sendVehicle() {\n      var _this3 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var res;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!_this3.update) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 3;\n                return _this3.CallApi(_this3.urlBase + '/api/vehicles/' + _this3.vehicle_to_update, 'PUT', _this3.vehicle);\n\n              case 3:\n                _this3.getVehicles();\n\n                _this3.update = false;\n                _context4.next = 13;\n                break;\n\n              case 7:\n                console.log(_this3.vehicle);\n                _context4.next = 10;\n                return _this3.CallApi(_this3.urlBase + '/api/vehicles/', 'POST', _this3.vehicle);\n\n              case 10:\n                res = _context4.sent;\n                console.log(res);\n\n                _this3.getVehicles();\n\n              case 13:\n                _this3.vehicle = new Vehicle();\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n    deleteVehicle: function deleteVehicle(id) {\n      var _this4 = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _this4.CallApi(_this4.urlBase + '/api/vehicles/' + id, 'DELETE', null);\n\n              case 2:\n                _this4.getVehicles();\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n    showPass: function showPass() {\n      this.show = true;\n      this.show2 = false;\n    },\n    verify: function verify() {\n      var x = document.getElementById(\"myPsw\").value;\n\n      if (x == 'admin') {\n        this.verif = true;\n        this.show = false;\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack://web-dashboard/./src/components/sub_info.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B4%5D.use%5B0%5D");
>>>>>>> master

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/openlayers3.vue?vue&type=template&id=23174047":
/*!*********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/openlayers3.vue?vue&type=template&id=23174047 ***!
  \*********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

<<<<<<< HEAD
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_ol_view = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-view\");\n\n  var _component_ol_source_osm = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-source-osm\");\n\n  var _component_ol_tile_layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-tile-layer\");\n\n  var _component_ol_geom_line_string = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-geom-line-string\");\n\n  var _component_ol_style_stroke = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-style-stroke\");\n\n  var _component_ol_style = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-style\");\n\n  var _component_ol_feature = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-feature\");\n\n  var _component_ol_source_vector = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-source-vector\");\n\n  var _component_ol_vector_layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-vector-layer\");\n\n  var _component_ol_map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"ol-map\");\n\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_ol_map, {\n    loadTilesWhileAnimating: true,\n    loadTilesWhileInteracting: true,\n    style: {\n      \"height\": \"400px\"\n    }\n  }, {\n    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {\n      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_view, {\n        ref: \"view\",\n        center: $setup.center,\n        rotation: $setup.rotation,\n        zoom: $setup.zoom,\n        projection: $setup.projection\n      }, null, 8\n      /* PROPS */\n      , [\"center\", \"rotation\", \"zoom\", \"projection\"]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_tile_layer, null, {\n        default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {\n          return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_source_osm)];\n        }),\n        _: 1\n        /* STABLE */\n\n      }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_vector_layer, null, {\n        default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {\n          return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_source_vector, null, {\n            default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {\n              return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_feature, null, {\n                default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {\n                  return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_geom_line_string, {\n                    coordinates: [[116.544921, 40.451633], [116.545264, 40.451649], [116.545865, 40.451698], [116.546144, 40.451551], [116.546337, 40.451274], [116.546788, 40.451143], [116.547324, 40.451078], [116.547539, 40.450996], [116.547839, 40.450719], [116.548440, 40.450506], [116.548933, 40.450604], [116.549448, 40.450604], [116.550242, 40.450376], [116.550865, 40.450163], [116.551702, 40.449935], [116.552581, 40.449576]]\n                  }, null, 8\n                  /* PROPS */\n                  , [\"coordinates\"]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_style, null, {\n                    default: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {\n                      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_ol_style_stroke, {\n                        color: $setup.strokeColor,\n                        width: $setup.strokeWidth\n                      }, null, 8\n                      /* PROPS */\n                      , [\"color\", \"width\"])];\n                    }),\n                    _: 1\n                    /* STABLE */\n\n                  })];\n                }),\n                _: 1\n                /* STABLE */\n\n              })];\n            }),\n            _: 1\n            /* STABLE */\n\n          })];\n        }),\n        _: 1\n        /* STABLE */\n\n      })];\n    }),\n    _: 1\n    /* STABLE */\n\n  });\n}\n\n//# sourceURL=webpack://web-dashboard/./src/components/openlayers3.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet%5B1%5D.rules%5B2%5D!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B4%5D.use%5B0%5D");
=======
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n\nvar _hoisted_1 = {\n  class: \"container\"\n};\nvar _hoisted_2 = {\n  class: \"row pt-5\"\n};\nvar _hoisted_3 = {\n  class: \"col-md-4\"\n};\nvar _hoisted_4 = {\n  key: 0,\n  class: \"card\"\n};\nvar _hoisted_5 = {\n  class: \"card-body\"\n};\n\nvar _hoisted_6 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"p\", null, \"Add new vehicle\", -1\n/* HOISTED */\n);\n\nvar _hoisted_7 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", {\n  disabled: \"\",\n  value: \"\"\n}, \"Please select one\", -1\n/* HOISTED */\n);\n\nvar _hoisted_8 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"boat\", -1\n/* HOISTED */\n);\n\nvar _hoisted_9 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"submarine\", -1\n/* HOISTED */\n);\n\nvar _hoisted_10 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"car\", -1\n/* HOISTED */\n);\n\nvar _hoisted_11 = [_hoisted_7, _hoisted_8, _hoisted_9, _hoisted_10];\nvar _hoisted_12 = {\n  class: \"card-body\"\n};\nvar _hoisted_13 = {\n  class: \"card-body\"\n};\nvar _hoisted_14 = {\n  class: \"card-body\"\n};\nvar _hoisted_15 = {\n  class: \"card-body\"\n};\nvar _hoisted_16 = {\n  class: \"card-body\"\n};\nvar _hoisted_17 = {\n  class: \"card-body\"\n};\nvar _hoisted_18 = {\n  class: \"card-body\"\n};\nvar _hoisted_19 = {\n  class: \"card-body\"\n};\nvar _hoisted_20 = {\n  class: \"card-body\"\n};\nvar _hoisted_21 = {\n  class: \"card-body\"\n};\nvar _hoisted_22 = {\n  class: \"card-body\"\n};\nvar _hoisted_23 = {\n  key: 0,\n  class: \"btn btn-primary\"\n};\nvar _hoisted_24 = {\n  key: 1,\n  class: \"btn btn-primary\"\n};\n\nvar _hoisted_25 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", {\n  class: \"form-group\"\n}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"textarea\", {\n  cols: \"30\",\n  rows: \"10\",\n  class: \"form-control\",\n  placeholder: \"Insert a description\"\n})], -1\n/* HOISTED */\n);\n\nvar _hoisted_26 = {\n  class: \"col-md-8\"\n};\nvar _hoisted_27 = {\n  class: \"table table-bordered\"\n};\n\nvar _hoisted_28 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"thead\", null, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"type\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"name\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"description\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"dimensions\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"mass\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"thruster\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"max_thrust\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"sensors\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"power_system\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"processor\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"comms\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"software\")], -1\n/* HOISTED */\n);\n\nvar _hoisted_29 = {\n  key: 0\n};\nvar _hoisted_30 = {\n  key: 1\n};\nvar _hoisted_31 = {\n  key: 2\n};\nvar _hoisted_32 = {\n  key: 3\n};\nvar _hoisted_33 = {\n  key: 4\n};\nvar _hoisted_34 = {\n  key: 5\n};\nvar _hoisted_35 = {\n  key: 6\n};\nvar _hoisted_36 = {\n  key: 7\n};\nvar _hoisted_37 = {\n  key: 8\n};\nvar _hoisted_38 = {\n  key: 9\n};\nvar _hoisted_39 = {\n  key: 10\n};\nvar _hoisted_40 = {\n  key: 11\n};\nvar _hoisted_41 = {\n  key: 12\n};\nvar _hoisted_42 = [\"onClick\"];\nvar _hoisted_43 = [\"onClick\"];\nvar _hoisted_44 = {\n  key: 1,\n  for: \"Pass\"\n};\nvar _hoisted_45 = {\n  key: 2,\n  type: \"password\",\n  id: \"myPsw\",\n  value: \"admin\",\n  size: \"20\"\n};\n\nvar _hoisted_46 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"br\", null, null, -1\n/* HOISTED */\n);\n\nvar _hoisted_47 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"p\", {\n  id: \"demo\"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_3, [$data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"form\", {\n    onSubmit: _cache[12] || (_cache[12] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)(function () {\n      return $options.sendVehicle && $options.sendVehicle.apply($options, arguments);\n    }, [\"prevent\"]))\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_5, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [_hoisted_6, (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"select\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = function ($event) {\n      return $data.vehicle.vehicle_type = $event;\n    })\n  }, _hoisted_11, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelSelect, $data.vehicle.vehicle_type]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_12, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[1] || (_cache[1] = function ($event) {\n      return $data.vehicle.vehicle_name = $event;\n    }),\n    placeholder: \"Insert vehicle name\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.vehicle_name]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_13, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[2] || (_cache[2] = function ($event) {\n      return $data.vehicle.description = $event;\n    }),\n    placeholder: \"Insert vehicle description\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.description]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_14, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[3] || (_cache[3] = function ($event) {\n      return $data.vehicle.dimensions = $event;\n    }),\n    placeholder: \"Insert vehicle dimensions\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.dimensions]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_15, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[4] || (_cache[4] = function ($event) {\n      return $data.vehicle.mass = $event;\n    }),\n    placeholder: \"Insert vehicle mass\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.mass]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_16, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[5] || (_cache[5] = function ($event) {\n      return $data.vehicle.thruster_name = $event;\n    }),\n    placeholder: \"Insert thruster brand\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.thruster_name]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_17, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[6] || (_cache[6] = function ($event) {\n      return $data.vehicle.max_thrust = $event;\n    }),\n    placeholder: \"Insert maximum thrust\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.max_thrust]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_18, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[7] || (_cache[7] = function ($event) {\n      return $data.vehicle.sensors = $event;\n    }),\n    placeholder: \"Insert sensors\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.sensors]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_19, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[8] || (_cache[8] = function ($event) {\n      return $data.vehicle.power_system = $event;\n    }),\n    placeholder: \"Insert Power System\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.power_system]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_20, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[9] || (_cache[9] = function ($event) {\n      return $data.vehicle.processor = $event;\n    }),\n    placeholder: \"Insert Processor\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.processor]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_21, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[10] || (_cache[10] = function ($event) {\n      return $data.vehicle.communications = $event;\n    }),\n    placeholder: \"Insert Comms\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.communications]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_22, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[11] || (_cache[11] = function ($event) {\n      return $data.vehicle.software = $event;\n    }),\n    placeholder: \"Insert Software\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.software]])])]), $data.update == false ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", _hoisted_23, \"Send\")) : ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", _hoisted_24, \"Update\")), _hoisted_25], 32\n  /* HYDRATE_EVENTS */\n  )])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_26, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"table\", _hoisted_27, [_hoisted_28, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"tbody\", null, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)($data.vehicles, function (vehicle) {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"tr\", {\n      key: vehicle._id\n    }, [vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_29, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.vehicle_type), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_30, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.vehicle_name), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_31, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.description), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_32, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.dimensions), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_33, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.mass), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_34, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.thruster_name), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_35, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.max_thrust), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_36, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.sensors), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_37, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.power_system), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_38, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.processor), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_39, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.communications), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_40, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.software), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'boat' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_41, [$data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n      key: 0,\n      onClick: function onClick($event) {\n        return $options.deleteVehicle(vehicle._id);\n      },\n      class: \"btn btn-danger\"\n    }, \" Delete \", 8\n    /* PROPS */\n    , _hoisted_42)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n      key: 1,\n      onClick: function onClick($event) {\n        return $options.updateVehicle(vehicle._id);\n      },\n      class: \"btn btn-secondary\"\n    }, \" Update \", 8\n    /* PROPS */\n    , _hoisted_43)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)]);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))])]), $data.show2 ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n    key: 0,\n    onClick: _cache[13] || (_cache[13] = function () {\n      return $options.showPass && $options.showPass.apply($options, arguments);\n    }),\n    type: \"button\",\n    class: \"btn btn-primary\"\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($data.show ? 'Editar' : 'Editar'), 1\n  /* TEXT */\n  )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"label\", _hoisted_44, \"Password:\")) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"input\", _hoisted_45)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), _hoisted_46, $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n    key: 3,\n    onClick: _cache[14] || (_cache[14] = function () {\n      return $options.verify && $options.verify.apply($options, arguments);\n    }),\n    type: \"button\",\n    class: \"btn btn-primary\"\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.verify ? 'Login' : 'Login'), 1\n  /* TEXT */\n  )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), _hoisted_47])])]);\n}\n\n//# sourceURL=webpack://web-dashboard/./src/components/boat_info.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet%5B1%5D.rules%5B2%5D!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B4%5D.use%5B0%5D");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/car_info.vue?vue&type=template&id=5b1469c9":
/*!******************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/car_info.vue?vue&type=template&id=5b1469c9 ***!
  \******************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n\nvar _hoisted_1 = {\n  class: \"container\"\n};\nvar _hoisted_2 = {\n  class: \"row pt-5\"\n};\nvar _hoisted_3 = {\n  class: \"col-md-4\"\n};\nvar _hoisted_4 = {\n  key: 0,\n  class: \"card\"\n};\nvar _hoisted_5 = {\n  class: \"card-body\"\n};\n\nvar _hoisted_6 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"p\", null, \"Add new vehicle\", -1\n/* HOISTED */\n);\n\nvar _hoisted_7 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", {\n  disabled: \"\",\n  value: \"\"\n}, \"Please select one\", -1\n/* HOISTED */\n);\n\nvar _hoisted_8 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"boat\", -1\n/* HOISTED */\n);\n\nvar _hoisted_9 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"submarine\", -1\n/* HOISTED */\n);\n\nvar _hoisted_10 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"car\", -1\n/* HOISTED */\n);\n\nvar _hoisted_11 = [_hoisted_7, _hoisted_8, _hoisted_9, _hoisted_10];\nvar _hoisted_12 = {\n  class: \"card-body\"\n};\nvar _hoisted_13 = {\n  class: \"card-body\"\n};\nvar _hoisted_14 = {\n  class: \"card-body\"\n};\nvar _hoisted_15 = {\n  class: \"card-body\"\n};\nvar _hoisted_16 = {\n  class: \"card-body\"\n};\nvar _hoisted_17 = {\n  class: \"card-body\"\n};\nvar _hoisted_18 = {\n  class: \"card-body\"\n};\nvar _hoisted_19 = {\n  class: \"card-body\"\n};\nvar _hoisted_20 = {\n  class: \"card-body\"\n};\nvar _hoisted_21 = {\n  class: \"card-body\"\n};\nvar _hoisted_22 = {\n  class: \"card-body\"\n};\nvar _hoisted_23 = {\n  key: 0,\n  class: \"btn btn-primary\"\n};\nvar _hoisted_24 = {\n  key: 1,\n  class: \"btn btn-primary\"\n};\n\nvar _hoisted_25 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", {\n  class: \"form-group\"\n}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"textarea\", {\n  cols: \"30\",\n  rows: \"10\",\n  class: \"form-control\",\n  placeholder: \"Insert a description\"\n})], -1\n/* HOISTED */\n);\n\nvar _hoisted_26 = {\n  class: \"col-md-8\"\n};\nvar _hoisted_27 = {\n  class: \"table table-bordered\"\n};\n\nvar _hoisted_28 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"thead\", null, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"type\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"name\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"description\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"dimensions\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"mass\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"thruster\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"max_thrust\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"sensors\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"power_system\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"processor\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"comms\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"software\")], -1\n/* HOISTED */\n);\n\nvar _hoisted_29 = {\n  key: 0\n};\nvar _hoisted_30 = {\n  key: 1\n};\nvar _hoisted_31 = {\n  key: 2\n};\nvar _hoisted_32 = {\n  key: 3\n};\nvar _hoisted_33 = {\n  key: 4\n};\nvar _hoisted_34 = {\n  key: 5\n};\nvar _hoisted_35 = {\n  key: 6\n};\nvar _hoisted_36 = {\n  key: 7\n};\nvar _hoisted_37 = {\n  key: 8\n};\nvar _hoisted_38 = {\n  key: 9\n};\nvar _hoisted_39 = {\n  key: 10\n};\nvar _hoisted_40 = {\n  key: 11\n};\nvar _hoisted_41 = {\n  key: 12\n};\nvar _hoisted_42 = [\"onClick\"];\nvar _hoisted_43 = [\"onClick\"];\nvar _hoisted_44 = {\n  key: 1,\n  for: \"Pass\"\n};\nvar _hoisted_45 = {\n  key: 2,\n  type: \"password\",\n  id: \"myPsw\",\n  value: \"mypwd345\",\n  size: \"20\"\n};\n\nvar _hoisted_46 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"br\", null, null, -1\n/* HOISTED */\n);\n\nvar _hoisted_47 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"p\", {\n  id: \"demo\"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_3, [$data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"form\", {\n    onSubmit: _cache[12] || (_cache[12] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)(function () {\n      return $options.sendVehicle && $options.sendVehicle.apply($options, arguments);\n    }, [\"prevent\"]))\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_5, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [_hoisted_6, (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"select\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = function ($event) {\n      return $data.vehicle.vehicle_type = $event;\n    })\n  }, _hoisted_11, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelSelect, $data.vehicle.vehicle_type]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_12, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[1] || (_cache[1] = function ($event) {\n      return $data.vehicle.vehicle_name = $event;\n    }),\n    placeholder: \"Insert vehicle name\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.vehicle_name]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_13, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[2] || (_cache[2] = function ($event) {\n      return $data.vehicle.description = $event;\n    }),\n    placeholder: \"Insert vehicle description\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.description]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_14, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[3] || (_cache[3] = function ($event) {\n      return $data.vehicle.dimensions = $event;\n    }),\n    placeholder: \"Insert vehicle dimensions\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.dimensions]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_15, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[4] || (_cache[4] = function ($event) {\n      return $data.vehicle.mass = $event;\n    }),\n    placeholder: \"Insert vehicle mass\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.mass]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_16, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[5] || (_cache[5] = function ($event) {\n      return $data.vehicle.thruster_name = $event;\n    }),\n    placeholder: \"Insert thruster brand\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.thruster_name]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_17, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[6] || (_cache[6] = function ($event) {\n      return $data.vehicle.max_thrust = $event;\n    }),\n    placeholder: \"Insert maximum thrust\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.max_thrust]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_18, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[7] || (_cache[7] = function ($event) {\n      return $data.vehicle.sensors = $event;\n    }),\n    placeholder: \"Insert sensors\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.sensors]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_19, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[8] || (_cache[8] = function ($event) {\n      return $data.vehicle.power_system = $event;\n    }),\n    placeholder: \"Insert Power System\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.power_system]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_20, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[9] || (_cache[9] = function ($event) {\n      return $data.vehicle.processor = $event;\n    }),\n    placeholder: \"Insert Processor\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.processor]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_21, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[10] || (_cache[10] = function ($event) {\n      return $data.vehicle.communications = $event;\n    }),\n    placeholder: \"Insert Comms\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.communications]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_22, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[11] || (_cache[11] = function ($event) {\n      return $data.vehicle.software = $event;\n    }),\n    placeholder: \"Insert Software\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.software]])])]), $data.update == false ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", _hoisted_23, \"Send\")) : ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", _hoisted_24, \"Update\")), _hoisted_25], 32\n  /* HYDRATE_EVENTS */\n  )])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_26, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"table\", _hoisted_27, [_hoisted_28, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"tbody\", null, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)($data.vehicles, function (vehicle) {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"tr\", {\n      key: vehicle._id\n    }, [vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_29, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.vehicle_type), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_30, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.vehicle_name), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_31, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.description), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_32, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.dimensions), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_33, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.mass), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_34, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.thruster_name), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_35, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.max_thrust), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_36, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.sensors), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_37, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.power_system), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_38, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.processor), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_39, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.communications), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_40, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.software), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'car' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_41, [$data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n      key: 0,\n      onClick: function onClick($event) {\n        return $options.deleteVehicle(vehicle._id);\n      },\n      class: \"btn btn-danger\"\n    }, \" Delete \", 8\n    /* PROPS */\n    , _hoisted_42)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n      key: 1,\n      onClick: function onClick($event) {\n        return $options.updateVehicle(vehicle._id);\n      },\n      class: \"btn btn-secondary\"\n    }, \" Update \", 8\n    /* PROPS */\n    , _hoisted_43)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)]);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))])]), $data.show2 ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n    key: 0,\n    onClick: _cache[13] || (_cache[13] = function () {\n      return $options.showPass && $options.showPass.apply($options, arguments);\n    }),\n    type: \"button\",\n    class: \"btn btn-primary\"\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($data.show ? 'Editar' : 'Editar'), 1\n  /* TEXT */\n  )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"label\", _hoisted_44, \"Password:\")) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"input\", _hoisted_45)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), _hoisted_46, $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n    key: 3,\n    onClick: _cache[14] || (_cache[14] = function () {\n      return $options.verify && $options.verify.apply($options, arguments);\n    }),\n    type: \"button\",\n    class: \"btn btn-primary\"\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.verify ? 'Login' : 'Login'), 1\n  /* TEXT */\n  )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), _hoisted_47])])]);\n}\n\n//# sourceURL=webpack://web-dashboard/./src/components/car_info.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet%5B1%5D.rules%5B2%5D!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B4%5D.use%5B0%5D");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/sub_info.vue?vue&type=template&id=3375a4dd":
/*!******************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/sub_info.vue?vue&type=template&id=3375a4dd ***!
  \******************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n\nvar _hoisted_1 = {\n  class: \"container\"\n};\nvar _hoisted_2 = {\n  class: \"row pt-5\"\n};\nvar _hoisted_3 = {\n  class: \"col-md-4\"\n};\nvar _hoisted_4 = {\n  key: 0,\n  class: \"card\"\n};\nvar _hoisted_5 = {\n  class: \"card-body\"\n};\n\nvar _hoisted_6 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"p\", null, \"Add new vehicle\", -1\n/* HOISTED */\n);\n\nvar _hoisted_7 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", {\n  disabled: \"\",\n  value: \"\"\n}, \"Please select one\", -1\n/* HOISTED */\n);\n\nvar _hoisted_8 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"boat\", -1\n/* HOISTED */\n);\n\nvar _hoisted_9 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"submarine\", -1\n/* HOISTED */\n);\n\nvar _hoisted_10 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"option\", null, \"car\", -1\n/* HOISTED */\n);\n\nvar _hoisted_11 = [_hoisted_7, _hoisted_8, _hoisted_9, _hoisted_10];\nvar _hoisted_12 = {\n  class: \"card-body\"\n};\nvar _hoisted_13 = {\n  class: \"card-body\"\n};\nvar _hoisted_14 = {\n  class: \"card-body\"\n};\nvar _hoisted_15 = {\n  class: \"card-body\"\n};\nvar _hoisted_16 = {\n  class: \"card-body\"\n};\nvar _hoisted_17 = {\n  class: \"card-body\"\n};\nvar _hoisted_18 = {\n  class: \"card-body\"\n};\nvar _hoisted_19 = {\n  class: \"card-body\"\n};\nvar _hoisted_20 = {\n  class: \"card-body\"\n};\nvar _hoisted_21 = {\n  class: \"card-body\"\n};\nvar _hoisted_22 = {\n  class: \"card-body\"\n};\nvar _hoisted_23 = {\n  key: 0,\n  class: \"btn btn-primary\"\n};\nvar _hoisted_24 = {\n  key: 1,\n  class: \"btn btn-primary\"\n};\n\nvar _hoisted_25 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", {\n  class: \"form-group\"\n}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"textarea\", {\n  cols: \"30\",\n  rows: \"10\",\n  class: \"form-control\",\n  placeholder: \"Insert a description\"\n})], -1\n/* HOISTED */\n);\n\nvar _hoisted_26 = {\n  class: \"col-md-8\"\n};\nvar _hoisted_27 = {\n  class: \"table table-bordered\"\n};\n\nvar _hoisted_28 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"thead\", null, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"type\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"name\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"description\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"dimensions\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"mass\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"thruster\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"max_thrust\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"sensors\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"power_system\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"processor\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"comms\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"software\")], -1\n/* HOISTED */\n);\n\nvar _hoisted_29 = {\n  key: 0\n};\nvar _hoisted_30 = {\n  key: 1\n};\nvar _hoisted_31 = {\n  key: 2\n};\nvar _hoisted_32 = {\n  key: 3\n};\nvar _hoisted_33 = {\n  key: 4\n};\nvar _hoisted_34 = {\n  key: 5\n};\nvar _hoisted_35 = {\n  key: 6\n};\nvar _hoisted_36 = {\n  key: 7\n};\nvar _hoisted_37 = {\n  key: 8\n};\nvar _hoisted_38 = {\n  key: 9\n};\nvar _hoisted_39 = {\n  key: 10\n};\nvar _hoisted_40 = {\n  key: 11\n};\nvar _hoisted_41 = {\n  key: 12\n};\nvar _hoisted_42 = [\"onClick\"];\nvar _hoisted_43 = [\"onClick\"];\nvar _hoisted_44 = {\n  key: 1,\n  for: \"Pass\"\n};\nvar _hoisted_45 = {\n  key: 2,\n  type: \"password\",\n  id: \"myPsw\",\n  value: \"mypwd345\",\n  size: \"20\"\n};\n\nvar _hoisted_46 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"br\", null, null, -1\n/* HOISTED */\n);\n\nvar _hoisted_47 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"p\", {\n  id: \"demo\"\n}, null, -1\n/* HOISTED */\n);\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_3, [$data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"form\", {\n    onSubmit: _cache[12] || (_cache[12] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)(function () {\n      return $options.sendVehicle && $options.sendVehicle.apply($options, arguments);\n    }, [\"prevent\"]))\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_5, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [_hoisted_6, (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"select\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = function ($event) {\n      return $data.vehicle.vehicle_type = $event;\n    })\n  }, _hoisted_11, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelSelect, $data.vehicle.vehicle_type]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_12, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[1] || (_cache[1] = function ($event) {\n      return $data.vehicle.vehicle_name = $event;\n    }),\n    placeholder: \"Insert vehicle name\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.vehicle_name]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_13, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[2] || (_cache[2] = function ($event) {\n      return $data.vehicle.description = $event;\n    }),\n    placeholder: \"Insert vehicle description\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.description]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_14, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[3] || (_cache[3] = function ($event) {\n      return $data.vehicle.dimensions = $event;\n    }),\n    placeholder: \"Insert vehicle dimensions\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.dimensions]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_15, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[4] || (_cache[4] = function ($event) {\n      return $data.vehicle.mass = $event;\n    }),\n    placeholder: \"Insert vehicle mass\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.mass]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_16, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[5] || (_cache[5] = function ($event) {\n      return $data.vehicle.thruster_name = $event;\n    }),\n    placeholder: \"Insert thruster brand\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.thruster_name]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_17, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[6] || (_cache[6] = function ($event) {\n      return $data.vehicle.max_thrust = $event;\n    }),\n    placeholder: \"Insert maximum thrust\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.max_thrust]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_18, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[7] || (_cache[7] = function ($event) {\n      return $data.vehicle.sensors = $event;\n    }),\n    placeholder: \"Insert sensors\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.sensors]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_19, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[8] || (_cache[8] = function ($event) {\n      return $data.vehicle.power_system = $event;\n    }),\n    placeholder: \"Insert Power System\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.power_system]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_20, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[9] || (_cache[9] = function ($event) {\n      return $data.vehicle.processor = $event;\n    }),\n    placeholder: \"Insert Processor\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.processor]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_21, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[10] || (_cache[10] = function ($event) {\n      return $data.vehicle.communications = $event;\n    }),\n    placeholder: \"Insert Comms\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.communications]])])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_22, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    type: \"text\",\n    \"onUpdate:modelValue\": _cache[11] || (_cache[11] = function ($event) {\n      return $data.vehicle.software = $event;\n    }),\n    placeholder: \"Insert Software\",\n    class: \"form-control\"\n  }, null, 512\n  /* NEED_PATCH */\n  ), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.vehicle.software]])])]), $data.update == false ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", _hoisted_23, \"Send\")) : ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", _hoisted_24, \"Update\")), _hoisted_25], 32\n  /* HYDRATE_EVENTS */\n  )])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_26, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"table\", _hoisted_27, [_hoisted_28, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"tbody\", null, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)($data.vehicles, function (vehicle) {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"tr\", {\n      key: vehicle._id\n    }, [vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_29, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.vehicle_type), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_30, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.vehicle_name), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_31, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.description), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_32, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.dimensions), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_33, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.mass), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_34, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.thruster_name), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_35, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.max_thrust), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_36, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.sensors), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_37, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.power_system), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_38, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.processor), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_39, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.communications), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_40, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(vehicle.software), 1\n    /* TEXT */\n    )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), vehicle.vehicle_type == 'submarine' ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"td\", _hoisted_41, [$data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n      key: 0,\n      onClick: function onClick($event) {\n        return $options.deleteVehicle(vehicle._id);\n      },\n      class: \"btn btn-danger\"\n    }, \" Delete \", 8\n    /* PROPS */\n    , _hoisted_42)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.verif ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n      key: 1,\n      onClick: function onClick($event) {\n        return $options.updateVehicle(vehicle._id);\n      },\n      class: \"btn btn-secondary\"\n    }, \" Update \", 8\n    /* PROPS */\n    , _hoisted_43)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)]);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))])]), $data.show2 ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n    key: 0,\n    onClick: _cache[13] || (_cache[13] = function () {\n      return $options.showPass && $options.showPass.apply($options, arguments);\n    }),\n    type: \"button\",\n    class: \"btn btn-primary\"\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($data.show ? 'Editar' : 'Editar'), 1\n  /* TEXT */\n  )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"label\", _hoisted_44, \"Password:\")) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"input\", _hoisted_45)) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), _hoisted_46, $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"button\", {\n    key: 3,\n    onClick: _cache[14] || (_cache[14] = function () {\n      return $options.verify && $options.verify.apply($options, arguments);\n    }),\n    type: \"button\",\n    class: \"btn btn-primary\"\n  }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($options.verify ? 'Login' : 'Login'), 1\n  /* TEXT */\n  )) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), _hoisted_47])])]);\n}\n\n//# sourceURL=webpack://web-dashboard/./src/components/sub_info.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet%5B1%5D.rules%5B2%5D!./node_modules/vue-loader/dist/index.js??ruleSet%5B1%5D.rules%5B4%5D.use%5B0%5D");
>>>>>>> master

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

<<<<<<< HEAD
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var vue3_openlayers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue3-openlayers */ \"./node_modules/vue3-openlayers/dist/vue3-openlayers.es.js\");\n/* harmony import */ var _components_openlayers3_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/openlayers3.vue */ \"./src/components/openlayers3.vue\");\n\n // import 'vue3-openlayers/dist/vue3-openlayers.css'\n// import App from './components/boat_info.vue'\n// createApp(App).mount('#boat');\n// import App from './app/components/map.vue'\n\n // const app = createApp(App);\n// app.use(OpenLayersMap)\n// app.mount('#map')\n// createApp(App).$mount('#app')\n// delete Icon.Default.prototype._getIconUrl;\n// Icon.Default.mergeOptions({\n//   iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n//   iconUrl: require('leaflet/dist/images/marker-icon.png'),\n//   shadowUrl: require('leaflet/dist/images/marker-shadow.png'),\n// });\n\n//# sourceURL=webpack://web-dashboard/./src/main.js?");
=======
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var _components_boat_info_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/boat_info.vue */ \"./src/components/boat_info.vue\");\n/* harmony import */ var _components_sub_info_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/sub_info.vue */ \"./src/components/sub_info.vue\");\n/* harmony import */ var _components_car_info_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/car_info.vue */ \"./src/components/car_info.vue\");\n\n\n(0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(_components_boat_info_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]).mount('#boat');\n\n(0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(_components_sub_info_vue__WEBPACK_IMPORTED_MODULE_2__[\"default\"]).mount('#sub');\n\n(0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(_components_car_info_vue__WEBPACK_IMPORTED_MODULE_3__[\"default\"]).mount('#car');\n\n//# sourceURL=webpack://web-dashboard/./src/main.js?");
>>>>>>> master

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports[\"default\"] = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n\n\n//# sourceURL=webpack://web-dashboard/./node_modules/vue-loader/dist/exportHelper.js?");

/***/ }),

/***/ "./src/components/openlayers3.vue":
/*!****************************************!*\
  !*** ./src/components/openlayers3.vue ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _openlayers3_vue_vue_type_template_id_23174047__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./openlayers3.vue?vue&type=template&id=23174047 */ \"./src/components/openlayers3.vue?vue&type=template&id=23174047\");\n/* harmony import */ var _openlayers3_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./openlayers3.vue?vue&type=script&lang=js */ \"./src/components/openlayers3.vue?vue&type=script&lang=js\");\n/* harmony import */ var _home_saveasmtz_Documents_web_dashboard_src_web_dashboard_client_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ \"./node_modules/vue-loader/dist/exportHelper.js\");\n\n\n\n\n;\nconst __exports__ = /*#__PURE__*/(0,_home_saveasmtz_Documents_web_dashboard_src_web_dashboard_client_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_openlayers3_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], [['render',_openlayers3_vue_vue_type_template_id_23174047__WEBPACK_IMPORTED_MODULE_0__.render],['__file',\"src/components/openlayers3.vue\"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (__exports__);\n\n//# sourceURL=webpack://web-dashboard/./src/components/openlayers3.vue?");

/***/ }),

<<<<<<< HEAD
/***/ "./src/components/openlayers3.vue?vue&type=script&lang=js":
/*!****************************************************************!*\
  !*** ./src/components/openlayers3.vue?vue&type=script&lang=js ***!
  \****************************************************************/
=======
/***/ "./src/components/car_info.vue":
/*!*************************************!*\
  !*** ./src/components/car_info.vue ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _car_info_vue_vue_type_template_id_5b1469c9__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./car_info.vue?vue&type=template&id=5b1469c9 */ \"./src/components/car_info.vue?vue&type=template&id=5b1469c9\");\n/* harmony import */ var _car_info_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./car_info.vue?vue&type=script&lang=js */ \"./src/components/car_info.vue?vue&type=script&lang=js\");\n/* harmony import */ var D_GitHub_ProyectoFInalWeb_web_dashboard_client_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ \"./node_modules/vue-loader/dist/exportHelper.js\");\n\n\n\n\n;\nconst __exports__ = /*#__PURE__*/(0,D_GitHub_ProyectoFInalWeb_web_dashboard_client_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_car_info_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], [['render',_car_info_vue_vue_type_template_id_5b1469c9__WEBPACK_IMPORTED_MODULE_0__.render],['__file',\"src/components/car_info.vue\"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (__exports__);\n\n//# sourceURL=webpack://web-dashboard/./src/components/car_info.vue?");

/***/ }),

/***/ "./src/components/sub_info.vue":
/*!*************************************!*\
  !*** ./src/components/sub_info.vue ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sub_info_vue_vue_type_template_id_3375a4dd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sub_info.vue?vue&type=template&id=3375a4dd */ \"./src/components/sub_info.vue?vue&type=template&id=3375a4dd\");\n/* harmony import */ var _sub_info_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sub_info.vue?vue&type=script&lang=js */ \"./src/components/sub_info.vue?vue&type=script&lang=js\");\n/* harmony import */ var D_GitHub_ProyectoFInalWeb_web_dashboard_client_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ \"./node_modules/vue-loader/dist/exportHelper.js\");\n\n\n\n\n;\nconst __exports__ = /*#__PURE__*/(0,D_GitHub_ProyectoFInalWeb_web_dashboard_client_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_sub_info_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], [['render',_sub_info_vue_vue_type_template_id_3375a4dd__WEBPACK_IMPORTED_MODULE_0__.render],['__file',\"src/components/sub_info.vue\"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (__exports__);\n\n//# sourceURL=webpack://web-dashboard/./src/components/sub_info.vue?");

/***/ }),

/***/ "./src/components/boat_info.vue?vue&type=script&lang=js":
/*!**************************************************************!*\
  !*** ./src/components/boat_info.vue?vue&type=script&lang=js ***!
  \**************************************************************/
>>>>>>> master
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_openlayers3_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_openlayers3_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./openlayers3.vue?vue&type=script&lang=js */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/openlayers3.vue?vue&type=script&lang=js\");\n \n\n//# sourceURL=webpack://web-dashboard/./src/components/openlayers3.vue?");

/***/ }),

<<<<<<< HEAD
/***/ "./src/components/openlayers3.vue?vue&type=template&id=23174047":
/*!**********************************************************************!*\
  !*** ./src/components/openlayers3.vue?vue&type=template&id=23174047 ***!
  \**********************************************************************/
=======
/***/ "./src/components/car_info.vue?vue&type=script&lang=js":
/*!*************************************************************!*\
  !*** ./src/components/car_info.vue?vue&type=script&lang=js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_car_info_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_car_info_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./car_info.vue?vue&type=script&lang=js */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/car_info.vue?vue&type=script&lang=js\");\n \n\n//# sourceURL=webpack://web-dashboard/./src/components/car_info.vue?");

/***/ }),

/***/ "./src/components/sub_info.vue?vue&type=script&lang=js":
/*!*************************************************************!*\
  !*** ./src/components/sub_info.vue?vue&type=script&lang=js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_sub_info_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_sub_info_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./sub_info.vue?vue&type=script&lang=js */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/sub_info.vue?vue&type=script&lang=js\");\n \n\n//# sourceURL=webpack://web-dashboard/./src/components/sub_info.vue?");

/***/ }),

/***/ "./src/components/boat_info.vue?vue&type=template&id=74ba85ed":
/*!********************************************************************!*\
  !*** ./src/components/boat_info.vue?vue&type=template&id=74ba85ed ***!
  \********************************************************************/
>>>>>>> master
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_openlayers3_vue_vue_type_template_id_23174047__WEBPACK_IMPORTED_MODULE_0__.render; }\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_openlayers3_vue_vue_type_template_id_23174047__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./openlayers3.vue?vue&type=template&id=23174047 */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/openlayers3.vue?vue&type=template&id=23174047\");\n\n\n//# sourceURL=webpack://web-dashboard/./src/components/openlayers3.vue?");

/***/ }),

/***/ "./src/components/car_info.vue?vue&type=template&id=5b1469c9":
/*!*******************************************************************!*\
  !*** ./src/components/car_info.vue?vue&type=template&id=5b1469c9 ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_car_info_vue_vue_type_template_id_5b1469c9__WEBPACK_IMPORTED_MODULE_0__.render; }\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_car_info_vue_vue_type_template_id_5b1469c9__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./car_info.vue?vue&type=template&id=5b1469c9 */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/car_info.vue?vue&type=template&id=5b1469c9\");\n\n\n//# sourceURL=webpack://web-dashboard/./src/components/car_info.vue?");

/***/ }),

/***/ "./src/components/sub_info.vue?vue&type=template&id=3375a4dd":
/*!*******************************************************************!*\
  !*** ./src/components/sub_info.vue?vue&type=template&id=3375a4dd ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_sub_info_vue_vue_type_template_id_3375a4dd__WEBPACK_IMPORTED_MODULE_0__.render; }\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_4_use_0_sub_info_vue_vue_type_template_id_3375a4dd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./sub_info.vue?vue&type=template&id=3375a4dd */ \"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[4].use[0]!./src/components/sub_info.vue?vue&type=template&id=3375a4dd\");\n\n\n//# sourceURL=webpack://web-dashboard/./src/components/sub_info.vue?");

/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm-bundler.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm-bundler.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTransition\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition; },\n/* harmony export */   \"Comment\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment; },\n/* harmony export */   \"EffectScope\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },\n/* harmony export */   \"Fragment\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment; },\n/* harmony export */   \"KeepAlive\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive; },\n/* harmony export */   \"ReactiveEffect\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect; },\n/* harmony export */   \"Static\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static; },\n/* harmony export */   \"Suspense\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense; },\n/* harmony export */   \"Teleport\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport; },\n/* harmony export */   \"Text\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text; },\n/* harmony export */   \"Transition\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition; },\n/* harmony export */   \"TransitionGroup\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup; },\n/* harmony export */   \"VueElement\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement; },\n/* harmony export */   \"callWithAsyncErrorHandling\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling; },\n/* harmony export */   \"callWithErrorHandling\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling; },\n/* harmony export */   \"camelize\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize; },\n/* harmony export */   \"capitalize\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize; },\n/* harmony export */   \"cloneVNode\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode; },\n/* harmony export */   \"compatUtils\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils; },\n/* harmony export */   \"compile\": function() { return /* binding */ compile; },\n/* harmony export */   \"computed\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed; },\n/* harmony export */   \"createApp\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp; },\n/* harmony export */   \"createBlock\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock; },\n/* harmony export */   \"createCommentVNode\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode; },\n/* harmony export */   \"createElementBlock\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock; },\n/* harmony export */   \"createElementVNode\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode; },\n/* harmony export */   \"createHydrationRenderer\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer; },\n/* harmony export */   \"createPropsRestProxy\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy; },\n/* harmony export */   \"createRenderer\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer; },\n/* harmony export */   \"createSSRApp\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp; },\n/* harmony export */   \"createSlots\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots; },\n/* harmony export */   \"createStaticVNode\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode; },\n/* harmony export */   \"createTextVNode\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode; },\n/* harmony export */   \"createVNode\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode; },\n/* harmony export */   \"customRef\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef; },\n/* harmony export */   \"defineAsyncComponent\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent; },\n/* harmony export */   \"defineComponent\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent; },\n/* harmony export */   \"defineCustomElement\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement; },\n/* harmony export */   \"defineEmits\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits; },\n/* harmony export */   \"defineExpose\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose; },\n/* harmony export */   \"defineProps\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps; },\n/* harmony export */   \"defineSSRCustomElement\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement; },\n/* harmony export */   \"devtools\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools; },\n/* harmony export */   \"effect\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect; },\n/* harmony export */   \"effectScope\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope; },\n/* harmony export */   \"getCurrentInstance\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance; },\n/* harmony export */   \"getCurrentScope\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },\n/* harmony export */   \"getTransitionRawChildren\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren; },\n/* harmony export */   \"guardReactiveProps\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps; },\n/* harmony export */   \"h\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h; },\n/* harmony export */   \"handleError\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError; },\n/* harmony export */   \"hydrate\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate; },\n/* harmony export */   \"initCustomFormatter\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter; },\n/* harmony export */   \"initDirectivesForSSR\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR; },\n/* harmony export */   \"inject\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject; },\n/* harmony export */   \"isMemoSame\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame; },\n/* harmony export */   \"isProxy\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy; },\n/* harmony export */   \"isReactive\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive; },\n/* harmony export */   \"isReadonly\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },\n/* harmony export */   \"isRef\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef; },\n/* harmony export */   \"isRuntimeOnly\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly; },\n/* harmony export */   \"isShallow\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow; },\n/* harmony export */   \"isVNode\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode; },\n/* harmony export */   \"markRaw\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw; },\n/* harmony export */   \"mergeDefaults\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults; },\n/* harmony export */   \"mergeProps\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps; },\n/* harmony export */   \"nextTick\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick; },\n/* harmony export */   \"normalizeClass\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass; },\n/* harmony export */   \"normalizeProps\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps; },\n/* harmony export */   \"normalizeStyle\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle; },\n/* harmony export */   \"onActivated\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated; },\n/* harmony export */   \"onBeforeMount\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount; },\n/* harmony export */   \"onBeforeUnmount\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount; },\n/* harmony export */   \"onBeforeUpdate\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate; },\n/* harmony export */   \"onDeactivated\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated; },\n/* harmony export */   \"onErrorCaptured\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured; },\n/* harmony export */   \"onMounted\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted; },\n/* harmony export */   \"onRenderTracked\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked; },\n/* harmony export */   \"onRenderTriggered\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered; },\n/* harmony export */   \"onScopeDispose\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },\n/* harmony export */   \"onServerPrefetch\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch; },\n/* harmony export */   \"onUnmounted\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted; },\n/* harmony export */   \"onUpdated\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated; },\n/* harmony export */   \"openBlock\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock; },\n/* harmony export */   \"popScopeId\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId; },\n/* harmony export */   \"provide\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide; },\n/* harmony export */   \"proxyRefs\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },\n/* harmony export */   \"pushScopeId\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId; },\n/* harmony export */   \"queuePostFlushCb\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb; },\n/* harmony export */   \"reactive\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive; },\n/* harmony export */   \"readonly\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly; },\n/* harmony export */   \"ref\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref; },\n/* harmony export */   \"registerRuntimeCompiler\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler; },\n/* harmony export */   \"render\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render; },\n/* harmony export */   \"renderList\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList; },\n/* harmony export */   \"renderSlot\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot; },\n/* harmony export */   \"resolveComponent\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent; },\n/* harmony export */   \"resolveDirective\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective; },\n/* harmony export */   \"resolveDynamicComponent\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent; },\n/* harmony export */   \"resolveFilter\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter; },\n/* harmony export */   \"resolveTransitionHooks\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks; },\n/* harmony export */   \"setBlockTracking\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking; },\n/* harmony export */   \"setDevtoolsHook\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook; },\n/* harmony export */   \"setTransitionHooks\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks; },\n/* harmony export */   \"shallowReactive\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },\n/* harmony export */   \"shallowReadonly\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },\n/* harmony export */   \"shallowRef\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },\n/* harmony export */   \"ssrContextKey\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey; },\n/* harmony export */   \"ssrUtils\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils; },\n/* harmony export */   \"stop\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop; },\n/* harmony export */   \"toDisplayString\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString; },\n/* harmony export */   \"toHandlerKey\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey; },\n/* harmony export */   \"toHandlers\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers; },\n/* harmony export */   \"toRaw\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw; },\n/* harmony export */   \"toRef\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef; },\n/* harmony export */   \"toRefs\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs; },\n/* harmony export */   \"transformVNodeArgs\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs; },\n/* harmony export */   \"triggerRef\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },\n/* harmony export */   \"unref\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref; },\n/* harmony export */   \"useAttrs\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs; },\n/* harmony export */   \"useCssModule\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule; },\n/* harmony export */   \"useCssVars\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars; },\n/* harmony export */   \"useSSRContext\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext; },\n/* harmony export */   \"useSlots\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots; },\n/* harmony export */   \"useTransitionState\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState; },\n/* harmony export */   \"vModelCheckbox\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox; },\n/* harmony export */   \"vModelDynamic\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic; },\n/* harmony export */   \"vModelRadio\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio; },\n/* harmony export */   \"vModelSelect\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect; },\n/* harmony export */   \"vModelText\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText; },\n/* harmony export */   \"vShow\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow; },\n/* harmony export */   \"version\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version; },\n/* harmony export */   \"warn\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn; },\n/* harmony export */   \"watch\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch; },\n/* harmony export */   \"watchEffect\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect; },\n/* harmony export */   \"watchPostEffect\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect; },\n/* harmony export */   \"watchSyncEffect\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect; },\n/* harmony export */   \"withAsyncContext\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext; },\n/* harmony export */   \"withCtx\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx; },\n/* harmony export */   \"withDefaults\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults; },\n/* harmony export */   \"withDirectives\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives; },\n/* harmony export */   \"withKeys\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys; },\n/* harmony export */   \"withMemo\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo; },\n/* harmony export */   \"withModifiers\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers; },\n/* harmony export */   \"withScopeId\": function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId; }\n/* harmony export */ });\n/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ \"./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\");\n\n\n\nfunction initDev() {\r\n    {\r\n        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();\r\n    }\r\n}\n\n// This entry exports the runtime only, and is built as\r\nif ((true)) {\r\n    initDev();\r\n}\r\nconst compile = () => {\r\n    if ((true)) {\r\n        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Runtime compilation is not supported in this build of Vue.` +\r\n            (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\r\n                ) /* should not happen */);\r\n    }\r\n};\n\n\n\n\n//# sourceURL=webpack://web-dashboard/./node_modules/vue/dist/vue.runtime.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/vue3-openlayers/dist/vue3-openlayers.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue3-openlayers/dist/vue3-openlayers.es.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Animations\": function() { return /* binding */ Animations; },\n/* harmony export */   \"Geometries\": function() { return /* binding */ Geometries; },\n/* harmony export */   \"Interactions\": function() { return /* binding */ Interactions; },\n/* harmony export */   \"Layers\": function() { return /* binding */ Layers; },\n/* harmony export */   \"Map\": function() { return /* binding */ Map$1; },\n/* harmony export */   \"MapControls\": function() { return /* binding */ MapControls; },\n/* harmony export */   \"Sources\": function() { return /* binding */ Sources; },\n/* harmony export */   \"Styles\": function() { return /* binding */ Styles; },\n/* harmony export */   \"default\": function() { return /* binding */ install; },\n/* harmony export */   \"install\": function() { return /* binding */ install; }\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b2) => {\n  for (var prop in b2 || (b2 = {}))\n    if (__hasOwnProp.call(b2, prop))\n      __defNormalProp(a2, prop, b2[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b2)) {\n      if (__propIsEnum.call(b2, prop))\n        __defNormalProp(a2, prop, b2[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));\n\nvar Disposable = function() {\n  function Disposable2() {\n    this.disposed = false;\n  }\n  Disposable2.prototype.dispose = function() {\n    if (!this.disposed) {\n      this.disposed = true;\n      this.disposeInternal();\n    }\n  };\n  Disposable2.prototype.disposeInternal = function() {\n  };\n  return Disposable2;\n}();\nvar Disposable$1 = Disposable;\nfunction binarySearch(haystack, needle, opt_comparator) {\n  var mid, cmp;\n  var comparator = opt_comparator || numberSafeCompareFunction;\n  var low = 0;\n  var high = haystack.length;\n  var found = false;\n  while (low < high) {\n    mid = low + (high - low >> 1);\n    cmp = +comparator(haystack[mid], needle);\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n      found = !cmp;\n    }\n  }\n  return found ? low : ~low;\n}\nfunction numberSafeCompareFunction(a2, b2) {\n  return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;\n}\nfunction includes(arr, obj) {\n  return arr.indexOf(obj) >= 0;\n}\nfunction linearFindNearest(arr, target, direction2) {\n  var n2 = arr.length;\n  if (arr[0] <= target) {\n    return 0;\n  } else if (target <= arr[n2 - 1]) {\n    return n2 - 1;\n  } else {\n    var i2 = void 0;\n    if (direction2 > 0) {\n      for (i2 = 1; i2 < n2; ++i2) {\n        if (arr[i2] < target) {\n          return i2 - 1;\n        }\n      }\n    } else if (direction2 < 0) {\n      for (i2 = 1; i2 < n2; ++i2) {\n        if (arr[i2] <= target) {\n          return i2;\n        }\n      }\n    } else {\n      for (i2 = 1; i2 < n2; ++i2) {\n        if (arr[i2] == target) {\n          return i2;\n        } else if (arr[i2] < target) {\n          if (typeof direction2 === \"function\") {\n            if (direction2(target, arr[i2 - 1], arr[i2]) > 0) {\n              return i2 - 1;\n            } else {\n              return i2;\n            }\n          } else if (arr[i2 - 1] - target < target - arr[i2]) {\n            return i2 - 1;\n          } else {\n            return i2;\n          }\n        }\n      }\n    }\n    return n2 - 1;\n  }\n}\nfunction reverseSubArray(arr, begin, end) {\n  while (begin < end) {\n    var tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n}\nfunction extend$3(arr, data2) {\n  var extension = Array.isArray(data2) ? data2 : [data2];\n  var length = extension.length;\n  for (var i2 = 0; i2 < length; i2++) {\n    arr[arr.length] = extension[i2];\n  }\n}\nfunction equals$2(arr1, arr2) {\n  var len1 = arr1.length;\n  if (len1 !== arr2.length) {\n    return false;\n  }\n  for (var i2 = 0; i2 < len1; i2++) {\n    if (arr1[i2] !== arr2[i2]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isSorted(arr, opt_func, opt_strict) {\n  var compare = opt_func || numberSafeCompareFunction;\n  return arr.every(function(currentVal, index2) {\n    if (index2 === 0) {\n      return true;\n    }\n    var res = compare(arr[index2 - 1], currentVal);\n    return !(res > 0 || opt_strict && res === 0);\n  });\n}\nfunction TRUE() {\n  return true;\n}\nfunction FALSE() {\n  return false;\n}\nfunction VOID() {\n}\nfunction memoizeOne(fn) {\n  var called = false;\n  var lastResult;\n  var lastArgs;\n  var lastThis;\n  return function() {\n    var nextArgs = Array.prototype.slice.call(arguments);\n    if (!called || this !== lastThis || !equals$2(nextArgs, lastArgs)) {\n      called = true;\n      lastThis = this;\n      lastArgs = nextArgs;\n      lastResult = fn.apply(this, arguments);\n    }\n    return lastResult;\n  };\n}\nfunction abstract() {\n  return function() {\n    throw new Error(\"Unimplemented abstract method.\");\n  }();\n}\nvar uidCounter_ = 0;\nfunction getUid(obj) {\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\nvar VERSION = \"6.14.1\";\nvar ua = typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\" ? navigator.userAgent.toLowerCase() : \"\";\nvar FIREFOX = ua.indexOf(\"firefox\") !== -1;\nvar SAFARI = ua.indexOf(\"safari\") !== -1 && ua.indexOf(\"chrom\") == -1;\nvar SAFARI_BUG_237906 = SAFARI && !!(ua.indexOf(\"version/15.4\") >= 0 || ua.match(/cpu (os|iphone os) 15_4 like mac os x/));\nvar WEBKIT = ua.indexOf(\"webkit\") !== -1 && ua.indexOf(\"edge\") == -1;\nvar MAC = ua.indexOf(\"macintosh\") !== -1;\nvar DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== \"undefined\" ? devicePixelRatio : 1;\nvar WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== \"undefined\" && typeof OffscreenCanvas !== \"undefined\" && self instanceof WorkerGlobalScope;\nvar IMAGE_DECODE = typeof Image !== \"undefined\" && Image.prototype.decode;\nvar PASSIVE_EVENT_LISTENERS = function() {\n  var passive = false;\n  try {\n    var options = Object.defineProperty({}, \"passive\", {\n      get: function() {\n        passive = true;\n      }\n    });\n    window.addEventListener(\"_\", null, options);\n    window.removeEventListener(\"_\", null, options);\n  } catch (error) {\n  }\n  return passive;\n}();\nvar __extends$2e = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar AssertionError = function(_super) {\n  __extends$2e(AssertionError2, _super);\n  function AssertionError2(code) {\n    var _this = this;\n    var path = \"v\" + VERSION.split(\"-\")[0];\n    var message = \"Assertion failed. See https://openlayers.org/en/\" + path + \"/doc/errors/#\" + code + \" for details.\";\n    _this = _super.call(this, message) || this;\n    _this.code = code;\n    _this.name = \"AssertionError\";\n    _this.message = message;\n    return _this;\n  }\n  return AssertionError2;\n}(Error);\nvar AssertionError$1 = AssertionError;\nfunction assert(assertion, errorCode) {\n  if (!assertion) {\n    throw new AssertionError$1(errorCode);\n  }\n}\nvar tmp_ = new Array(6);\nfunction create$6() {\n  return [1, 0, 0, 1, 0, 0];\n}\nfunction reset(transform2) {\n  return set$2(transform2, 1, 0, 0, 1, 0, 0);\n}\nfunction multiply(transform1, transform2) {\n  var a1 = transform1[0];\n  var b1 = transform1[1];\n  var c1 = transform1[2];\n  var d1 = transform1[3];\n  var e1 = transform1[4];\n  var f1 = transform1[5];\n  var a2 = transform2[0];\n  var b2 = transform2[1];\n  var c2 = transform2[2];\n  var d2 = transform2[3];\n  var e2 = transform2[4];\n  var f2 = transform2[5];\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n  return transform1;\n}\nfunction set$2(transform2, a2, b2, c2, d2, e2, f2) {\n  transform2[0] = a2;\n  transform2[1] = b2;\n  transform2[2] = c2;\n  transform2[3] = d2;\n  transform2[4] = e2;\n  transform2[5] = f2;\n  return transform2;\n}\nfunction setFromArray(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n}\nfunction apply$5(transform2, coordinate) {\n  var x2 = coordinate[0];\n  var y2 = coordinate[1];\n  coordinate[0] = transform2[0] * x2 + transform2[2] * y2 + transform2[4];\n  coordinate[1] = transform2[1] * x2 + transform2[3] * y2 + transform2[5];\n  return coordinate;\n}\nfunction rotate$2(transform2, angle2) {\n  var cos = Math.cos(angle2);\n  var sin = Math.sin(angle2);\n  return multiply(transform2, set$2(tmp_, cos, sin, -sin, cos, 0, 0));\n}\nfunction scale$3(transform2, x2, y2) {\n  return multiply(transform2, set$2(tmp_, x2, 0, 0, y2, 0, 0));\n}\nfunction makeScale(target, x2, y2) {\n  return set$2(target, x2, 0, 0, y2, 0, 0);\n}\nfunction translate$1(transform2, dx, dy) {\n  return multiply(transform2, set$2(tmp_, 1, 0, 0, 1, dx, dy));\n}\nfunction compose(transform2, dx1, dy1, sx, sy, angle2, dx2, dy2) {\n  var sin = Math.sin(angle2);\n  var cos = Math.cos(angle2);\n  transform2[0] = sx * cos;\n  transform2[1] = sy * sin;\n  transform2[2] = -sx * sin;\n  transform2[3] = sy * cos;\n  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform2;\n}\nfunction makeInverse(target, source) {\n  var det = determinant(source);\n  assert(det !== 0, 32);\n  var a2 = source[0];\n  var b2 = source[1];\n  var c2 = source[2];\n  var d2 = source[3];\n  var e2 = source[4];\n  var f2 = source[5];\n  target[0] = d2 / det;\n  target[1] = -b2 / det;\n  target[2] = -c2 / det;\n  target[3] = a2 / det;\n  target[4] = (c2 * f2 - d2 * e2) / det;\n  target[5] = -(a2 * f2 - b2 * e2) / det;\n  return target;\n}\nfunction determinant(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n}\nvar transformStringDiv;\nfunction toString$d(mat) {\n  var transformString = \"matrix(\" + mat.join(\", \") + \")\";\n  if (WORKER_OFFSCREEN_CANVAS) {\n    return transformString;\n  }\n  var node2 = transformStringDiv || (transformStringDiv = document.createElement(\"div\"));\n  node2.style.transform = transformString;\n  return node2.style.transform;\n}\nvar Corner = {\n  BOTTOM_LEFT: \"bottom-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  TOP_LEFT: \"top-left\",\n  TOP_RIGHT: \"top-right\"\n};\nvar Relationship = {\n  UNKNOWN: 0,\n  INTERSECTING: 1,\n  ABOVE: 2,\n  RIGHT: 4,\n  BELOW: 8,\n  LEFT: 16\n};\nfunction boundingExtent(coordinates2) {\n  var extent2 = createEmpty();\n  for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {\n    extendCoordinate(extent2, coordinates2[i2]);\n  }\n  return extent2;\n}\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\n  var minX = Math.min.apply(null, xs);\n  var minY = Math.min.apply(null, ys);\n  var maxX = Math.max.apply(null, xs);\n  var maxY = Math.max.apply(null, ys);\n  return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);\n}\nfunction buffer$1(extent2, value, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent2[0] - value;\n    opt_extent[1] = extent2[1] - value;\n    opt_extent[2] = extent2[2] + value;\n    opt_extent[3] = extent2[3] + value;\n    return opt_extent;\n  } else {\n    return [\n      extent2[0] - value,\n      extent2[1] - value,\n      extent2[2] + value,\n      extent2[3] + value\n    ];\n  }\n}\nfunction clone$1(extent2, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent2[0];\n    opt_extent[1] = extent2[1];\n    opt_extent[2] = extent2[2];\n    opt_extent[3] = extent2[3];\n    return opt_extent;\n  } else {\n    return extent2.slice();\n  }\n}\nfunction closestSquaredDistanceXY(extent2, x2, y2) {\n  var dx, dy;\n  if (x2 < extent2[0]) {\n    dx = extent2[0] - x2;\n  } else if (extent2[2] < x2) {\n    dx = x2 - extent2[2];\n  } else {\n    dx = 0;\n  }\n  if (y2 < extent2[1]) {\n    dy = extent2[1] - y2;\n  } else if (extent2[3] < y2) {\n    dy = y2 - extent2[3];\n  } else {\n    dy = 0;\n  }\n  return dx * dx + dy * dy;\n}\nfunction containsCoordinate(extent2, coordinate) {\n  return containsXY(extent2, coordinate[0], coordinate[1]);\n}\nfunction containsExtent(extent1, extent2) {\n  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\n}\nfunction containsXY(extent2, x2, y2) {\n  return extent2[0] <= x2 && x2 <= extent2[2] && extent2[1] <= y2 && y2 <= extent2[3];\n}\nfunction coordinateRelationship(extent2, coordinate) {\n  var minX = extent2[0];\n  var minY = extent2[1];\n  var maxX = extent2[2];\n  var maxY = extent2[3];\n  var x2 = coordinate[0];\n  var y2 = coordinate[1];\n  var relationship = Relationship.UNKNOWN;\n  if (x2 < minX) {\n    relationship = relationship | Relationship.LEFT;\n  } else if (x2 > maxX) {\n    relationship = relationship | Relationship.RIGHT;\n  }\n  if (y2 < minY) {\n    relationship = relationship | Relationship.BELOW;\n  } else if (y2 > maxY) {\n    relationship = relationship | Relationship.ABOVE;\n  }\n  if (relationship === Relationship.UNKNOWN) {\n    relationship = Relationship.INTERSECTING;\n  }\n  return relationship;\n}\nfunction createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\nfunction createOrUpdate$2(minX, minY, maxX, maxY, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = minX;\n    opt_extent[1] = minY;\n    opt_extent[2] = maxX;\n    opt_extent[3] = maxY;\n    return opt_extent;\n  } else {\n    return [minX, minY, maxX, maxY];\n  }\n}\nfunction createOrUpdateEmpty(opt_extent) {\n  return createOrUpdate$2(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n}\nfunction createOrUpdateFromCoordinate(coordinate, opt_extent) {\n  var x2 = coordinate[0];\n  var y2 = coordinate[1];\n  return createOrUpdate$2(x2, y2, x2, y2, opt_extent);\n}\nfunction createOrUpdateFromCoordinates(coordinates2, opt_extent) {\n  var extent2 = createOrUpdateEmpty(opt_extent);\n  return extendCoordinates(extent2, coordinates2);\n}\nfunction createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, end, stride, opt_extent) {\n  var extent2 = createOrUpdateEmpty(opt_extent);\n  return extendFlatCoordinates(extent2, flatCoordinates, offset2, end, stride);\n}\nfunction createOrUpdateFromRings(rings, opt_extent) {\n  var extent2 = createOrUpdateEmpty(opt_extent);\n  return extendRings(extent2, rings);\n}\nfunction equals$1(extent1, extent2) {\n  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];\n}\nfunction approximatelyEquals(extent1, extent2, tolerance) {\n  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;\n}\nfunction extend$2(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n  return extent1;\n}\nfunction extendCoordinate(extent2, coordinate) {\n  if (coordinate[0] < extent2[0]) {\n    extent2[0] = coordinate[0];\n  }\n  if (coordinate[0] > extent2[2]) {\n    extent2[2] = coordinate[0];\n  }\n  if (coordinate[1] < extent2[1]) {\n    extent2[1] = coordinate[1];\n  }\n  if (coordinate[1] > extent2[3]) {\n    extent2[3] = coordinate[1];\n  }\n}\nfunction extendCoordinates(extent2, coordinates2) {\n  for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {\n    extendCoordinate(extent2, coordinates2[i2]);\n  }\n  return extent2;\n}\nfunction extendFlatCoordinates(extent2, flatCoordinates, offset2, end, stride) {\n  for (; offset2 < end; offset2 += stride) {\n    extendXY(extent2, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);\n  }\n  return extent2;\n}\nfunction extendRings(extent2, rings) {\n  for (var i2 = 0, ii = rings.length; i2 < ii; ++i2) {\n    extendCoordinates(extent2, rings[i2]);\n  }\n  return extent2;\n}\nfunction extendXY(extent2, x2, y2) {\n  extent2[0] = Math.min(extent2[0], x2);\n  extent2[1] = Math.min(extent2[1], y2);\n  extent2[2] = Math.max(extent2[2], x2);\n  extent2[3] = Math.max(extent2[3], y2);\n}\nfunction forEachCorner(extent2, callback) {\n  var val;\n  val = callback(getBottomLeft(extent2));\n  if (val) {\n    return val;\n  }\n  val = callback(getBottomRight(extent2));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopRight(extent2));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopLeft(extent2));\n  if (val) {\n    return val;\n  }\n  return false;\n}\nfunction getArea(extent2) {\n  var area = 0;\n  if (!isEmpty$1(extent2)) {\n    area = getWidth(extent2) * getHeight(extent2);\n  }\n  return area;\n}\nfunction getBottomLeft(extent2) {\n  return [extent2[0], extent2[1]];\n}\nfunction getBottomRight(extent2) {\n  return [extent2[2], extent2[1]];\n}\nfunction getCenter(extent2) {\n  return [(extent2[0] + extent2[2]) / 2, (extent2[1] + extent2[3]) / 2];\n}\nfunction getCorner(extent2, corner) {\n  var coordinate;\n  if (corner === Corner.BOTTOM_LEFT) {\n    coordinate = getBottomLeft(extent2);\n  } else if (corner === Corner.BOTTOM_RIGHT) {\n    coordinate = getBottomRight(extent2);\n  } else if (corner === Corner.TOP_LEFT) {\n    coordinate = getTopLeft(extent2);\n  } else if (corner === Corner.TOP_RIGHT) {\n    coordinate = getTopRight(extent2);\n  } else {\n    assert(false, 13);\n  }\n  return coordinate;\n}\nfunction getEnlargedArea(extent1, extent2) {\n  var minX = Math.min(extent1[0], extent2[0]);\n  var minY = Math.min(extent1[1], extent2[1]);\n  var maxX = Math.max(extent1[2], extent2[2]);\n  var maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\nfunction getForViewAndSize(center, resolution, rotation, size, opt_extent) {\n  var dx = resolution * size[0] / 2;\n  var dy = resolution * size[1] / 2;\n  var cosRotation = Math.cos(rotation);\n  var sinRotation = Math.sin(rotation);\n  var xCos = dx * cosRotation;\n  var xSin = dx * sinRotation;\n  var yCos = dy * cosRotation;\n  var ySin = dy * sinRotation;\n  var x2 = center[0];\n  var y2 = center[1];\n  var x0 = x2 - xCos + ySin;\n  var x1 = x2 - xCos - ySin;\n  var x22 = x2 + xCos - ySin;\n  var x3 = x2 + xCos + ySin;\n  var y0 = y2 - xSin - yCos;\n  var y1 = y2 - xSin + yCos;\n  var y22 = y2 + xSin + yCos;\n  var y3 = y2 + xSin - yCos;\n  return createOrUpdate$2(Math.min(x0, x1, x22, x3), Math.min(y0, y1, y22, y3), Math.max(x0, x1, x22, x3), Math.max(y0, y1, y22, y3), opt_extent);\n}\nfunction getHeight(extent2) {\n  return extent2[3] - extent2[1];\n}\nfunction getIntersectionArea(extent1, extent2) {\n  var intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\nfunction getIntersection(extent1, extent2, opt_extent) {\n  var intersection = opt_extent ? opt_extent : createEmpty();\n  if (intersects$1(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n  return intersection;\n}\nfunction getMargin(extent2) {\n  return getWidth(extent2) + getHeight(extent2);\n}\nfunction getSize(extent2) {\n  return [extent2[2] - extent2[0], extent2[3] - extent2[1]];\n}\nfunction getTopLeft(extent2) {\n  return [extent2[0], extent2[3]];\n}\nfunction getTopRight(extent2) {\n  return [extent2[2], extent2[3]];\n}\nfunction getWidth(extent2) {\n  return extent2[2] - extent2[0];\n}\nfunction intersects$1(extent1, extent2) {\n  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];\n}\nfunction isEmpty$1(extent2) {\n  return extent2[2] < extent2[0] || extent2[3] < extent2[1];\n}\nfunction returnOrUpdate(extent2, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent2[0];\n    opt_extent[1] = extent2[1];\n    opt_extent[2] = extent2[2];\n    opt_extent[3] = extent2[3];\n    return opt_extent;\n  } else {\n    return extent2;\n  }\n}\nfunction scaleFromCenter(extent2, value) {\n  var deltaX = (extent2[2] - extent2[0]) / 2 * (value - 1);\n  var deltaY = (extent2[3] - extent2[1]) / 2 * (value - 1);\n  extent2[0] -= deltaX;\n  extent2[2] += deltaX;\n  extent2[1] -= deltaY;\n  extent2[3] += deltaY;\n}\nfunction intersectsSegment(extent2, start2, end) {\n  var intersects2 = false;\n  var startRel = coordinateRelationship(extent2, start2);\n  var endRel = coordinateRelationship(extent2, end);\n  if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {\n    intersects2 = true;\n  } else {\n    var minX = extent2[0];\n    var minY = extent2[1];\n    var maxX = extent2[2];\n    var maxY = extent2[3];\n    var startX = start2[0];\n    var startY = start2[1];\n    var endX = end[0];\n    var endY = end[1];\n    var slope = (endY - startY) / (endX - startX);\n    var x2 = void 0, y2 = void 0;\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n      x2 = endX - (endY - maxY) / slope;\n      intersects2 = x2 >= minX && x2 <= maxX;\n    }\n    if (!intersects2 && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {\n      y2 = endY - (endX - maxX) * slope;\n      intersects2 = y2 >= minY && y2 <= maxY;\n    }\n    if (!intersects2 && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {\n      x2 = endX - (endY - minY) / slope;\n      intersects2 = x2 >= minX && x2 <= maxX;\n    }\n    if (!intersects2 && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {\n      y2 = endY - (endX - minX) * slope;\n      intersects2 = y2 >= minY && y2 <= maxY;\n    }\n  }\n  return intersects2;\n}\nfunction applyTransform(extent2, transformFn, opt_extent, opt_stops) {\n  var coordinates2 = [];\n  if (opt_stops > 1) {\n    var width = extent2[2] - extent2[0];\n    var height = extent2[3] - extent2[1];\n    for (var i2 = 0; i2 < opt_stops; ++i2) {\n      coordinates2.push(extent2[0] + width * i2 / opt_stops, extent2[1], extent2[2], extent2[1] + height * i2 / opt_stops, extent2[2] - width * i2 / opt_stops, extent2[3], extent2[0], extent2[3] - height * i2 / opt_stops);\n    }\n  } else {\n    coordinates2 = [\n      extent2[0],\n      extent2[1],\n      extent2[2],\n      extent2[1],\n      extent2[2],\n      extent2[3],\n      extent2[0],\n      extent2[3]\n    ];\n  }\n  transformFn(coordinates2, coordinates2, 2);\n  var xs = [];\n  var ys = [];\n  for (var i2 = 0, l2 = coordinates2.length; i2 < l2; i2 += 2) {\n    xs.push(coordinates2[i2]);\n    ys.push(coordinates2[i2 + 1]);\n  }\n  return _boundingExtentXYs(xs, ys, opt_extent);\n}\nfunction wrapX$2(extent2, projection) {\n  var projectionExtent = projection.getExtent();\n  var center = getCenter(extent2);\n  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {\n    var worldWidth = getWidth(projectionExtent);\n    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);\n    var offset2 = worldsAway * worldWidth;\n    extent2[0] -= offset2;\n    extent2[2] -= offset2;\n  }\n  return extent2;\n}\nvar extent = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  boundingExtent,\n  buffer: buffer$1,\n  clone: clone$1,\n  closestSquaredDistanceXY,\n  containsCoordinate,\n  containsExtent,\n  containsXY,\n  coordinateRelationship,\n  createEmpty,\n  createOrUpdate: createOrUpdate$2,\n  createOrUpdateEmpty,\n  createOrUpdateFromCoordinate,\n  createOrUpdateFromCoordinates,\n  createOrUpdateFromFlatCoordinates,\n  createOrUpdateFromRings,\n  equals: equals$1,\n  approximatelyEquals,\n  extend: extend$2,\n  extendCoordinate,\n  extendCoordinates,\n  extendFlatCoordinates,\n  extendRings,\n  extendXY,\n  forEachCorner,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getCenter,\n  getCorner,\n  getEnlargedArea,\n  getForViewAndSize,\n  getHeight,\n  getIntersectionArea,\n  getIntersection,\n  getMargin,\n  getSize,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects: intersects$1,\n  isEmpty: isEmpty$1,\n  returnOrUpdate,\n  scaleFromCenter,\n  intersectsSegment,\n  applyTransform,\n  wrapX: wrapX$2\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction clamp(value, min2, max2) {\n  return Math.min(Math.max(value, min2), max2);\n}\nvar cosh$1 = function() {\n  var cosh2;\n  if (\"cosh\" in Math) {\n    cosh2 = Math.cosh;\n  } else {\n    cosh2 = function(x2) {\n      var y2 = Math.exp(x2);\n      return (y2 + 1 / y2) / 2;\n    };\n  }\n  return cosh2;\n}();\nvar log2 = function() {\n  var log22;\n  if (\"log2\" in Math) {\n    log22 = Math.log2;\n  } else {\n    log22 = function(x2) {\n      return Math.log(x2) * Math.LOG2E;\n    };\n  }\n  return log22;\n}();\nfunction squaredSegmentDistance(x2, y2, x1, y1, x22, y22) {\n  var dx = x22 - x1;\n  var dy = y22 - y1;\n  if (dx !== 0 || dy !== 0) {\n    var t3 = ((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy);\n    if (t3 > 1) {\n      x1 = x22;\n      y1 = y22;\n    } else if (t3 > 0) {\n      x1 += dx * t3;\n      y1 += dy * t3;\n    }\n  }\n  return squaredDistance$1(x2, y2, x1, y1);\n}\nfunction squaredDistance$1(x1, y1, x2, y2) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\nfunction solveLinearSystem(mat) {\n  var n2 = mat.length;\n  for (var i2 = 0; i2 < n2; i2++) {\n    var maxRow = i2;\n    var maxEl = Math.abs(mat[i2][i2]);\n    for (var r2 = i2 + 1; r2 < n2; r2++) {\n      var absValue = Math.abs(mat[r2][i2]);\n      if (absValue > maxEl) {\n        maxEl = absValue;\n        maxRow = r2;\n      }\n    }\n    if (maxEl === 0) {\n      return null;\n    }\n    var tmp = mat[maxRow];\n    mat[maxRow] = mat[i2];\n    mat[i2] = tmp;\n    for (var j2 = i2 + 1; j2 < n2; j2++) {\n      var coef = -mat[j2][i2] / mat[i2][i2];\n      for (var k2 = i2; k2 < n2 + 1; k2++) {\n        if (i2 == k2) {\n          mat[j2][k2] = 0;\n        } else {\n          mat[j2][k2] += coef * mat[i2][k2];\n        }\n      }\n    }\n  }\n  var x2 = new Array(n2);\n  for (var l2 = n2 - 1; l2 >= 0; l2--) {\n    x2[l2] = mat[l2][n2] / mat[l2][l2];\n    for (var m2 = l2 - 1; m2 >= 0; m2--) {\n      mat[m2][n2] -= mat[m2][l2] * x2[l2];\n    }\n  }\n  return x2;\n}\nfunction toDegrees(angleInRadians) {\n  return angleInRadians * 180 / Math.PI;\n}\nfunction toRadians(angleInDegrees) {\n  return angleInDegrees * Math.PI / 180;\n}\nfunction modulo(a2, b2) {\n  var r2 = a2 % b2;\n  return r2 * b2 < 0 ? r2 + b2 : r2;\n}\nfunction lerp$1(a2, b2, x2) {\n  return a2 + x2 * (b2 - a2);\n}\nfunction toFixed(n2, decimals) {\n  var factor = Math.pow(10, decimals);\n  return Math.round(n2 * factor) / factor;\n}\nfunction round(n2, decimals) {\n  return Math.round(toFixed(n2, decimals));\n}\nfunction floor$2(n2, decimals) {\n  return Math.floor(toFixed(n2, decimals));\n}\nfunction ceil$1(n2, decimals) {\n  return Math.ceil(toFixed(n2, decimals));\n}\nvar HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\nvar NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\nfunction asString$1(color2) {\n  if (typeof color2 === \"string\") {\n    return color2;\n  } else {\n    return toString$c(color2);\n  }\n}\nfunction fromNamed(color2) {\n  var el = document.createElement(\"div\");\n  el.style.color = color2;\n  if (el.style.color !== \"\") {\n    document.body.appendChild(el);\n    var rgb2 = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb2;\n  } else {\n    return \"\";\n  }\n}\nvar fromString = function() {\n  var MAX_CACHE_SIZE = 1024;\n  var cache2 = {};\n  var cacheSize = 0;\n  return function(s2) {\n    var color2;\n    if (cache2.hasOwnProperty(s2)) {\n      color2 = cache2[s2];\n    } else {\n      if (cacheSize >= MAX_CACHE_SIZE) {\n        var i2 = 0;\n        for (var key in cache2) {\n          if ((i2++ & 3) === 0) {\n            delete cache2[key];\n            --cacheSize;\n          }\n        }\n      }\n      color2 = fromStringInternal_(s2);\n      cache2[s2] = color2;\n      ++cacheSize;\n    }\n    return color2;\n  };\n}();\nfunction asArray(color2) {\n  if (Array.isArray(color2)) {\n    return color2;\n  } else {\n    return fromString(color2);\n  }\n}\nfunction fromStringInternal_(s2) {\n  var r2, g2, b2, a2, color2;\n  if (NAMED_COLOR_RE_.exec(s2)) {\n    s2 = fromNamed(s2);\n  }\n  if (HEX_COLOR_RE_.exec(s2)) {\n    var n2 = s2.length - 1;\n    var d2 = void 0;\n    if (n2 <= 4) {\n      d2 = 1;\n    } else {\n      d2 = 2;\n    }\n    var hasAlpha = n2 === 4 || n2 === 8;\n    r2 = parseInt(s2.substr(1 + 0 * d2, d2), 16);\n    g2 = parseInt(s2.substr(1 + 1 * d2, d2), 16);\n    b2 = parseInt(s2.substr(1 + 2 * d2, d2), 16);\n    if (hasAlpha) {\n      a2 = parseInt(s2.substr(1 + 3 * d2, d2), 16);\n    } else {\n      a2 = 255;\n    }\n    if (d2 == 1) {\n      r2 = (r2 << 4) + r2;\n      g2 = (g2 << 4) + g2;\n      b2 = (b2 << 4) + b2;\n      if (hasAlpha) {\n        a2 = (a2 << 4) + a2;\n      }\n    }\n    color2 = [r2, g2, b2, a2 / 255];\n  } else if (s2.indexOf(\"rgba(\") == 0) {\n    color2 = s2.slice(5, -1).split(\",\").map(Number);\n    normalize$1(color2);\n  } else if (s2.indexOf(\"rgb(\") == 0) {\n    color2 = s2.slice(4, -1).split(\",\").map(Number);\n    color2.push(1);\n    normalize$1(color2);\n  } else {\n    assert(false, 14);\n  }\n  return color2;\n}\nfunction normalize$1(color2) {\n  color2[0] = clamp(color2[0] + 0.5 | 0, 0, 255);\n  color2[1] = clamp(color2[1] + 0.5 | 0, 0, 255);\n  color2[2] = clamp(color2[2] + 0.5 | 0, 0, 255);\n  color2[3] = clamp(color2[3], 0, 1);\n  return color2;\n}\nfunction toString$c(color2) {\n  var r2 = color2[0];\n  if (r2 != (r2 | 0)) {\n    r2 = r2 + 0.5 | 0;\n  }\n  var g2 = color2[1];\n  if (g2 != (g2 | 0)) {\n    g2 = g2 + 0.5 | 0;\n  }\n  var b2 = color2[2];\n  if (b2 != (b2 | 0)) {\n    b2 = b2 + 0.5 | 0;\n  }\n  var a2 = color2[3] === void 0 ? 1 : Math.round(color2[3] * 100) / 100;\n  return \"rgba(\" + r2 + \",\" + g2 + \",\" + b2 + \",\" + a2 + \")\";\n}\nfunction isStringColor(s2) {\n  if (NAMED_COLOR_RE_.test(s2)) {\n    s2 = fromNamed(s2);\n  }\n  return HEX_COLOR_RE_.test(s2) || s2.indexOf(\"rgba(\") === 0 || s2.indexOf(\"rgb(\") === 0;\n}\nvar IconImageCache = function() {\n  function IconImageCache2() {\n    this.cache_ = {};\n    this.cacheSize_ = 0;\n    this.maxCacheSize_ = 32;\n  }\n  IconImageCache2.prototype.clear = function() {\n    this.cache_ = {};\n    this.cacheSize_ = 0;\n  };\n  IconImageCache2.prototype.canExpireCache = function() {\n    return this.cacheSize_ > this.maxCacheSize_;\n  };\n  IconImageCache2.prototype.expire = function() {\n    if (this.canExpireCache()) {\n      var i2 = 0;\n      for (var key in this.cache_) {\n        var iconImage = this.cache_[key];\n        if ((i2++ & 3) === 0 && !iconImage.hasListener()) {\n          delete this.cache_[key];\n          --this.cacheSize_;\n        }\n      }\n    }\n  };\n  IconImageCache2.prototype.get = function(src, crossOrigin, color2) {\n    var key = getKey$1(src, crossOrigin, color2);\n    return key in this.cache_ ? this.cache_[key] : null;\n  };\n  IconImageCache2.prototype.set = function(src, crossOrigin, color2, iconImage) {\n    var key = getKey$1(src, crossOrigin, color2);\n    this.cache_[key] = iconImage;\n    ++this.cacheSize_;\n  };\n  IconImageCache2.prototype.setSize = function(maxCacheSize) {\n    this.maxCacheSize_ = maxCacheSize;\n    this.expire();\n  };\n  return IconImageCache2;\n}();\nfunction getKey$1(src, crossOrigin, color2) {\n  var colorString = color2 ? asString$1(color2) : \"null\";\n  return crossOrigin + \":\" + src + \":\" + colorString;\n}\nvar shared$5 = new IconImageCache();\nvar BaseEvent = function() {\n  function BaseEvent2(type) {\n    this.propagationStopped;\n    this.defaultPrevented;\n    this.type = type;\n    this.target = null;\n  }\n  BaseEvent2.prototype.preventDefault = function() {\n    this.defaultPrevented = true;\n  };\n  BaseEvent2.prototype.stopPropagation = function() {\n    this.propagationStopped = true;\n  };\n  return BaseEvent2;\n}();\nfunction stopPropagation(evt) {\n  evt.stopPropagation();\n}\nvar Event$1 = BaseEvent;\nvar ObjectEventType = {\n  PROPERTYCHANGE: \"propertychange\"\n};\nvar assign = typeof Object.assign === \"function\" ? Object.assign : function(target, var_sources) {\n  if (target === void 0 || target === null) {\n    throw new TypeError(\"Cannot convert undefined or null to object\");\n  }\n  var output = Object(target);\n  for (var i2 = 1, ii = arguments.length; i2 < ii; ++i2) {\n    var source = arguments[i2];\n    if (source !== void 0 && source !== null) {\n      for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n          output[key] = source[key];\n        }\n      }\n    }\n  }\n  return output;\n};\nfunction clear$1(object) {\n  for (var property in object) {\n    delete object[property];\n  }\n}\nvar getValues = typeof Object.values === \"function\" ? Object.values : function(object) {\n  var values2 = [];\n  for (var property in object) {\n    values2.push(object[property]);\n  }\n  return values2;\n};\nfunction isEmpty(object) {\n  var property;\n  for (property in object) {\n    return false;\n  }\n  return !property;\n}\nvar __extends$2d = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Target = function(_super) {\n  __extends$2d(Target2, _super);\n  function Target2(opt_target) {\n    var _this = _super.call(this) || this;\n    _this.eventTarget_ = opt_target;\n    _this.pendingRemovals_ = null;\n    _this.dispatching_ = null;\n    _this.listeners_ = null;\n    return _this;\n  }\n  Target2.prototype.addEventListener = function(type, listener2) {\n    if (!type || !listener2) {\n      return;\n    }\n    var listeners = this.listeners_ || (this.listeners_ = {});\n    var listenersForType = listeners[type] || (listeners[type] = []);\n    if (listenersForType.indexOf(listener2) === -1) {\n      listenersForType.push(listener2);\n    }\n  };\n  Target2.prototype.dispatchEvent = function(event) {\n    var isString = typeof event === \"string\";\n    var type = isString ? event : event.type;\n    var listeners = this.listeners_ && this.listeners_[type];\n    if (!listeners) {\n      return;\n    }\n    var evt = isString ? new Event$1(event) : event;\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n    var dispatching = this.dispatching_ || (this.dispatching_ = {});\n    var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});\n    if (!(type in dispatching)) {\n      dispatching[type] = 0;\n      pendingRemovals[type] = 0;\n    }\n    ++dispatching[type];\n    var propagate;\n    for (var i2 = 0, ii = listeners.length; i2 < ii; ++i2) {\n      if (\"handleEvent\" in listeners[i2]) {\n        propagate = listeners[i2].handleEvent(evt);\n      } else {\n        propagate = listeners[i2].call(this, evt);\n      }\n      if (propagate === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n    if (--dispatching[type] === 0) {\n      var pr = pendingRemovals[type];\n      delete pendingRemovals[type];\n      while (pr--) {\n        this.removeEventListener(type, VOID);\n      }\n      delete dispatching[type];\n    }\n    return propagate;\n  };\n  Target2.prototype.disposeInternal = function() {\n    this.listeners_ && clear$1(this.listeners_);\n  };\n  Target2.prototype.getListeners = function(type) {\n    return this.listeners_ && this.listeners_[type] || void 0;\n  };\n  Target2.prototype.hasListener = function(opt_type) {\n    if (!this.listeners_) {\n      return false;\n    }\n    return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n  };\n  Target2.prototype.removeEventListener = function(type, listener2) {\n    var listeners = this.listeners_ && this.listeners_[type];\n    if (listeners) {\n      var index2 = listeners.indexOf(listener2);\n      if (index2 !== -1) {\n        if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n          listeners[index2] = VOID;\n          ++this.pendingRemovals_[type];\n        } else {\n          listeners.splice(index2, 1);\n          if (listeners.length === 0) {\n            delete this.listeners_[type];\n          }\n        }\n      }\n    }\n  };\n  return Target2;\n}(Disposable$1);\nvar EventTarget = Target;\nvar EventType = {\n  CHANGE: \"change\",\n  ERROR: \"error\",\n  BLUR: \"blur\",\n  CLEAR: \"clear\",\n  CONTEXTMENU: \"contextmenu\",\n  CLICK: \"click\",\n  DBLCLICK: \"dblclick\",\n  DRAGENTER: \"dragenter\",\n  DRAGOVER: \"dragover\",\n  DROP: \"drop\",\n  FOCUS: \"focus\",\n  KEYDOWN: \"keydown\",\n  KEYPRESS: \"keypress\",\n  LOAD: \"load\",\n  RESIZE: \"resize\",\n  TOUCHMOVE: \"touchmove\",\n  WHEEL: \"wheel\"\n};\nfunction listen(target, type, listener2, opt_this, opt_once) {\n  if (opt_this && opt_this !== target) {\n    listener2 = listener2.bind(opt_this);\n  }\n  if (opt_once) {\n    var originalListener_1 = listener2;\n    listener2 = function() {\n      target.removeEventListener(type, listener2);\n      originalListener_1.apply(this, arguments);\n    };\n  }\n  var eventsKey = {\n    target,\n    type,\n    listener: listener2\n  };\n  target.addEventListener(type, listener2);\n  return eventsKey;\n}\nfunction listenOnce(target, type, listener2, opt_this) {\n  return listen(target, type, listener2, opt_this, true);\n}\nfunction unlistenByKey(key) {\n  if (key && key.target) {\n    key.target.removeEventListener(key.type, key.listener);\n    clear$1(key);\n  }\n}\nvar __extends$2c = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Observable = function(_super) {\n  __extends$2c(Observable2, _super);\n  function Observable2() {\n    var _this = _super.call(this) || this;\n    _this.on = _this.onInternal;\n    _this.once = _this.onceInternal;\n    _this.un = _this.unInternal;\n    _this.revision_ = 0;\n    return _this;\n  }\n  Observable2.prototype.changed = function() {\n    ++this.revision_;\n    this.dispatchEvent(EventType.CHANGE);\n  };\n  Observable2.prototype.getRevision = function() {\n    return this.revision_;\n  };\n  Observable2.prototype.onInternal = function(type, listener2) {\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys3 = new Array(len);\n      for (var i2 = 0; i2 < len; ++i2) {\n        keys3[i2] = listen(this, type[i2], listener2);\n      }\n      return keys3;\n    } else {\n      return listen(this, type, listener2);\n    }\n  };\n  Observable2.prototype.onceInternal = function(type, listener2) {\n    var key;\n    if (Array.isArray(type)) {\n      var len = type.length;\n      key = new Array(len);\n      for (var i2 = 0; i2 < len; ++i2) {\n        key[i2] = listenOnce(this, type[i2], listener2);\n      }\n    } else {\n      key = listenOnce(this, type, listener2);\n    }\n    listener2.ol_key = key;\n    return key;\n  };\n  Observable2.prototype.unInternal = function(type, listener2) {\n    var key = listener2.ol_key;\n    if (key) {\n      unByKey(key);\n    } else if (Array.isArray(type)) {\n      for (var i2 = 0, ii = type.length; i2 < ii; ++i2) {\n        this.removeEventListener(type[i2], listener2);\n      }\n    } else {\n      this.removeEventListener(type, listener2);\n    }\n  };\n  return Observable2;\n}(EventTarget);\nObservable.prototype.on;\nObservable.prototype.once;\nObservable.prototype.un;\nfunction unByKey(key) {\n  if (Array.isArray(key)) {\n    for (var i2 = 0, ii = key.length; i2 < ii; ++i2) {\n      unlistenByKey(key[i2]);\n    }\n  } else {\n    unlistenByKey(key);\n  }\n}\nvar __extends$2b = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ObjectEvent = function(_super) {\n  __extends$2b(ObjectEvent2, _super);\n  function ObjectEvent2(type, key, oldValue) {\n    var _this = _super.call(this, type) || this;\n    _this.key = key;\n    _this.oldValue = oldValue;\n    return _this;\n  }\n  return ObjectEvent2;\n}(Event$1);\nvar BaseObject = function(_super) {\n  __extends$2b(BaseObject2, _super);\n  function BaseObject2(opt_values) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    getUid(_this);\n    _this.values_ = null;\n    if (opt_values !== void 0) {\n      _this.setProperties(opt_values);\n    }\n    return _this;\n  }\n  BaseObject2.prototype.get = function(key) {\n    var value;\n    if (this.values_ && this.values_.hasOwnProperty(key)) {\n      value = this.values_[key];\n    }\n    return value;\n  };\n  BaseObject2.prototype.getKeys = function() {\n    return this.values_ && Object.keys(this.values_) || [];\n  };\n  BaseObject2.prototype.getProperties = function() {\n    return this.values_ && assign({}, this.values_) || {};\n  };\n  BaseObject2.prototype.hasProperties = function() {\n    return !!this.values_;\n  };\n  BaseObject2.prototype.notify = function(key, oldValue) {\n    var eventType;\n    eventType = \"change:\".concat(key);\n    if (this.hasListener(eventType)) {\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    }\n    eventType = ObjectEventType.PROPERTYCHANGE;\n    if (this.hasListener(eventType)) {\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    }\n  };\n  BaseObject2.prototype.addChangeListener = function(key, listener2) {\n    this.addEventListener(\"change:\".concat(key), listener2);\n  };\n  BaseObject2.prototype.removeChangeListener = function(key, listener2) {\n    this.removeEventListener(\"change:\".concat(key), listener2);\n  };\n  BaseObject2.prototype.set = function(key, value, opt_silent) {\n    var values2 = this.values_ || (this.values_ = {});\n    if (opt_silent) {\n      values2[key] = value;\n    } else {\n      var oldValue = values2[key];\n      values2[key] = value;\n      if (oldValue !== value) {\n        this.notify(key, oldValue);\n      }\n    }\n  };\n  BaseObject2.prototype.setProperties = function(values2, opt_silent) {\n    for (var key in values2) {\n      this.set(key, values2[key], opt_silent);\n    }\n  };\n  BaseObject2.prototype.applyProperties = function(source) {\n    if (!source.values_) {\n      return;\n    }\n    assign(this.values_ || (this.values_ = {}), source.values_);\n  };\n  BaseObject2.prototype.unset = function(key, opt_silent) {\n    if (this.values_ && key in this.values_) {\n      var oldValue = this.values_[key];\n      delete this.values_[key];\n      if (isEmpty(this.values_)) {\n        this.values_ = null;\n      }\n      if (!opt_silent) {\n        this.notify(key, oldValue);\n      }\n    }\n  };\n  return BaseObject2;\n}(Observable);\nvar ol_Object = BaseObject;\nvar LayerProperty = {\n  OPACITY: \"opacity\",\n  VISIBLE: \"visible\",\n  EXTENT: \"extent\",\n  Z_INDEX: \"zIndex\",\n  MAX_RESOLUTION: \"maxResolution\",\n  MIN_RESOLUTION: \"minResolution\",\n  MAX_ZOOM: \"maxZoom\",\n  MIN_ZOOM: \"minZoom\",\n  SOURCE: \"source\",\n  MAP: \"map\"\n};\nvar __extends$2a = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar BaseLayer$1 = function(_super) {\n  __extends$2a(BaseLayer2, _super);\n  function BaseLayer2(options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.background_ = options.background;\n    var properties = assign({}, options);\n    if (typeof options.properties === \"object\") {\n      delete properties.properties;\n      assign(properties, options.properties);\n    }\n    properties[LayerProperty.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;\n    assert(typeof properties[LayerProperty.OPACITY] === \"number\", 64);\n    properties[LayerProperty.VISIBLE] = options.visible !== void 0 ? options.visible : true;\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\n    properties[LayerProperty.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;\n    properties[LayerProperty.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;\n    properties[LayerProperty.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;\n    properties[LayerProperty.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;\n    _this.className_ = properties.className !== void 0 ? properties.className : \"ol-layer\";\n    delete properties.className;\n    _this.setProperties(properties);\n    _this.state_ = null;\n    return _this;\n  }\n  BaseLayer2.prototype.getBackground = function() {\n    return this.background_;\n  };\n  BaseLayer2.prototype.getClassName = function() {\n    return this.className_;\n  };\n  BaseLayer2.prototype.getLayerState = function(opt_managed) {\n    var state = this.state_ || {\n      layer: this,\n      managed: opt_managed === void 0 ? true : opt_managed\n    };\n    var zIndex2 = this.getZIndex();\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\n    state.visible = this.getVisible();\n    state.extent = this.getExtent();\n    state.zIndex = zIndex2 === void 0 && !state.managed ? Infinity : zIndex2;\n    state.maxResolution = this.getMaxResolution();\n    state.minResolution = Math.max(this.getMinResolution(), 0);\n    state.minZoom = this.getMinZoom();\n    state.maxZoom = this.getMaxZoom();\n    this.state_ = state;\n    return state;\n  };\n  BaseLayer2.prototype.getLayersArray = function(opt_array) {\n    return abstract();\n  };\n  BaseLayer2.prototype.getLayerStatesArray = function(opt_states) {\n    return abstract();\n  };\n  BaseLayer2.prototype.getExtent = function() {\n    return this.get(LayerProperty.EXTENT);\n  };\n  BaseLayer2.prototype.getMaxResolution = function() {\n    return this.get(LayerProperty.MAX_RESOLUTION);\n  };\n  BaseLayer2.prototype.getMinResolution = function() {\n    return this.get(LayerProperty.MIN_RESOLUTION);\n  };\n  BaseLayer2.prototype.getMinZoom = function() {\n    return this.get(LayerProperty.MIN_ZOOM);\n  };\n  BaseLayer2.prototype.getMaxZoom = function() {\n    return this.get(LayerProperty.MAX_ZOOM);\n  };\n  BaseLayer2.prototype.getOpacity = function() {\n    return this.get(LayerProperty.OPACITY);\n  };\n  BaseLayer2.prototype.getSourceState = function() {\n    return abstract();\n  };\n  BaseLayer2.prototype.getVisible = function() {\n    return this.get(LayerProperty.VISIBLE);\n  };\n  BaseLayer2.prototype.getZIndex = function() {\n    return this.get(LayerProperty.Z_INDEX);\n  };\n  BaseLayer2.prototype.setBackground = function(opt_background) {\n    this.background_ = opt_background;\n    this.changed();\n  };\n  BaseLayer2.prototype.setExtent = function(extent2) {\n    this.set(LayerProperty.EXTENT, extent2);\n  };\n  BaseLayer2.prototype.setMaxResolution = function(maxResolution) {\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\n  };\n  BaseLayer2.prototype.setMinResolution = function(minResolution) {\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\n  };\n  BaseLayer2.prototype.setMaxZoom = function(maxZoom) {\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\n  };\n  BaseLayer2.prototype.setMinZoom = function(minZoom) {\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\n  };\n  BaseLayer2.prototype.setOpacity = function(opacity2) {\n    assert(typeof opacity2 === \"number\", 64);\n    this.set(LayerProperty.OPACITY, opacity2);\n  };\n  BaseLayer2.prototype.setVisible = function(visible) {\n    this.set(LayerProperty.VISIBLE, visible);\n  };\n  BaseLayer2.prototype.setZIndex = function(zindex) {\n    this.set(LayerProperty.Z_INDEX, zindex);\n  };\n  BaseLayer2.prototype.disposeInternal = function() {\n    if (this.state_) {\n      this.state_.layer = null;\n      this.state_ = null;\n    }\n    _super.prototype.disposeInternal.call(this);\n  };\n  return BaseLayer2;\n}(ol_Object);\nvar ol_layer_Base$1 = BaseLayer$1;\nvar RenderEventType = {\n  PRERENDER: \"prerender\",\n  POSTRENDER: \"postrender\",\n  PRECOMPOSE: \"precompose\",\n  POSTCOMPOSE: \"postcompose\",\n  RENDERCOMPLETE: \"rendercomplete\"\n};\nvar SourceState = {\n  UNDEFINED: \"undefined\",\n  LOADING: \"loading\",\n  READY: \"ready\",\n  ERROR: \"error\"\n};\nvar __extends$29 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Layer = function(_super) {\n  __extends$29(Layer2, _super);\n  function Layer2(options) {\n    var _this = this;\n    var baseOptions = assign({}, options);\n    delete baseOptions.source;\n    _this = _super.call(this, baseOptions) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.mapPrecomposeKey_ = null;\n    _this.mapRenderKey_ = null;\n    _this.sourceChangeKey_ = null;\n    _this.renderer_ = null;\n    _this.rendered = false;\n    if (options.render) {\n      _this.render = options.render;\n    }\n    if (options.map) {\n      _this.setMap(options.map);\n    }\n    _this.addChangeListener(LayerProperty.SOURCE, _this.handleSourcePropertyChange_);\n    var source = options.source ? options.source : null;\n    _this.setSource(source);\n    return _this;\n  }\n  Layer2.prototype.getLayersArray = function(opt_array) {\n    var array = opt_array ? opt_array : [];\n    array.push(this);\n    return array;\n  };\n  Layer2.prototype.getLayerStatesArray = function(opt_states) {\n    var states = opt_states ? opt_states : [];\n    states.push(this.getLayerState());\n    return states;\n  };\n  Layer2.prototype.getSource = function() {\n    return this.get(LayerProperty.SOURCE) || null;\n  };\n  Layer2.prototype.getRenderSource = function() {\n    return this.getSource();\n  };\n  Layer2.prototype.getSourceState = function() {\n    var source = this.getSource();\n    return !source ? SourceState.UNDEFINED : source.getState();\n  };\n  Layer2.prototype.handleSourceChange_ = function() {\n    this.changed();\n  };\n  Layer2.prototype.handleSourcePropertyChange_ = function() {\n    if (this.sourceChangeKey_) {\n      unlistenByKey(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n    var source = this.getSource();\n    if (source) {\n      this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);\n    }\n    this.changed();\n  };\n  Layer2.prototype.getFeatures = function(pixel) {\n    if (!this.renderer_) {\n      return new Promise(function(resolve2) {\n        return resolve2([]);\n      });\n    }\n    return this.renderer_.getFeatures(pixel);\n  };\n  Layer2.prototype.getData = function(pixel) {\n    if (!this.renderer_ || !this.rendered) {\n      return null;\n    }\n    return this.renderer_.getData(pixel);\n  };\n  Layer2.prototype.render = function(frameState, target) {\n    var layerRenderer = this.getRenderer();\n    if (layerRenderer.prepareFrame(frameState)) {\n      this.rendered = true;\n      return layerRenderer.renderFrame(frameState, target);\n    }\n  };\n  Layer2.prototype.unrender = function() {\n    this.rendered = false;\n  };\n  Layer2.prototype.setMapInternal = function(map) {\n    if (!map) {\n      this.unrender();\n    }\n    this.set(LayerProperty.MAP, map);\n  };\n  Layer2.prototype.getMapInternal = function() {\n    return this.get(LayerProperty.MAP);\n  };\n  Layer2.prototype.setMap = function(map) {\n    if (this.mapPrecomposeKey_) {\n      unlistenByKey(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n    if (!map) {\n      this.changed();\n    }\n    if (this.mapRenderKey_) {\n      unlistenByKey(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n    if (map) {\n      this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function(evt) {\n        var renderEvent = evt;\n        var layerStatesArray = renderEvent.frameState.layerStatesArray;\n        var layerState = this.getLayerState(false);\n        assert(!layerStatesArray.some(function(arrayLayerState) {\n          return arrayLayerState.layer === layerState.layer;\n        }), 67);\n        layerStatesArray.push(layerState);\n      }, this);\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\n      this.changed();\n    }\n  };\n  Layer2.prototype.setSource = function(source) {\n    this.set(LayerProperty.SOURCE, source);\n  };\n  Layer2.prototype.getRenderer = function() {\n    if (!this.renderer_) {\n      this.renderer_ = this.createRenderer();\n    }\n    return this.renderer_;\n  };\n  Layer2.prototype.hasRenderer = function() {\n    return !!this.renderer_;\n  };\n  Layer2.prototype.createRenderer = function() {\n    return null;\n  };\n  Layer2.prototype.disposeInternal = function() {\n    if (this.renderer_) {\n      this.renderer_.dispose();\n      delete this.renderer_;\n    }\n    this.setSource(null);\n    _super.prototype.disposeInternal.call(this);\n  };\n  return Layer2;\n}(ol_layer_Base$1);\nfunction inView(layerState, viewState) {\n  if (!layerState.visible) {\n    return false;\n  }\n  var resolution = viewState.resolution;\n  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {\n    return false;\n  }\n  var zoom = viewState.zoom;\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\n}\nvar ol_layer_Base = Layer;\nfunction padNumber(number, width, opt_precision) {\n  var numberString = opt_precision !== void 0 ? number.toFixed(opt_precision) : \"\" + number;\n  var decimal = numberString.indexOf(\".\");\n  decimal = decimal === -1 ? numberString.length : decimal;\n  return decimal > width ? numberString : new Array(1 + width - decimal).join(\"0\") + numberString;\n}\nfunction compareVersions(v1, v2) {\n  var s1 = (\"\" + v1).split(\".\");\n  var s2 = (\"\" + v2).split(\".\");\n  for (var i2 = 0; i2 < Math.max(s1.length, s2.length); i2++) {\n    var n1 = parseInt(s1[i2] || \"0\", 10);\n    var n2 = parseInt(s2[i2] || \"0\", 10);\n    if (n1 > n2) {\n      return 1;\n    }\n    if (n2 > n1) {\n      return -1;\n    }\n  }\n  return 0;\n}\nfunction add$3(coordinate, delta) {\n  coordinate[0] += +delta[0];\n  coordinate[1] += +delta[1];\n  return coordinate;\n}\nfunction closestOnCircle(coordinate, circle) {\n  var r2 = circle.getRadius();\n  var center = circle.getCenter();\n  var x0 = center[0];\n  var y0 = center[1];\n  var x1 = coordinate[0];\n  var y1 = coordinate[1];\n  var dx = x1 - x0;\n  var dy = y1 - y0;\n  if (dx === 0 && dy === 0) {\n    dx = 1;\n  }\n  var d2 = Math.sqrt(dx * dx + dy * dy);\n  var x2 = x0 + r2 * dx / d2;\n  var y2 = y0 + r2 * dy / d2;\n  return [x2, y2];\n}\nfunction closestOnSegment(coordinate, segment) {\n  var x0 = coordinate[0];\n  var y0 = coordinate[1];\n  var start2 = segment[0];\n  var end = segment[1];\n  var x1 = start2[0];\n  var y1 = start2[1];\n  var x2 = end[0];\n  var y2 = end[1];\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n  var x3, y3;\n  if (along <= 0) {\n    x3 = x1;\n    y3 = y1;\n  } else if (along >= 1) {\n    x3 = x2;\n    y3 = y2;\n  } else {\n    x3 = x1 + along * dx;\n    y3 = y1 + along * dy;\n  }\n  return [x3, y3];\n}\nfunction equals(coordinate1, coordinate2) {\n  var equals2 = true;\n  for (var i2 = coordinate1.length - 1; i2 >= 0; --i2) {\n    if (coordinate1[i2] != coordinate2[i2]) {\n      equals2 = false;\n      break;\n    }\n  }\n  return equals2;\n}\nfunction rotate$1(coordinate, angle2) {\n  var cosAngle = Math.cos(angle2);\n  var sinAngle = Math.sin(angle2);\n  var x2 = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  var y2 = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  coordinate[0] = x2;\n  coordinate[1] = y2;\n  return coordinate;\n}\nfunction scale$2(coordinate, scale2) {\n  coordinate[0] *= scale2;\n  coordinate[1] *= scale2;\n  return coordinate;\n}\nfunction squaredDistance(coord1, coord2) {\n  var dx = coord1[0] - coord2[0];\n  var dy = coord1[1] - coord2[1];\n  return dx * dx + dy * dy;\n}\nfunction distance$1(coord1, coord2) {\n  return Math.sqrt(squaredDistance(coord1, coord2));\n}\nfunction squaredDistanceToSegment(coordinate, segment) {\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\nfunction wrapX$1(coordinate, projection) {\n  if (projection.canWrapX()) {\n    var worldWidth = getWidth(projection.getExtent());\n    var worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n    if (worldsAway) {\n      coordinate[0] -= worldsAway * worldWidth;\n    }\n  }\n  return coordinate;\n}\nfunction getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {\n  var projectionExtent = projection.getExtent();\n  var worldsAway = 0;\n  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {\n    var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);\n    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);\n  }\n  return worldsAway;\n}\nvar __extends$28 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MapRenderer = function(_super) {\n  __extends$28(MapRenderer2, _super);\n  function MapRenderer2(map) {\n    var _this = _super.call(this) || this;\n    _this.map_ = map;\n    return _this;\n  }\n  MapRenderer2.prototype.dispatchRenderEvent = function(type, frameState) {\n    abstract();\n  };\n  MapRenderer2.prototype.calculateMatrices2D = function(frameState) {\n    var viewState = frameState.viewState;\n    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n    compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  };\n  MapRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {\n    var result;\n    var viewState = frameState.viewState;\n    function forEachFeatureAtCoordinate(managed, feature2, layer2, geometry) {\n      return callback.call(thisArg, feature2, managed ? layer2 : null, geometry);\n    }\n    var projection = viewState.projection;\n    var translatedCoordinate = wrapX$1(coordinate.slice(), projection);\n    var offsets = [[0, 0]];\n    if (projection.canWrapX() && checkWrapped) {\n      var projectionExtent = projection.getExtent();\n      var worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var matches = [];\n    var tmpCoord = [];\n    for (var i2 = 0; i2 < offsets.length; i2++) {\n      for (var j2 = numLayers - 1; j2 >= 0; --j2) {\n        var layerState = layerStates[j2];\n        var layer = layerState.layer;\n        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {\n          var layerRenderer = layer.getRenderer();\n          var source = layer.getSource();\n          if (layerRenderer && source) {\n            var coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;\n            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);\n            tmpCoord[0] = coordinates2[0] + offsets[i2][0];\n            tmpCoord[1] = coordinates2[1] + offsets[i2][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);\n          }\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    if (matches.length === 0) {\n      return void 0;\n    }\n    var order = 1 / matches.length;\n    matches.forEach(function(m2, i3) {\n      return m2.distanceSq += i3 * order;\n    });\n    matches.sort(function(a2, b2) {\n      return a2.distanceSq - b2.distanceSq;\n    });\n    matches.some(function(m2) {\n      return result = m2.callback(m2.feature, m2.layer, m2.geometry);\n    });\n    return result;\n  };\n  MapRenderer2.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {\n    return abstract();\n  };\n  MapRenderer2.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {\n    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);\n    return hasFeature !== void 0;\n  };\n  MapRenderer2.prototype.getMap = function() {\n    return this.map_;\n  };\n  MapRenderer2.prototype.renderFrame = function(frameState) {\n    abstract();\n  };\n  MapRenderer2.prototype.scheduleExpireIconCache = function(frameState) {\n    if (shared$5.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  };\n  return MapRenderer2;\n}(Disposable$1);\nfunction expireIconCache(map, frameState) {\n  shared$5.expire();\n}\nvar MapRenderer$1 = MapRenderer;\nvar __extends$27 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar RenderEvent = function(_super) {\n  __extends$27(RenderEvent2, _super);\n  function RenderEvent2(type, opt_inversePixelTransform, opt_frameState, opt_context) {\n    var _this = _super.call(this, type) || this;\n    _this.inversePixelTransform = opt_inversePixelTransform;\n    _this.frameState = opt_frameState;\n    _this.context = opt_context;\n    return _this;\n  }\n  return RenderEvent2;\n}(Event$1);\nvar RenderEvent$1 = RenderEvent;\nvar CLASS_HIDDEN = \"ol-hidden\";\nvar CLASS_SELECTABLE = \"ol-selectable\";\nvar CLASS_UNSELECTABLE = \"ol-unselectable\";\nvar CLASS_UNSUPPORTED = \"ol-unsupported\";\nvar CLASS_CONTROL = \"ol-control\";\nvar CLASS_COLLAPSED = \"ol-collapsed\";\nvar fontRegEx = new RegExp([\n  \"^\\\\s*(?=(?:(?:[-a-z]+\\\\s*){0,2}(italic|oblique))?)\",\n  \"(?=(?:(?:[-a-z]+\\\\s*){0,2}(small-caps))?)\",\n  \"(?=(?:(?:[-a-z]+\\\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)\",\n  \"(?:(?:normal|\\\\1|\\\\2|\\\\3)\\\\s*){0,3}((?:xx?-)?\",\n  \"(?:small|large)|medium|smaller|larger|[\\\\.\\\\d]+(?:\\\\%|in|[cem]m|ex|p[ctx]))\",\n  \"(?:\\\\s*\\\\/\\\\s*(normal|[\\\\.\\\\d]+(?:\\\\%|in|[cem]m|ex|p[ctx])?))\",\n  `?\\\\s*([-,\\\\\"\\\\'\\\\sa-z]+?)\\\\s*$`\n].join(\"\"), \"i\");\nvar fontRegExMatchIndex = [\n  \"style\",\n  \"variant\",\n  \"weight\",\n  \"size\",\n  \"lineHeight\",\n  \"family\"\n];\nvar getFontParameters = function(fontSpec) {\n  var match2 = fontSpec.match(fontRegEx);\n  if (!match2) {\n    return null;\n  }\n  var style2 = {\n    lineHeight: \"normal\",\n    size: \"1.2em\",\n    style: \"normal\",\n    weight: \"normal\",\n    variant: \"normal\"\n  };\n  for (var i2 = 0, ii = fontRegExMatchIndex.length; i2 < ii; ++i2) {\n    var value = match2[i2 + 1];\n    if (value !== void 0) {\n      style2[fontRegExMatchIndex[i2]] = value;\n    }\n  }\n  style2.families = style2.family.split(/,\\s?/);\n  return style2;\n};\nfunction cssOpacity(opacity2) {\n  return opacity2 === 1 ? \"\" : String(Math.round(opacity2 * 100) / 100);\n}\nfunction createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {\n  var canvas;\n  if (opt_canvasPool && opt_canvasPool.length) {\n    canvas = opt_canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);\n  } else {\n    canvas = document.createElement(\"canvas\");\n  }\n  if (opt_width) {\n    canvas.width = opt_width;\n  }\n  if (opt_height) {\n    canvas.height = opt_height;\n  }\n  return canvas.getContext(\"2d\", opt_Context2DSettings);\n}\nfunction outerWidth(element) {\n  var width = element.offsetWidth;\n  var style2 = getComputedStyle(element);\n  width += parseInt(style2.marginLeft, 10) + parseInt(style2.marginRight, 10);\n  return width;\n}\nfunction outerHeight(element) {\n  var height = element.offsetHeight;\n  var style2 = getComputedStyle(element);\n  height += parseInt(style2.marginTop, 10) + parseInt(style2.marginBottom, 10);\n  return height;\n}\nfunction replaceNode(newNode, oldNode) {\n  var parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\nfunction removeNode(node2) {\n  return node2 && node2.parentNode ? node2.parentNode.removeChild(node2) : null;\n}\nfunction removeChildren(node2) {\n  while (node2.lastChild) {\n    node2.removeChild(node2.lastChild);\n  }\n}\nfunction replaceChildren(node2, children) {\n  var oldChildren = node2.childNodes;\n  for (var i2 = 0; true; ++i2) {\n    var oldChild = oldChildren[i2];\n    var newChild = children[i2];\n    if (!oldChild && !newChild) {\n      break;\n    }\n    if (oldChild === newChild) {\n      continue;\n    }\n    if (!oldChild) {\n      node2.appendChild(newChild);\n      continue;\n    }\n    if (!newChild) {\n      node2.removeChild(oldChild);\n      --i2;\n      continue;\n    }\n    node2.insertBefore(newChild, oldChild);\n  }\n}\nvar defaultFont = \"10px sans-serif\";\nvar defaultFillStyle = \"#000\";\nvar defaultLineCap = \"round\";\nvar defaultLineDash = [];\nvar defaultLineDashOffset = 0;\nvar defaultLineJoin = \"round\";\nvar defaultMiterLimit = 10;\nvar defaultStrokeStyle = \"#000\";\nvar defaultTextAlign = \"center\";\nvar defaultTextBaseline = \"middle\";\nvar defaultPadding = [0, 0, 0, 0];\nvar defaultLineWidth = 1;\nvar checkedFonts = new ol_Object();\nvar labelCache = new EventTarget();\nlabelCache.setSize = function() {\n  console.warn(\"labelCache is deprecated.\");\n};\nvar measureContext = null;\nvar measureFont;\nvar textHeights = {};\nvar registerFont = function() {\n  var retries = 100;\n  var size = \"32px \";\n  var referenceFonts = [\"monospace\", \"serif\"];\n  var len = referenceFonts.length;\n  var text2 = \"wmytzilWMYTZIL@#/&?$%10\\uF013\";\n  var interval, referenceWidth;\n  function isAvailable(fontStyle2, fontWeight2, fontFamily2) {\n    var available = true;\n    for (var i2 = 0; i2 < len; ++i2) {\n      var referenceFont = referenceFonts[i2];\n      referenceWidth = measureTextWidth(fontStyle2 + \" \" + fontWeight2 + \" \" + size + referenceFont, text2);\n      if (fontFamily2 != referenceFont) {\n        var width = measureTextWidth(fontStyle2 + \" \" + fontWeight2 + \" \" + size + fontFamily2 + \",\" + referenceFont, text2);\n        available = available && width != referenceWidth;\n      }\n    }\n    if (available) {\n      return true;\n    }\n    return false;\n  }\n  function check2() {\n    var done = true;\n    var fonts = checkedFonts.getKeys();\n    for (var i2 = 0, ii = fonts.length; i2 < ii; ++i2) {\n      var font = fonts[i2];\n      if (checkedFonts.get(font) < retries) {\n        if (isAvailable.apply(this, font.split(\"\\n\"))) {\n          clear$1(textHeights);\n          measureContext = null;\n          measureFont = void 0;\n          checkedFonts.set(font, retries);\n        } else {\n          checkedFonts.set(font, checkedFonts.get(font) + 1, true);\n          done = false;\n        }\n      }\n    }\n    if (done) {\n      clearInterval(interval);\n      interval = void 0;\n    }\n  }\n  return function(fontSpec) {\n    var font = getFontParameters(fontSpec);\n    if (!font) {\n      return;\n    }\n    var families = font.families;\n    for (var i2 = 0, ii = families.length; i2 < ii; ++i2) {\n      var family = families[i2];\n      var key = font.style + \"\\n\" + font.weight + \"\\n\" + family;\n      if (checkedFonts.get(key) === void 0) {\n        checkedFonts.set(key, retries, true);\n        if (!isAvailable(font.style, font.weight, family)) {\n          checkedFonts.set(key, 0, true);\n          if (interval === void 0) {\n            interval = setInterval(check2, 32);\n          }\n        }\n      }\n    }\n  };\n}();\nvar measureTextHeight = function() {\n  var measureElement;\n  return function(fontSpec) {\n    var height = textHeights[fontSpec];\n    if (height == void 0) {\n      if (WORKER_OFFSCREEN_CANVAS) {\n        var font = getFontParameters(fontSpec);\n        var metrics = measureText(fontSpec, \"\\u017Dg\");\n        var lineHeight2 = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);\n        height = lineHeight2 * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);\n      } else {\n        if (!measureElement) {\n          measureElement = document.createElement(\"div\");\n          measureElement.innerHTML = \"M\";\n          measureElement.style.minHeight = \"0\";\n          measureElement.style.maxHeight = \"none\";\n          measureElement.style.height = \"auto\";\n          measureElement.style.padding = \"0\";\n          measureElement.style.border = \"none\";\n          measureElement.style.position = \"absolute\";\n          measureElement.style.display = \"block\";\n          measureElement.style.left = \"-99999px\";\n        }\n        measureElement.style.font = fontSpec;\n        document.body.appendChild(measureElement);\n        height = measureElement.offsetHeight;\n        document.body.removeChild(measureElement);\n      }\n      textHeights[fontSpec] = height;\n    }\n    return height;\n  };\n}();\nfunction measureText(font, text2) {\n  if (!measureContext) {\n    measureContext = createCanvasContext2D(1, 1);\n  }\n  if (font != measureFont) {\n    measureContext.font = font;\n    measureFont = measureContext.font;\n  }\n  return measureContext.measureText(text2);\n}\nfunction measureTextWidth(font, text2) {\n  return measureText(font, text2).width;\n}\nfunction measureAndCacheTextWidth(font, text2, cache2) {\n  if (text2 in cache2) {\n    return cache2[text2];\n  }\n  var width = measureTextWidth(font, text2);\n  cache2[text2] = width;\n  return width;\n}\nfunction getTextDimensions(baseStyle, chunks) {\n  var widths = [];\n  var heights = [];\n  var lineWidths = [];\n  var width = 0;\n  var lineWidth = 0;\n  var height = 0;\n  var lineHeight2 = 0;\n  for (var i2 = 0, ii = chunks.length; i2 <= ii; i2 += 2) {\n    var text2 = chunks[i2];\n    if (text2 === \"\\n\" || i2 === ii) {\n      width = Math.max(width, lineWidth);\n      lineWidths.push(lineWidth);\n      lineWidth = 0;\n      height += lineHeight2;\n      continue;\n    }\n    var font = chunks[i2 + 1] || baseStyle.font;\n    var currentWidth = measureTextWidth(font, text2);\n    widths.push(currentWidth);\n    lineWidth += currentWidth;\n    var currentHeight = measureTextHeight(font);\n    heights.push(currentHeight);\n    lineHeight2 = Math.max(lineHeight2, currentHeight);\n  }\n  return { width, height, widths, heights, lineWidths };\n}\nfunction drawImageOrLabel(context, transform2, opacity2, labelOrImage, originX, originY, w2, h2, x2, y2, scale2) {\n  context.save();\n  if (opacity2 !== 1) {\n    context.globalAlpha *= opacity2;\n  }\n  if (transform2) {\n    context.setTransform.apply(context, transform2);\n  }\n  if (labelOrImage.contextInstructions) {\n    context.translate(x2, y2);\n    context.scale(scale2[0], scale2[1]);\n    executeLabelInstructions(labelOrImage, context);\n  } else if (scale2[0] < 0 || scale2[1] < 0) {\n    context.translate(x2, y2);\n    context.scale(scale2[0], scale2[1]);\n    context.drawImage(labelOrImage, originX, originY, w2, h2, 0, 0, w2, h2);\n  } else {\n    context.drawImage(labelOrImage, originX, originY, w2, h2, x2, y2, w2 * scale2[0], h2 * scale2[1]);\n  }\n  context.restore();\n}\nfunction executeLabelInstructions(label, context) {\n  var contextInstructions = label.contextInstructions;\n  for (var i2 = 0, ii = contextInstructions.length; i2 < ii; i2 += 2) {\n    if (Array.isArray(contextInstructions[i2 + 1])) {\n      context[contextInstructions[i2]].apply(context, contextInstructions[i2 + 1]);\n    } else {\n      context[contextInstructions[i2]] = contextInstructions[i2 + 1];\n    }\n  }\n}\nvar __extends$26 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CompositeMapRenderer = function(_super) {\n  __extends$26(CompositeMapRenderer2, _super);\n  function CompositeMapRenderer2(map) {\n    var _this = _super.call(this, map) || this;\n    _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));\n    _this.element_ = document.createElement(\"div\");\n    var style2 = _this.element_.style;\n    style2.position = \"absolute\";\n    style2.width = \"100%\";\n    style2.height = \"100%\";\n    style2.zIndex = \"0\";\n    _this.element_.className = CLASS_UNSELECTABLE + \" ol-layers\";\n    var container = map.getViewport();\n    container.insertBefore(_this.element_, container.firstChild || null);\n    _this.children_ = [];\n    _this.renderedVisible_ = true;\n    return _this;\n  }\n  CompositeMapRenderer2.prototype.dispatchRenderEvent = function(type, frameState) {\n    var map = this.getMap();\n    if (map.hasListener(type)) {\n      var event_1 = new RenderEvent$1(type, void 0, frameState);\n      map.dispatchEvent(event_1);\n    }\n  };\n  CompositeMapRenderer2.prototype.disposeInternal = function() {\n    unlistenByKey(this.fontChangeListenerKey_);\n    this.element_.parentNode.removeChild(this.element_);\n    _super.prototype.disposeInternal.call(this);\n  };\n  CompositeMapRenderer2.prototype.renderFrame = function(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element_.style.display = \"none\";\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n    this.calculateMatrices2D(frameState);\n    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n    var layerStatesArray = frameState.layerStatesArray.sort(function(a2, b2) {\n      return a2.zIndex - b2.zIndex;\n    });\n    var viewState = frameState.viewState;\n    this.children_.length = 0;\n    var declutterLayers = [];\n    var previousElement = null;\n    for (var i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {\n      var layerState = layerStatesArray[i2];\n      frameState.layerIndex = i2;\n      var layer = layerState.layer;\n      var sourceState = layer.getSourceState();\n      if (!inView(layerState, viewState) || sourceState != SourceState.READY && sourceState != SourceState.UNDEFINED) {\n        layer.unrender();\n        continue;\n      }\n      var element = layer.render(frameState, previousElement);\n      if (!element) {\n        continue;\n      }\n      if (element !== previousElement) {\n        this.children_.push(element);\n        previousElement = element;\n      }\n      if (\"getDeclutter\" in layer) {\n        declutterLayers.push(layer);\n      }\n    }\n    for (var i2 = declutterLayers.length - 1; i2 >= 0; --i2) {\n      declutterLayers[i2].renderDeclutter(frameState);\n    }\n    replaceChildren(this.element_, this.children_);\n    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n    if (!this.renderedVisible_) {\n      this.element_.style.display = \"\";\n      this.renderedVisible_ = true;\n    }\n    this.scheduleExpireIconCache(frameState);\n  };\n  CompositeMapRenderer2.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {\n    var viewState = frameState.viewState;\n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    for (var i2 = numLayers - 1; i2 >= 0; --i2) {\n      var layerState = layerStates[i2];\n      var layer = layerState.layer;\n      if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter(layer)) {\n        var layerRenderer = layer.getRenderer();\n        var data2 = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);\n        if (data2) {\n          var result = callback(layer, data2);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return void 0;\n  };\n  return CompositeMapRenderer2;\n}(MapRenderer$1);\nvar CompositeMapRenderer$1 = CompositeMapRenderer;\nvar CollectionEventType = {\n  ADD: \"add\",\n  REMOVE: \"remove\"\n};\nvar __extends$25 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Property$6 = {\n  LENGTH: \"length\"\n};\nvar CollectionEvent = function(_super) {\n  __extends$25(CollectionEvent2, _super);\n  function CollectionEvent2(type, opt_element, opt_index) {\n    var _this = _super.call(this, type) || this;\n    _this.element = opt_element;\n    _this.index = opt_index;\n    return _this;\n  }\n  return CollectionEvent2;\n}(Event$1);\nvar Collection = function(_super) {\n  __extends$25(Collection2, _super);\n  function Collection2(opt_array, opt_options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    var options = opt_options || {};\n    _this.unique_ = !!options.unique;\n    _this.array_ = opt_array ? opt_array : [];\n    if (_this.unique_) {\n      for (var i2 = 0, ii = _this.array_.length; i2 < ii; ++i2) {\n        _this.assertUnique_(_this.array_[i2], i2);\n      }\n    }\n    _this.updateLength_();\n    return _this;\n  }\n  Collection2.prototype.clear = function() {\n    while (this.getLength() > 0) {\n      this.pop();\n    }\n  };\n  Collection2.prototype.extend = function(arr) {\n    for (var i2 = 0, ii = arr.length; i2 < ii; ++i2) {\n      this.push(arr[i2]);\n    }\n    return this;\n  };\n  Collection2.prototype.forEach = function(f2) {\n    var array = this.array_;\n    for (var i2 = 0, ii = array.length; i2 < ii; ++i2) {\n      f2(array[i2], i2, array);\n    }\n  };\n  Collection2.prototype.getArray = function() {\n    return this.array_;\n  };\n  Collection2.prototype.item = function(index2) {\n    return this.array_[index2];\n  };\n  Collection2.prototype.getLength = function() {\n    return this.get(Property$6.LENGTH);\n  };\n  Collection2.prototype.insertAt = function(index2, elem) {\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n    this.array_.splice(index2, 0, elem);\n    this.updateLength_();\n    this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index2));\n  };\n  Collection2.prototype.pop = function() {\n    return this.removeAt(this.getLength() - 1);\n  };\n  Collection2.prototype.push = function(elem) {\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n    var n2 = this.getLength();\n    this.insertAt(n2, elem);\n    return this.getLength();\n  };\n  Collection2.prototype.remove = function(elem) {\n    var arr = this.array_;\n    for (var i2 = 0, ii = arr.length; i2 < ii; ++i2) {\n      if (arr[i2] === elem) {\n        return this.removeAt(i2);\n      }\n    }\n    return void 0;\n  };\n  Collection2.prototype.removeAt = function(index2) {\n    var prev = this.array_[index2];\n    this.array_.splice(index2, 1);\n    this.updateLength_();\n    this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index2));\n    return prev;\n  };\n  Collection2.prototype.setAt = function(index2, elem) {\n    var n2 = this.getLength();\n    if (index2 < n2) {\n      if (this.unique_) {\n        this.assertUnique_(elem, index2);\n      }\n      var prev = this.array_[index2];\n      this.array_[index2] = elem;\n      this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index2));\n      this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index2));\n    } else {\n      for (var j2 = n2; j2 < index2; ++j2) {\n        this.insertAt(j2, void 0);\n      }\n      this.insertAt(index2, elem);\n    }\n  };\n  Collection2.prototype.updateLength_ = function() {\n    this.set(Property$6.LENGTH, this.array_.length);\n  };\n  Collection2.prototype.assertUnique_ = function(elem, opt_except) {\n    for (var i2 = 0, ii = this.array_.length; i2 < ii; ++i2) {\n      if (this.array_[i2] === elem && i2 !== opt_except) {\n        throw new AssertionError$1(58);\n      }\n    }\n  };\n  return Collection2;\n}(ol_Object);\nvar ol_Collection = Collection;\nvar __extends$24 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar GroupEvent = function(_super) {\n  __extends$24(GroupEvent2, _super);\n  function GroupEvent2(type, layer) {\n    var _this = _super.call(this, type) || this;\n    _this.layer = layer;\n    return _this;\n  }\n  return GroupEvent2;\n}(Event$1);\nvar Property$5 = {\n  LAYERS: \"layers\"\n};\nvar LayerGroup = function(_super) {\n  __extends$24(LayerGroup2, _super);\n  function LayerGroup2(opt_options) {\n    var _this = this;\n    var options = opt_options || {};\n    var baseOptions = assign({}, options);\n    delete baseOptions.layers;\n    var layers = options.layers;\n    _this = _super.call(this, baseOptions) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.layersListenerKeys_ = [];\n    _this.listenerKeys_ = {};\n    _this.addChangeListener(Property$5.LAYERS, _this.handleLayersChanged_);\n    if (layers) {\n      if (Array.isArray(layers)) {\n        layers = new ol_Collection(layers.slice(), { unique: true });\n      } else {\n        assert(typeof layers.getArray === \"function\", 43);\n      }\n    } else {\n      layers = new ol_Collection(void 0, { unique: true });\n    }\n    _this.setLayers(layers);\n    return _this;\n  }\n  LayerGroup2.prototype.handleLayerChange_ = function() {\n    this.changed();\n  };\n  LayerGroup2.prototype.handleLayersChanged_ = function() {\n    this.layersListenerKeys_.forEach(unlistenByKey);\n    this.layersListenerKeys_.length = 0;\n    var layers = this.getLayers();\n    this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));\n    for (var id in this.listenerKeys_) {\n      this.listenerKeys_[id].forEach(unlistenByKey);\n    }\n    clear$1(this.listenerKeys_);\n    var layersArray = layers.getArray();\n    for (var i2 = 0, ii = layersArray.length; i2 < ii; i2++) {\n      var layer = layersArray[i2];\n      this.registerLayerListeners_(layer);\n      this.dispatchEvent(new GroupEvent(\"addlayer\", layer));\n    }\n    this.changed();\n  };\n  LayerGroup2.prototype.registerLayerListeners_ = function(layer) {\n    var listenerKeys = [\n      listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),\n      listen(layer, EventType.CHANGE, this.handleLayerChange_, this)\n    ];\n    if (layer instanceof LayerGroup2) {\n      listenerKeys.push(listen(layer, \"addlayer\", this.handleLayerGroupAdd_, this), listen(layer, \"removelayer\", this.handleLayerGroupRemove_, this));\n    }\n    this.listenerKeys_[getUid(layer)] = listenerKeys;\n  };\n  LayerGroup2.prototype.handleLayerGroupAdd_ = function(event) {\n    this.dispatchEvent(new GroupEvent(\"addlayer\", event.layer));\n  };\n  LayerGroup2.prototype.handleLayerGroupRemove_ = function(event) {\n    this.dispatchEvent(new GroupEvent(\"removelayer\", event.layer));\n  };\n  LayerGroup2.prototype.handleLayersAdd_ = function(collectionEvent) {\n    var layer = collectionEvent.element;\n    this.registerLayerListeners_(layer);\n    this.dispatchEvent(new GroupEvent(\"addlayer\", layer));\n    this.changed();\n  };\n  LayerGroup2.prototype.handleLayersRemove_ = function(collectionEvent) {\n    var layer = collectionEvent.element;\n    var key = getUid(layer);\n    this.listenerKeys_[key].forEach(unlistenByKey);\n    delete this.listenerKeys_[key];\n    this.dispatchEvent(new GroupEvent(\"removelayer\", layer));\n    this.changed();\n  };\n  LayerGroup2.prototype.getLayers = function() {\n    return this.get(Property$5.LAYERS);\n  };\n  LayerGroup2.prototype.setLayers = function(layers) {\n    var collection = this.getLayers();\n    if (collection) {\n      var currentLayers = collection.getArray();\n      for (var i2 = 0, ii = currentLayers.length; i2 < ii; ++i2) {\n        this.dispatchEvent(new GroupEvent(\"removelayer\", currentLayers[i2]));\n      }\n    }\n    this.set(Property$5.LAYERS, layers);\n  };\n  LayerGroup2.prototype.getLayersArray = function(opt_array) {\n    var array = opt_array !== void 0 ? opt_array : [];\n    this.getLayers().forEach(function(layer) {\n      layer.getLayersArray(array);\n    });\n    return array;\n  };\n  LayerGroup2.prototype.getLayerStatesArray = function(opt_states) {\n    var states = opt_states !== void 0 ? opt_states : [];\n    var pos = states.length;\n    this.getLayers().forEach(function(layer) {\n      layer.getLayerStatesArray(states);\n    });\n    var ownLayerState = this.getLayerState();\n    var defaultZIndex = ownLayerState.zIndex;\n    if (!opt_states && ownLayerState.zIndex === void 0) {\n      defaultZIndex = 0;\n    }\n    for (var i2 = pos, ii = states.length; i2 < ii; i2++) {\n      var layerState = states[i2];\n      layerState.opacity *= ownLayerState.opacity;\n      layerState.visible = layerState.visible && ownLayerState.visible;\n      layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);\n      layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);\n      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);\n      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);\n      if (ownLayerState.extent !== void 0) {\n        if (layerState.extent !== void 0) {\n          layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);\n        } else {\n          layerState.extent = ownLayerState.extent;\n        }\n      }\n      if (layerState.zIndex === void 0) {\n        layerState.zIndex = defaultZIndex;\n      }\n    }\n    return states;\n  };\n  LayerGroup2.prototype.getSourceState = function() {\n    return SourceState.READY;\n  };\n  return LayerGroup2;\n}(ol_layer_Base$1);\nvar ol_layer_Group = LayerGroup;\nvar __extends$23 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MapEvent = function(_super) {\n  __extends$23(MapEvent2, _super);\n  function MapEvent2(type, map, opt_frameState) {\n    var _this = _super.call(this, type) || this;\n    _this.map = map;\n    _this.frameState = opt_frameState !== void 0 ? opt_frameState : null;\n    return _this;\n  }\n  return MapEvent2;\n}(Event$1);\nvar MapEvent$1 = MapEvent;\nvar __extends$22 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MapBrowserEvent = function(_super) {\n  __extends$22(MapBrowserEvent2, _super);\n  function MapBrowserEvent2(type, map, originalEvent, opt_dragging, opt_frameState) {\n    var _this = _super.call(this, type, map, opt_frameState) || this;\n    _this.originalEvent = originalEvent;\n    _this.pixel_ = null;\n    _this.coordinate_ = null;\n    _this.dragging = opt_dragging !== void 0 ? opt_dragging : false;\n    return _this;\n  }\n  Object.defineProperty(MapBrowserEvent2.prototype, \"pixel\", {\n    get: function() {\n      if (!this.pixel_) {\n        this.pixel_ = this.map.getEventPixel(this.originalEvent);\n      }\n      return this.pixel_;\n    },\n    set: function(pixel) {\n      this.pixel_ = pixel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MapBrowserEvent2.prototype, \"coordinate\", {\n    get: function() {\n      if (!this.coordinate_) {\n        this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);\n      }\n      return this.coordinate_;\n    },\n    set: function(coordinate) {\n      this.coordinate_ = coordinate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MapBrowserEvent2.prototype.preventDefault = function() {\n    _super.prototype.preventDefault.call(this);\n    if (\"preventDefault\" in this.originalEvent) {\n      this.originalEvent.preventDefault();\n    }\n  };\n  MapBrowserEvent2.prototype.stopPropagation = function() {\n    _super.prototype.stopPropagation.call(this);\n    if (\"stopPropagation\" in this.originalEvent) {\n      this.originalEvent.stopPropagation();\n    }\n  };\n  return MapBrowserEvent2;\n}(MapEvent$1);\nvar MapBrowserEvent$1 = MapBrowserEvent;\nvar MapBrowserEventType = {\n  SINGLECLICK: \"singleclick\",\n  CLICK: EventType.CLICK,\n  DBLCLICK: EventType.DBLCLICK,\n  POINTERDRAG: \"pointerdrag\",\n  POINTERMOVE: \"pointermove\",\n  POINTERDOWN: \"pointerdown\",\n  POINTERUP: \"pointerup\",\n  POINTEROVER: \"pointerover\",\n  POINTEROUT: \"pointerout\",\n  POINTERENTER: \"pointerenter\",\n  POINTERLEAVE: \"pointerleave\",\n  POINTERCANCEL: \"pointercancel\"\n};\nvar PointerEventType = {\n  POINTERMOVE: \"pointermove\",\n  POINTERDOWN: \"pointerdown\",\n  POINTERUP: \"pointerup\",\n  POINTEROVER: \"pointerover\",\n  POINTEROUT: \"pointerout\",\n  POINTERENTER: \"pointerenter\",\n  POINTERLEAVE: \"pointerleave\",\n  POINTERCANCEL: \"pointercancel\"\n};\nvar __extends$21 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MapBrowserEventHandler = function(_super) {\n  __extends$21(MapBrowserEventHandler2, _super);\n  function MapBrowserEventHandler2(map, moveTolerance) {\n    var _this = _super.call(this, map) || this;\n    _this.map_ = map;\n    _this.clickTimeoutId_;\n    _this.emulateClicks_ = false;\n    _this.dragging_ = false;\n    _this.dragListenerKeys_ = [];\n    _this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;\n    _this.down_ = null;\n    var element = _this.map_.getViewport();\n    _this.activePointers_ = 0;\n    _this.trackedTouches_ = {};\n    _this.element_ = element;\n    _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);\n    _this.originalPointerMoveEvent_;\n    _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayEvent_, _this);\n    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);\n    _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);\n    return _this;\n  }\n  MapBrowserEventHandler2.prototype.emulateClick_ = function(pointerEvent) {\n    var newEvent = new MapBrowserEvent$1(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== void 0) {\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = void 0;\n      newEvent = new MapBrowserEvent$1(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      this.clickTimeoutId_ = setTimeout(function() {\n        this.clickTimeoutId_ = void 0;\n        var newEvent2 = new MapBrowserEvent$1(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent2);\n      }.bind(this), 250);\n    }\n  };\n  MapBrowserEventHandler2.prototype.updateActivePointers_ = function(pointerEvent) {\n    var event = pointerEvent;\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == MapBrowserEventType.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  };\n  MapBrowserEventHandler2.prototype.handlePointerUp_ = function(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserEvent$1(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  };\n  MapBrowserEventHandler2.prototype.isMouseActionButton_ = function(pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n  MapBrowserEventHandler2.prototype.handlePointerDown_ = function(pointerEvent) {\n    this.emulateClicks_ = this.activePointers_ === 0;\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserEvent$1(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    this.down_ = {};\n    for (var property in pointerEvent) {\n      var value = pointerEvent[property];\n      this.down_[property] = typeof value === \"function\" ? VOID : value;\n    }\n    if (this.dragListenerKeys_.length === 0) {\n      var doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n      }\n    }\n  };\n  MapBrowserEventHandler2.prototype.handlePointerMove_ = function(pointerEvent) {\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      var newEvent = new MapBrowserEvent$1(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);\n      this.dispatchEvent(newEvent);\n    }\n  };\n  MapBrowserEventHandler2.prototype.relayEvent_ = function(pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserEvent$1(pointerEvent.type, this.map_, pointerEvent, dragging));\n  };\n  MapBrowserEventHandler2.prototype.handleTouchMove_ = function(event) {\n    var originalEvent = this.originalPointerMoveEvent_;\n    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== \"boolean\" || event.cancelable === true)) {\n      event.preventDefault();\n    }\n  };\n  MapBrowserEventHandler2.prototype.isMoving_ = function(pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n  MapBrowserEventHandler2.prototype.disposeInternal = function() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.element_ = null;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return MapBrowserEventHandler2;\n}(EventTarget);\nvar MapBrowserEventHandler$1 = MapBrowserEventHandler;\nvar MapEventType = {\n  POSTRENDER: \"postrender\",\n  MOVESTART: \"movestart\",\n  MOVEEND: \"moveend\",\n  LOADSTART: \"loadstart\",\n  LOADEND: \"loadend\"\n};\nvar MapProperty = {\n  LAYERGROUP: \"layergroup\",\n  SIZE: \"size\",\n  TARGET: \"target\",\n  VIEW: \"view\"\n};\nvar DROP = Infinity;\nvar PriorityQueue = function() {\n  function PriorityQueue2(priorityFunction, keyFunction) {\n    this.priorityFunction_ = priorityFunction;\n    this.keyFunction_ = keyFunction;\n    this.elements_ = [];\n    this.priorities_ = [];\n    this.queuedElements_ = {};\n  }\n  PriorityQueue2.prototype.clear = function() {\n    this.elements_.length = 0;\n    this.priorities_.length = 0;\n    clear$1(this.queuedElements_);\n  };\n  PriorityQueue2.prototype.dequeue = function() {\n    var elements2 = this.elements_;\n    var priorities = this.priorities_;\n    var element = elements2[0];\n    if (elements2.length == 1) {\n      elements2.length = 0;\n      priorities.length = 0;\n    } else {\n      elements2[0] = elements2.pop();\n      priorities[0] = priorities.pop();\n      this.siftUp_(0);\n    }\n    var elementKey = this.keyFunction_(element);\n    delete this.queuedElements_[elementKey];\n    return element;\n  };\n  PriorityQueue2.prototype.enqueue = function(element) {\n    assert(!(this.keyFunction_(element) in this.queuedElements_), 31);\n    var priority = this.priorityFunction_(element);\n    if (priority != DROP) {\n      this.elements_.push(element);\n      this.priorities_.push(priority);\n      this.queuedElements_[this.keyFunction_(element)] = true;\n      this.siftDown_(0, this.elements_.length - 1);\n      return true;\n    }\n    return false;\n  };\n  PriorityQueue2.prototype.getCount = function() {\n    return this.elements_.length;\n  };\n  PriorityQueue2.prototype.getLeftChildIndex_ = function(index2) {\n    return index2 * 2 + 1;\n  };\n  PriorityQueue2.prototype.getRightChildIndex_ = function(index2) {\n    return index2 * 2 + 2;\n  };\n  PriorityQueue2.prototype.getParentIndex_ = function(index2) {\n    return index2 - 1 >> 1;\n  };\n  PriorityQueue2.prototype.heapify_ = function() {\n    var i2;\n    for (i2 = (this.elements_.length >> 1) - 1; i2 >= 0; i2--) {\n      this.siftUp_(i2);\n    }\n  };\n  PriorityQueue2.prototype.isEmpty = function() {\n    return this.elements_.length === 0;\n  };\n  PriorityQueue2.prototype.isKeyQueued = function(key) {\n    return key in this.queuedElements_;\n  };\n  PriorityQueue2.prototype.isQueued = function(element) {\n    return this.isKeyQueued(this.keyFunction_(element));\n  };\n  PriorityQueue2.prototype.siftUp_ = function(index2) {\n    var elements2 = this.elements_;\n    var priorities = this.priorities_;\n    var count = elements2.length;\n    var element = elements2[index2];\n    var priority = priorities[index2];\n    var startIndex = index2;\n    while (index2 < count >> 1) {\n      var lIndex = this.getLeftChildIndex_(index2);\n      var rIndex = this.getRightChildIndex_(index2);\n      var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;\n      elements2[index2] = elements2[smallerChildIndex];\n      priorities[index2] = priorities[smallerChildIndex];\n      index2 = smallerChildIndex;\n    }\n    elements2[index2] = element;\n    priorities[index2] = priority;\n    this.siftDown_(startIndex, index2);\n  };\n  PriorityQueue2.prototype.siftDown_ = function(startIndex, index2) {\n    var elements2 = this.elements_;\n    var priorities = this.priorities_;\n    var element = elements2[index2];\n    var priority = priorities[index2];\n    while (index2 > startIndex) {\n      var parentIndex = this.getParentIndex_(index2);\n      if (priorities[parentIndex] > priority) {\n        elements2[index2] = elements2[parentIndex];\n        priorities[index2] = priorities[parentIndex];\n        index2 = parentIndex;\n      } else {\n        break;\n      }\n    }\n    elements2[index2] = element;\n    priorities[index2] = priority;\n  };\n  PriorityQueue2.prototype.reprioritize = function() {\n    var priorityFunction = this.priorityFunction_;\n    var elements2 = this.elements_;\n    var priorities = this.priorities_;\n    var index2 = 0;\n    var n2 = elements2.length;\n    var element, i2, priority;\n    for (i2 = 0; i2 < n2; ++i2) {\n      element = elements2[i2];\n      priority = priorityFunction(element);\n      if (priority == DROP) {\n        delete this.queuedElements_[this.keyFunction_(element)];\n      } else {\n        priorities[index2] = priority;\n        elements2[index2++] = element;\n      }\n    }\n    elements2.length = index2;\n    priorities.length = index2;\n    this.heapify_();\n  };\n  return PriorityQueue2;\n}();\nvar PriorityQueue$1 = PriorityQueue;\nvar TileState = {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  ERROR: 3,\n  EMPTY: 4\n};\nvar __extends$20 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TileQueue = function(_super) {\n  __extends$20(TileQueue2, _super);\n  function TileQueue2(tilePriorityFunction, tileChangeCallback) {\n    var _this = _super.call(this, function(element) {\n      return tilePriorityFunction.apply(null, element);\n    }, function(element) {\n      return element[0].getKey();\n    }) || this;\n    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);\n    _this.tileChangeCallback_ = tileChangeCallback;\n    _this.tilesLoading_ = 0;\n    _this.tilesLoadingKeys_ = {};\n    return _this;\n  }\n  TileQueue2.prototype.enqueue = function(element) {\n    var added = _super.prototype.enqueue.call(this, element);\n    if (added) {\n      var tile2 = element[0];\n      tile2.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n    }\n    return added;\n  };\n  TileQueue2.prototype.getTilesLoading = function() {\n    return this.tilesLoading_;\n  };\n  TileQueue2.prototype.handleTileChange = function(event) {\n    var tile2 = event.target;\n    var state = tile2.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {\n      tile2.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n      var tileKey = tile2.getKey();\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n      this.tileChangeCallback_();\n    }\n  };\n  TileQueue2.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {\n    var newLoads = 0;\n    var state, tile2, tileKey;\n    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {\n      tile2 = this.dequeue()[0];\n      tileKey = tile2.getKey();\n      state = tile2.getState();\n      if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile2.load();\n      }\n    }\n  };\n  return TileQueue2;\n}(PriorityQueue$1);\nvar TileQueue$1 = TileQueue;\nfunction getTilePriority(frameState, tile2, tileSourceKey, tileCenter, tileResolution) {\n  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n    return DROP;\n  }\n  if (!frameState.wantedTiles[tileSourceKey][tile2.getKey()]) {\n    return DROP;\n  }\n  var center = frameState.viewState.center;\n  var deltaX = tileCenter[0] - center[0];\n  var deltaY = tileCenter[1] - center[1];\n  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n}\nvar GeometryType = {\n  POINT: \"Point\",\n  LINE_STRING: \"LineString\",\n  LINEAR_RING: \"LinearRing\",\n  POLYGON: \"Polygon\",\n  MULTI_POINT: \"MultiPoint\",\n  MULTI_LINE_STRING: \"MultiLineString\",\n  MULTI_POLYGON: \"MultiPolygon\",\n  GEOMETRY_COLLECTION: \"GeometryCollection\",\n  CIRCLE: \"Circle\"\n};\nvar Units$1 = {\n  RADIANS: \"radians\",\n  DEGREES: \"degrees\",\n  FEET: \"ft\",\n  METERS: \"m\",\n  PIXELS: \"pixels\",\n  TILE_PIXELS: \"tile-pixels\",\n  USFEET: \"us-ft\"\n};\nvar METERS_PER_UNIT$1 = {};\nMETERS_PER_UNIT$1[Units$1.RADIANS] = 6370997 / (2 * Math.PI);\nMETERS_PER_UNIT$1[Units$1.DEGREES] = 2 * Math.PI * 6370997 / 360;\nMETERS_PER_UNIT$1[Units$1.FEET] = 0.3048;\nMETERS_PER_UNIT$1[Units$1.METERS] = 1;\nMETERS_PER_UNIT$1[Units$1.USFEET] = 1200 / 3937;\nvar Units$2 = Units$1;\nvar ViewHint = {\n  ANIMATING: 0,\n  INTERACTING: 1\n};\nvar ViewProperty = {\n  CENTER: \"center\",\n  RESOLUTION: \"resolution\",\n  ROTATION: \"rotation\"\n};\nvar DEFAULT_MAX_ZOOM = 42;\nvar DEFAULT_TILE_SIZE = 256;\nvar Projection$2 = function() {\n  function Projection2(options) {\n    this.code_ = options.code;\n    this.units_ = options.units;\n    this.extent_ = options.extent !== void 0 ? options.extent : null;\n    this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;\n    this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : \"enu\";\n    this.global_ = options.global !== void 0 ? options.global : false;\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n    this.getPointResolutionFunc_ = options.getPointResolution;\n    this.defaultTileGrid_ = null;\n    this.metersPerUnit_ = options.metersPerUnit;\n  }\n  Projection2.prototype.canWrapX = function() {\n    return this.canWrapX_;\n  };\n  Projection2.prototype.getCode = function() {\n    return this.code_;\n  };\n  Projection2.prototype.getExtent = function() {\n    return this.extent_;\n  };\n  Projection2.prototype.getUnits = function() {\n    return this.units_;\n  };\n  Projection2.prototype.getMetersPerUnit = function() {\n    return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];\n  };\n  Projection2.prototype.getWorldExtent = function() {\n    return this.worldExtent_;\n  };\n  Projection2.prototype.getAxisOrientation = function() {\n    return this.axisOrientation_;\n  };\n  Projection2.prototype.isGlobal = function() {\n    return this.global_;\n  };\n  Projection2.prototype.setGlobal = function(global2) {\n    this.global_ = global2;\n    this.canWrapX_ = !!(global2 && this.extent_);\n  };\n  Projection2.prototype.getDefaultTileGrid = function() {\n    return this.defaultTileGrid_;\n  };\n  Projection2.prototype.setDefaultTileGrid = function(tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  };\n  Projection2.prototype.setExtent = function(extent2) {\n    this.extent_ = extent2;\n    this.canWrapX_ = !!(this.global_ && extent2);\n  };\n  Projection2.prototype.setWorldExtent = function(worldExtent) {\n    this.worldExtent_ = worldExtent;\n  };\n  Projection2.prototype.setGetPointResolution = function(func) {\n    this.getPointResolutionFunc_ = func;\n  };\n  Projection2.prototype.getPointResolutionFunc = function() {\n    return this.getPointResolutionFunc_;\n  };\n  return Projection2;\n}();\nvar Projection$3 = Projection$2;\nvar __extends$1$ = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar RADIUS$1 = 6378137;\nvar HALF_SIZE = Math.PI * RADIUS$1;\nvar EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\nvar WORLD_EXTENT = [-180, -85, 180, 85];\nvar MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));\nvar EPSG3857Projection = function(_super) {\n  __extends$1$(EPSG3857Projection2, _super);\n  function EPSG3857Projection2(code) {\n    return _super.call(this, {\n      code,\n      units: Units$2.METERS,\n      extent: EXTENT$1,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function(resolution, point) {\n        return resolution / cosh$1(point[1] / RADIUS$1);\n      }\n    }) || this;\n  }\n  return EPSG3857Projection2;\n}(Projection$3);\nvar PROJECTIONS$1 = [\n  new EPSG3857Projection(\"EPSG:3857\"),\n  new EPSG3857Projection(\"EPSG:102100\"),\n  new EPSG3857Projection(\"EPSG:102113\"),\n  new EPSG3857Projection(\"EPSG:900913\"),\n  new EPSG3857Projection(\"http://www.opengis.net/def/crs/EPSG/0/3857\"),\n  new EPSG3857Projection(\"http://www.opengis.net/gml/srs/epsg.xml#3857\")\n];\nfunction fromEPSG4326(input, opt_output, opt_dimension) {\n  var length = input.length;\n  var dimension = opt_dimension > 1 ? opt_dimension : 2;\n  var output = opt_output;\n  if (output === void 0) {\n    if (dimension > 2) {\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (var i2 = 0; i2 < length; i2 += dimension) {\n    output[i2] = HALF_SIZE * input[i2] / 180;\n    var y2 = RADIUS$1 * Math.log(Math.tan(Math.PI * (+input[i2 + 1] + 90) / 360));\n    if (y2 > MAX_SAFE_Y) {\n      y2 = MAX_SAFE_Y;\n    } else if (y2 < -MAX_SAFE_Y) {\n      y2 = -MAX_SAFE_Y;\n    }\n    output[i2 + 1] = y2;\n  }\n  return output;\n}\nfunction toEPSG4326(input, opt_output, opt_dimension) {\n  var length = input.length;\n  var dimension = opt_dimension > 1 ? opt_dimension : 2;\n  var output = opt_output;\n  if (output === void 0) {\n    if (dimension > 2) {\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (var i2 = 0; i2 < length; i2 += dimension) {\n    output[i2] = 180 * input[i2] / HALF_SIZE;\n    output[i2 + 1] = 360 * Math.atan(Math.exp(input[i2 + 1] / RADIUS$1)) / Math.PI - 90;\n  }\n  return output;\n}\nvar __extends$1_ = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar RADIUS = 6378137;\nvar EXTENT = [-180, -90, 180, 90];\nvar METERS_PER_UNIT = Math.PI * RADIUS / 180;\nvar EPSG4326Projection = function(_super) {\n  __extends$1_(EPSG4326Projection2, _super);\n  function EPSG4326Projection2(code, opt_axisOrientation) {\n    return _super.call(this, {\n      code,\n      units: Units$2.DEGREES,\n      extent: EXTENT,\n      axisOrientation: opt_axisOrientation,\n      global: true,\n      metersPerUnit: METERS_PER_UNIT,\n      worldExtent: EXTENT\n    }) || this;\n  }\n  return EPSG4326Projection2;\n}(Projection$3);\nvar PROJECTIONS = [\n  new EPSG4326Projection(\"CRS:84\"),\n  new EPSG4326Projection(\"EPSG:4326\", \"neu\"),\n  new EPSG4326Projection(\"urn:ogc:def:crs:OGC:1.3:CRS84\"),\n  new EPSG4326Projection(\"urn:ogc:def:crs:OGC:2:84\"),\n  new EPSG4326Projection(\"http://www.opengis.net/def/crs/OGC/1.3/CRS84\"),\n  new EPSG4326Projection(\"http://www.opengis.net/gml/srs/epsg.xml#4326\", \"neu\"),\n  new EPSG4326Projection(\"http://www.opengis.net/def/crs/EPSG/0/4326\", \"neu\")\n];\nvar cache = {};\nfunction get$5(code) {\n  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, \"EPSG:$3\")] || null;\n}\nfunction add$2(code, projection) {\n  cache[code] = projection;\n}\nvar transforms = {};\nfunction add$1(source, destination, transformFn) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\nfunction get$4(sourceCode, destinationCode) {\n  var transform2;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform2 = transforms[sourceCode][destinationCode];\n  }\n  return transform2;\n}\nvar DEFAULT_RADIUS = 63710088e-1;\nfunction getDistance(c1, c2, opt_radius) {\n  var radius = opt_radius || DEFAULT_RADIUS;\n  var lat1 = toRadians(c1[1]);\n  var lat2 = toRadians(c2[1]);\n  var deltaLatBy2 = (lat2 - lat1) / 2;\n  var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  var a2 = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));\n}\nfunction offset(c1, distance2, bearing, opt_radius) {\n  var radius = opt_radius || DEFAULT_RADIUS;\n  var lat1 = toRadians(c1[1]);\n  var lon1 = toRadians(c1[0]);\n  var dByR = distance2 / radius;\n  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [toDegrees(lon), toDegrees(lat)];\n}\nvar showCoordinateWarning = true;\nfunction disableCoordinateWarning(opt_disable) {\n  var hide = opt_disable === void 0 ? true : opt_disable;\n  showCoordinateWarning = !hide;\n}\nfunction cloneTransform(input, opt_output, opt_dimension) {\n  var output;\n  if (opt_output !== void 0) {\n    for (var i2 = 0, ii = input.length; i2 < ii; ++i2) {\n      opt_output[i2] = input[i2];\n    }\n    output = opt_output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\nfunction identityTransform(input, opt_output, opt_dimension) {\n  if (opt_output !== void 0 && input !== opt_output) {\n    for (var i2 = 0, ii = input.length; i2 < ii; ++i2) {\n      opt_output[i2] = input[i2];\n    }\n    input = opt_output;\n  }\n  return input;\n}\nfunction addProjection(projection) {\n  add$2(projection.getCode(), projection);\n  add$1(projection, projection, cloneTransform);\n}\nfunction addProjections(projections2) {\n  projections2.forEach(addProjection);\n}\nfunction get$3(projectionLike) {\n  return typeof projectionLike === \"string\" ? get$5(projectionLike) : projectionLike || null;\n}\nfunction getPointResolution(projection, resolution, point, opt_units) {\n  projection = get$3(projection);\n  var pointResolution;\n  var getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (opt_units && opt_units !== projection.getUnits()) {\n      var metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT$1[opt_units];\n      }\n    }\n  } else {\n    var units2 = projection.getUnits();\n    if (units2 == Units$2.DEGREES && !opt_units || opt_units == Units$2.DEGREES) {\n      pointResolution = resolution;\n    } else {\n      var toEPSG4326_1 = getTransformFromProjections(projection, get$3(\"EPSG:4326\"));\n      if (toEPSG4326_1 === identityTransform && units2 !== Units$2.DEGREES) {\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        var vertices = [\n          point[0] - resolution / 2,\n          point[1],\n          point[0] + resolution / 2,\n          point[1],\n          point[0],\n          point[1] - resolution / 2,\n          point[0],\n          point[1] + resolution / 2\n        ];\n        vertices = toEPSG4326_1(vertices, vertices, 2);\n        var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      var metersPerUnit = opt_units ? METERS_PER_UNIT$1[opt_units] : projection.getMetersPerUnit();\n      if (metersPerUnit !== void 0) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\nfunction addEquivalentProjections(projections2) {\n  addProjections(projections2);\n  projections2.forEach(function(source) {\n    projections2.forEach(function(destination) {\n      if (source !== destination) {\n        add$1(source, destination, cloneTransform);\n      }\n    });\n  });\n}\nfunction addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function(projection1) {\n    projections2.forEach(function(projection2) {\n      add$1(projection1, projection2, forwardTransform);\n      add$1(projection2, projection1, inverseTransform);\n    });\n  });\n}\nfunction createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get$3(defaultCode);\n  } else if (typeof projection === \"string\") {\n    return get$3(projection);\n  } else {\n    return projection;\n  }\n}\nfunction createTransformFromCoordinateTransform(coordTransform) {\n  return function(input, opt_output, opt_dimension) {\n    var length = input.length;\n    var dimension = opt_dimension !== void 0 ? opt_dimension : 2;\n    var output = opt_output !== void 0 ? opt_output : new Array(length);\n    for (var i2 = 0; i2 < length; i2 += dimension) {\n      var point = coordTransform([input[i2], input[i2 + 1]]);\n      output[i2] = point[0];\n      output[i2 + 1] = point[1];\n      for (var j2 = dimension - 1; j2 >= 2; --j2) {\n        output[i2 + j2] = input[i2 + j2];\n      }\n    }\n    return output;\n  };\n}\nfunction addCoordinateTransforms(source, destination, forward2, inverse2) {\n  var sourceProj = get$3(source);\n  var destProj = get$3(destination);\n  add$1(sourceProj, destProj, createTransformFromCoordinateTransform(forward2));\n  add$1(destProj, sourceProj, createTransformFromCoordinateTransform(inverse2));\n}\nfunction equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  var equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    var transformFunc = getTransformFromProjections(projection1, projection2);\n    return transformFunc === cloneTransform && equalUnits;\n  }\n}\nfunction getTransformFromProjections(sourceProjection, destinationProjection) {\n  var sourceCode = sourceProjection.getCode();\n  var destinationCode = destinationProjection.getCode();\n  var transformFunc = get$4(sourceCode, destinationCode);\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n  return transformFunc;\n}\nfunction getTransform(source, destination) {\n  var sourceProjection = get$3(source);\n  var destinationProjection = get$3(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\nfunction transform$3(coordinate, source, destination) {\n  var transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, void 0, coordinate.length);\n}\nfunction transformExtent(extent2, source, destination, opt_stops) {\n  var transformFunc = getTransform(source, destination);\n  return applyTransform(extent2, transformFunc, void 0, opt_stops);\n}\nvar userProjection = null;\nfunction getUserProjection() {\n  return userProjection;\n}\nfunction toUserCoordinate(coordinate, sourceProjection) {\n  {\n    return coordinate;\n  }\n}\nfunction fromUserCoordinate(coordinate, destProjection) {\n  {\n    if (showCoordinateWarning && !equals(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {\n      showCoordinateWarning = false;\n      console.warn(\"Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.\");\n    }\n    return coordinate;\n  }\n}\nfunction toUserExtent(extent2, sourceProjection) {\n  {\n    return extent2;\n  }\n}\nfunction fromUserExtent(extent2, destProjection) {\n  {\n    return extent2;\n  }\n}\nfunction fromUserResolution(resolution, destProjection) {\n  {\n    return resolution;\n  }\n}\nfunction createSafeCoordinateTransform(sourceProj, destProj, transform2) {\n  return function(coord) {\n    var sourceX = coord[0];\n    var sourceY = coord[1];\n    var transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      var sourceExtent = sourceProj.getExtent();\n      var sourceExtentWidth = getWidth(sourceExtent);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        sourceX = sourceX - worldsAway * sourceExtentWidth;\n      }\n      sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);\n      sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);\n      transformed = transform2([sourceX, sourceY]);\n    } else {\n      transformed = transform2(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\nfunction addCommon() {\n  addEquivalentProjections(PROJECTIONS$1);\n  addEquivalentProjections(PROJECTIONS);\n  addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326);\n}\naddCommon();\nfunction createExtent(extent2, onlyCenter, smooth) {\n  return function(center, resolution, size, opt_isMoving, opt_centerShift) {\n    if (!center) {\n      return void 0;\n    }\n    if (!resolution && !onlyCenter) {\n      return center;\n    }\n    var viewWidth = onlyCenter ? 0 : size[0] * resolution;\n    var viewHeight = onlyCenter ? 0 : size[1] * resolution;\n    var shiftX = opt_centerShift ? opt_centerShift[0] : 0;\n    var shiftY = opt_centerShift ? opt_centerShift[1] : 0;\n    var minX = extent2[0] + viewWidth / 2 + shiftX;\n    var maxX = extent2[2] - viewWidth / 2 + shiftX;\n    var minY = extent2[1] + viewHeight / 2 + shiftY;\n    var maxY = extent2[3] - viewHeight / 2 + shiftY;\n    if (minX > maxX) {\n      minX = (maxX + minX) / 2;\n      maxX = minX;\n    }\n    if (minY > maxY) {\n      minY = (maxY + minY) / 2;\n      maxY = minY;\n    }\n    var x2 = clamp(center[0], minX, maxX);\n    var y2 = clamp(center[1], minY, maxY);\n    if (opt_isMoving && smooth && resolution) {\n      var ratio = 30 * resolution;\n      x2 += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\n      y2 += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\n    }\n    return [x2, y2];\n  };\n}\nfunction none$1(center) {\n  return center;\n}\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n  var xResolution = getWidth(maxExtent) / viewportSize[0];\n  var yResolution = getHeight(maxExtent) / viewportSize[1];\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  var result = Math.min(resolution, maxResolution);\n  var ratio = 50;\n  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\nfunction createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return function(resolution, direction2, size, opt_isMoving) {\n    if (resolution !== void 0) {\n      var maxResolution = resolutions[0];\n      var minResolution = resolutions[resolutions.length - 1];\n      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n      if (opt_isMoving) {\n        var smooth = opt_smooth !== void 0 ? opt_smooth : true;\n        if (!smooth) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      }\n      var capped = Math.min(cappedMaxRes, resolution);\n      var z2 = Math.floor(linearFindNearest(resolutions, capped, direction2));\n      if (resolutions[z2] > cappedMaxRes && z2 < resolutions.length - 1) {\n        return resolutions[z2 + 1];\n      }\n      return resolutions[z2];\n    } else {\n      return void 0;\n    }\n  };\n}\nfunction createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return function(resolution, direction2, size, opt_isMoving) {\n    if (resolution !== void 0) {\n      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n      var minResolution = opt_minResolution !== void 0 ? opt_minResolution : 0;\n      if (opt_isMoving) {\n        var smooth = opt_smooth !== void 0 ? opt_smooth : true;\n        if (!smooth) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      }\n      var tolerance = 1e-9;\n      var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n      var offset2 = -direction2 * (0.5 - tolerance) + 0.5;\n      var capped = Math.min(cappedMaxRes, resolution);\n      var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset2);\n      var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n      var newResolution = maxResolution / Math.pow(power, zoomLevel);\n      return clamp(newResolution, minResolution, cappedMaxRes);\n    } else {\n      return void 0;\n    }\n  };\n}\nfunction createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n  return function(resolution, direction2, size, opt_isMoving) {\n    if (resolution !== void 0) {\n      var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;\n      var smooth = opt_smooth !== void 0 ? opt_smooth : true;\n      if (!smooth || !opt_isMoving) {\n        return clamp(resolution, minResolution, cappedMaxRes);\n      }\n      return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n    } else {\n      return void 0;\n    }\n  };\n}\nfunction disable(rotation) {\n  if (rotation !== void 0) {\n    return 0;\n  } else {\n    return void 0;\n  }\n}\nfunction none(rotation) {\n  if (rotation !== void 0) {\n    return rotation;\n  } else {\n    return void 0;\n  }\n}\nfunction createSnapToN(n2) {\n  var theta = 2 * Math.PI / n2;\n  return function(rotation, opt_isMoving) {\n    if (opt_isMoving) {\n      return rotation;\n    }\n    if (rotation !== void 0) {\n      rotation = Math.floor(rotation / theta + 0.5) * theta;\n      return rotation;\n    } else {\n      return void 0;\n    }\n  };\n}\nfunction createSnapToZero(opt_tolerance) {\n  var tolerance = opt_tolerance || toRadians(5);\n  return function(rotation, opt_isMoving) {\n    if (opt_isMoving) {\n      return rotation;\n    }\n    if (rotation !== void 0) {\n      if (Math.abs(rotation) <= tolerance) {\n        return 0;\n      } else {\n        return rotation;\n      }\n    } else {\n      return void 0;\n    }\n  };\n}\nfunction easeIn(t3) {\n  return Math.pow(t3, 3);\n}\nfunction easeOut(t3) {\n  return 1 - easeIn(1 - t3);\n}\nfunction inAndOut(t3) {\n  return 3 * t3 * t3 - 2 * t3 * t3 * t3;\n}\nfunction linear(t3) {\n  return t3;\n}\nfunction upAndDown(t3) {\n  if (t3 < 0.5) {\n    return inAndOut(2 * t3);\n  } else {\n    return 1 - inAndOut(2 * (t3 - 0.5));\n  }\n}\nvar animations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  easeIn,\n  easeOut,\n  inAndOut,\n  linear,\n  upAndDown\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar GeometryLayout = {\n  XY: \"XY\",\n  XYZ: \"XYZ\",\n  XYM: \"XYM\",\n  XYZM: \"XYZM\"\n};\nfunction transform2D(flatCoordinates, offset2, end, stride, transform2, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i2 = 0;\n  for (var j2 = offset2; j2 < end; j2 += stride) {\n    var x2 = flatCoordinates[j2];\n    var y2 = flatCoordinates[j2 + 1];\n    dest[i2++] = transform2[0] * x2 + transform2[2] * y2 + transform2[4];\n    dest[i2++] = transform2[1] * x2 + transform2[3] * y2 + transform2[5];\n  }\n  if (opt_dest && dest.length != i2) {\n    dest.length = i2;\n  }\n  return dest;\n}\nfunction rotate(flatCoordinates, offset2, end, stride, angle2, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var cos = Math.cos(angle2);\n  var sin = Math.sin(angle2);\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i2 = 0;\n  for (var j2 = offset2; j2 < end; j2 += stride) {\n    var deltaX = flatCoordinates[j2] - anchorX;\n    var deltaY = flatCoordinates[j2 + 1] - anchorY;\n    dest[i2++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i2++] = anchorY + deltaX * sin + deltaY * cos;\n    for (var k2 = j2 + 2; k2 < j2 + stride; ++k2) {\n      dest[i2++] = flatCoordinates[k2];\n    }\n  }\n  if (opt_dest && dest.length != i2) {\n    dest.length = i2;\n  }\n  return dest;\n}\nfunction scale$1(flatCoordinates, offset2, end, stride, sx, sy, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i2 = 0;\n  for (var j2 = offset2; j2 < end; j2 += stride) {\n    var deltaX = flatCoordinates[j2] - anchorX;\n    var deltaY = flatCoordinates[j2 + 1] - anchorY;\n    dest[i2++] = anchorX + sx * deltaX;\n    dest[i2++] = anchorY + sy * deltaY;\n    for (var k2 = j2 + 2; k2 < j2 + stride; ++k2) {\n      dest[i2++] = flatCoordinates[k2];\n    }\n  }\n  if (opt_dest && dest.length != i2) {\n    dest.length = i2;\n  }\n  return dest;\n}\nfunction translate(flatCoordinates, offset2, end, stride, deltaX, deltaY, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i2 = 0;\n  for (var j2 = offset2; j2 < end; j2 += stride) {\n    dest[i2++] = flatCoordinates[j2] + deltaX;\n    dest[i2++] = flatCoordinates[j2 + 1] + deltaY;\n    for (var k2 = j2 + 2; k2 < j2 + stride; ++k2) {\n      dest[i2++] = flatCoordinates[k2];\n    }\n  }\n  if (opt_dest && dest.length != i2) {\n    dest.length = i2;\n  }\n  return dest;\n}\nvar __extends$1Z = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar tmpTransform$1 = create$6();\nvar Geometry = function(_super) {\n  __extends$1Z(Geometry2, _super);\n  function Geometry2() {\n    var _this = _super.call(this) || this;\n    _this.extent_ = createEmpty();\n    _this.extentRevision_ = -1;\n    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n    _this.simplifiedGeometryRevision = 0;\n    _this.simplifyTransformedInternal = memoizeOne(function(revision, squaredTolerance, opt_transform) {\n      if (!opt_transform) {\n        return this.getSimplifiedGeometry(squaredTolerance);\n      }\n      var clone2 = this.clone();\n      clone2.applyTransform(opt_transform);\n      return clone2.getSimplifiedGeometry(squaredTolerance);\n    });\n    return _this;\n  }\n  Geometry2.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {\n    return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);\n  };\n  Geometry2.prototype.clone = function() {\n    return abstract();\n  };\n  Geometry2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    return abstract();\n  };\n  Geometry2.prototype.containsXY = function(x2, y2) {\n    var coord = this.getClosestPoint([x2, y2]);\n    return coord[0] === x2 && coord[1] === y2;\n  };\n  Geometry2.prototype.getClosestPoint = function(point, opt_closestPoint) {\n    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  };\n  Geometry2.prototype.intersectsCoordinate = function(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  };\n  Geometry2.prototype.computeExtent = function(extent2) {\n    return abstract();\n  };\n  Geometry2.prototype.getExtent = function(opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      var extent2 = this.computeExtent(this.extent_);\n      if (isNaN(extent2[0]) || isNaN(extent2[1])) {\n        createOrUpdateEmpty(extent2);\n      }\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, opt_extent);\n  };\n  Geometry2.prototype.rotate = function(angle2, anchor) {\n    abstract();\n  };\n  Geometry2.prototype.scale = function(sx, opt_sy, opt_anchor) {\n    abstract();\n  };\n  Geometry2.prototype.simplify = function(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  };\n  Geometry2.prototype.getSimplifiedGeometry = function(squaredTolerance) {\n    return abstract();\n  };\n  Geometry2.prototype.getType = function() {\n    return abstract();\n  };\n  Geometry2.prototype.applyTransform = function(transformFn) {\n    abstract();\n  };\n  Geometry2.prototype.intersectsExtent = function(extent2) {\n    return abstract();\n  };\n  Geometry2.prototype.translate = function(deltaX, deltaY) {\n    abstract();\n  };\n  Geometry2.prototype.transform = function(source, destination) {\n    var sourceProj = get$3(source);\n    var transformFn = sourceProj.getUnits() == Units$2.TILE_PIXELS ? function(inCoordinates, outCoordinates, stride) {\n      var pixelExtent = sourceProj.getExtent();\n      var projectedExtent = sourceProj.getWorldExtent();\n      var scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);\n      compose(tmpTransform$1, projectedExtent[0], projectedExtent[3], scale2, -scale2, 0, 0, 0);\n      transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform$1, outCoordinates);\n      return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n    } : getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  };\n  return Geometry2;\n}(ol_Object);\nvar Geometry$1 = Geometry;\nvar __extends$1Y = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar SimpleGeometry = function(_super) {\n  __extends$1Y(SimpleGeometry2, _super);\n  function SimpleGeometry2() {\n    var _this = _super.call(this) || this;\n    _this.layout = GeometryLayout.XY;\n    _this.stride = 2;\n    _this.flatCoordinates = null;\n    return _this;\n  }\n  SimpleGeometry2.prototype.computeExtent = function(extent2) {\n    return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent2);\n  };\n  SimpleGeometry2.prototype.getCoordinates = function() {\n    return abstract();\n  };\n  SimpleGeometry2.prototype.getFirstCoordinate = function() {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  SimpleGeometry2.prototype.getFlatCoordinates = function() {\n    return this.flatCoordinates;\n  };\n  SimpleGeometry2.prototype.getLastCoordinate = function() {\n    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n  };\n  SimpleGeometry2.prototype.getLayout = function() {\n    return this.layout;\n  };\n  SimpleGeometry2.prototype.getSimplifiedGeometry = function(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {\n      return this;\n    }\n    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    } else {\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n  };\n  SimpleGeometry2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    return this;\n  };\n  SimpleGeometry2.prototype.getStride = function() {\n    return this.stride;\n  };\n  SimpleGeometry2.prototype.setFlatCoordinates = function(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  };\n  SimpleGeometry2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n    abstract();\n  };\n  SimpleGeometry2.prototype.setLayout = function(layout, coordinates2, nesting) {\n    var stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (var i2 = 0; i2 < nesting; ++i2) {\n        if (coordinates2.length === 0) {\n          this.layout = GeometryLayout.XY;\n          this.stride = 2;\n          return;\n        } else {\n          coordinates2 = coordinates2[0];\n        }\n      }\n      stride = coordinates2.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  };\n  SimpleGeometry2.prototype.applyTransform = function(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  };\n  SimpleGeometry2.prototype.rotate = function(angle2, anchor) {\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle2, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  SimpleGeometry2.prototype.scale = function(sx, opt_sy, opt_anchor) {\n    var sy = opt_sy;\n    if (sy === void 0) {\n      sy = sx;\n    }\n    var anchor = opt_anchor;\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      scale$1(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  SimpleGeometry2.prototype.translate = function(deltaX, deltaY) {\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n      this.changed();\n    }\n  };\n  return SimpleGeometry2;\n}(Geometry$1);\nfunction getLayoutForStride(stride) {\n  var layout;\n  if (stride == 2) {\n    layout = GeometryLayout.XY;\n  } else if (stride == 3) {\n    layout = GeometryLayout.XYZ;\n  } else if (stride == 4) {\n    layout = GeometryLayout.XYZM;\n  }\n  return layout;\n}\nfunction getStrideForLayout(layout) {\n  var stride;\n  if (layout == GeometryLayout.XY) {\n    stride = 2;\n  } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\n    stride = 3;\n  } else if (layout == GeometryLayout.XYZM) {\n    stride = 4;\n  }\n  return stride;\n}\nfunction transformGeom2D(simpleGeometry, transform2, opt_dest) {\n  var flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  } else {\n    var stride = simpleGeometry.getStride();\n    return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform2, opt_dest);\n  }\n}\nvar SimpleGeometry$1 = SimpleGeometry;\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x2, y2, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var offset3;\n  if (dx === 0 && dy === 0) {\n    offset3 = offset1;\n  } else {\n    var t3 = ((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy);\n    if (t3 > 1) {\n      offset3 = offset2;\n    } else if (t3 > 0) {\n      for (var i2 = 0; i2 < stride; ++i2) {\n        closestPoint[i2] = lerp$1(flatCoordinates[offset1 + i2], flatCoordinates[offset2 + i2], t3);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset3 = offset1;\n    }\n  }\n  for (var i2 = 0; i2 < stride; ++i2) {\n    closestPoint[i2] = flatCoordinates[offset3 + i2];\n  }\n  closestPoint.length = stride;\n}\nfunction maxSquaredDelta(flatCoordinates, offset2, end, stride, max2) {\n  var x1 = flatCoordinates[offset2];\n  var y1 = flatCoordinates[offset2 + 1];\n  for (offset2 += stride; offset2 < end; offset2 += stride) {\n    var x2 = flatCoordinates[offset2];\n    var y2 = flatCoordinates[offset2 + 1];\n    var squaredDelta = squaredDistance$1(x1, y1, x2, y2);\n    if (squaredDelta > max2) {\n      max2 = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max2;\n}\nfunction arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max2) {\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    max2 = maxSquaredDelta(flatCoordinates, offset2, end, stride, max2);\n    offset2 = end;\n  }\n  return max2;\n}\nfunction multiArrayMaxSquaredDelta(flatCoordinates, offset2, endss, stride, max2) {\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    max2 = arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max2);\n    offset2 = ends[ends.length - 1];\n  }\n  return max2;\n}\nfunction assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  if (offset2 == end) {\n    return minSquaredDistance;\n  }\n  var i2, squaredDistance2;\n  if (maxDelta === 0) {\n    squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);\n    if (squaredDistance2 < minSquaredDistance) {\n      for (i2 = 0; i2 < stride; ++i2) {\n        closestPoint[i2] = flatCoordinates[offset2 + i2];\n      }\n      closestPoint.length = stride;\n      return squaredDistance2;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index2 = offset2 + stride;\n  while (index2 < end) {\n    assignClosest(flatCoordinates, index2 - stride, index2, stride, x2, y2, tmpPoint);\n    squaredDistance2 = squaredDistance$1(x2, y2, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance2 < minSquaredDistance) {\n      minSquaredDistance = squaredDistance2;\n      for (i2 = 0; i2 < stride; ++i2) {\n        closestPoint[i2] = tmpPoint[i2];\n      }\n      closestPoint.length = stride;\n      index2 += stride;\n    } else {\n      index2 += stride * Math.max((Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n    }\n  }\n  if (isRing) {\n    assignClosest(flatCoordinates, end - stride, offset2, stride, x2, y2, tmpPoint);\n    squaredDistance2 = squaredDistance$1(x2, y2, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance2 < minSquaredDistance) {\n      minSquaredDistance = squaredDistance2;\n      for (i2 = 0; i2 < stride; ++i2) {\n        closestPoint[i2] = tmpPoint[i2];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\nfunction assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    minSquaredDistance = assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint);\n    offset2 = end;\n  }\n  return minSquaredDistance;\n}\nfunction assignClosestMultiArrayPoint(flatCoordinates, offset2, endss, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint);\n    offset2 = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\nfunction deflateCoordinate(flatCoordinates, offset2, coordinate, stride) {\n  for (var i2 = 0, ii = coordinate.length; i2 < ii; ++i2) {\n    flatCoordinates[offset2++] = coordinate[i2];\n  }\n  return offset2;\n}\nfunction deflateCoordinates(flatCoordinates, offset2, coordinates2, stride) {\n  for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {\n    var coordinate = coordinates2[i2];\n    for (var j2 = 0; j2 < stride; ++j2) {\n      flatCoordinates[offset2++] = coordinate[j2];\n    }\n  }\n  return offset2;\n}\nfunction deflateCoordinatesArray(flatCoordinates, offset2, coordinatess, stride, opt_ends) {\n  var ends = opt_ends ? opt_ends : [];\n  var i2 = 0;\n  for (var j2 = 0, jj = coordinatess.length; j2 < jj; ++j2) {\n    var end = deflateCoordinates(flatCoordinates, offset2, coordinatess[j2], stride);\n    ends[i2++] = end;\n    offset2 = end;\n  }\n  ends.length = i2;\n  return ends;\n}\nfunction deflateMultiCoordinatesArray(flatCoordinates, offset2, coordinatesss, stride, opt_endss) {\n  var endss = opt_endss ? opt_endss : [];\n  var i2 = 0;\n  for (var j2 = 0, jj = coordinatesss.length; j2 < jj; ++j2) {\n    var ends = deflateCoordinatesArray(flatCoordinates, offset2, coordinatesss[j2], stride, endss[i2]);\n    endss[i2++] = ends;\n    offset2 = ends[ends.length - 1];\n  }\n  endss.length = i2;\n  return endss;\n}\nfunction douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n2 = (end - offset2) / stride;\n  if (n2 < 3) {\n    for (; offset2 < end; offset2 += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];\n    }\n    return simplifiedOffset;\n  }\n  var markers = new Array(n2);\n  markers[0] = 1;\n  markers[n2 - 1] = 1;\n  var stack = [offset2, end - stride];\n  var index2 = 0;\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n    for (var i2 = first + stride; i2 < last; i2 += stride) {\n      var x3 = flatCoordinates[i2];\n      var y3 = flatCoordinates[i2 + 1];\n      var squaredDistance_1 = squaredSegmentDistance(x3, y3, x1, y1, x2, y2);\n      if (squaredDistance_1 > maxSquaredDistance) {\n        index2 = i2;\n        maxSquaredDistance = squaredDistance_1;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index2 - offset2) / stride] = 1;\n      if (first + stride < index2) {\n        stack.push(first, index2);\n      }\n      if (index2 + stride < last) {\n        stack.push(index2, last);\n      }\n    }\n  }\n  for (var i2 = 0; i2 < n2; ++i2) {\n    if (markers[i2]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i2 * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i2 * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\nfunction douglasPeuckerArray(flatCoordinates, offset2, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    simplifiedOffset = douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset2 = end;\n  }\n  return simplifiedOffset;\n}\nfunction snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\nfunction quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (offset2 == end) {\n    return simplifiedOffset;\n  }\n  var x1 = snap(flatCoordinates[offset2], tolerance);\n  var y1 = snap(flatCoordinates[offset2 + 1], tolerance);\n  offset2 += stride;\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset2], tolerance);\n    y2 = snap(flatCoordinates[offset2 + 1], tolerance);\n    offset2 += stride;\n    if (offset2 == end) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset2 < end) {\n    var x3 = snap(flatCoordinates[offset2], tolerance);\n    var y3 = snap(flatCoordinates[offset2 + 1], tolerance);\n    offset2 += stride;\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1;\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1;\n    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\nfunction quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    simplifiedOffset = quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset2 = end;\n  }\n  return simplifiedOffset;\n}\nfunction quantizeMultiArray(flatCoordinates, offset2, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    var simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset2 = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\nfunction inflateCoordinates(flatCoordinates, offset2, end, stride, opt_coordinates) {\n  var coordinates2 = opt_coordinates !== void 0 ? opt_coordinates : [];\n  var i2 = 0;\n  for (var j2 = offset2; j2 < end; j2 += stride) {\n    coordinates2[i2++] = flatCoordinates.slice(j2, j2 + stride);\n  }\n  coordinates2.length = i2;\n  return coordinates2;\n}\nfunction inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, opt_coordinatess) {\n  var coordinatess = opt_coordinatess !== void 0 ? opt_coordinatess : [];\n  var i2 = 0;\n  for (var j2 = 0, jj = ends.length; j2 < jj; ++j2) {\n    var end = ends[j2];\n    coordinatess[i2++] = inflateCoordinates(flatCoordinates, offset2, end, stride, coordinatess[i2]);\n    offset2 = end;\n  }\n  coordinatess.length = i2;\n  return coordinatess;\n}\nfunction inflateMultiCoordinatesArray(flatCoordinates, offset2, endss, stride, opt_coordinatesss) {\n  var coordinatesss = opt_coordinatesss !== void 0 ? opt_coordinatesss : [];\n  var i2 = 0;\n  for (var j2 = 0, jj = endss.length; j2 < jj; ++j2) {\n    var ends = endss[j2];\n    coordinatesss[i2++] = inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatesss[i2]);\n    offset2 = ends[ends.length - 1];\n  }\n  coordinatesss.length = i2;\n  return coordinatesss;\n}\nfunction linearRing(flatCoordinates, offset2, end, stride) {\n  var twiceArea = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset2 < end; offset2 += stride) {\n    var x2 = flatCoordinates[offset2];\n    var y2 = flatCoordinates[offset2 + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n  return twiceArea / 2;\n}\nfunction linearRings(flatCoordinates, offset2, ends, stride) {\n  var area = 0;\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    area += linearRing(flatCoordinates, offset2, end, stride);\n    offset2 = end;\n  }\n  return area;\n}\nfunction linearRingss$1(flatCoordinates, offset2, endss, stride) {\n  var area = 0;\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    area += linearRings(flatCoordinates, offset2, ends, stride);\n    offset2 = ends[ends.length - 1];\n  }\n  return area;\n}\nvar __extends$1X = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar LinearRing = function(_super) {\n  __extends$1X(LinearRing2, _super);\n  function LinearRing2(coordinates2, opt_layout) {\n    var _this = _super.call(this) || this;\n    _this.maxDelta_ = -1;\n    _this.maxDeltaRevision_ = -1;\n    if (opt_layout !== void 0 && !Array.isArray(coordinates2[0])) {\n      _this.setFlatCoordinates(opt_layout, coordinates2);\n    } else {\n      _this.setCoordinates(coordinates2, opt_layout);\n    }\n    return _this;\n  }\n  LinearRing2.prototype.clone = function() {\n    return new LinearRing2(this.flatCoordinates.slice(), this.layout);\n  };\n  LinearRing2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);\n  };\n  LinearRing2.prototype.getArea = function() {\n    return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  LinearRing2.prototype.getCoordinates = function() {\n    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  LinearRing2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LinearRing2(simplifiedFlatCoordinates, GeometryLayout.XY);\n  };\n  LinearRing2.prototype.getType = function() {\n    return GeometryType.LINEAR_RING;\n  };\n  LinearRing2.prototype.intersectsExtent = function(extent2) {\n    return false;\n  };\n  LinearRing2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n    this.setLayout(opt_layout, coordinates2, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);\n    this.changed();\n  };\n  return LinearRing2;\n}(SimpleGeometry$1);\nvar LinearRing$1 = LinearRing;\nvar __extends$1W = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Point$3 = function(_super) {\n  __extends$1W(Point2, _super);\n  function Point2(coordinates2, opt_layout) {\n    var _this = _super.call(this) || this;\n    _this.setCoordinates(coordinates2, opt_layout);\n    return _this;\n  }\n  Point2.prototype.clone = function() {\n    var point = new Point2(this.flatCoordinates.slice(), this.layout);\n    point.applyProperties(this);\n    return point;\n  };\n  Point2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[0], flatCoordinates[1]);\n    if (squaredDistance2 < minSquaredDistance) {\n      var stride = this.stride;\n      for (var i2 = 0; i2 < stride; ++i2) {\n        closestPoint[i2] = flatCoordinates[i2];\n      }\n      closestPoint.length = stride;\n      return squaredDistance2;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  Point2.prototype.getCoordinates = function() {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  };\n  Point2.prototype.computeExtent = function(extent2) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent2);\n  };\n  Point2.prototype.getType = function() {\n    return GeometryType.POINT;\n  };\n  Point2.prototype.intersectsExtent = function(extent2) {\n    return containsXY(extent2, this.flatCoordinates[0], this.flatCoordinates[1]);\n  };\n  Point2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n    this.setLayout(opt_layout, coordinates2, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates2, this.stride);\n    this.changed();\n  };\n  return Point2;\n}(SimpleGeometry$1);\nvar Point$4 = Point$3;\nfunction linearRingContainsExtent(flatCoordinates, offset2, end, stride, extent2) {\n  var outside = forEachCorner(extent2, function(coordinate) {\n    return !linearRingContainsXY(flatCoordinates, offset2, end, stride, coordinate[0], coordinate[1]);\n  });\n  return !outside;\n}\nfunction linearRingContainsXY(flatCoordinates, offset2, end, stride, x2, y2) {\n  var wn = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset2 < end; offset2 += stride) {\n    var x22 = flatCoordinates[offset2];\n    var y22 = flatCoordinates[offset2 + 1];\n    if (y1 <= y2) {\n      if (y22 > y2 && (x22 - x1) * (y2 - y1) - (x2 - x1) * (y22 - y1) > 0) {\n        wn++;\n      }\n    } else if (y22 <= y2 && (x22 - x1) * (y2 - y1) - (x2 - x1) * (y22 - y1) < 0) {\n      wn--;\n    }\n    x1 = x22;\n    y1 = y22;\n  }\n  return wn !== 0;\n}\nfunction linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y2) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset2, ends[0], stride, x2, y2)) {\n    return false;\n  }\n  for (var i2 = 1, ii = ends.length; i2 < ii; ++i2) {\n    if (linearRingContainsXY(flatCoordinates, ends[i2 - 1], ends[i2], stride, x2, y2)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction linearRingssContainsXY(flatCoordinates, offset2, endss, stride, x2, y2) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y2)) {\n      return true;\n    }\n    offset2 = ends[ends.length - 1];\n  }\n  return false;\n}\nfunction getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n  var i2, ii, x2, x1, x22, y1, y2;\n  var y3 = flatCenters[flatCentersOffset + 1];\n  var intersections = [];\n  for (var r2 = 0, rr = ends.length; r2 < rr; ++r2) {\n    var end = ends[r2];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i2 = offset2; i2 < end; i2 += stride) {\n      x22 = flatCoordinates[i2];\n      y2 = flatCoordinates[i2 + 1];\n      if (y3 <= y1 && y2 <= y3 || y1 <= y3 && y3 <= y2) {\n        x2 = (y3 - y1) / (y2 - y1) * (x22 - x1) + x1;\n        intersections.push(x2);\n      }\n      x1 = x22;\n      y1 = y2;\n    }\n  }\n  var pointX = NaN;\n  var maxSegmentLength = -Infinity;\n  intersections.sort(numberSafeCompareFunction);\n  x1 = intersections[0];\n  for (i2 = 1, ii = intersections.length; i2 < ii; ++i2) {\n    x22 = intersections[i2];\n    var segmentLength = Math.abs(x22 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x2 = (x1 + x22) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y3)) {\n        pointX = x2;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x22;\n  }\n  if (isNaN(pointX)) {\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (opt_dest) {\n    opt_dest.push(pointX, y3, maxSegmentLength);\n    return opt_dest;\n  } else {\n    return [pointX, y3, maxSegmentLength];\n  }\n}\nfunction getInteriorPointsOfMultiArray(flatCoordinates, offset2, endss, stride, flatCenters) {\n  var interiorPoints = [];\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, 2 * i2, interiorPoints);\n    offset2 = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\nfunction forEach(flatCoordinates, offset2, end, stride, callback) {\n  var ret;\n  offset2 += stride;\n  for (; offset2 < end; offset2 += stride) {\n    ret = callback(flatCoordinates.slice(offset2 - stride, offset2), flatCoordinates.slice(offset2, offset2 + stride));\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\nfunction intersectsLineString(flatCoordinates, offset2, end, stride, extent2) {\n  var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset2, end, stride);\n  if (!intersects$1(extent2, coordinatesExtent)) {\n    return false;\n  }\n  if (containsExtent(extent2, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent2[0] && coordinatesExtent[2] <= extent2[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent2[1] && coordinatesExtent[3] <= extent2[3]) {\n    return true;\n  }\n  return forEach(flatCoordinates, offset2, end, stride, function(point1, point2) {\n    return intersectsSegment(extent2, point1, point2);\n  });\n}\nfunction intersectsLineStringArray(flatCoordinates, offset2, ends, stride, extent2) {\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    if (intersectsLineString(flatCoordinates, offset2, ends[i2], stride, extent2)) {\n      return true;\n    }\n    offset2 = ends[i2];\n  }\n  return false;\n}\nfunction intersectsLinearRing(flatCoordinates, offset2, end, stride, extent2) {\n  if (intersectsLineString(flatCoordinates, offset2, end, stride, extent2)) {\n    return true;\n  }\n  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[0], extent2[1])) {\n    return true;\n  }\n  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[0], extent2[3])) {\n    return true;\n  }\n  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[2], extent2[1])) {\n    return true;\n  }\n  if (linearRingContainsXY(flatCoordinates, offset2, end, stride, extent2[2], extent2[3])) {\n    return true;\n  }\n  return false;\n}\nfunction intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent2) {\n  if (!intersectsLinearRing(flatCoordinates, offset2, ends[0], stride, extent2)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (var i2 = 1, ii = ends.length; i2 < ii; ++i2) {\n    if (linearRingContainsExtent(flatCoordinates, ends[i2 - 1], ends[i2], stride, extent2)) {\n      if (!intersectsLineString(flatCoordinates, ends[i2 - 1], ends[i2], stride, extent2)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction intersectsLinearRingMultiArray(flatCoordinates, offset2, endss, stride, extent2) {\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    if (intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent2)) {\n      return true;\n    }\n    offset2 = ends[ends.length - 1];\n  }\n  return false;\n}\nfunction coordinates(flatCoordinates, offset2, end, stride) {\n  while (offset2 < end - stride) {\n    for (var i2 = 0; i2 < stride; ++i2) {\n      var tmp = flatCoordinates[offset2 + i2];\n      flatCoordinates[offset2 + i2] = flatCoordinates[end - stride + i2];\n      flatCoordinates[end - stride + i2] = tmp;\n    }\n    offset2 += stride;\n    end -= stride;\n  }\n}\nfunction linearRingIsClockwise(flatCoordinates, offset2, end, stride) {\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset2 < end; offset2 += stride) {\n    var x2 = flatCoordinates[offset2];\n    var y2 = flatCoordinates[offset2 + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? void 0 : edge > 0;\n}\nfunction linearRingsAreOriented(flatCoordinates, offset2, ends, stride, opt_right) {\n  var right = opt_right !== void 0 ? opt_right : false;\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset2, end, stride);\n    if (i2 === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n    offset2 = end;\n  }\n  return true;\n}\nfunction linearRingssAreOriented(flatCoordinates, offset2, endss, stride, opt_right) {\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    if (!linearRingsAreOriented(flatCoordinates, offset2, ends, stride, opt_right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset2 = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\nfunction orientLinearRings(flatCoordinates, offset2, ends, stride, opt_right) {\n  var right = opt_right !== void 0 ? opt_right : false;\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset2, end, stride);\n    var reverse2 = i2 === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n    if (reverse2) {\n      coordinates(flatCoordinates, offset2, end, stride);\n    }\n    offset2 = end;\n  }\n  return offset2;\n}\nfunction orientLinearRingsArray(flatCoordinates, offset2, endss, stride, opt_right) {\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    offset2 = orientLinearRings(flatCoordinates, offset2, endss[i2], stride, opt_right);\n  }\n  return offset2;\n}\nfunction inflateEnds(flatCoordinates, ends) {\n  var endss = [];\n  var offset2 = 0;\n  var prevEndIndex = 0;\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    if (!linearRingIsClockwise(flatCoordinates, offset2, end, 2)) {\n      endss.push(ends.slice(prevEndIndex, i2 + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i2 + 1;\n    offset2 = end;\n  }\n  return endss;\n}\nvar __extends$1V = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Polygon$1 = function(_super) {\n  __extends$1V(Polygon2, _super);\n  function Polygon2(coordinates2, opt_layout, opt_ends) {\n    var _this = _super.call(this) || this;\n    _this.ends_ = [];\n    _this.flatInteriorPointRevision_ = -1;\n    _this.flatInteriorPoint_ = null;\n    _this.maxDelta_ = -1;\n    _this.maxDeltaRevision_ = -1;\n    _this.orientedRevision_ = -1;\n    _this.orientedFlatCoordinates_ = null;\n    if (opt_layout !== void 0 && opt_ends) {\n      _this.setFlatCoordinates(opt_layout, coordinates2);\n      _this.ends_ = opt_ends;\n    } else {\n      _this.setCoordinates(coordinates2, opt_layout);\n    }\n    return _this;\n  }\n  Polygon2.prototype.appendLinearRing = function(linearRing2) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();\n    } else {\n      extend$3(this.flatCoordinates, linearRing2.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  Polygon2.prototype.clone = function() {\n    var polygon = new Polygon2(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n    polygon.applyProperties(this);\n    return polygon;\n  };\n  Polygon2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);\n  };\n  Polygon2.prototype.containsXY = function(x2, y2) {\n    return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x2, y2);\n  };\n  Polygon2.prototype.getArea = function() {\n    return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n  };\n  Polygon2.prototype.getCoordinates = function(opt_right) {\n    var flatCoordinates;\n    if (opt_right !== void 0) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  };\n  Polygon2.prototype.getEnds = function() {\n    return this.ends_;\n  };\n  Polygon2.prototype.getFlatInteriorPoint = function() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      var flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoint_;\n  };\n  Polygon2.prototype.getInteriorPoint = function() {\n    return new Point$4(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n  };\n  Polygon2.prototype.getLinearRingCount = function() {\n    return this.ends_.length;\n  };\n  Polygon2.prototype.getLinearRing = function(index2) {\n    if (index2 < 0 || this.ends_.length <= index2) {\n      return null;\n    }\n    return new LinearRing$1(this.flatCoordinates.slice(index2 === 0 ? 0 : this.ends_[index2 - 1], this.ends_[index2]), this.layout);\n  };\n  Polygon2.prototype.getLinearRings = function() {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var linearRings2 = [];\n    var offset2 = 0;\n    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n      var end = ends[i2];\n      var linearRing2 = new LinearRing$1(flatCoordinates.slice(offset2, end), layout);\n      linearRings2.push(linearRing2);\n      offset2 = end;\n    }\n    return linearRings2;\n  };\n  Polygon2.prototype.getOrientedFlatCoordinates = function() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n  Polygon2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new Polygon2(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n  Polygon2.prototype.getType = function() {\n    return GeometryType.POLYGON;\n  };\n  Polygon2.prototype.intersectsExtent = function(extent2) {\n    return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent2);\n  };\n  Polygon2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n    this.setLayout(opt_layout, coordinates2, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n  return Polygon2;\n}(SimpleGeometry$1);\nvar Polygon$2 = Polygon$1;\nfunction circular(center, radius, opt_n, opt_sphereRadius) {\n  var n2 = opt_n ? opt_n : 32;\n  var flatCoordinates = [];\n  for (var i2 = 0; i2 < n2; ++i2) {\n    extend$3(flatCoordinates, offset(center, radius, 2 * Math.PI * i2 / n2, opt_sphereRadius));\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon$1(flatCoordinates, GeometryLayout.XY, [\n    flatCoordinates.length\n  ]);\n}\nfunction fromExtent(extent2) {\n  var minX = extent2[0];\n  var minY = extent2[1];\n  var maxX = extent2[2];\n  var maxY = extent2[3];\n  var flatCoordinates = [\n    minX,\n    minY,\n    minX,\n    maxY,\n    maxX,\n    maxY,\n    maxX,\n    minY,\n    minX,\n    minY\n  ];\n  return new Polygon$1(flatCoordinates, GeometryLayout.XY, [\n    flatCoordinates.length\n  ]);\n}\nfunction fromCircle(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var center = circle.getCenter();\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n  for (var i2 = 0; i2 < arrayLength; i2 += stride) {\n    flatCoordinates[i2] = 0;\n    flatCoordinates[i2 + 1] = 0;\n    for (var j2 = 2; j2 < stride; j2++) {\n      flatCoordinates[i2 + j2] = center[j2];\n    }\n  }\n  var ends = [flatCoordinates.length];\n  var polygon = new Polygon$1(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), opt_angle);\n  return polygon;\n}\nfunction makeRegular(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var stride = polygon.getStride();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n  for (var i2 = 0; i2 <= sides; ++i2) {\n    var offset2 = i2 * stride;\n    var angle2 = startAngle + modulo(i2, sides) * 2 * Math.PI / sides;\n    flatCoordinates[offset2] = center[0] + radius * Math.cos(angle2);\n    flatCoordinates[offset2 + 1] = center[1] + radius * Math.sin(angle2);\n  }\n  polygon.changed();\n}\nvar __extends$1U = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DEFAULT_MIN_ZOOM = 0;\nvar View$1 = function(_super) {\n  __extends$1U(View2, _super);\n  function View2(opt_options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    var options = assign({}, opt_options);\n    _this.hints_ = [0, 0];\n    _this.animations_ = [];\n    _this.updateAnimationKey_;\n    _this.projection_ = createProjection(options.projection, \"EPSG:3857\");\n    _this.viewportSize_ = [100, 100];\n    _this.targetCenter_ = null;\n    _this.targetResolution_;\n    _this.targetRotation_;\n    _this.nextCenter_ = null;\n    _this.nextResolution_;\n    _this.nextRotation_;\n    _this.cancelAnchor_ = void 0;\n    if (options.projection) {\n      disableCoordinateWarning();\n    }\n    if (options.center) {\n      options.center = fromUserCoordinate(options.center, _this.projection_);\n    }\n    if (options.extent) {\n      options.extent = fromUserExtent(options.extent, _this.projection_);\n    }\n    _this.applyOptions_(options);\n    return _this;\n  }\n  View2.prototype.applyOptions_ = function(options) {\n    var properties = assign({}, options);\n    for (var key in ViewProperty) {\n      delete properties[key];\n    }\n    this.setProperties(properties, true);\n    var resolutionConstraintInfo = createResolutionConstraint(options);\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n    this.resolutions_ = options.resolutions;\n    this.padding_ = options.padding;\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n    var centerConstraint = createCenterConstraint(options);\n    var resolutionConstraint = resolutionConstraintInfo.constraint;\n    var rotationConstraint = createRotationConstraint(options);\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint\n    };\n    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);\n    this.setCenterInternal(options.center !== void 0 ? options.center : null);\n    if (options.resolution !== void 0) {\n      this.setResolution(options.resolution);\n    } else if (options.zoom !== void 0) {\n      this.setZoom(options.zoom);\n    }\n  };\n  Object.defineProperty(View2.prototype, \"padding\", {\n    get: function() {\n      return this.padding_;\n    },\n    set: function(padding) {\n      var oldPadding = this.padding_;\n      this.padding_ = padding;\n      var center = this.getCenter();\n      if (center) {\n        var newPadding = padding || [0, 0, 0, 0];\n        oldPadding = oldPadding || [0, 0, 0, 0];\n        var resolution = this.getResolution();\n        var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\n        var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\n        this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  View2.prototype.getUpdatedOptions_ = function(newOptions) {\n    var options = this.getProperties();\n    if (options.resolution !== void 0) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    }\n    options.center = this.getCenterInternal();\n    options.rotation = this.getRotation();\n    return assign({}, options, newOptions);\n  };\n  View2.prototype.animate = function(var_args) {\n    if (this.isDef() && !this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n    var args = new Array(arguments.length);\n    for (var i2 = 0; i2 < args.length; ++i2) {\n      var options = arguments[i2];\n      if (options.center) {\n        options = assign({}, options);\n        options.center = fromUserCoordinate(options.center, this.getProjection());\n      }\n      if (options.anchor) {\n        options = assign({}, options);\n        options.anchor = fromUserCoordinate(options.anchor, this.getProjection());\n      }\n      args[i2] = options;\n    }\n    this.animateInternal.apply(this, args);\n  };\n  View2.prototype.animateInternal = function(var_args) {\n    var animationCount = arguments.length;\n    var callback;\n    if (animationCount > 1 && typeof arguments[animationCount - 1] === \"function\") {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n    var i2 = 0;\n    for (; i2 < animationCount && !this.isDef(); ++i2) {\n      var state = arguments[i2];\n      if (state.center) {\n        this.setCenterInternal(state.center);\n      }\n      if (state.zoom !== void 0) {\n        this.setZoom(state.zoom);\n      } else if (state.resolution) {\n        this.setResolution(state.resolution);\n      }\n      if (state.rotation !== void 0) {\n        this.setRotation(state.rotation);\n      }\n    }\n    if (i2 === animationCount) {\n      if (callback) {\n        animationCallback(callback, true);\n      }\n      return;\n    }\n    var start2 = Date.now();\n    var center = this.targetCenter_.slice();\n    var resolution = this.targetResolution_;\n    var rotation = this.targetRotation_;\n    var series = [];\n    for (; i2 < animationCount; ++i2) {\n      var options = arguments[i2];\n      var animation = {\n        start: start2,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== void 0 ? options.duration : 1e3,\n        easing: options.easing || inAndOut,\n        callback\n      };\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center.slice();\n        center = animation.targetCenter;\n      }\n      if (options.zoom !== void 0) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n      if (options.rotation !== void 0) {\n        animation.sourceRotation = rotation;\n        var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n      if (isNoopAnimation(animation)) {\n        animation.complete = true;\n      } else {\n        start2 += animation.duration;\n      }\n      series.push(animation);\n    }\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  };\n  View2.prototype.getAnimating = function() {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  };\n  View2.prototype.getInteracting = function() {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  };\n  View2.prototype.cancelAnimations = function() {\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n    var anchor;\n    for (var i2 = 0, ii = this.animations_.length; i2 < ii; ++i2) {\n      var series = this.animations_[i2];\n      if (series[0].callback) {\n        animationCallback(series[0].callback, false);\n      }\n      if (!anchor) {\n        for (var j2 = 0, jj = series.length; j2 < jj; ++j2) {\n          var animation = series[j2];\n          if (!animation.complete) {\n            anchor = animation.anchor;\n            break;\n          }\n        }\n      }\n    }\n    this.animations_.length = 0;\n    this.cancelAnchor_ = anchor;\n    this.nextCenter_ = null;\n    this.nextResolution_ = NaN;\n    this.nextRotation_ = NaN;\n  };\n  View2.prototype.updateAnimations_ = function() {\n    if (this.updateAnimationKey_ !== void 0) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = void 0;\n    }\n    if (!this.getAnimating()) {\n      return;\n    }\n    var now2 = Date.now();\n    var more = false;\n    for (var i2 = this.animations_.length - 1; i2 >= 0; --i2) {\n      var series = this.animations_[i2];\n      var seriesComplete = true;\n      for (var j2 = 0, jj = series.length; j2 < jj; ++j2) {\n        var animation = series[j2];\n        if (animation.complete) {\n          continue;\n        }\n        var elapsed = now2 - animation.start;\n        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n        var progress = animation.easing(fraction);\n        if (animation.sourceCenter) {\n          var x0 = animation.sourceCenter[0];\n          var y0 = animation.sourceCenter[1];\n          var x1 = animation.targetCenter[0];\n          var y1 = animation.targetCenter[1];\n          this.nextCenter_ = animation.targetCenter;\n          var x2 = x0 + progress * (x1 - x0);\n          var y2 = y0 + progress * (y1 - y0);\n          this.targetCenter_ = [x2, y2];\n        }\n        if (animation.sourceResolution && animation.targetResolution) {\n          var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\n          if (animation.anchor) {\n            var size = this.getViewportSize_(this.getRotation());\n            var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);\n            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);\n          }\n          this.nextResolution_ = animation.targetResolution;\n          this.targetResolution_ = resolution;\n          this.applyTargetState_(true);\n        }\n        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {\n          var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\n          if (animation.anchor) {\n            var constrainedRotation = this.constraints_.rotation(rotation, true);\n            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);\n          }\n          this.nextRotation_ = animation.targetRotation;\n          this.targetRotation_ = rotation;\n        }\n        this.applyTargetState_(true);\n        more = true;\n        if (!animation.complete) {\n          break;\n        }\n      }\n      if (seriesComplete) {\n        this.animations_[i2] = null;\n        this.setHint(ViewHint.ANIMATING, -1);\n        this.nextCenter_ = null;\n        this.nextResolution_ = NaN;\n        this.nextRotation_ = NaN;\n        var callback = series[0].callback;\n        if (callback) {\n          animationCallback(callback, true);\n        }\n      }\n    }\n    this.animations_ = this.animations_.filter(Boolean);\n    if (more && this.updateAnimationKey_ === void 0) {\n      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));\n    }\n  };\n  View2.prototype.calculateCenterRotate = function(rotation, anchor) {\n    var center;\n    var currentCenter = this.getCenterInternal();\n    if (currentCenter !== void 0) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotate$1(center, rotation - this.getRotation());\n      add$3(center, anchor);\n    }\n    return center;\n  };\n  View2.prototype.calculateCenterZoom = function(resolution, anchor) {\n    var center;\n    var currentCenter = this.getCenterInternal();\n    var currentResolution = this.getResolution();\n    if (currentCenter !== void 0 && currentResolution !== void 0) {\n      var x2 = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;\n      var y2 = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;\n      center = [x2, y2];\n    }\n    return center;\n  };\n  View2.prototype.getViewportSize_ = function(opt_rotation) {\n    var size = this.viewportSize_;\n    if (opt_rotation) {\n      var w2 = size[0];\n      var h2 = size[1];\n      return [\n        Math.abs(w2 * Math.cos(opt_rotation)) + Math.abs(h2 * Math.sin(opt_rotation)),\n        Math.abs(w2 * Math.sin(opt_rotation)) + Math.abs(h2 * Math.cos(opt_rotation))\n      ];\n    } else {\n      return size;\n    }\n  };\n  View2.prototype.setViewportSize = function(opt_size) {\n    this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];\n    if (!this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n  };\n  View2.prototype.getCenter = function() {\n    var center = this.getCenterInternal();\n    if (!center) {\n      return center;\n    }\n    return toUserCoordinate(center, this.getProjection());\n  };\n  View2.prototype.getCenterInternal = function() {\n    return this.get(ViewProperty.CENTER);\n  };\n  View2.prototype.getConstraints = function() {\n    return this.constraints_;\n  };\n  View2.prototype.getConstrainResolution = function() {\n    return this.get(\"constrainResolution\");\n  };\n  View2.prototype.getHints = function(opt_hints) {\n    if (opt_hints !== void 0) {\n      opt_hints[0] = this.hints_[0];\n      opt_hints[1] = this.hints_[1];\n      return opt_hints;\n    } else {\n      return this.hints_.slice();\n    }\n  };\n  View2.prototype.calculateExtent = function(opt_size) {\n    var extent2 = this.calculateExtentInternal(opt_size);\n    return toUserExtent(extent2, this.getProjection());\n  };\n  View2.prototype.calculateExtentInternal = function(opt_size) {\n    var size = opt_size || this.getViewportSizeMinusPadding_();\n    var center = this.getCenterInternal();\n    assert(center, 1);\n    var resolution = this.getResolution();\n    assert(resolution !== void 0, 2);\n    var rotation = this.getRotation();\n    assert(rotation !== void 0, 3);\n    return getForViewAndSize(center, resolution, rotation, size);\n  };\n  View2.prototype.getMaxResolution = function() {\n    return this.maxResolution_;\n  };\n  View2.prototype.getMinResolution = function() {\n    return this.minResolution_;\n  };\n  View2.prototype.getMaxZoom = function() {\n    return this.getZoomForResolution(this.minResolution_);\n  };\n  View2.prototype.setMaxZoom = function(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));\n  };\n  View2.prototype.getMinZoom = function() {\n    return this.getZoomForResolution(this.maxResolution_);\n  };\n  View2.prototype.setMinZoom = function(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));\n  };\n  View2.prototype.setConstrainResolution = function(enabled) {\n    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));\n  };\n  View2.prototype.getProjection = function() {\n    return this.projection_;\n  };\n  View2.prototype.getResolution = function() {\n    return this.get(ViewProperty.RESOLUTION);\n  };\n  View2.prototype.getResolutions = function() {\n    return this.resolutions_;\n  };\n  View2.prototype.getResolutionForExtent = function(extent2, opt_size) {\n    return this.getResolutionForExtentInternal(fromUserExtent(extent2, this.getProjection()), opt_size);\n  };\n  View2.prototype.getResolutionForExtentInternal = function(extent2, opt_size) {\n    var size = opt_size || this.getViewportSizeMinusPadding_();\n    var xResolution = getWidth(extent2) / size[0];\n    var yResolution = getHeight(extent2) / size[1];\n    return Math.max(xResolution, yResolution);\n  };\n  View2.prototype.getResolutionForValueFunction = function(opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    var minResolution = this.minResolution_;\n    var max2 = Math.log(maxResolution / minResolution) / Math.log(power);\n    return function(value) {\n      var resolution = maxResolution / Math.pow(power, value * max2);\n      return resolution;\n    };\n  };\n  View2.prototype.getRotation = function() {\n    return this.get(ViewProperty.ROTATION);\n  };\n  View2.prototype.getValueForResolutionFunction = function(opt_power) {\n    var logPower = Math.log(opt_power || 2);\n    var maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    var minResolution = this.minResolution_;\n    var max2 = Math.log(maxResolution / minResolution) / logPower;\n    return function(resolution) {\n      var value = Math.log(maxResolution / resolution) / logPower / max2;\n      return value;\n    };\n  };\n  View2.prototype.getViewportSizeMinusPadding_ = function(opt_rotation) {\n    var size = this.getViewportSize_(opt_rotation);\n    var padding = this.padding_;\n    if (padding) {\n      size = [\n        size[0] - padding[1] - padding[3],\n        size[1] - padding[0] - padding[2]\n      ];\n    }\n    return size;\n  };\n  View2.prototype.getState = function() {\n    var projection = this.getProjection();\n    var resolution = this.getResolution();\n    var rotation = this.getRotation();\n    var center = this.getCenterInternal();\n    var padding = this.padding_;\n    if (padding) {\n      var reducedSize = this.getViewportSizeMinusPadding_();\n      center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);\n    }\n    return {\n      center: center.slice(0),\n      projection: projection !== void 0 ? projection : null,\n      resolution,\n      nextCenter: this.nextCenter_,\n      nextResolution: this.nextResolution_,\n      nextRotation: this.nextRotation_,\n      rotation,\n      zoom: this.getZoom()\n    };\n  };\n  View2.prototype.getZoom = function() {\n    var zoom;\n    var resolution = this.getResolution();\n    if (resolution !== void 0) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n    return zoom;\n  };\n  View2.prototype.getZoomForResolution = function(resolution) {\n    var offset2 = this.minZoom_ || 0;\n    var max2, zoomFactor;\n    if (this.resolutions_) {\n      var nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset2 = nearest;\n      max2 = this.resolutions_[nearest];\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max2 / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max2 = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n    return offset2 + Math.log(max2 / resolution) / Math.log(zoomFactor);\n  };\n  View2.prototype.getResolutionForZoom = function(zoom) {\n    if (this.resolutions_) {\n      if (this.resolutions_.length <= 1) {\n        return 0;\n      }\n      var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);\n      var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\n      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));\n    } else {\n      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);\n    }\n  };\n  View2.prototype.fit = function(geometryOrExtent, opt_options) {\n    var geometry;\n    assert(Array.isArray(geometryOrExtent) || typeof geometryOrExtent.getSimplifiedGeometry === \"function\", 24);\n    if (Array.isArray(geometryOrExtent)) {\n      assert(!isEmpty$1(geometryOrExtent), 25);\n      var extent2 = fromUserExtent(geometryOrExtent, this.getProjection());\n      geometry = fromExtent(extent2);\n    } else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {\n      var extent2 = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());\n      geometry = fromExtent(extent2);\n      geometry.rotate(this.getRotation(), getCenter(extent2));\n    } else {\n      var userProjection2 = getUserProjection();\n      if (userProjection2) {\n        geometry = geometryOrExtent.clone().transform(userProjection2, this.getProjection());\n      } else {\n        geometry = geometryOrExtent;\n      }\n    }\n    this.fitInternal(geometry, opt_options);\n  };\n  View2.prototype.rotatedExtentForGeometry = function(geometry) {\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(rotation);\n    var sinAngle = Math.sin(-rotation);\n    var coords = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n    var minRotX = Infinity;\n    var minRotY = Infinity;\n    var maxRotX = -Infinity;\n    var maxRotY = -Infinity;\n    for (var i2 = 0, ii = coords.length; i2 < ii; i2 += stride) {\n      var rotX = coords[i2] * cosAngle - coords[i2 + 1] * sinAngle;\n      var rotY = coords[i2] * sinAngle + coords[i2 + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n    return [minRotX, minRotY, maxRotX, maxRotY];\n  };\n  View2.prototype.fitInternal = function(geometry, opt_options) {\n    var options = opt_options || {};\n    var size = options.size;\n    if (!size) {\n      size = this.getViewportSizeMinusPadding_();\n    }\n    var padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];\n    var nearest = options.nearest !== void 0 ? options.nearest : false;\n    var minResolution;\n    if (options.minResolution !== void 0) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== void 0) {\n      minResolution = this.getResolutionForZoom(options.maxZoom);\n    } else {\n      minResolution = 0;\n    }\n    var rotatedExtent = this.rotatedExtentForGeometry(geometry);\n    var resolution = this.getResolutionForExtentInternal(rotatedExtent, [\n      size[0] - padding[1] - padding[3],\n      size[1] - padding[0] - padding[2]\n    ]);\n    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\n    var rotation = this.getRotation();\n    var sinAngle = Math.sin(rotation);\n    var cosAngle = Math.cos(rotation);\n    var centerRot = getCenter(rotatedExtent);\n    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;\n    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;\n    var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\n    var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\n    var center = this.getConstrainedCenter([centerX, centerY], resolution);\n    var callback = options.callback ? options.callback : VOID;\n    if (options.duration !== void 0) {\n      this.animateInternal({\n        resolution,\n        center,\n        duration: options.duration,\n        easing: options.easing\n      }, callback);\n    } else {\n      this.targetResolution_ = resolution;\n      this.targetCenter_ = center;\n      this.applyTargetState_(false, true);\n      animationCallback(callback, true);\n    }\n  };\n  View2.prototype.centerOn = function(coordinate, size, position2) {\n    this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position2);\n  };\n  View2.prototype.centerOnInternal = function(coordinate, size, position2) {\n    this.setCenterInternal(calculateCenterOn(coordinate, size, position2, this.getResolution(), this.getRotation()));\n  };\n  View2.prototype.calculateCenterShift = function(center, resolution, rotation, size) {\n    var centerShift;\n    var padding = this.padding_;\n    if (padding && center) {\n      var reducedSize = this.getViewportSizeMinusPadding_(-rotation);\n      var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);\n      centerShift = [\n        center[0] - shiftedCenter[0],\n        center[1] - shiftedCenter[1]\n      ];\n    }\n    return centerShift;\n  };\n  View2.prototype.isDef = function() {\n    return !!this.getCenterInternal() && this.getResolution() !== void 0;\n  };\n  View2.prototype.adjustCenter = function(deltaCoordinates) {\n    var center = toUserCoordinate(this.targetCenter_, this.getProjection());\n    this.setCenter([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1]\n    ]);\n  };\n  View2.prototype.adjustCenterInternal = function(deltaCoordinates) {\n    var center = this.targetCenter_;\n    this.setCenterInternal([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1]\n    ]);\n  };\n  View2.prototype.adjustResolution = function(ratio, opt_anchor) {\n    var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());\n    this.adjustResolutionInternal(ratio, anchor);\n  };\n  View2.prototype.adjustResolutionInternal = function(ratio, opt_anchor) {\n    var isMoving = this.getAnimating() || this.getInteracting();\n    var size = this.getViewportSize_(this.getRotation());\n    var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);\n    if (opt_anchor) {\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);\n    }\n    this.targetResolution_ *= ratio;\n    this.applyTargetState_();\n  };\n  View2.prototype.adjustZoom = function(delta, opt_anchor) {\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);\n  };\n  View2.prototype.adjustRotation = function(delta, opt_anchor) {\n    if (opt_anchor) {\n      opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());\n    }\n    this.adjustRotationInternal(delta, opt_anchor);\n  };\n  View2.prototype.adjustRotationInternal = function(delta, opt_anchor) {\n    var isMoving = this.getAnimating() || this.getInteracting();\n    var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);\n    if (opt_anchor) {\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);\n    }\n    this.targetRotation_ += delta;\n    this.applyTargetState_();\n  };\n  View2.prototype.setCenter = function(center) {\n    this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);\n  };\n  View2.prototype.setCenterInternal = function(center) {\n    this.targetCenter_ = center;\n    this.applyTargetState_();\n  };\n  View2.prototype.setHint = function(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  };\n  View2.prototype.setResolution = function(resolution) {\n    this.targetResolution_ = resolution;\n    this.applyTargetState_();\n  };\n  View2.prototype.setRotation = function(rotation) {\n    this.targetRotation_ = rotation;\n    this.applyTargetState_();\n  };\n  View2.prototype.setZoom = function(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  };\n  View2.prototype.applyTargetState_ = function(opt_doNotCancelAnims, opt_forceMoving) {\n    var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;\n    var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);\n    var size = this.getViewportSize_(newRotation);\n    var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);\n    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\n      this.set(ViewProperty.ROTATION, newRotation);\n    }\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\n      this.set(ViewProperty.RESOLUTION, newResolution);\n      this.set(\"zoom\", this.getZoom(), true);\n    }\n    if (!newCenter || !this.get(ViewProperty.CENTER) || !equals(this.get(ViewProperty.CENTER), newCenter)) {\n      this.set(ViewProperty.CENTER, newCenter);\n    }\n    if (this.getAnimating() && !opt_doNotCancelAnims) {\n      this.cancelAnimations();\n    }\n    this.cancelAnchor_ = void 0;\n  };\n  View2.prototype.resolveConstraints = function(opt_duration, opt_resolutionDirection, opt_anchor) {\n    var duration2 = opt_duration !== void 0 ? opt_duration : 200;\n    var direction2 = opt_resolutionDirection || 0;\n    var newRotation = this.constraints_.rotation(this.targetRotation_);\n    var size = this.getViewportSize_(newRotation);\n    var newResolution = this.constraints_.resolution(this.targetResolution_, direction2, size);\n    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));\n    if (duration2 === 0 && !this.cancelAnchor_) {\n      this.targetResolution_ = newResolution;\n      this.targetRotation_ = newRotation;\n      this.targetCenter_ = newCenter;\n      this.applyTargetState_();\n      return;\n    }\n    var anchor = opt_anchor || (duration2 === 0 ? this.cancelAnchor_ : void 0);\n    this.cancelAnchor_ = void 0;\n    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals(this.getCenterInternal(), newCenter)) {\n      if (this.getAnimating()) {\n        this.cancelAnimations();\n      }\n      this.animateInternal({\n        rotation: newRotation,\n        center: newCenter,\n        resolution: newResolution,\n        duration: duration2,\n        easing: easeOut,\n        anchor\n      });\n    }\n  };\n  View2.prototype.beginInteraction = function() {\n    this.resolveConstraints(0);\n    this.setHint(ViewHint.INTERACTING, 1);\n  };\n  View2.prototype.endInteraction = function(opt_duration, opt_resolutionDirection, opt_anchor) {\n    var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());\n    this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);\n  };\n  View2.prototype.endInteractionInternal = function(opt_duration, opt_resolutionDirection, opt_anchor) {\n    this.setHint(ViewHint.INTERACTING, -1);\n    this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);\n  };\n  View2.prototype.getConstrainedCenter = function(targetCenter, opt_targetResolution) {\n    var size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);\n  };\n  View2.prototype.getConstrainedZoom = function(targetZoom, opt_direction) {\n    var targetRes = this.getResolutionForZoom(targetZoom);\n    return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));\n  };\n  View2.prototype.getConstrainedResolution = function(targetResolution, opt_direction) {\n    var direction2 = opt_direction || 0;\n    var size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.resolution(targetResolution, direction2, size);\n  };\n  return View2;\n}(ol_Object);\nfunction animationCallback(callback, returnValue) {\n  setTimeout(function() {\n    callback(returnValue);\n  }, 0);\n}\nfunction createCenterConstraint(options) {\n  if (options.extent !== void 0) {\n    var smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\n  }\n  var projection = createProjection(options.projection, \"EPSG:3857\");\n  if (options.multiWorld !== true && projection.isGlobal()) {\n    var extent2 = projection.getExtent().slice();\n    extent2[0] = -Infinity;\n    extent2[2] = Infinity;\n    return createExtent(extent2, false, false);\n  }\n  return none$1;\n}\nfunction createResolutionConstraint(options) {\n  var resolutionConstraint;\n  var maxResolution;\n  var minResolution;\n  var defaultMaxZoom = 28;\n  var defaultZoomFactor = 2;\n  var minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;\n  var maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;\n  var zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;\n  var multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;\n  var smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;\n  var showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;\n  var projection = createProjection(options.projection, \"EPSG:3857\");\n  var projExtent = projection.getExtent();\n  var constrainOnlyCenter = options.constrainOnlyCenter;\n  var extent2 = options.extent;\n  if (!multiWorld && !extent2 && projection.isGlobal()) {\n    constrainOnlyCenter = false;\n    extent2 = projExtent;\n  }\n  if (options.resolutions !== void 0) {\n    var resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent2, showFullExtent);\n    } else {\n      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);\n    }\n  } else {\n    var size = !projExtent ? 360 * METERS_PER_UNIT$1[Units$2.DEGREES] / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));\n    var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\n    maxResolution = options.maxResolution;\n    if (maxResolution !== void 0) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    }\n    minResolution = options.minResolution;\n    if (minResolution === void 0) {\n      if (options.maxZoom !== void 0) {\n        if (options.maxResolution !== void 0) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    }\n    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);\n    } else {\n      resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent2, showFullExtent);\n    }\n  }\n  return {\n    constraint: resolutionConstraint,\n    maxResolution,\n    minResolution,\n    minZoom,\n    zoomFactor\n  };\n}\nfunction createRotationConstraint(options) {\n  var enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;\n  if (enableRotation) {\n    var constrainRotation = options.constrainRotation;\n    if (constrainRotation === void 0 || constrainRotation === true) {\n      return createSnapToZero();\n    } else if (constrainRotation === false) {\n      return none;\n    } else if (typeof constrainRotation === \"number\") {\n      return createSnapToN(constrainRotation);\n    } else {\n      return none;\n    }\n  } else {\n    return disable;\n  }\n}\nfunction isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!equals(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n  return true;\n}\nfunction calculateCenterOn(coordinate, size, position2, resolution, rotation) {\n  var cosAngle = Math.cos(-rotation);\n  var sinAngle = Math.sin(-rotation);\n  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  rotX += (size[0] / 2 - position2[0]) * resolution;\n  rotY += (position2[1] - size[1] / 2) * resolution;\n  sinAngle = -sinAngle;\n  var centerX = rotX * cosAngle - rotY * sinAngle;\n  var centerY = rotY * cosAngle + rotX * sinAngle;\n  return [centerX, centerY];\n}\nvar ol_View = View$1;\nfunction buffer(size, num, opt_size) {\n  if (opt_size === void 0) {\n    opt_size = [0, 0];\n  }\n  opt_size[0] = size[0] + 2 * num;\n  opt_size[1] = size[1] + 2 * num;\n  return opt_size;\n}\nfunction hasArea(size) {\n  return size[0] > 0 && size[1] > 0;\n}\nfunction scale(size, ratio, opt_size) {\n  if (opt_size === void 0) {\n    opt_size = [0, 0];\n  }\n  opt_size[0] = size[0] * ratio + 0.5 | 0;\n  opt_size[1] = size[1] * ratio + 0.5 | 0;\n  return opt_size;\n}\nfunction toSize(size, opt_size) {\n  if (Array.isArray(size)) {\n    return size;\n  } else {\n    if (opt_size === void 0) {\n      opt_size = [size, size];\n    } else {\n      opt_size[0] = size;\n      opt_size[1] = size;\n    }\n    return opt_size;\n  }\n}\nvar __extends$1T = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nfunction removeLayerMapProperty(layer) {\n  if (layer instanceof ol_layer_Base) {\n    layer.setMapInternal(null);\n    return;\n  }\n  if (layer instanceof ol_layer_Group) {\n    layer.getLayers().forEach(removeLayerMapProperty);\n  }\n}\nfunction setLayerMapProperty(layer, map) {\n  if (layer instanceof ol_layer_Base) {\n    layer.setMapInternal(map);\n    return;\n  }\n  if (layer instanceof ol_layer_Group) {\n    var layers = layer.getLayers().getArray();\n    for (var i2 = 0, ii = layers.length; i2 < ii; ++i2) {\n      setLayerMapProperty(layers[i2], map);\n    }\n  }\n}\nvar PluggableMap = function(_super) {\n  __extends$1T(PluggableMap2, _super);\n  function PluggableMap2(options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    var optionsInternal = createOptionsInternal(options);\n    _this.renderComplete_;\n    _this.loaded_ = true;\n    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);\n    _this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;\n    _this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n    _this.postRenderTimeoutHandle_;\n    _this.animationDelayKey_;\n    _this.animationDelay_ = function() {\n      this.animationDelayKey_ = void 0;\n      this.renderFrame_(Date.now());\n    }.bind(_this);\n    _this.coordinateToPixelTransform_ = create$6();\n    _this.pixelToCoordinateTransform_ = create$6();\n    _this.frameIndex_ = 0;\n    _this.frameState_ = null;\n    _this.previousExtent_ = null;\n    _this.viewPropertyListenerKey_ = null;\n    _this.viewChangeListenerKey_ = null;\n    _this.layerGroupPropertyListenerKeys_ = null;\n    _this.viewport_ = document.createElement(\"div\");\n    _this.viewport_.className = \"ol-viewport\" + (\"ontouchstart\" in window ? \" ol-touch\" : \"\");\n    _this.viewport_.style.position = \"relative\";\n    _this.viewport_.style.overflow = \"hidden\";\n    _this.viewport_.style.width = \"100%\";\n    _this.viewport_.style.height = \"100%\";\n    _this.overlayContainer_ = document.createElement(\"div\");\n    _this.overlayContainer_.style.position = \"absolute\";\n    _this.overlayContainer_.style.zIndex = \"0\";\n    _this.overlayContainer_.style.width = \"100%\";\n    _this.overlayContainer_.style.height = \"100%\";\n    _this.overlayContainer_.style.pointerEvents = \"none\";\n    _this.overlayContainer_.className = \"ol-overlaycontainer\";\n    _this.viewport_.appendChild(_this.overlayContainer_);\n    _this.overlayContainerStopEvent_ = document.createElement(\"div\");\n    _this.overlayContainerStopEvent_.style.position = \"absolute\";\n    _this.overlayContainerStopEvent_.style.zIndex = \"0\";\n    _this.overlayContainerStopEvent_.style.width = \"100%\";\n    _this.overlayContainerStopEvent_.style.height = \"100%\";\n    _this.overlayContainerStopEvent_.style.pointerEvents = \"none\";\n    _this.overlayContainerStopEvent_.className = \"ol-overlaycontainer-stopevent\";\n    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);\n    _this.mapBrowserEventHandler_ = null;\n    _this.moveTolerance_ = options.moveTolerance;\n    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n    _this.targetChangeHandlerKeys_ = null;\n    _this.controls = optionsInternal.controls || new ol_Collection();\n    _this.interactions = optionsInternal.interactions || new ol_Collection();\n    _this.overlays_ = optionsInternal.overlays;\n    _this.overlayIdIndex_ = {};\n    _this.renderer_ = null;\n    _this.postRenderFunctions_ = [];\n    _this.tileQueue_ = new TileQueue$1(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));\n    _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);\n    _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);\n    _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);\n    _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_);\n    _this.setProperties(optionsInternal.values);\n    var map = _this;\n    if (options.view && !(options.view instanceof ol_View)) {\n      options.view.then(function(viewOptions) {\n        map.setView(new ol_View(viewOptions));\n      });\n    }\n    _this.controls.addEventListener(CollectionEventType.ADD, function(event) {\n      event.element.setMap(this);\n    }.bind(_this));\n    _this.controls.addEventListener(CollectionEventType.REMOVE, function(event) {\n      event.element.setMap(null);\n    }.bind(_this));\n    _this.interactions.addEventListener(CollectionEventType.ADD, function(event) {\n      event.element.setMap(this);\n    }.bind(_this));\n    _this.interactions.addEventListener(CollectionEventType.REMOVE, function(event) {\n      event.element.setMap(null);\n    }.bind(_this));\n    _this.overlays_.addEventListener(CollectionEventType.ADD, function(event) {\n      this.addOverlayInternal_(event.element);\n    }.bind(_this));\n    _this.overlays_.addEventListener(CollectionEventType.REMOVE, function(event) {\n      var overlay = event.element;\n      var id = overlay.getId();\n      if (id !== void 0) {\n        delete this.overlayIdIndex_[id.toString()];\n      }\n      event.element.setMap(null);\n    }.bind(_this));\n    _this.controls.forEach(function(control) {\n      control.setMap(this);\n    }.bind(_this));\n    _this.interactions.forEach(function(interaction) {\n      interaction.setMap(this);\n    }.bind(_this));\n    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));\n    return _this;\n  }\n  PluggableMap2.prototype.createRenderer = function() {\n    throw new Error(\"Use a map type that has a createRenderer method\");\n  };\n  PluggableMap2.prototype.addControl = function(control) {\n    this.getControls().push(control);\n  };\n  PluggableMap2.prototype.addInteraction = function(interaction) {\n    this.getInteractions().push(interaction);\n  };\n  PluggableMap2.prototype.addLayer = function(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n  PluggableMap2.prototype.handleLayerAdd_ = function(event) {\n    setLayerMapProperty(event.layer, this);\n  };\n  PluggableMap2.prototype.addOverlay = function(overlay) {\n    this.getOverlays().push(overlay);\n  };\n  PluggableMap2.prototype.addOverlayInternal_ = function(overlay) {\n    var id = overlay.getId();\n    if (id !== void 0) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n    overlay.setMap(this);\n  };\n  PluggableMap2.prototype.disposeInternal = function() {\n    this.setTarget(null);\n    _super.prototype.disposeInternal.call(this);\n  };\n  PluggableMap2.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return;\n    }\n    var coordinate = this.getCoordinateFromPixelInternal(pixel);\n    opt_options = opt_options !== void 0 ? opt_options : {};\n    var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;\n    var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : TRUE;\n    var checkWrapped = opt_options.checkWrapped !== false;\n    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);\n  };\n  PluggableMap2.prototype.getFeaturesAtPixel = function(pixel, opt_options) {\n    var features = [];\n    this.forEachFeatureAtPixel(pixel, function(feature2) {\n      features.push(feature2);\n    }, opt_options);\n    return features;\n  };\n  PluggableMap2.prototype.getAllLayers = function() {\n    var layers = [];\n    function addLayersFrom(layerGroup) {\n      layerGroup.forEach(function(layer) {\n        if (layer instanceof ol_layer_Group) {\n          addLayersFrom(layer.getLayers());\n        } else {\n          layers.push(layer);\n        }\n      });\n    }\n    addLayersFrom(this.getLayers());\n    return layers;\n  };\n  PluggableMap2.prototype.forEachLayerAtPixel = function(pixel, callback, opt_options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return;\n    }\n    var options = opt_options || {};\n    var hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;\n    var layerFilter = options.layerFilter || TRUE;\n    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);\n  };\n  PluggableMap2.prototype.hasFeatureAtPixel = function(pixel, opt_options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return false;\n    }\n    var coordinate = this.getCoordinateFromPixelInternal(pixel);\n    opt_options = opt_options !== void 0 ? opt_options : {};\n    var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : TRUE;\n    var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;\n    var checkWrapped = opt_options.checkWrapped !== false;\n    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);\n  };\n  PluggableMap2.prototype.getEventCoordinate = function(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n  PluggableMap2.prototype.getEventCoordinateInternal = function(event) {\n    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n  };\n  PluggableMap2.prototype.getEventPixel = function(event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = \"changedTouches\" in event ? event.changedTouches[0] : event;\n    return [\n      eventPosition.clientX - viewportPosition.left,\n      eventPosition.clientY - viewportPosition.top\n    ];\n  };\n  PluggableMap2.prototype.getTarget = function() {\n    return this.get(MapProperty.TARGET);\n  };\n  PluggableMap2.prototype.getTargetElement = function() {\n    var target = this.getTarget();\n    if (target !== void 0) {\n      return typeof target === \"string\" ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  };\n  PluggableMap2.prototype.getCoordinateFromPixel = function(pixel) {\n    return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());\n  };\n  PluggableMap2.prototype.getCoordinateFromPixelInternal = function(pixel) {\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return apply$5(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n  PluggableMap2.prototype.getControls = function() {\n    return this.controls;\n  };\n  PluggableMap2.prototype.getOverlays = function() {\n    return this.overlays_;\n  };\n  PluggableMap2.prototype.getOverlayById = function(id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== void 0 ? overlay : null;\n  };\n  PluggableMap2.prototype.getInteractions = function() {\n    return this.interactions;\n  };\n  PluggableMap2.prototype.getLayerGroup = function() {\n    return this.get(MapProperty.LAYERGROUP);\n  };\n  PluggableMap2.prototype.setLayers = function(layers) {\n    var group = this.getLayerGroup();\n    if (layers instanceof ol_Collection) {\n      group.setLayers(layers);\n      return;\n    }\n    var collection = group.getLayers();\n    collection.clear();\n    collection.extend(layers);\n  };\n  PluggableMap2.prototype.getLayers = function() {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n  PluggableMap2.prototype.getLoadingOrNotReady = function() {\n    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n    for (var i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {\n      var state = layerStatesArray[i2];\n      if (!state.visible) {\n        continue;\n      }\n      var renderer = state.layer.getRenderer();\n      if (renderer && !renderer.ready) {\n        return true;\n      }\n      var source = state.layer.getSource();\n      if (source && source.loading) {\n        return true;\n      }\n    }\n    return false;\n  };\n  PluggableMap2.prototype.getPixelFromCoordinate = function(coordinate) {\n    var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());\n    return this.getPixelFromCoordinateInternal(viewCoordinate);\n  };\n  PluggableMap2.prototype.getPixelFromCoordinateInternal = function(coordinate) {\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return apply$5(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  };\n  PluggableMap2.prototype.getRenderer = function() {\n    return this.renderer_;\n  };\n  PluggableMap2.prototype.getSize = function() {\n    return this.get(MapProperty.SIZE);\n  };\n  PluggableMap2.prototype.getView = function() {\n    return this.get(MapProperty.VIEW);\n  };\n  PluggableMap2.prototype.getViewport = function() {\n    return this.viewport_;\n  };\n  PluggableMap2.prototype.getOverlayContainer = function() {\n    return this.overlayContainer_;\n  };\n  PluggableMap2.prototype.getOverlayContainerStopEvent = function() {\n    return this.overlayContainerStopEvent_;\n  };\n  PluggableMap2.prototype.getOwnerDocument = function() {\n    var targetElement = this.getTargetElement();\n    return targetElement ? targetElement.ownerDocument : document;\n  };\n  PluggableMap2.prototype.getTilePriority = function(tile2, tileSourceKey, tileCenter, tileResolution) {\n    return getTilePriority(this.frameState_, tile2, tileSourceKey, tileCenter, tileResolution);\n  };\n  PluggableMap2.prototype.handleBrowserEvent = function(browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new MapBrowserEvent$1(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n  PluggableMap2.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {\n    if (!this.frameState_) {\n      return;\n    }\n    var originalEvent = mapBrowserEvent.originalEvent;\n    var eventType = originalEvent.type;\n    if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {\n      var doc = this.getOwnerDocument();\n      var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;\n      var target = originalEvent.target;\n      if (this.overlayContainerStopEvent_.contains(target) || !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {\n        return;\n      }\n    }\n    mapBrowserEvent.frameState = this.frameState_;\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      var interactionsArray = this.getInteractions().getArray().slice();\n      for (var i2 = interactionsArray.length - 1; i2 >= 0; i2--) {\n        var interaction = interactionsArray[i2];\n        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {\n          continue;\n        }\n        var cont = interaction.handleEvent(mapBrowserEvent);\n        if (!cont || mapBrowserEvent.propagationStopped) {\n          break;\n        }\n      }\n    }\n  };\n  PluggableMap2.prototype.handlePostRender = function() {\n    var frameState = this.frameState_;\n    var tileQueue = this.tileQueue_;\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = this.maxTilesLoading_;\n      var maxNewLoads = maxTotalLoading;\n      if (frameState) {\n        var hints = frameState.viewHints;\n        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n          var lowOnFrameBudget = Date.now() - frameState.time > 8;\n          maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n          maxNewLoads = lowOnFrameBudget ? 0 : 2;\n        }\n      }\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize();\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n    if (frameState && this.renderer_ && !frameState.animate) {\n      if (this.renderComplete_ === true) {\n        if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {\n          this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n        }\n        if (this.loaded_ === false) {\n          this.loaded_ = true;\n          this.dispatchEvent(new MapEvent$1(MapEventType.LOADEND, this, frameState));\n        }\n      } else if (this.loaded_ === true) {\n        this.loaded_ = false;\n        this.dispatchEvent(new MapEvent$1(MapEventType.LOADSTART, this, frameState));\n      }\n    }\n    var postRenderFunctions = this.postRenderFunctions_;\n    for (var i2 = 0, ii = postRenderFunctions.length; i2 < ii; ++i2) {\n      postRenderFunctions[i2](this, frameState);\n    }\n    postRenderFunctions.length = 0;\n  };\n  PluggableMap2.prototype.handleSizeChanged_ = function() {\n    if (this.getView() && !this.getView().getAnimating()) {\n      this.getView().resolveConstraints(0);\n    }\n    this.render();\n  };\n  PluggableMap2.prototype.handleTargetChanged_ = function() {\n    if (this.mapBrowserEventHandler_) {\n      for (var i2 = 0, ii = this.targetChangeHandlerKeys_.length; i2 < ii; ++i2) {\n        unlistenByKey(this.targetChangeHandlerKeys_[i2]);\n      }\n      this.targetChangeHandlerKeys_ = null;\n      this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);\n      this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);\n      this.mapBrowserEventHandler_.dispose();\n      this.mapBrowserEventHandler_ = null;\n      removeNode(this.viewport_);\n    }\n    var targetElement = this.getTargetElement();\n    if (!targetElement) {\n      if (this.renderer_) {\n        clearTimeout(this.postRenderTimeoutHandle_);\n        this.postRenderTimeoutHandle_ = void 0;\n        this.postRenderFunctions_.length = 0;\n        this.renderer_.dispose();\n        this.renderer_ = null;\n      }\n      if (this.animationDelayKey_) {\n        cancelAnimationFrame(this.animationDelayKey_);\n        this.animationDelayKey_ = void 0;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n      if (!this.renderer_) {\n        this.renderer_ = this.createRenderer();\n      }\n      this.mapBrowserEventHandler_ = new MapBrowserEventHandler$1(this, this.moveTolerance_);\n      for (var key in MapBrowserEventType) {\n        this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));\n      }\n      this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);\n      this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);\n      var defaultView = this.getOwnerDocument().defaultView;\n      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n      this.targetChangeHandlerKeys_ = [\n        listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),\n        listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),\n        listen(defaultView, EventType.RESIZE, this.updateSize, this)\n      ];\n    }\n    this.updateSize();\n  };\n  PluggableMap2.prototype.handleTileChange_ = function() {\n    this.render();\n  };\n  PluggableMap2.prototype.handleViewPropertyChanged_ = function() {\n    this.render();\n  };\n  PluggableMap2.prototype.handleViewChanged_ = function() {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n    var view = this.getView();\n    if (view) {\n      this.updateViewportSize_();\n      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n      view.resolveConstraints(0);\n    }\n    this.render();\n  };\n  PluggableMap2.prototype.handleLayerGroupChanged_ = function() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n    var layerGroup = this.getLayerGroup();\n    if (layerGroup) {\n      this.handleLayerAdd_(new GroupEvent(\"addlayer\", layerGroup));\n      this.layerGroupPropertyListenerKeys_ = [\n        listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),\n        listen(layerGroup, EventType.CHANGE, this.render, this),\n        listen(layerGroup, \"addlayer\", this.handleLayerAdd_, this),\n        listen(layerGroup, \"removelayer\", this.handleLayerRemove_, this)\n      ];\n    }\n    this.render();\n  };\n  PluggableMap2.prototype.isRendered = function() {\n    return !!this.frameState_;\n  };\n  PluggableMap2.prototype.renderSync = function() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n    this.animationDelay_();\n  };\n  PluggableMap2.prototype.redrawText = function() {\n    var layerStates = this.getLayerGroup().getLayerStatesArray();\n    for (var i2 = 0, ii = layerStates.length; i2 < ii; ++i2) {\n      var layer = layerStates[i2].layer;\n      if (layer.hasRenderer()) {\n        layer.getRenderer().handleFontsChanged();\n      }\n    }\n  };\n  PluggableMap2.prototype.render = function() {\n    if (this.renderer_ && this.animationDelayKey_ === void 0) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  };\n  PluggableMap2.prototype.removeControl = function(control) {\n    return this.getControls().remove(control);\n  };\n  PluggableMap2.prototype.removeInteraction = function(interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n  PluggableMap2.prototype.removeLayer = function(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n  PluggableMap2.prototype.handleLayerRemove_ = function(event) {\n    removeLayerMapProperty(event.layer);\n  };\n  PluggableMap2.prototype.removeOverlay = function(overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n  PluggableMap2.prototype.renderFrame_ = function(time2) {\n    var _this = this;\n    var size = this.getSize();\n    var view = this.getView();\n    var previousFrameState = this.frameState_;\n    var frameState = null;\n    if (size !== void 0 && hasArea(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : void 0);\n      var viewState = view.getState();\n      frameState = {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        declutterTree: null,\n        extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),\n        index: this.frameIndex_++,\n        layerIndex: 0,\n        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size,\n        tileQueue: this.tileQueue_,\n        time: time2,\n        usedTiles: {},\n        viewState,\n        viewHints,\n        wantedTiles: {},\n        mapId: getUid(this),\n        renderTargets: {}\n      };\n      if (viewState.nextCenter && viewState.nextResolution) {\n        var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;\n        frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);\n      }\n    }\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ || !isEmpty$1(this.previousExtent_) && !equals$1(frameState.extent, this.previousExtent_);\n        if (moveStart) {\n          this.dispatchEvent(new MapEvent$1(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals$1(frameState.extent, this.previousExtent_);\n      if (idle) {\n        this.dispatchEvent(new MapEvent$1(MapEventType.MOVEEND, this, frameState));\n        clone$1(frameState.extent, this.previousExtent_);\n      }\n    }\n    this.dispatchEvent(new MapEvent$1(MapEventType.POSTRENDER, this, frameState));\n    this.renderComplete_ = this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(RenderEventType.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;\n    if (!this.postRenderTimeoutHandle_) {\n      this.postRenderTimeoutHandle_ = setTimeout(function() {\n        _this.postRenderTimeoutHandle_ = void 0;\n        _this.handlePostRender();\n      }, 0);\n    }\n  };\n  PluggableMap2.prototype.setLayerGroup = function(layerGroup) {\n    var oldLayerGroup = this.getLayerGroup();\n    if (oldLayerGroup) {\n      this.handleLayerRemove_(new GroupEvent(\"removelayer\", oldLayerGroup));\n    }\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  };\n  PluggableMap2.prototype.setSize = function(size) {\n    this.set(MapProperty.SIZE, size);\n  };\n  PluggableMap2.prototype.setTarget = function(target) {\n    this.set(MapProperty.TARGET, target);\n  };\n  PluggableMap2.prototype.setView = function(view) {\n    if (!view || view instanceof ol_View) {\n      this.set(MapProperty.VIEW, view);\n      return;\n    }\n    this.set(MapProperty.VIEW, new ol_View());\n    var map = this;\n    view.then(function(viewOptions) {\n      map.setView(new ol_View(viewOptions));\n    });\n  };\n  PluggableMap2.prototype.updateSize = function() {\n    var targetElement = this.getTargetElement();\n    var size = void 0;\n    if (targetElement) {\n      var computedStyle = getComputedStyle(targetElement);\n      var width = targetElement.offsetWidth - parseFloat(computedStyle[\"borderLeftWidth\"]) - parseFloat(computedStyle[\"paddingLeft\"]) - parseFloat(computedStyle[\"paddingRight\"]) - parseFloat(computedStyle[\"borderRightWidth\"]);\n      var height = targetElement.offsetHeight - parseFloat(computedStyle[\"borderTopWidth\"]) - parseFloat(computedStyle[\"paddingTop\"]) - parseFloat(computedStyle[\"paddingBottom\"]) - parseFloat(computedStyle[\"borderBottomWidth\"]);\n      if (!isNaN(width) && !isNaN(height)) {\n        size = [width, height];\n        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {\n          console.warn(\"No map visible because the map container's width or height are 0.\");\n        }\n      }\n    }\n    this.setSize(size);\n    this.updateViewportSize_();\n  };\n  PluggableMap2.prototype.updateViewportSize_ = function() {\n    var view = this.getView();\n    if (view) {\n      var size = void 0;\n      var computedStyle = getComputedStyle(this.viewport_);\n      if (computedStyle.width && computedStyle.height) {\n        size = [\n          parseInt(computedStyle.width, 10),\n          parseInt(computedStyle.height, 10)\n        ];\n      }\n      view.setViewportSize(size);\n    }\n  };\n  return PluggableMap2;\n}(ol_Object);\nfunction createOptionsInternal(options) {\n  var keyboardEventTarget = null;\n  if (options.keyboardEventTarget !== void 0) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === \"string\" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n  var values2 = {};\n  var layerGroup = options.layers && typeof options.layers.getLayers === \"function\" ? options.layers : new ol_layer_Group({ layers: options.layers });\n  values2[MapProperty.LAYERGROUP] = layerGroup;\n  values2[MapProperty.TARGET] = options.target;\n  values2[MapProperty.VIEW] = options.view instanceof ol_View ? options.view : new ol_View();\n  var controls;\n  if (options.controls !== void 0) {\n    if (Array.isArray(options.controls)) {\n      controls = new ol_Collection(options.controls.slice());\n    } else {\n      assert(typeof options.controls.getArray === \"function\", 47);\n      controls = options.controls;\n    }\n  }\n  var interactions;\n  if (options.interactions !== void 0) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new ol_Collection(options.interactions.slice());\n    } else {\n      assert(typeof options.interactions.getArray === \"function\", 48);\n      interactions = options.interactions;\n    }\n  }\n  var overlays;\n  if (options.overlays !== void 0) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new ol_Collection(options.overlays.slice());\n    } else {\n      assert(typeof options.overlays.getArray === \"function\", 49);\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new ol_Collection();\n  }\n  return {\n    controls,\n    interactions,\n    keyboardEventTarget,\n    overlays,\n    values: values2\n  };\n}\nvar PluggableMap$1 = PluggableMap;\nvar __extends$1S = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Control$1 = function(_super) {\n  __extends$1S(Control2, _super);\n  function Control2(options) {\n    var _this = _super.call(this) || this;\n    var element = options.element;\n    if (element && !options.target && !element.style.pointerEvents) {\n      element.style.pointerEvents = \"auto\";\n    }\n    _this.element = element ? element : null;\n    _this.target_ = null;\n    _this.map_ = null;\n    _this.listenerKeys = [];\n    if (options.render) {\n      _this.render = options.render;\n    }\n    if (options.target) {\n      _this.setTarget(options.target);\n    }\n    return _this;\n  }\n  Control2.prototype.disposeInternal = function() {\n    removeNode(this.element);\n    _super.prototype.disposeInternal.call(this);\n  };\n  Control2.prototype.getMap = function() {\n    return this.map_;\n  };\n  Control2.prototype.setMap = function(map) {\n    if (this.map_) {\n      removeNode(this.element);\n    }\n    for (var i2 = 0, ii = this.listenerKeys.length; i2 < ii; ++i2) {\n      unlistenByKey(this.listenerKeys[i2]);\n    }\n    this.listenerKeys.length = 0;\n    this.map_ = map;\n    if (map) {\n      var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();\n      target.appendChild(this.element);\n      if (this.render !== VOID) {\n        this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));\n      }\n      map.render();\n    }\n  };\n  Control2.prototype.render = function(mapEvent) {\n  };\n  Control2.prototype.setTarget = function(target) {\n    this.target_ = typeof target === \"string\" ? document.getElementById(target) : target;\n  };\n  return Control2;\n}(ol_Object);\nvar ol_control_Control = Control$1;\nvar Control$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": ol_control_Control\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar __extends$1R = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Attribution = function(_super) {\n  __extends$1R(Attribution2, _super);\n  function Attribution2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      element: document.createElement(\"div\"),\n      render: options.render,\n      target: options.target\n    }) || this;\n    _this.ulElement_ = document.createElement(\"ul\");\n    _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;\n    _this.userCollapsed_ = _this.collapsed_;\n    _this.overrideCollapsible_ = options.collapsible !== void 0;\n    _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;\n    if (!_this.collapsible_) {\n      _this.collapsed_ = false;\n    }\n    var className = options.className !== void 0 ? options.className : \"ol-attribution\";\n    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : \"Attributions\";\n    var expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + \"-expand\";\n    var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : \"\\u203A\";\n    var collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + \"-collapse\";\n    if (typeof collapseLabel === \"string\") {\n      _this.collapseLabel_ = document.createElement(\"span\");\n      _this.collapseLabel_.textContent = collapseLabel;\n      _this.collapseLabel_.className = collapseClassName;\n    } else {\n      _this.collapseLabel_ = collapseLabel;\n    }\n    var label = options.label !== void 0 ? options.label : \"i\";\n    if (typeof label === \"string\") {\n      _this.label_ = document.createElement(\"span\");\n      _this.label_.textContent = label;\n      _this.label_.className = expandClassName;\n    } else {\n      _this.label_ = label;\n    }\n    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;\n    _this.toggleButton_ = document.createElement(\"button\");\n    _this.toggleButton_.setAttribute(\"type\", \"button\");\n    _this.toggleButton_.setAttribute(\"aria-expanded\", String(!_this.collapsed_));\n    _this.toggleButton_.title = tipLabel;\n    _this.toggleButton_.appendChild(activeLabel);\n    _this.toggleButton_.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);\n    var cssClasses = className + \" \" + CLASS_UNSELECTABLE + \" \" + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? \" \" + CLASS_COLLAPSED : \"\") + (_this.collapsible_ ? \"\" : \" ol-uncollapsible\");\n    var element = _this.element;\n    element.className = cssClasses;\n    element.appendChild(_this.toggleButton_);\n    element.appendChild(_this.ulElement_);\n    _this.renderedAttributions_ = [];\n    _this.renderedVisible_ = true;\n    return _this;\n  }\n  Attribution2.prototype.collectSourceAttributions_ = function(frameState) {\n    var lookup2 = {};\n    var visibleAttributions = [];\n    var collapsible = true;\n    var layerStatesArray = frameState.layerStatesArray;\n    for (var i2 = 0, ii = layerStatesArray.length; i2 < ii; ++i2) {\n      var layerState = layerStatesArray[i2];\n      if (!inView(layerState, frameState.viewState)) {\n        continue;\n      }\n      var source = layerState.layer.getSource();\n      if (!source) {\n        continue;\n      }\n      var attributionGetter = source.getAttributions();\n      if (!attributionGetter) {\n        continue;\n      }\n      var attributions = attributionGetter(frameState);\n      if (!attributions) {\n        continue;\n      }\n      collapsible = collapsible && source.getAttributionsCollapsible() !== false;\n      if (Array.isArray(attributions)) {\n        for (var j2 = 0, jj = attributions.length; j2 < jj; ++j2) {\n          if (!(attributions[j2] in lookup2)) {\n            visibleAttributions.push(attributions[j2]);\n            lookup2[attributions[j2]] = true;\n          }\n        }\n      } else {\n        if (!(attributions in lookup2)) {\n          visibleAttributions.push(attributions);\n          lookup2[attributions] = true;\n        }\n      }\n    }\n    if (!this.overrideCollapsible_) {\n      this.setCollapsible(collapsible);\n    }\n    return visibleAttributions;\n  };\n  Attribution2.prototype.updateElement_ = function(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element.style.display = \"none\";\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n    var attributions = this.collectSourceAttributions_(frameState);\n    var visible = attributions.length > 0;\n    if (this.renderedVisible_ != visible) {\n      this.element.style.display = visible ? \"\" : \"none\";\n      this.renderedVisible_ = visible;\n    }\n    if (equals$2(attributions, this.renderedAttributions_)) {\n      return;\n    }\n    removeChildren(this.ulElement_);\n    for (var i2 = 0, ii = attributions.length; i2 < ii; ++i2) {\n      var element = document.createElement(\"li\");\n      element.innerHTML = attributions[i2];\n      this.ulElement_.appendChild(element);\n    }\n    this.renderedAttributions_ = attributions;\n  };\n  Attribution2.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    this.handleToggle_();\n    this.userCollapsed_ = this.collapsed_;\n  };\n  Attribution2.prototype.handleToggle_ = function() {\n    this.element.classList.toggle(CLASS_COLLAPSED);\n    if (this.collapsed_) {\n      replaceNode(this.collapseLabel_, this.label_);\n    } else {\n      replaceNode(this.label_, this.collapseLabel_);\n    }\n    this.collapsed_ = !this.collapsed_;\n    this.toggleButton_.setAttribute(\"aria-expanded\", String(!this.collapsed_));\n  };\n  Attribution2.prototype.getCollapsible = function() {\n    return this.collapsible_;\n  };\n  Attribution2.prototype.setCollapsible = function(collapsible) {\n    if (this.collapsible_ === collapsible) {\n      return;\n    }\n    this.collapsible_ = collapsible;\n    this.element.classList.toggle(\"ol-uncollapsible\");\n    if (this.userCollapsed_) {\n      this.handleToggle_();\n    }\n  };\n  Attribution2.prototype.setCollapsed = function(collapsed) {\n    this.userCollapsed_ = collapsed;\n    if (!this.collapsible_ || this.collapsed_ === collapsed) {\n      return;\n    }\n    this.handleToggle_();\n  };\n  Attribution2.prototype.getCollapsed = function() {\n    return this.collapsed_;\n  };\n  Attribution2.prototype.render = function(mapEvent) {\n    this.updateElement_(mapEvent.frameState);\n  };\n  return Attribution2;\n}(ol_control_Control);\nvar Attribution$1 = Attribution;\nvar __extends$1Q = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Rotate$1 = function(_super) {\n  __extends$1Q(Rotate2, _super);\n  function Rotate2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      element: document.createElement(\"div\"),\n      render: options.render,\n      target: options.target\n    }) || this;\n    var className = options.className !== void 0 ? options.className : \"ol-rotate\";\n    var label = options.label !== void 0 ? options.label : \"\\u21E7\";\n    var compassClassName = options.compassClassName !== void 0 ? options.compassClassName : \"ol-compass\";\n    _this.label_ = null;\n    if (typeof label === \"string\") {\n      _this.label_ = document.createElement(\"span\");\n      _this.label_.className = compassClassName;\n      _this.label_.textContent = label;\n    } else {\n      _this.label_ = label;\n      _this.label_.classList.add(compassClassName);\n    }\n    var tipLabel = options.tipLabel ? options.tipLabel : \"Reset rotation\";\n    var button = document.createElement(\"button\");\n    button.className = className + \"-reset\";\n    button.setAttribute(\"type\", \"button\");\n    button.title = tipLabel;\n    button.appendChild(_this.label_);\n    button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);\n    var cssClasses = className + \" \" + CLASS_UNSELECTABLE + \" \" + CLASS_CONTROL;\n    var element = _this.element;\n    element.className = cssClasses;\n    element.appendChild(button);\n    _this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 250;\n    _this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;\n    _this.rotation_ = void 0;\n    if (_this.autoHide_) {\n      _this.element.classList.add(CLASS_HIDDEN);\n    }\n    return _this;\n  }\n  Rotate2.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    if (this.callResetNorth_ !== void 0) {\n      this.callResetNorth_();\n    } else {\n      this.resetNorth_();\n    }\n  };\n  Rotate2.prototype.resetNorth_ = function() {\n    var map = this.getMap();\n    var view = map.getView();\n    if (!view) {\n      return;\n    }\n    var rotation = view.getRotation();\n    if (rotation !== void 0) {\n      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {\n        view.animate({\n          rotation: 0,\n          duration: this.duration_,\n          easing: easeOut\n        });\n      } else {\n        view.setRotation(0);\n      }\n    }\n  };\n  Rotate2.prototype.render = function(mapEvent) {\n    var frameState = mapEvent.frameState;\n    if (!frameState) {\n      return;\n    }\n    var rotation = frameState.viewState.rotation;\n    if (rotation != this.rotation_) {\n      var transform2 = \"rotate(\" + rotation + \"rad)\";\n      if (this.autoHide_) {\n        var contains2 = this.element.classList.contains(CLASS_HIDDEN);\n        if (!contains2 && rotation === 0) {\n          this.element.classList.add(CLASS_HIDDEN);\n        } else if (contains2 && rotation !== 0) {\n          this.element.classList.remove(CLASS_HIDDEN);\n        }\n      }\n      this.label_.style.transform = transform2;\n    }\n    this.rotation_ = rotation;\n  };\n  return Rotate2;\n}(ol_control_Control);\nvar Rotate$2 = Rotate$1;\nvar __extends$1P = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Zoom = function(_super) {\n  __extends$1P(Zoom2, _super);\n  function Zoom2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      element: document.createElement(\"div\"),\n      target: options.target\n    }) || this;\n    var className = options.className !== void 0 ? options.className : \"ol-zoom\";\n    var delta = options.delta !== void 0 ? options.delta : 1;\n    var zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + \"-in\";\n    var zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + \"-out\";\n    var zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : \"+\";\n    var zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : \"\\u2013\";\n    var zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : \"Zoom in\";\n    var zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : \"Zoom out\";\n    var inElement = document.createElement(\"button\");\n    inElement.className = zoomInClassName;\n    inElement.setAttribute(\"type\", \"button\");\n    inElement.title = zoomInTipLabel;\n    inElement.appendChild(typeof zoomInLabel === \"string\" ? document.createTextNode(zoomInLabel) : zoomInLabel);\n    inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, delta), false);\n    var outElement = document.createElement(\"button\");\n    outElement.className = zoomOutClassName;\n    outElement.setAttribute(\"type\", \"button\");\n    outElement.title = zoomOutTipLabel;\n    outElement.appendChild(typeof zoomOutLabel === \"string\" ? document.createTextNode(zoomOutLabel) : zoomOutLabel);\n    outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, -delta), false);\n    var cssClasses = className + \" \" + CLASS_UNSELECTABLE + \" \" + CLASS_CONTROL;\n    var element = _this.element;\n    element.className = cssClasses;\n    element.appendChild(inElement);\n    element.appendChild(outElement);\n    _this.duration_ = options.duration !== void 0 ? options.duration : 250;\n    return _this;\n  }\n  Zoom2.prototype.handleClick_ = function(delta, event) {\n    event.preventDefault();\n    this.zoomByDelta_(delta);\n  };\n  Zoom2.prototype.zoomByDelta_ = function(delta) {\n    var map = this.getMap();\n    var view = map.getView();\n    if (!view) {\n      return;\n    }\n    var currentZoom = view.getZoom();\n    if (currentZoom !== void 0) {\n      var newZoom = view.getConstrainedZoom(currentZoom + delta);\n      if (this.duration_ > 0) {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.animate({\n          zoom: newZoom,\n          duration: this.duration_,\n          easing: easeOut\n        });\n      } else {\n        view.setZoom(newZoom);\n      }\n    }\n  };\n  return Zoom2;\n}(ol_control_Control);\nvar Zoom$1 = Zoom;\nvar __extends$1O = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar events = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nvar FullScreenEventType = {\n  ENTERFULLSCREEN: \"enterfullscreen\",\n  LEAVEFULLSCREEN: \"leavefullscreen\"\n};\nvar FullScreen = function(_super) {\n  __extends$1O(FullScreen2, _super);\n  function FullScreen2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      element: document.createElement(\"div\"),\n      target: options.target\n    }) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.keys_ = options.keys !== void 0 ? options.keys : false;\n    _this.source_ = options.source;\n    _this.isInFullscreen_ = false;\n    _this.boundHandleMapTargetChange_ = _this.handleMapTargetChange_.bind(_this);\n    _this.cssClassName_ = options.className !== void 0 ? options.className : \"ol-full-screen\";\n    _this.documentListeners_ = [];\n    _this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(\" \") : [_this.cssClassName_ + \"-true\"];\n    _this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(\" \") : [_this.cssClassName_ + \"-false\"];\n    var label = options.label !== void 0 ? options.label : \"\\u2922\";\n    _this.labelNode_ = typeof label === \"string\" ? document.createTextNode(label) : label;\n    var labelActive = options.labelActive !== void 0 ? options.labelActive : \"\\xD7\";\n    _this.labelActiveNode_ = typeof labelActive === \"string\" ? document.createTextNode(labelActive) : labelActive;\n    var tipLabel = options.tipLabel ? options.tipLabel : \"Toggle full-screen\";\n    _this.button_ = document.createElement(\"button\");\n    _this.button_.title = tipLabel;\n    _this.button_.setAttribute(\"type\", \"button\");\n    _this.button_.appendChild(_this.labelNode_);\n    _this.button_.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);\n    _this.setClassName_(_this.button_, _this.isInFullscreen_);\n    _this.element.className = \"\".concat(_this.cssClassName_, \" \").concat(CLASS_UNSELECTABLE, \" \").concat(CLASS_CONTROL);\n    _this.element.appendChild(_this.button_);\n    return _this;\n  }\n  FullScreen2.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    this.handleFullScreen_();\n  };\n  FullScreen2.prototype.handleFullScreen_ = function() {\n    var map = this.getMap();\n    if (!map) {\n      return;\n    }\n    var doc = map.getOwnerDocument();\n    if (!isFullScreenSupported(doc)) {\n      return;\n    }\n    if (isFullScreen(doc)) {\n      exitFullScreen(doc);\n    } else {\n      var element = void 0;\n      if (this.source_) {\n        element = typeof this.source_ === \"string\" ? doc.getElementById(this.source_) : this.source_;\n      } else {\n        element = map.getTargetElement();\n      }\n      if (this.keys_) {\n        requestFullScreenWithKeys(element);\n      } else {\n        requestFullScreen(element);\n      }\n    }\n  };\n  FullScreen2.prototype.handleFullScreenChange_ = function() {\n    var map = this.getMap();\n    if (!map) {\n      return;\n    }\n    var wasInFullscreen = this.isInFullscreen_;\n    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());\n    if (wasInFullscreen !== this.isInFullscreen_) {\n      this.setClassName_(this.button_, this.isInFullscreen_);\n      if (this.isInFullscreen_) {\n        replaceNode(this.labelActiveNode_, this.labelNode_);\n        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);\n      } else {\n        replaceNode(this.labelNode_, this.labelActiveNode_);\n        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);\n      }\n      map.updateSize();\n    }\n  };\n  FullScreen2.prototype.setClassName_ = function(element, fullscreen) {\n    var _a2, _b2, _c, _d;\n    if (fullscreen) {\n      (_a2 = element.classList).remove.apply(_a2, this.inactiveClassName_);\n      (_b2 = element.classList).add.apply(_b2, this.activeClassName_);\n    } else {\n      (_c = element.classList).remove.apply(_c, this.activeClassName_);\n      (_d = element.classList).add.apply(_d, this.inactiveClassName_);\n    }\n  };\n  FullScreen2.prototype.setMap = function(map) {\n    var oldMap = this.getMap();\n    if (oldMap) {\n      oldMap.removeChangeListener(MapProperty.TARGET, this.boundHandleMapTargetChange_);\n    }\n    _super.prototype.setMap.call(this, map);\n    this.handleMapTargetChange_();\n    if (map) {\n      map.addChangeListener(MapProperty.TARGET, this.boundHandleMapTargetChange_);\n    }\n  };\n  FullScreen2.prototype.handleMapTargetChange_ = function() {\n    var listeners = this.documentListeners_;\n    for (var i2 = 0, ii = listeners.length; i2 < ii; ++i2) {\n      unlistenByKey(listeners[i2]);\n    }\n    listeners.length = 0;\n    var map = this.getMap();\n    if (map) {\n      var doc = map.getOwnerDocument();\n      if (isFullScreenSupported(doc)) {\n        this.element.classList.remove(CLASS_UNSUPPORTED);\n      } else {\n        this.element.classList.add(CLASS_UNSUPPORTED);\n      }\n      for (var i2 = 0, ii = events.length; i2 < ii; ++i2) {\n        listeners.push(listen(doc, events[i2], this.handleFullScreenChange_, this));\n      }\n      this.handleFullScreenChange_();\n    }\n  };\n  return FullScreen2;\n}(ol_control_Control);\nfunction isFullScreenSupported(doc) {\n  var body = doc.body;\n  return !!(body[\"webkitRequestFullscreen\"] || body[\"msRequestFullscreen\"] && doc[\"msFullscreenEnabled\"] || body.requestFullscreen && doc.fullscreenEnabled);\n}\nfunction isFullScreen(doc) {\n  return !!(doc[\"webkitIsFullScreen\"] || doc[\"msFullscreenElement\"] || doc.fullscreenElement);\n}\nfunction requestFullScreen(element) {\n  if (element.requestFullscreen) {\n    element.requestFullscreen();\n  } else if (element[\"msRequestFullscreen\"]) {\n    element[\"msRequestFullscreen\"]();\n  } else if (element[\"webkitRequestFullscreen\"]) {\n    element[\"webkitRequestFullscreen\"]();\n  }\n}\nfunction requestFullScreenWithKeys(element) {\n  if (element[\"webkitRequestFullscreen\"]) {\n    element[\"webkitRequestFullscreen\"]();\n  } else {\n    requestFullScreen(element);\n  }\n}\nfunction exitFullScreen(doc) {\n  if (doc.exitFullscreen) {\n    doc.exitFullscreen();\n  } else if (doc[\"msExitFullscreen\"]) {\n    doc[\"msExitFullscreen\"]();\n  } else if (doc[\"webkitExitFullscreen\"]) {\n    doc[\"webkitExitFullscreen\"]();\n  }\n}\nvar FullScreen$1 = FullScreen;\nvar __extends$1N = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar PROJECTION = \"projection\";\nvar COORDINATE_FORMAT = \"coordinateFormat\";\nvar MousePosition = function(_super) {\n  __extends$1N(MousePosition2, _super);\n  function MousePosition2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var element = document.createElement(\"div\");\n    element.className = options.className !== void 0 ? options.className : \"ol-mouse-position\";\n    _this = _super.call(this, {\n      element,\n      render: options.render,\n      target: options.target\n    }) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.addChangeListener(PROJECTION, _this.handleProjectionChanged_);\n    if (options.coordinateFormat) {\n      _this.setCoordinateFormat(options.coordinateFormat);\n    }\n    if (options.projection) {\n      _this.setProjection(options.projection);\n    }\n    var renderOnMouseOut = true;\n    var placeholder = \"&#160;\";\n    if (\"undefinedHTML\" in options) {\n      if (options.undefinedHTML !== void 0) {\n        placeholder = options.undefinedHTML;\n      }\n      renderOnMouseOut = !!placeholder;\n    } else if (\"placeholder\" in options) {\n      if (options.placeholder === false) {\n        renderOnMouseOut = false;\n      } else {\n        placeholder = String(options.placeholder);\n      }\n    }\n    _this.placeholder_ = placeholder;\n    _this.renderOnMouseOut_ = renderOnMouseOut;\n    _this.renderedHTML_ = element.innerHTML;\n    _this.mapProjection_ = null;\n    _this.transform_ = null;\n    return _this;\n  }\n  MousePosition2.prototype.handleProjectionChanged_ = function() {\n    this.transform_ = null;\n  };\n  MousePosition2.prototype.getCoordinateFormat = function() {\n    return this.get(COORDINATE_FORMAT);\n  };\n  MousePosition2.prototype.getProjection = function() {\n    return this.get(PROJECTION);\n  };\n  MousePosition2.prototype.handleMouseMove = function(event) {\n    var map = this.getMap();\n    this.updateHTML_(map.getEventPixel(event));\n  };\n  MousePosition2.prototype.handleMouseOut = function(event) {\n    this.updateHTML_(null);\n  };\n  MousePosition2.prototype.setMap = function(map) {\n    _super.prototype.setMap.call(this, map);\n    if (map) {\n      var viewport = map.getViewport();\n      this.listenerKeys.push(listen(viewport, PointerEventType.POINTERMOVE, this.handleMouseMove, this));\n      if (this.renderOnMouseOut_) {\n        this.listenerKeys.push(listen(viewport, PointerEventType.POINTEROUT, this.handleMouseOut, this));\n      }\n      this.updateHTML_(null);\n    }\n  };\n  MousePosition2.prototype.setCoordinateFormat = function(format2) {\n    this.set(COORDINATE_FORMAT, format2);\n  };\n  MousePosition2.prototype.setProjection = function(projection) {\n    this.set(PROJECTION, get$3(projection));\n  };\n  MousePosition2.prototype.updateHTML_ = function(pixel) {\n    var html2 = this.placeholder_;\n    if (pixel && this.mapProjection_) {\n      if (!this.transform_) {\n        var projection = this.getProjection();\n        if (projection) {\n          this.transform_ = getTransformFromProjections(this.mapProjection_, projection);\n        } else {\n          this.transform_ = identityTransform;\n        }\n      }\n      var map = this.getMap();\n      var coordinate = map.getCoordinateFromPixelInternal(pixel);\n      if (coordinate) {\n        var userProjection2 = getUserProjection();\n        if (userProjection2) {\n          this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection2);\n        }\n        this.transform_(coordinate, coordinate);\n        var coordinateFormat = this.getCoordinateFormat();\n        if (coordinateFormat) {\n          html2 = coordinateFormat(coordinate);\n        } else {\n          html2 = coordinate.toString();\n        }\n      }\n    }\n    if (!this.renderedHTML_ || html2 !== this.renderedHTML_) {\n      this.element.innerHTML = html2;\n      this.renderedHTML_ = html2;\n    }\n  };\n  MousePosition2.prototype.render = function(mapEvent) {\n    var frameState = mapEvent.frameState;\n    if (!frameState) {\n      this.mapProjection_ = null;\n    } else {\n      if (this.mapProjection_ != frameState.viewState.projection) {\n        this.mapProjection_ = frameState.viewState.projection;\n        this.transform_ = null;\n      }\n    }\n  };\n  return MousePosition2;\n}(ol_control_Control);\nvar MousePosition$1 = MousePosition;\nvar OverlayPositioning = {\n  BOTTOM_LEFT: \"bottom-left\",\n  BOTTOM_CENTER: \"bottom-center\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  CENTER_LEFT: \"center-left\",\n  CENTER_CENTER: \"center-center\",\n  CENTER_RIGHT: \"center-right\",\n  TOP_LEFT: \"top-left\",\n  TOP_CENTER: \"top-center\",\n  TOP_RIGHT: \"top-right\"\n};\nvar __extends$1M = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Property$4 = {\n  ELEMENT: \"element\",\n  MAP: \"map\",\n  OFFSET: \"offset\",\n  POSITION: \"position\",\n  POSITIONING: \"positioning\"\n};\nvar Overlay$1 = function(_super) {\n  __extends$1M(Overlay2, _super);\n  function Overlay2(options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.options = options;\n    _this.id = options.id;\n    _this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;\n    _this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;\n    _this.element = document.createElement(\"div\");\n    _this.element.className = options.className !== void 0 ? options.className : \"ol-overlay-container \" + CLASS_SELECTABLE;\n    _this.element.style.position = \"absolute\";\n    _this.element.style.pointerEvents = \"auto\";\n    var autoPan = options.autoPan;\n    if (autoPan && typeof autoPan !== \"object\") {\n      autoPan = {\n        animation: options.autoPanAnimation,\n        margin: options.autoPanMargin\n      };\n    }\n    _this.autoPan = autoPan || false;\n    _this.rendered = {\n      transform_: \"\",\n      visible: true\n    };\n    _this.mapPostrenderListenerKey = null;\n    _this.addChangeListener(Property$4.ELEMENT, _this.handleElementChanged);\n    _this.addChangeListener(Property$4.MAP, _this.handleMapChanged);\n    _this.addChangeListener(Property$4.OFFSET, _this.handleOffsetChanged);\n    _this.addChangeListener(Property$4.POSITION, _this.handlePositionChanged);\n    _this.addChangeListener(Property$4.POSITIONING, _this.handlePositioningChanged);\n    if (options.element !== void 0) {\n      _this.setElement(options.element);\n    }\n    _this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);\n    _this.setPositioning(options.positioning !== void 0 ? options.positioning : OverlayPositioning.TOP_LEFT);\n    if (options.position !== void 0) {\n      _this.setPosition(options.position);\n    }\n    return _this;\n  }\n  Overlay2.prototype.getElement = function() {\n    return this.get(Property$4.ELEMENT);\n  };\n  Overlay2.prototype.getId = function() {\n    return this.id;\n  };\n  Overlay2.prototype.getMap = function() {\n    return this.get(Property$4.MAP) || null;\n  };\n  Overlay2.prototype.getOffset = function() {\n    return this.get(Property$4.OFFSET);\n  };\n  Overlay2.prototype.getPosition = function() {\n    return this.get(Property$4.POSITION);\n  };\n  Overlay2.prototype.getPositioning = function() {\n    return this.get(Property$4.POSITIONING);\n  };\n  Overlay2.prototype.handleElementChanged = function() {\n    removeChildren(this.element);\n    var element = this.getElement();\n    if (element) {\n      this.element.appendChild(element);\n    }\n  };\n  Overlay2.prototype.handleMapChanged = function() {\n    if (this.mapPostrenderListenerKey) {\n      removeNode(this.element);\n      unlistenByKey(this.mapPostrenderListenerKey);\n      this.mapPostrenderListenerKey = null;\n    }\n    var map = this.getMap();\n    if (map) {\n      this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);\n      this.updatePixelPosition();\n      var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();\n      if (this.insertFirst) {\n        container.insertBefore(this.element, container.childNodes[0] || null);\n      } else {\n        container.appendChild(this.element);\n      }\n      this.performAutoPan();\n    }\n  };\n  Overlay2.prototype.render = function() {\n    this.updatePixelPosition();\n  };\n  Overlay2.prototype.handleOffsetChanged = function() {\n    this.updatePixelPosition();\n  };\n  Overlay2.prototype.handlePositionChanged = function() {\n    this.updatePixelPosition();\n    this.performAutoPan();\n  };\n  Overlay2.prototype.handlePositioningChanged = function() {\n    this.updatePixelPosition();\n  };\n  Overlay2.prototype.setElement = function(element) {\n    this.set(Property$4.ELEMENT, element);\n  };\n  Overlay2.prototype.setMap = function(map) {\n    this.set(Property$4.MAP, map);\n  };\n  Overlay2.prototype.setOffset = function(offset2) {\n    this.set(Property$4.OFFSET, offset2);\n  };\n  Overlay2.prototype.setPosition = function(position2) {\n    this.set(Property$4.POSITION, position2);\n  };\n  Overlay2.prototype.performAutoPan = function() {\n    if (this.autoPan) {\n      this.panIntoView(this.autoPan);\n    }\n  };\n  Overlay2.prototype.panIntoView = function(opt_panIntoViewOptions) {\n    var map = this.getMap();\n    if (!map || !map.getTargetElement() || !this.get(Property$4.POSITION)) {\n      return;\n    }\n    var mapRect = this.getRect(map.getTargetElement(), map.getSize());\n    var element = this.getElement();\n    var overlayRect = this.getRect(element, [\n      outerWidth(element),\n      outerHeight(element)\n    ]);\n    var panIntoViewOptions = opt_panIntoViewOptions || {};\n    var myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;\n    if (!containsExtent(mapRect, overlayRect)) {\n      var offsetLeft = overlayRect[0] - mapRect[0];\n      var offsetRight = mapRect[2] - overlayRect[2];\n      var offsetTop = overlayRect[1] - mapRect[1];\n      var offsetBottom = mapRect[3] - overlayRect[3];\n      var delta = [0, 0];\n      if (offsetLeft < 0) {\n        delta[0] = offsetLeft - myMargin;\n      } else if (offsetRight < 0) {\n        delta[0] = Math.abs(offsetRight) + myMargin;\n      }\n      if (offsetTop < 0) {\n        delta[1] = offsetTop - myMargin;\n      } else if (offsetBottom < 0) {\n        delta[1] = Math.abs(offsetBottom) + myMargin;\n      }\n      if (delta[0] !== 0 || delta[1] !== 0) {\n        var center = map.getView().getCenterInternal();\n        var centerPx = map.getPixelFromCoordinateInternal(center);\n        if (!centerPx) {\n          return;\n        }\n        var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n        var panOptions = panIntoViewOptions.animation || {};\n        map.getView().animateInternal({\n          center: map.getCoordinateFromPixelInternal(newCenterPx),\n          duration: panOptions.duration,\n          easing: panOptions.easing\n        });\n      }\n    }\n  };\n  Overlay2.prototype.getRect = function(element, size) {\n    var box = element.getBoundingClientRect();\n    var offsetX = box.left + window.pageXOffset;\n    var offsetY = box.top + window.pageYOffset;\n    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n  };\n  Overlay2.prototype.setPositioning = function(positioning) {\n    this.set(Property$4.POSITIONING, positioning);\n  };\n  Overlay2.prototype.setVisible = function(visible) {\n    if (this.rendered.visible !== visible) {\n      this.element.style.display = visible ? \"\" : \"none\";\n      this.rendered.visible = visible;\n    }\n  };\n  Overlay2.prototype.updatePixelPosition = function() {\n    var map = this.getMap();\n    var position2 = this.getPosition();\n    if (!map || !map.isRendered() || !position2) {\n      this.setVisible(false);\n      return;\n    }\n    var pixel = map.getPixelFromCoordinate(position2);\n    var mapSize = map.getSize();\n    this.updateRenderedPosition(pixel, mapSize);\n  };\n  Overlay2.prototype.updateRenderedPosition = function(pixel, mapSize) {\n    var style2 = this.element.style;\n    var offset2 = this.getOffset();\n    var positioning = this.getPositioning();\n    this.setVisible(true);\n    var x2 = Math.round(pixel[0] + offset2[0]) + \"px\";\n    var y2 = Math.round(pixel[1] + offset2[1]) + \"px\";\n    var posX = \"0%\";\n    var posY = \"0%\";\n    if (positioning == OverlayPositioning.BOTTOM_RIGHT || positioning == OverlayPositioning.CENTER_RIGHT || positioning == OverlayPositioning.TOP_RIGHT) {\n      posX = \"-100%\";\n    } else if (positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.TOP_CENTER) {\n      posX = \"-50%\";\n    }\n    if (positioning == OverlayPositioning.BOTTOM_LEFT || positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.BOTTOM_RIGHT) {\n      posY = \"-100%\";\n    } else if (positioning == OverlayPositioning.CENTER_LEFT || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.CENTER_RIGHT) {\n      posY = \"-50%\";\n    }\n    var transform2 = \"translate(\".concat(posX, \", \").concat(posY, \") translate(\").concat(x2, \", \").concat(y2, \")\");\n    if (this.rendered.transform_ != transform2) {\n      this.rendered.transform_ = transform2;\n      style2.transform = transform2;\n      style2.msTransform = transform2;\n    }\n  };\n  Overlay2.prototype.getOptions = function() {\n    return this.options;\n  };\n  return Overlay2;\n}(ol_Object);\nvar Overlay$2 = Overlay$1;\nvar __extends$1L = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MAX_RATIO = 0.75;\nvar MIN_RATIO = 0.1;\nvar ControlledMap = function(_super) {\n  __extends$1L(ControlledMap2, _super);\n  function ControlledMap2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  ControlledMap2.prototype.createRenderer = function() {\n    return new CompositeMapRenderer$1(this);\n  };\n  return ControlledMap2;\n}(PluggableMap$1);\nvar OverviewMap = function(_super) {\n  __extends$1L(OverviewMap2, _super);\n  function OverviewMap2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      element: document.createElement(\"div\"),\n      render: options.render,\n      target: options.target\n    }) || this;\n    _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);\n    _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;\n    _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;\n    if (!_this.collapsible_) {\n      _this.collapsed_ = false;\n    }\n    _this.rotateWithView_ = options.rotateWithView !== void 0 ? options.rotateWithView : false;\n    _this.viewExtent_ = void 0;\n    var className = options.className !== void 0 ? options.className : \"ol-overviewmap\";\n    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : \"Overview map\";\n    var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : \"\\u2039\";\n    if (typeof collapseLabel === \"string\") {\n      _this.collapseLabel_ = document.createElement(\"span\");\n      _this.collapseLabel_.textContent = collapseLabel;\n    } else {\n      _this.collapseLabel_ = collapseLabel;\n    }\n    var label = options.label !== void 0 ? options.label : \"\\u203A\";\n    if (typeof label === \"string\") {\n      _this.label_ = document.createElement(\"span\");\n      _this.label_.textContent = label;\n    } else {\n      _this.label_ = label;\n    }\n    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;\n    var button = document.createElement(\"button\");\n    button.setAttribute(\"type\", \"button\");\n    button.title = tipLabel;\n    button.appendChild(activeLabel);\n    button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);\n    _this.ovmapDiv_ = document.createElement(\"div\");\n    _this.ovmapDiv_.className = \"ol-overviewmap-map\";\n    _this.view_ = options.view;\n    _this.ovmap_ = new ControlledMap({\n      view: options.view\n    });\n    var ovmap = _this.ovmap_;\n    if (options.layers) {\n      options.layers.forEach(function(layer) {\n        ovmap.addLayer(layer);\n      });\n    }\n    var box = document.createElement(\"div\");\n    box.className = \"ol-overviewmap-box\";\n    box.style.boxSizing = \"border-box\";\n    _this.boxOverlay_ = new Overlay$2({\n      position: [0, 0],\n      positioning: OverlayPositioning.CENTER_CENTER,\n      element: box\n    });\n    _this.ovmap_.addOverlay(_this.boxOverlay_);\n    var cssClasses = className + \" \" + CLASS_UNSELECTABLE + \" \" + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? \" \" + CLASS_COLLAPSED : \"\") + (_this.collapsible_ ? \"\" : \" ol-uncollapsible\");\n    var element = _this.element;\n    element.className = cssClasses;\n    element.appendChild(_this.ovmapDiv_);\n    element.appendChild(button);\n    var scope = _this;\n    var overlay = _this.boxOverlay_;\n    var overlayBox = _this.boxOverlay_.getElement();\n    var computeDesiredMousePosition = function(mousePosition) {\n      return {\n        clientX: mousePosition.clientX,\n        clientY: mousePosition.clientY\n      };\n    };\n    var move = function(event) {\n      var position2 = computeDesiredMousePosition(event);\n      var coordinates2 = ovmap.getEventCoordinateInternal(position2);\n      overlay.setPosition(coordinates2);\n    };\n    var endMoving = function(event) {\n      var coordinates2 = ovmap.getEventCoordinateInternal(event);\n      scope.getMap().getView().setCenterInternal(coordinates2);\n      window.removeEventListener(\"mousemove\", move);\n      window.removeEventListener(\"mouseup\", endMoving);\n    };\n    overlayBox.addEventListener(\"mousedown\", function() {\n      window.addEventListener(\"mousemove\", move);\n      window.addEventListener(\"mouseup\", endMoving);\n    });\n    return _this;\n  }\n  OverviewMap2.prototype.setMap = function(map) {\n    var oldMap = this.getMap();\n    if (map === oldMap) {\n      return;\n    }\n    if (oldMap) {\n      var oldView = oldMap.getView();\n      if (oldView) {\n        this.unbindView_(oldView);\n      }\n      this.ovmap_.setTarget(null);\n    }\n    _super.prototype.setMap.call(this, map);\n    if (map) {\n      this.ovmap_.setTarget(this.ovmapDiv_);\n      this.listenerKeys.push(listen(map, ObjectEventType.PROPERTYCHANGE, this.handleMapPropertyChange_, this));\n      var view = map.getView();\n      if (view) {\n        this.bindView_(view);\n        if (view.isDef()) {\n          this.ovmap_.updateSize();\n          this.resetExtent_();\n        }\n      }\n      if (!this.ovmap_.isRendered()) {\n        this.updateBoxAfterOvmapIsRendered_();\n      }\n    }\n  };\n  OverviewMap2.prototype.handleMapPropertyChange_ = function(event) {\n    if (event.key === MapProperty.VIEW) {\n      var oldView = event.oldValue;\n      if (oldView) {\n        this.unbindView_(oldView);\n      }\n      var newView = this.getMap().getView();\n      this.bindView_(newView);\n    } else if (!this.ovmap_.isRendered() && (event.key === MapProperty.TARGET || event.key === MapProperty.SIZE)) {\n      this.ovmap_.updateSize();\n    }\n  };\n  OverviewMap2.prototype.bindView_ = function(view) {\n    if (!this.view_) {\n      var newView = new ol_View({\n        projection: view.getProjection()\n      });\n      this.ovmap_.setView(newView);\n    }\n    view.addChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);\n    this.handleRotationChanged_();\n  };\n  OverviewMap2.prototype.unbindView_ = function(view) {\n    view.removeChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);\n  };\n  OverviewMap2.prototype.handleRotationChanged_ = function() {\n    if (this.rotateWithView_) {\n      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());\n    }\n  };\n  OverviewMap2.prototype.validateExtent_ = function() {\n    var map = this.getMap();\n    var ovmap = this.ovmap_;\n    if (!map.isRendered() || !ovmap.isRendered()) {\n      return;\n    }\n    var mapSize = map.getSize();\n    var view = map.getView();\n    var extent2 = view.calculateExtentInternal(mapSize);\n    if (this.viewExtent_ && equals$1(extent2, this.viewExtent_)) {\n      return;\n    }\n    this.viewExtent_ = extent2;\n    var ovmapSize = ovmap.getSize();\n    var ovview = ovmap.getView();\n    var ovextent = ovview.calculateExtentInternal(ovmapSize);\n    var topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent2));\n    var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent2));\n    var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);\n    var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);\n    var ovmapWidth = ovmapSize[0];\n    var ovmapHeight = ovmapSize[1];\n    if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {\n      this.resetExtent_();\n    } else if (!containsExtent(ovextent, extent2)) {\n      this.recenter_();\n    }\n  };\n  OverviewMap2.prototype.resetExtent_ = function() {\n    var map = this.getMap();\n    var ovmap = this.ovmap_;\n    var mapSize = map.getSize();\n    var view = map.getView();\n    var extent2 = view.calculateExtentInternal(mapSize);\n    var ovview = ovmap.getView();\n    var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;\n    var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);\n    scaleFromCenter(extent2, ratio);\n    ovview.fitInternal(fromExtent(extent2));\n  };\n  OverviewMap2.prototype.recenter_ = function() {\n    var map = this.getMap();\n    var ovmap = this.ovmap_;\n    var view = map.getView();\n    var ovview = ovmap.getView();\n    ovview.setCenterInternal(view.getCenterInternal());\n  };\n  OverviewMap2.prototype.updateBox_ = function() {\n    var map = this.getMap();\n    var ovmap = this.ovmap_;\n    if (!map.isRendered() || !ovmap.isRendered()) {\n      return;\n    }\n    var mapSize = map.getSize();\n    var view = map.getView();\n    var ovview = ovmap.getView();\n    var rotation = this.rotateWithView_ ? 0 : -view.getRotation();\n    var overlay = this.boxOverlay_;\n    var box = this.boxOverlay_.getElement();\n    var center = view.getCenterInternal();\n    var resolution = view.getResolution();\n    var ovresolution = ovview.getResolution();\n    var width = mapSize[0] * resolution / ovresolution;\n    var height = mapSize[1] * resolution / ovresolution;\n    overlay.setPosition(center);\n    if (box) {\n      box.style.width = width + \"px\";\n      box.style.height = height + \"px\";\n      var transform2 = \"rotate(\" + rotation + \"rad)\";\n      box.style.transform = transform2;\n    }\n  };\n  OverviewMap2.prototype.updateBoxAfterOvmapIsRendered_ = function() {\n    if (this.ovmapPostrenderKey_) {\n      return;\n    }\n    this.ovmapPostrenderKey_ = listenOnce(this.ovmap_, MapEventType.POSTRENDER, function(event) {\n      delete this.ovmapPostrenderKey_;\n      this.updateBox_();\n    }, this);\n  };\n  OverviewMap2.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    this.handleToggle_();\n  };\n  OverviewMap2.prototype.handleToggle_ = function() {\n    this.element.classList.toggle(CLASS_COLLAPSED);\n    if (this.collapsed_) {\n      replaceNode(this.collapseLabel_, this.label_);\n    } else {\n      replaceNode(this.label_, this.collapseLabel_);\n    }\n    this.collapsed_ = !this.collapsed_;\n    var ovmap = this.ovmap_;\n    if (!this.collapsed_) {\n      if (ovmap.isRendered()) {\n        this.viewExtent_ = void 0;\n        ovmap.render();\n        return;\n      }\n      ovmap.updateSize();\n      this.resetExtent_();\n      this.updateBoxAfterOvmapIsRendered_();\n    }\n  };\n  OverviewMap2.prototype.getCollapsible = function() {\n    return this.collapsible_;\n  };\n  OverviewMap2.prototype.setCollapsible = function(collapsible) {\n    if (this.collapsible_ === collapsible) {\n      return;\n    }\n    this.collapsible_ = collapsible;\n    this.element.classList.toggle(\"ol-uncollapsible\");\n    if (!collapsible && this.collapsed_) {\n      this.handleToggle_();\n    }\n  };\n  OverviewMap2.prototype.setCollapsed = function(collapsed) {\n    if (!this.collapsible_ || this.collapsed_ === collapsed) {\n      return;\n    }\n    this.handleToggle_();\n  };\n  OverviewMap2.prototype.getCollapsed = function() {\n    return this.collapsed_;\n  };\n  OverviewMap2.prototype.getRotateWithView = function() {\n    return this.rotateWithView_;\n  };\n  OverviewMap2.prototype.setRotateWithView = function(rotateWithView) {\n    if (this.rotateWithView_ === rotateWithView) {\n      return;\n    }\n    this.rotateWithView_ = rotateWithView;\n    if (this.getMap().getView().getRotation() !== 0) {\n      if (this.rotateWithView_) {\n        this.handleRotationChanged_();\n      } else {\n        this.ovmap_.getView().setRotation(0);\n      }\n      this.viewExtent_ = void 0;\n      this.validateExtent_();\n      this.updateBox_();\n    }\n  };\n  OverviewMap2.prototype.getOverviewMap = function() {\n    return this.ovmap_;\n  };\n  OverviewMap2.prototype.render = function(mapEvent) {\n    this.validateExtent_();\n    this.updateBox_();\n  };\n  return OverviewMap2;\n}(ol_control_Control);\nvar OverviewMap$1 = OverviewMap;\nvar __extends$1K = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar UNITS_PROP = \"units\";\nvar Units = {\n  DEGREES: \"degrees\",\n  IMPERIAL: \"imperial\",\n  NAUTICAL: \"nautical\",\n  METRIC: \"metric\",\n  US: \"us\"\n};\nvar LEADING_DIGITS = [1, 2, 5];\nvar DEFAULT_DPI = 25.4 / 0.28;\nvar ScaleLine = function(_super) {\n  __extends$1K(ScaleLine2, _super);\n  function ScaleLine2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var className = options.className !== void 0 ? options.className : options.bar ? \"ol-scale-bar\" : \"ol-scale-line\";\n    _this = _super.call(this, {\n      element: document.createElement(\"div\"),\n      render: options.render,\n      target: options.target\n    }) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.innerElement_ = document.createElement(\"div\");\n    _this.innerElement_.className = className + \"-inner\";\n    _this.element.className = className + \" \" + CLASS_UNSELECTABLE;\n    _this.element.appendChild(_this.innerElement_);\n    _this.viewState_ = null;\n    _this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;\n    _this.renderedVisible_ = false;\n    _this.renderedWidth_ = void 0;\n    _this.renderedHTML_ = \"\";\n    _this.addChangeListener(UNITS_PROP, _this.handleUnitsChanged_);\n    _this.setUnits(options.units || Units.METRIC);\n    _this.scaleBar_ = options.bar || false;\n    _this.scaleBarSteps_ = options.steps || 4;\n    _this.scaleBarText_ = options.text || false;\n    _this.dpi_ = options.dpi || void 0;\n    return _this;\n  }\n  ScaleLine2.prototype.getUnits = function() {\n    return this.get(UNITS_PROP);\n  };\n  ScaleLine2.prototype.handleUnitsChanged_ = function() {\n    this.updateElement_();\n  };\n  ScaleLine2.prototype.setUnits = function(units2) {\n    this.set(UNITS_PROP, units2);\n  };\n  ScaleLine2.prototype.setDpi = function(dpi) {\n    this.dpi_ = dpi;\n  };\n  ScaleLine2.prototype.updateElement_ = function() {\n    var viewState = this.viewState_;\n    if (!viewState) {\n      if (this.renderedVisible_) {\n        this.element.style.display = \"none\";\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n    var center = viewState.center;\n    var projection = viewState.projection;\n    var units2 = this.getUnits();\n    var pointResolutionUnits = units2 == Units.DEGREES ? Units$2.DEGREES : Units$2.METERS;\n    var pointResolution = getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);\n    var minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;\n    var nominalCount = minWidth * pointResolution;\n    var suffix2 = \"\";\n    if (units2 == Units.DEGREES) {\n      var metersPerDegree = METERS_PER_UNIT$1[Units$2.DEGREES];\n      nominalCount *= metersPerDegree;\n      if (nominalCount < metersPerDegree / 60) {\n        suffix2 = \"\\u2033\";\n        pointResolution *= 3600;\n      } else if (nominalCount < metersPerDegree) {\n        suffix2 = \"\\u2032\";\n        pointResolution *= 60;\n      } else {\n        suffix2 = \"\\xB0\";\n      }\n    } else if (units2 == Units.IMPERIAL) {\n      if (nominalCount < 0.9144) {\n        suffix2 = \"in\";\n        pointResolution /= 0.0254;\n      } else if (nominalCount < 1609.344) {\n        suffix2 = \"ft\";\n        pointResolution /= 0.3048;\n      } else {\n        suffix2 = \"mi\";\n        pointResolution /= 1609.344;\n      }\n    } else if (units2 == Units.NAUTICAL) {\n      pointResolution /= 1852;\n      suffix2 = \"nm\";\n    } else if (units2 == Units.METRIC) {\n      if (nominalCount < 1e-3) {\n        suffix2 = \"\\u03BCm\";\n        pointResolution *= 1e6;\n      } else if (nominalCount < 1) {\n        suffix2 = \"mm\";\n        pointResolution *= 1e3;\n      } else if (nominalCount < 1e3) {\n        suffix2 = \"m\";\n      } else {\n        suffix2 = \"km\";\n        pointResolution /= 1e3;\n      }\n    } else if (units2 == Units.US) {\n      if (nominalCount < 0.9144) {\n        suffix2 = \"in\";\n        pointResolution *= 39.37;\n      } else if (nominalCount < 1609.344) {\n        suffix2 = \"ft\";\n        pointResolution /= 0.30480061;\n      } else {\n        suffix2 = \"mi\";\n        pointResolution /= 1609.3472;\n      }\n    } else {\n      assert(false, 33);\n    }\n    var i2 = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));\n    var count, width, decimalCount;\n    while (true) {\n      decimalCount = Math.floor(i2 / 3);\n      var decimal = Math.pow(10, decimalCount);\n      count = LEADING_DIGITS[(i2 % 3 + 3) % 3] * decimal;\n      width = Math.round(count / pointResolution);\n      if (isNaN(width)) {\n        this.element.style.display = \"none\";\n        this.renderedVisible_ = false;\n        return;\n      } else if (width >= minWidth) {\n        break;\n      }\n      ++i2;\n    }\n    var html2;\n    if (this.scaleBar_) {\n      html2 = this.createScaleBar(width, count, suffix2);\n    } else {\n      html2 = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + \" \" + suffix2;\n    }\n    if (this.renderedHTML_ != html2) {\n      this.innerElement_.innerHTML = html2;\n      this.renderedHTML_ = html2;\n    }\n    if (this.renderedWidth_ != width) {\n      this.innerElement_.style.width = width + \"px\";\n      this.renderedWidth_ = width;\n    }\n    if (!this.renderedVisible_) {\n      this.element.style.display = \"\";\n      this.renderedVisible_ = true;\n    }\n  };\n  ScaleLine2.prototype.createScaleBar = function(width, scale2, suffix2) {\n    var mapScale = \"1 : \" + Math.round(this.getScaleForResolution()).toLocaleString();\n    var scaleSteps = [];\n    var stepWidth = width / this.scaleBarSteps_;\n    var backgroundColor2 = \"#ffffff\";\n    for (var i2 = 0; i2 < this.scaleBarSteps_; i2++) {\n      if (i2 === 0) {\n        scaleSteps.push(this.createMarker(\"absolute\", i2));\n      }\n      scaleSteps.push('<div><div class=\"ol-scale-singlebar\" style=\"width: ' + stepWidth + \"px;background-color: \" + backgroundColor2 + ';\"></div>' + this.createMarker(\"relative\", i2) + (i2 % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i2, width, false, scale2, suffix2) : \"\") + \"</div>\");\n      if (i2 === this.scaleBarSteps_ - 1) {\n        scaleSteps.push(this.createStepText(i2 + 1, width, true, scale2, suffix2));\n      }\n      if (backgroundColor2 === \"#ffffff\") {\n        backgroundColor2 = \"#000000\";\n      } else {\n        backgroundColor2 = \"#ffffff\";\n      }\n    }\n    var scaleBarText;\n    if (this.scaleBarText_) {\n      scaleBarText = '<div class=\"ol-scale-text\" style=\"width: ' + width + 'px;\">' + mapScale + \"</div>\";\n    } else {\n      scaleBarText = \"\";\n    }\n    var container = '<div style=\"display: flex;\">' + scaleBarText + scaleSteps.join(\"\") + \"</div>\";\n    return container;\n  };\n  ScaleLine2.prototype.createMarker = function(position2, i2) {\n    var top = position2 === \"absolute\" ? 3 : -10;\n    return '<div class=\"ol-scale-step-marker\" style=\"position: ' + position2 + \";top: \" + top + 'px;\"></div>';\n  };\n  ScaleLine2.prototype.createStepText = function(i2, width, isLast, scale2, suffix2) {\n    var length = i2 === 0 ? 0 : Math.round(scale2 / this.scaleBarSteps_ * i2 * 100) / 100;\n    var lengthString = length + (i2 === 0 ? \"\" : \" \" + suffix2);\n    var margin = i2 === 0 ? -3 : width / this.scaleBarSteps_ * -1;\n    var minWidth = i2 === 0 ? 0 : width / this.scaleBarSteps_ * 2;\n    return '<div class=\"ol-scale-step-text\" style=\"margin-left: ' + margin + \"px;text-align: \" + (i2 === 0 ? \"left\" : \"center\") + \"; min-width: \" + minWidth + \"px;left: \" + (isLast ? width + \"px\" : \"unset\") + ';\">' + lengthString + \"</div>\";\n  };\n  ScaleLine2.prototype.getScaleForResolution = function() {\n    var resolution = getPointResolution(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, Units$2.METERS);\n    var dpi = this.dpi_ || DEFAULT_DPI;\n    var inchesPerMeter = 1e3 / 25.4;\n    return parseFloat(resolution.toString()) * inchesPerMeter * dpi;\n  };\n  ScaleLine2.prototype.render = function(mapEvent) {\n    var frameState = mapEvent.frameState;\n    if (!frameState) {\n      this.viewState_ = null;\n    } else {\n      this.viewState_ = frameState.viewState;\n    }\n    this.updateElement_();\n  };\n  return ScaleLine2;\n}(ol_control_Control);\nvar ScaleLine$1 = ScaleLine;\nvar __extends$1J = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Direction = {\n  VERTICAL: 0,\n  HORIZONTAL: 1\n};\nvar ZoomSlider = function(_super) {\n  __extends$1J(ZoomSlider2, _super);\n  function ZoomSlider2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      element: document.createElement(\"div\"),\n      render: options.render\n    }) || this;\n    _this.dragListenerKeys_ = [];\n    _this.currentResolution_ = void 0;\n    _this.direction_ = Direction.VERTICAL;\n    _this.dragging_;\n    _this.heightLimit_ = 0;\n    _this.widthLimit_ = 0;\n    _this.startX_;\n    _this.startY_;\n    _this.thumbSize_ = null;\n    _this.sliderInitialized_ = false;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 200;\n    var className = options.className !== void 0 ? options.className : \"ol-zoomslider\";\n    var thumbElement = document.createElement(\"button\");\n    thumbElement.setAttribute(\"type\", \"button\");\n    thumbElement.className = className + \"-thumb \" + CLASS_UNSELECTABLE;\n    var containerElement = _this.element;\n    containerElement.className = className + \" \" + CLASS_UNSELECTABLE + \" \" + CLASS_CONTROL;\n    containerElement.appendChild(thumbElement);\n    containerElement.addEventListener(PointerEventType.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);\n    containerElement.addEventListener(PointerEventType.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);\n    containerElement.addEventListener(PointerEventType.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);\n    containerElement.addEventListener(EventType.CLICK, _this.handleContainerClick_.bind(_this), false);\n    thumbElement.addEventListener(EventType.CLICK, stopPropagation, false);\n    return _this;\n  }\n  ZoomSlider2.prototype.setMap = function(map) {\n    _super.prototype.setMap.call(this, map);\n    if (map) {\n      map.render();\n    }\n  };\n  ZoomSlider2.prototype.initSlider_ = function() {\n    var container = this.element;\n    var containerWidth = container.offsetWidth;\n    var containerHeight = container.offsetHeight;\n    if (containerWidth === 0 && containerHeight === 0) {\n      return this.sliderInitialized_ = false;\n    }\n    var containerStyle = getComputedStyle(container);\n    containerWidth -= parseFloat(containerStyle[\"paddingRight\"]) + parseFloat(containerStyle[\"paddingLeft\"]);\n    containerHeight -= parseFloat(containerStyle[\"paddingTop\"]) + parseFloat(containerStyle[\"paddingBottom\"]);\n    var thumb = container.firstElementChild;\n    var thumbStyle = getComputedStyle(thumb);\n    var thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle[\"marginRight\"]) + parseFloat(thumbStyle[\"marginLeft\"]);\n    var thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle[\"marginTop\"]) + parseFloat(thumbStyle[\"marginBottom\"]);\n    this.thumbSize_ = [thumbWidth, thumbHeight];\n    if (containerWidth > containerHeight) {\n      this.direction_ = Direction.HORIZONTAL;\n      this.widthLimit_ = containerWidth - thumbWidth;\n    } else {\n      this.direction_ = Direction.VERTICAL;\n      this.heightLimit_ = containerHeight - thumbHeight;\n    }\n    return this.sliderInitialized_ = true;\n  };\n  ZoomSlider2.prototype.handleContainerClick_ = function(event) {\n    var view = this.getMap().getView();\n    var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);\n    var resolution = this.getResolutionForPosition_(relativePosition);\n    var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));\n    view.animateInternal({\n      zoom,\n      duration: this.duration_,\n      easing: easeOut\n    });\n  };\n  ZoomSlider2.prototype.handleDraggerStart_ = function(event) {\n    if (!this.dragging_ && event.target === this.element.firstElementChild) {\n      var element = this.element.firstElementChild;\n      this.getMap().getView().beginInteraction();\n      this.startX_ = event.clientX - parseFloat(element.style.left);\n      this.startY_ = event.clientY - parseFloat(element.style.top);\n      this.dragging_ = true;\n      if (this.dragListenerKeys_.length === 0) {\n        var drag = this.handleDraggerDrag_;\n        var end = this.handleDraggerEnd_;\n        var doc = this.getMap().getOwnerDocument();\n        this.dragListenerKeys_.push(listen(doc, PointerEventType.POINTERMOVE, drag, this), listen(doc, PointerEventType.POINTERUP, end, this));\n      }\n    }\n  };\n  ZoomSlider2.prototype.handleDraggerDrag_ = function(event) {\n    if (this.dragging_) {\n      var deltaX = event.clientX - this.startX_;\n      var deltaY = event.clientY - this.startY_;\n      var relativePosition = this.getRelativePosition_(deltaX, deltaY);\n      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);\n      this.getMap().getView().setResolution(this.currentResolution_);\n    }\n  };\n  ZoomSlider2.prototype.handleDraggerEnd_ = function(event) {\n    if (this.dragging_) {\n      var view = this.getMap().getView();\n      view.endInteraction();\n      this.dragging_ = false;\n      this.startX_ = void 0;\n      this.startY_ = void 0;\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n    }\n  };\n  ZoomSlider2.prototype.setThumbPosition_ = function(res) {\n    var position2 = this.getPositionForResolution_(res);\n    var thumb = this.element.firstElementChild;\n    if (this.direction_ == Direction.HORIZONTAL) {\n      thumb.style.left = this.widthLimit_ * position2 + \"px\";\n    } else {\n      thumb.style.top = this.heightLimit_ * position2 + \"px\";\n    }\n  };\n  ZoomSlider2.prototype.getRelativePosition_ = function(x2, y2) {\n    var amount;\n    if (this.direction_ === Direction.HORIZONTAL) {\n      amount = x2 / this.widthLimit_;\n    } else {\n      amount = y2 / this.heightLimit_;\n    }\n    return clamp(amount, 0, 1);\n  };\n  ZoomSlider2.prototype.getResolutionForPosition_ = function(position2) {\n    var fn = this.getMap().getView().getResolutionForValueFunction();\n    return fn(1 - position2);\n  };\n  ZoomSlider2.prototype.getPositionForResolution_ = function(res) {\n    var fn = this.getMap().getView().getValueForResolutionFunction();\n    return clamp(1 - fn(res), 0, 1);\n  };\n  ZoomSlider2.prototype.render = function(mapEvent) {\n    if (!mapEvent.frameState) {\n      return;\n    }\n    if (!this.sliderInitialized_ && !this.initSlider_()) {\n      return;\n    }\n    var res = mapEvent.frameState.viewState.resolution;\n    this.currentResolution_ = res;\n    this.setThumbPosition_(res);\n  };\n  return ZoomSlider2;\n}(ol_control_Control);\nvar ZoomSlider$1 = ZoomSlider;\nvar __extends$1I = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ZoomToExtent = function(_super) {\n  __extends$1I(ZoomToExtent2, _super);\n  function ZoomToExtent2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      element: document.createElement(\"div\"),\n      target: options.target\n    }) || this;\n    _this.extent = options.extent ? options.extent : null;\n    var className = options.className !== void 0 ? options.className : \"ol-zoom-extent\";\n    var label = options.label !== void 0 ? options.label : \"E\";\n    var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : \"Fit to extent\";\n    var button = document.createElement(\"button\");\n    button.setAttribute(\"type\", \"button\");\n    button.title = tipLabel;\n    button.appendChild(typeof label === \"string\" ? document.createTextNode(label) : label);\n    button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);\n    var cssClasses = className + \" \" + CLASS_UNSELECTABLE + \" \" + CLASS_CONTROL;\n    var element = _this.element;\n    element.className = cssClasses;\n    element.appendChild(button);\n    return _this;\n  }\n  ZoomToExtent2.prototype.handleClick_ = function(event) {\n    event.preventDefault();\n    this.handleZoomToExtent();\n  };\n  ZoomToExtent2.prototype.handleZoomToExtent = function() {\n    var map = this.getMap();\n    var view = map.getView();\n    var extent2 = !this.extent ? view.getProjection().getExtent() : this.extent;\n    view.fitInternal(fromExtent(extent2));\n  };\n  return ZoomToExtent2;\n}(ol_control_Control);\nvar ZoomToExtent$1 = ZoomToExtent;\nfunction defaults$1(opt_options) {\n  var options = opt_options ? opt_options : {};\n  var controls = new ol_Collection();\n  var zoomControl = options.zoom !== void 0 ? options.zoom : true;\n  if (zoomControl) {\n    controls.push(new Zoom$1(options.zoomOptions));\n  }\n  var rotateControl = options.rotate !== void 0 ? options.rotate : true;\n  if (rotateControl) {\n    controls.push(new Rotate$2(options.rotateOptions));\n  }\n  var attributionControl = options.attribution !== void 0 ? options.attribution : true;\n  if (attributionControl) {\n    controls.push(new Attribution$1(options.attributionOptions));\n  }\n  return controls;\n}\nvar InteractionProperty = {\n  ACTIVE: \"active\"\n};\nvar __extends$1H = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Interaction = function(_super) {\n  __extends$1H(Interaction2, _super);\n  function Interaction2(opt_options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    if (opt_options && opt_options.handleEvent) {\n      _this.handleEvent = opt_options.handleEvent;\n    }\n    _this.map_ = null;\n    _this.setActive(true);\n    return _this;\n  }\n  Interaction2.prototype.getActive = function() {\n    return this.get(InteractionProperty.ACTIVE);\n  };\n  Interaction2.prototype.getMap = function() {\n    return this.map_;\n  };\n  Interaction2.prototype.handleEvent = function(mapBrowserEvent) {\n    return true;\n  };\n  Interaction2.prototype.setActive = function(active) {\n    this.set(InteractionProperty.ACTIVE, active);\n  };\n  Interaction2.prototype.setMap = function(map) {\n    this.map_ = map;\n  };\n  return Interaction2;\n}(ol_Object);\nfunction pan(view, delta, opt_duration) {\n  var currentCenter = view.getCenterInternal();\n  if (currentCenter) {\n    var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];\n    view.animateInternal({\n      duration: opt_duration !== void 0 ? opt_duration : 250,\n      easing: linear,\n      center: view.getConstrainedCenter(center)\n    });\n  }\n}\nfunction zoomByDelta(view, delta, opt_anchor, opt_duration) {\n  var currentZoom = view.getZoom();\n  if (currentZoom === void 0) {\n    return;\n  }\n  var newZoom = view.getConstrainedZoom(currentZoom + delta);\n  var newResolution = view.getResolutionForZoom(newZoom);\n  if (view.getAnimating()) {\n    view.cancelAnimations();\n  }\n  view.animate({\n    resolution: newResolution,\n    anchor: opt_anchor,\n    duration: opt_duration !== void 0 ? opt_duration : 250,\n    easing: easeOut\n  });\n}\nvar Interaction$1 = Interaction;\nvar __extends$1G = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DoubleClickZoom = function(_super) {\n  __extends$1G(DoubleClickZoom2, _super);\n  function DoubleClickZoom2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.delta_ = options.delta ? options.delta : 1;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 250;\n    return _this;\n  }\n  DoubleClickZoom2.prototype.handleEvent = function(mapBrowserEvent) {\n    var stopEvent = false;\n    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {\n      var browserEvent = mapBrowserEvent.originalEvent;\n      var map = mapBrowserEvent.map;\n      var anchor = mapBrowserEvent.coordinate;\n      var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n      var view = map.getView();\n      zoomByDelta(view, delta, anchor, this.duration_);\n      browserEvent.preventDefault();\n      stopEvent = true;\n    }\n    return !stopEvent;\n  };\n  return DoubleClickZoom2;\n}(Interaction$1);\nvar DoubleClickZoom$1 = DoubleClickZoom;\nvar __extends$1F = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar PointerInteraction = function(_super) {\n  __extends$1F(PointerInteraction2, _super);\n  function PointerInteraction2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, options) || this;\n    if (options.handleDownEvent) {\n      _this.handleDownEvent = options.handleDownEvent;\n    }\n    if (options.handleDragEvent) {\n      _this.handleDragEvent = options.handleDragEvent;\n    }\n    if (options.handleMoveEvent) {\n      _this.handleMoveEvent = options.handleMoveEvent;\n    }\n    if (options.handleUpEvent) {\n      _this.handleUpEvent = options.handleUpEvent;\n    }\n    if (options.stopDown) {\n      _this.stopDown = options.stopDown;\n    }\n    _this.handlingDownUpSequence = false;\n    _this.trackedPointers_ = {};\n    _this.targetPointers = [];\n    return _this;\n  }\n  PointerInteraction2.prototype.getPointerCount = function() {\n    return this.targetPointers.length;\n  };\n  PointerInteraction2.prototype.handleDownEvent = function(mapBrowserEvent) {\n    return false;\n  };\n  PointerInteraction2.prototype.handleDragEvent = function(mapBrowserEvent) {\n  };\n  PointerInteraction2.prototype.handleEvent = function(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n    var stopEvent = false;\n    this.updateTrackedPointers_(mapBrowserEvent);\n    if (this.handlingDownUpSequence) {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\n        this.handleDragEvent(mapBrowserEvent);\n        mapBrowserEvent.originalEvent.preventDefault();\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n        var handledUp = this.handleUpEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;\n      }\n    } else {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n        var handled = this.handleDownEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handled;\n        stopEvent = this.stopDown(handled);\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\n        this.handleMoveEvent(mapBrowserEvent);\n      }\n    }\n    return !stopEvent;\n  };\n  PointerInteraction2.prototype.handleMoveEvent = function(mapBrowserEvent) {\n  };\n  PointerInteraction2.prototype.handleUpEvent = function(mapBrowserEvent) {\n    return false;\n  };\n  PointerInteraction2.prototype.stopDown = function(handled) {\n    return handled;\n  };\n  PointerInteraction2.prototype.updateTrackedPointers_ = function(mapBrowserEvent) {\n    if (isPointerDraggingEvent(mapBrowserEvent)) {\n      var event_1 = mapBrowserEvent.originalEvent;\n      var id = event_1.pointerId.toString();\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n        delete this.trackedPointers_[id];\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n        this.trackedPointers_[id] = event_1;\n      } else if (id in this.trackedPointers_) {\n        this.trackedPointers_[id] = event_1;\n      }\n      this.targetPointers = getValues(this.trackedPointers_);\n    }\n  };\n  return PointerInteraction2;\n}(Interaction$1);\nfunction centroid(pointerEvents) {\n  var length = pointerEvents.length;\n  var clientX = 0;\n  var clientY = 0;\n  for (var i2 = 0; i2 < length; i2++) {\n    clientX += pointerEvents[i2].clientX;\n    clientY += pointerEvents[i2].clientY;\n  }\n  return [clientX / length, clientY / length];\n}\nfunction isPointerDraggingEvent(mapBrowserEvent) {\n  var type = mapBrowserEvent.type;\n  return type === MapBrowserEventType.POINTERDOWN || type === MapBrowserEventType.POINTERDRAG || type === MapBrowserEventType.POINTERUP;\n}\nvar ol_interaction_Pointer = PointerInteraction;\nfunction all$1(var_args) {\n  var conditions = arguments;\n  return function(event) {\n    var pass = true;\n    for (var i2 = 0, ii = conditions.length; i2 < ii; ++i2) {\n      pass = pass && conditions[i2](event);\n      if (!pass) {\n        break;\n      }\n    }\n    return pass;\n  };\n}\nvar altKeyOnly = function(mapBrowserEvent) {\n  var originalEvent = mapBrowserEvent.originalEvent;\n  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\nvar altShiftKeysOnly = function(mapBrowserEvent) {\n  var originalEvent = mapBrowserEvent.originalEvent;\n  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;\n};\nvar focus = function(event) {\n  var targetElement = event.map.getTargetElement();\n  var activeElement = event.map.getOwnerDocument().activeElement;\n  return targetElement.contains(activeElement);\n};\nvar focusWithTabindex = function(event) {\n  return event.map.getTargetElement().hasAttribute(\"tabindex\") ? focus(event) : true;\n};\nvar always = TRUE;\nvar click = function(mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.CLICK;\n};\nvar mouseActionButton = function(mapBrowserEvent) {\n  var originalEvent = mapBrowserEvent.originalEvent;\n  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);\n};\nvar never = FALSE;\nvar pointerMove = function(mapBrowserEvent) {\n  return mapBrowserEvent.type == \"pointermove\";\n};\nvar singleClick = function(mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;\n};\nvar doubleClick = function(mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;\n};\nvar noModifierKeys = function(mapBrowserEvent) {\n  var originalEvent = mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\nvar platformModifierKeyOnly = function(mapBrowserEvent) {\n  var originalEvent = mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\nvar shiftKeyOnly = function(mapBrowserEvent) {\n  var originalEvent = mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;\n};\nvar targetNotEditable = function(mapBrowserEvent) {\n  var originalEvent = mapBrowserEvent.originalEvent;\n  var tagName = originalEvent.target.tagName;\n  return tagName !== \"INPUT\" && tagName !== \"SELECT\" && tagName !== \"TEXTAREA\";\n};\nvar mouseOnly = function(mapBrowserEvent) {\n  var pointerEvent = mapBrowserEvent.originalEvent;\n  assert(pointerEvent !== void 0, 56);\n  return pointerEvent.pointerType == \"mouse\";\n};\nvar touchOnly = function(mapBrowserEvent) {\n  var pointerEvt = mapBrowserEvent.originalEvent;\n  assert(pointerEvt !== void 0, 56);\n  return pointerEvt.pointerType === \"touch\";\n};\nvar penOnly = function(mapBrowserEvent) {\n  var pointerEvt = mapBrowserEvent.originalEvent;\n  assert(pointerEvt !== void 0, 56);\n  return pointerEvt.pointerType === \"pen\";\n};\nvar primaryAction = function(mapBrowserEvent) {\n  var pointerEvent = mapBrowserEvent.originalEvent;\n  assert(pointerEvent !== void 0, 56);\n  return pointerEvent.isPrimary && pointerEvent.button === 0;\n};\nvar selectconditions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  all: all$1,\n  altKeyOnly,\n  altShiftKeysOnly,\n  focus,\n  focusWithTabindex,\n  always,\n  click,\n  mouseActionButton,\n  never,\n  pointerMove,\n  singleClick,\n  doubleClick,\n  noModifierKeys,\n  platformModifierKeyOnly,\n  shiftKeyOnly,\n  targetNotEditable,\n  mouseOnly,\n  touchOnly,\n  penOnly,\n  primaryAction\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar __extends$1E = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DragPan = function(_super) {\n  __extends$1E(DragPan2, _super);\n  function DragPan2(opt_options) {\n    var _this = _super.call(this, {\n      stopDown: FALSE\n    }) || this;\n    var options = opt_options ? opt_options : {};\n    _this.kinetic_ = options.kinetic;\n    _this.lastCentroid = null;\n    _this.lastPointersCount_;\n    _this.panning_ = false;\n    var condition = options.condition ? options.condition : all$1(noModifierKeys, primaryAction);\n    _this.condition_ = options.onFocusOnly ? all$1(focusWithTabindex, condition) : condition;\n    _this.noKinetic_ = false;\n    return _this;\n  }\n  DragPan2.prototype.handleDragEvent = function(mapBrowserEvent) {\n    if (!this.panning_) {\n      this.panning_ = true;\n      this.getMap().getView().beginInteraction();\n    }\n    var targetPointers = this.targetPointers;\n    var centroid$1 = centroid(targetPointers);\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid$1[0], centroid$1[1]);\n      }\n      if (this.lastCentroid) {\n        var delta = [\n          this.lastCentroid[0] - centroid$1[0],\n          centroid$1[1] - this.lastCentroid[1]\n        ];\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        scale$2(delta, view.getResolution());\n        rotate$1(delta, view.getRotation());\n        view.adjustCenterInternal(delta);\n      }\n    } else if (this.kinetic_) {\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = centroid$1;\n    this.lastPointersCount_ = targetPointers.length;\n    mapBrowserEvent.originalEvent.preventDefault();\n  };\n  DragPan2.prototype.handleUpEvent = function(mapBrowserEvent) {\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        var distance2 = this.kinetic_.getDistance();\n        var angle2 = this.kinetic_.getAngle();\n        var center = view.getCenterInternal();\n        var centerpx = map.getPixelFromCoordinateInternal(center);\n        var dest = map.getCoordinateFromPixelInternal([\n          centerpx[0] - distance2 * Math.cos(angle2),\n          centerpx[1] - distance2 * Math.sin(angle2)\n        ]);\n        view.animateInternal({\n          center: view.getConstrainedCenter(dest),\n          duration: 500,\n          easing: easeOut\n        });\n      }\n      if (this.panning_) {\n        this.panning_ = false;\n        view.endInteraction();\n      }\n      return false;\n    } else {\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      this.lastCentroid = null;\n      return true;\n    }\n  };\n  DragPan2.prototype.handleDownEvent = function(mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      this.lastCentroid = null;\n      if (view.getAnimating()) {\n        view.cancelAnimations();\n      }\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return DragPan2;\n}(ol_interaction_Pointer);\nvar DragPan$1 = DragPan;\nvar __extends$1D = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DragRotate = function(_super) {\n  __extends$1D(DragRotate2, _super);\n  function DragRotate2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, {\n      stopDown: FALSE\n    }) || this;\n    _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;\n    _this.lastAngle_ = void 0;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 250;\n    return _this;\n  }\n  DragRotate2.prototype.handleDragEvent = function(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n    var size = map.getSize();\n    var offset2 = mapBrowserEvent.pixel;\n    var theta = Math.atan2(size[1] / 2 - offset2[1], offset2[0] - size[0] / 2);\n    if (this.lastAngle_ !== void 0) {\n      var delta = theta - this.lastAngle_;\n      view.adjustRotationInternal(-delta);\n    }\n    this.lastAngle_ = theta;\n  };\n  DragRotate2.prototype.handleUpEvent = function(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    view.endInteraction(this.duration_);\n    return false;\n  };\n  DragRotate2.prototype.handleDownEvent = function(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {\n      var map = mapBrowserEvent.map;\n      map.getView().beginInteraction();\n      this.lastAngle_ = void 0;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return DragRotate2;\n}(ol_interaction_Pointer);\nvar DragRotate$1 = DragRotate;\nvar __extends$1C = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar RenderBox = function(_super) {\n  __extends$1C(RenderBox2, _super);\n  function RenderBox2(className) {\n    var _this = _super.call(this) || this;\n    _this.geometry_ = null;\n    _this.element_ = document.createElement(\"div\");\n    _this.element_.style.position = \"absolute\";\n    _this.element_.style.pointerEvents = \"auto\";\n    _this.element_.className = \"ol-box \" + className;\n    _this.map_ = null;\n    _this.startPixel_ = null;\n    _this.endPixel_ = null;\n    return _this;\n  }\n  RenderBox2.prototype.disposeInternal = function() {\n    this.setMap(null);\n  };\n  RenderBox2.prototype.render_ = function() {\n    var startPixel = this.startPixel_;\n    var endPixel = this.endPixel_;\n    var px = \"px\";\n    var style2 = this.element_.style;\n    style2.left = Math.min(startPixel[0], endPixel[0]) + px;\n    style2.top = Math.min(startPixel[1], endPixel[1]) + px;\n    style2.width = Math.abs(endPixel[0] - startPixel[0]) + px;\n    style2.height = Math.abs(endPixel[1] - startPixel[1]) + px;\n  };\n  RenderBox2.prototype.setMap = function(map) {\n    if (this.map_) {\n      this.map_.getOverlayContainer().removeChild(this.element_);\n      var style2 = this.element_.style;\n      style2.left = \"inherit\";\n      style2.top = \"inherit\";\n      style2.width = \"inherit\";\n      style2.height = \"inherit\";\n    }\n    this.map_ = map;\n    if (this.map_) {\n      this.map_.getOverlayContainer().appendChild(this.element_);\n    }\n  };\n  RenderBox2.prototype.setPixels = function(startPixel, endPixel) {\n    this.startPixel_ = startPixel;\n    this.endPixel_ = endPixel;\n    this.createOrUpdateGeometry();\n    this.render_();\n  };\n  RenderBox2.prototype.createOrUpdateGeometry = function() {\n    var startPixel = this.startPixel_;\n    var endPixel = this.endPixel_;\n    var pixels = [\n      startPixel,\n      [startPixel[0], endPixel[1]],\n      endPixel,\n      [endPixel[0], startPixel[1]]\n    ];\n    var coordinates2 = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);\n    coordinates2[4] = coordinates2[0].slice();\n    if (!this.geometry_) {\n      this.geometry_ = new Polygon$2([coordinates2]);\n    } else {\n      this.geometry_.setCoordinates([coordinates2]);\n    }\n  };\n  RenderBox2.prototype.getGeometry = function() {\n    return this.geometry_;\n  };\n  return RenderBox2;\n}(Disposable$1);\nvar RenderBox$1 = RenderBox;\nvar __extends$1B = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DragBoxEventType = {\n  BOXSTART: \"boxstart\",\n  BOXDRAG: \"boxdrag\",\n  BOXEND: \"boxend\",\n  BOXCANCEL: \"boxcancel\"\n};\nvar DragBoxEvent = function(_super) {\n  __extends$1B(DragBoxEvent2, _super);\n  function DragBoxEvent2(type, coordinate, mapBrowserEvent) {\n    var _this = _super.call(this, type) || this;\n    _this.coordinate = coordinate;\n    _this.mapBrowserEvent = mapBrowserEvent;\n    return _this;\n  }\n  return DragBoxEvent2;\n}(Event$1);\nvar DragBox = function(_super) {\n  __extends$1B(DragBox2, _super);\n  function DragBox2(opt_options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    var options = opt_options ? opt_options : {};\n    _this.box_ = new RenderBox$1(options.className || \"ol-dragbox\");\n    _this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;\n    if (options.onBoxEnd) {\n      _this.onBoxEnd = options.onBoxEnd;\n    }\n    _this.startPixel_ = null;\n    _this.condition_ = options.condition ? options.condition : mouseActionButton;\n    _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;\n    return _this;\n  }\n  DragBox2.prototype.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {\n    var width = endPixel[0] - startPixel[0];\n    var height = endPixel[1] - startPixel[1];\n    return width * width + height * height >= this.minArea_;\n  };\n  DragBox2.prototype.getGeometry = function() {\n    return this.box_.getGeometry();\n  };\n  DragBox2.prototype.handleDragEvent = function(mapBrowserEvent) {\n    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));\n  };\n  DragBox2.prototype.handleUpEvent = function(mapBrowserEvent) {\n    this.box_.setMap(null);\n    var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);\n    if (completeBox) {\n      this.onBoxEnd(mapBrowserEvent);\n    }\n    this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));\n    return false;\n  };\n  DragBox2.prototype.handleDownEvent = function(mapBrowserEvent) {\n    if (this.condition_(mapBrowserEvent)) {\n      this.startPixel_ = mapBrowserEvent.pixel;\n      this.box_.setMap(mapBrowserEvent.map);\n      this.box_.setPixels(this.startPixel_, this.startPixel_);\n      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));\n      return true;\n    } else {\n      return false;\n    }\n  };\n  DragBox2.prototype.onBoxEnd = function(event) {\n  };\n  return DragBox2;\n}(ol_interaction_Pointer);\nvar DragBox$1 = DragBox;\nvar __extends$1A = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DragZoom = function(_super) {\n  __extends$1A(DragZoom2, _super);\n  function DragZoom2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var condition = options.condition ? options.condition : shiftKeyOnly;\n    _this = _super.call(this, {\n      condition,\n      className: options.className || \"ol-dragzoom\",\n      minArea: options.minArea\n    }) || this;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 200;\n    _this.out_ = options.out !== void 0 ? options.out : false;\n    return _this;\n  }\n  DragZoom2.prototype.onBoxEnd = function(event) {\n    var map = this.getMap();\n    var view = map.getView();\n    var geometry = this.getGeometry();\n    if (this.out_) {\n      var rotatedExtent = view.rotatedExtentForGeometry(geometry);\n      var resolution = view.getResolutionForExtentInternal(rotatedExtent);\n      var factor = view.getResolution() / resolution;\n      geometry = geometry.clone();\n      geometry.scale(factor * factor);\n    }\n    view.fitInternal(geometry, {\n      duration: this.duration_,\n      easing: easeOut\n    });\n  };\n  return DragZoom2;\n}(DragBox$1);\nvar DragZoom$1 = DragZoom;\nvar KeyCode = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\nvar __extends$1z = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar KeyboardPan = function(_super) {\n  __extends$1z(KeyboardPan2, _super);\n  function KeyboardPan2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options || {};\n    _this.defaultCondition_ = function(mapBrowserEvent) {\n      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);\n    };\n    _this.condition_ = options.condition !== void 0 ? options.condition : _this.defaultCondition_;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 100;\n    _this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;\n    return _this;\n  }\n  KeyboardPan2.prototype.handleEvent = function(mapBrowserEvent) {\n    var stopEvent = false;\n    if (mapBrowserEvent.type == EventType.KEYDOWN) {\n      var keyEvent = mapBrowserEvent.originalEvent;\n      var keyCode = keyEvent.keyCode;\n      if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        var mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n        var deltaX = 0, deltaY = 0;\n        if (keyCode == KeyCode.DOWN) {\n          deltaY = -mapUnitsDelta;\n        } else if (keyCode == KeyCode.LEFT) {\n          deltaX = -mapUnitsDelta;\n        } else if (keyCode == KeyCode.RIGHT) {\n          deltaX = mapUnitsDelta;\n        } else {\n          deltaY = mapUnitsDelta;\n        }\n        var delta = [deltaX, deltaY];\n        rotate$1(delta, view.getRotation());\n        pan(view, delta, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  };\n  return KeyboardPan2;\n}(Interaction$1);\nvar KeyboardPan$1 = KeyboardPan;\nvar __extends$1y = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar KeyboardZoom = function(_super) {\n  __extends$1y(KeyboardZoom2, _super);\n  function KeyboardZoom2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.condition_ = options.condition ? options.condition : targetNotEditable;\n    _this.delta_ = options.delta ? options.delta : 1;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 100;\n    return _this;\n  }\n  KeyboardZoom2.prototype.handleEvent = function(mapBrowserEvent) {\n    var stopEvent = false;\n    if (mapBrowserEvent.type == EventType.KEYDOWN || mapBrowserEvent.type == EventType.KEYPRESS) {\n      var keyEvent = mapBrowserEvent.originalEvent;\n      var charCode = keyEvent.charCode;\n      if (this.condition_(mapBrowserEvent) && (charCode == \"+\".charCodeAt(0) || charCode == \"-\".charCodeAt(0))) {\n        var map = mapBrowserEvent.map;\n        var delta = charCode == \"+\".charCodeAt(0) ? this.delta_ : -this.delta_;\n        var view = map.getView();\n        zoomByDelta(view, delta, void 0, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  };\n  return KeyboardZoom2;\n}(Interaction$1);\nvar KeyboardZoom$1 = KeyboardZoom;\nvar Kinetic = function() {\n  function Kinetic2(decay, minVelocity, delay) {\n    this.decay_ = decay;\n    this.minVelocity_ = minVelocity;\n    this.delay_ = delay;\n    this.points_ = [];\n    this.angle_ = 0;\n    this.initialVelocity_ = 0;\n  }\n  Kinetic2.prototype.begin = function() {\n    this.points_.length = 0;\n    this.angle_ = 0;\n    this.initialVelocity_ = 0;\n  };\n  Kinetic2.prototype.update = function(x2, y2) {\n    this.points_.push(x2, y2, Date.now());\n  };\n  Kinetic2.prototype.end = function() {\n    if (this.points_.length < 6) {\n      return false;\n    }\n    var delay = Date.now() - this.delay_;\n    var lastIndex = this.points_.length - 3;\n    if (this.points_[lastIndex + 2] < delay) {\n      return false;\n    }\n    var firstIndex = lastIndex - 3;\n    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {\n      firstIndex -= 3;\n    }\n    var duration2 = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];\n    if (duration2 < 1e3 / 60) {\n      return false;\n    }\n    var dx = this.points_[lastIndex] - this.points_[firstIndex];\n    var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];\n    this.angle_ = Math.atan2(dy, dx);\n    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration2;\n    return this.initialVelocity_ > this.minVelocity_;\n  };\n  Kinetic2.prototype.getDistance = function() {\n    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;\n  };\n  Kinetic2.prototype.getAngle = function() {\n    return this.angle_;\n  };\n  return Kinetic2;\n}();\nvar Kinetic$1 = Kinetic;\nvar __extends$1x = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Mode$1 = {\n  TRACKPAD: \"trackpad\",\n  WHEEL: \"wheel\"\n};\nvar MouseWheelZoom = function(_super) {\n  __extends$1x(MouseWheelZoom2, _super);\n  function MouseWheelZoom2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, options) || this;\n    _this.totalDelta_ = 0;\n    _this.lastDelta_ = 0;\n    _this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 250;\n    _this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;\n    _this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;\n    _this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;\n    var condition = options.condition ? options.condition : always;\n    _this.condition_ = options.onFocusOnly ? all$1(focusWithTabindex, condition) : condition;\n    _this.lastAnchor_ = null;\n    _this.startTime_ = void 0;\n    _this.timeoutId_;\n    _this.mode_ = void 0;\n    _this.trackpadEventGap_ = 400;\n    _this.trackpadTimeoutId_;\n    _this.deltaPerZoom_ = 300;\n    return _this;\n  }\n  MouseWheelZoom2.prototype.endInteraction_ = function() {\n    this.trackpadTimeoutId_ = void 0;\n    var view = this.getMap().getView();\n    view.endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);\n  };\n  MouseWheelZoom2.prototype.handleEvent = function(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    var type = mapBrowserEvent.type;\n    if (type !== EventType.WHEEL) {\n      return true;\n    }\n    var map = mapBrowserEvent.map;\n    var wheelEvent = mapBrowserEvent.originalEvent;\n    wheelEvent.preventDefault();\n    if (this.useAnchor_) {\n      this.lastAnchor_ = mapBrowserEvent.coordinate;\n    }\n    var delta;\n    if (mapBrowserEvent.type == EventType.WHEEL) {\n      delta = wheelEvent.deltaY;\n      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n        delta /= DEVICE_PIXEL_RATIO;\n      }\n      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        delta *= 40;\n      }\n    }\n    if (delta === 0) {\n      return false;\n    } else {\n      this.lastDelta_ = delta;\n    }\n    var now2 = Date.now();\n    if (this.startTime_ === void 0) {\n      this.startTime_ = now2;\n    }\n    if (!this.mode_ || now2 - this.startTime_ > this.trackpadEventGap_) {\n      this.mode_ = Math.abs(delta) < 4 ? Mode$1.TRACKPAD : Mode$1.WHEEL;\n    }\n    var view = map.getView();\n    if (this.mode_ === Mode$1.TRACKPAD && !(view.getConstrainResolution() || this.constrainResolution_)) {\n      if (this.trackpadTimeoutId_) {\n        clearTimeout(this.trackpadTimeoutId_);\n      } else {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.beginInteraction();\n      }\n      this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);\n      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);\n      this.startTime_ = now2;\n      return false;\n    }\n    this.totalDelta_ += delta;\n    var timeLeft = Math.max(this.timeout_ - (now2 - this.startTime_), 0);\n    clearTimeout(this.timeoutId_);\n    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);\n    return false;\n  };\n  MouseWheelZoom2.prototype.handleWheelZoom_ = function(map) {\n    var view = map.getView();\n    if (view.getAnimating()) {\n      view.cancelAnimations();\n    }\n    var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;\n    if (view.getConstrainResolution() || this.constrainResolution_) {\n      delta = delta ? delta > 0 ? 1 : -1 : 0;\n    }\n    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);\n    this.mode_ = void 0;\n    this.totalDelta_ = 0;\n    this.lastAnchor_ = null;\n    this.startTime_ = void 0;\n    this.timeoutId_ = void 0;\n  };\n  MouseWheelZoom2.prototype.setMouseAnchor = function(useAnchor) {\n    this.useAnchor_ = useAnchor;\n    if (!useAnchor) {\n      this.lastAnchor_ = null;\n    }\n  };\n  return MouseWheelZoom2;\n}(Interaction$1);\nvar MouseWheelZoom$1 = MouseWheelZoom;\nvar __extends$1w = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar PinchRotate = function(_super) {\n  __extends$1w(PinchRotate2, _super);\n  function PinchRotate2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = options;\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this = _super.call(this, pointerOptions) || this;\n    _this.anchor_ = null;\n    _this.lastAngle_ = void 0;\n    _this.rotating_ = false;\n    _this.rotationDelta_ = 0;\n    _this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 250;\n    return _this;\n  }\n  PinchRotate2.prototype.handleDragEvent = function(mapBrowserEvent) {\n    var rotationDelta = 0;\n    var touch0 = this.targetPointers[0];\n    var touch1 = this.targetPointers[1];\n    var angle2 = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);\n    if (this.lastAngle_ !== void 0) {\n      var delta = angle2 - this.lastAngle_;\n      this.rotationDelta_ += delta;\n      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n      rotationDelta = delta;\n    }\n    this.lastAngle_ = angle2;\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n    var viewportPosition = map.getViewport().getBoundingClientRect();\n    var centroid$1 = centroid(this.targetPointers);\n    centroid$1[0] -= viewportPosition.left;\n    centroid$1[1] -= viewportPosition.top;\n    this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);\n    if (this.rotating_) {\n      map.render();\n      view.adjustRotationInternal(rotationDelta, this.anchor_);\n    }\n  };\n  PinchRotate2.prototype.handleUpEvent = function(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      view.endInteraction(this.duration_);\n      return false;\n    } else {\n      return true;\n    }\n  };\n  PinchRotate2.prototype.handleDownEvent = function(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      var map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = void 0;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return PinchRotate2;\n}(ol_interaction_Pointer);\nvar PinchRotate$1 = PinchRotate;\nvar __extends$1v = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar PinchZoom = function(_super) {\n  __extends$1v(PinchZoom2, _super);\n  function PinchZoom2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = options;\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this = _super.call(this, pointerOptions) || this;\n    _this.anchor_ = null;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 400;\n    _this.lastDistance_ = void 0;\n    _this.lastScaleDelta_ = 1;\n    return _this;\n  }\n  PinchZoom2.prototype.handleDragEvent = function(mapBrowserEvent) {\n    var scaleDelta = 1;\n    var touch0 = this.targetPointers[0];\n    var touch1 = this.targetPointers[1];\n    var dx = touch0.clientX - touch1.clientX;\n    var dy = touch0.clientY - touch1.clientY;\n    var distance2 = Math.sqrt(dx * dx + dy * dy);\n    if (this.lastDistance_ !== void 0) {\n      scaleDelta = this.lastDistance_ / distance2;\n    }\n    this.lastDistance_ = distance2;\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    if (scaleDelta != 1) {\n      this.lastScaleDelta_ = scaleDelta;\n    }\n    var viewportPosition = map.getViewport().getBoundingClientRect();\n    var centroid$1 = centroid(this.targetPointers);\n    centroid$1[0] -= viewportPosition.left;\n    centroid$1[1] -= viewportPosition.top;\n    this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);\n    map.render();\n    view.adjustResolutionInternal(scaleDelta, this.anchor_);\n  };\n  PinchZoom2.prototype.handleUpEvent = function(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      var direction2 = this.lastScaleDelta_ > 1 ? 1 : -1;\n      view.endInteraction(this.duration_, direction2);\n      return false;\n    } else {\n      return true;\n    }\n  };\n  PinchZoom2.prototype.handleDownEvent = function(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      var map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastDistance_ = void 0;\n      this.lastScaleDelta_ = 1;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return PinchZoom2;\n}(ol_interaction_Pointer);\nvar PinchZoom$1 = PinchZoom;\nvar FormatType = {\n  ARRAY_BUFFER: \"arraybuffer\",\n  JSON: \"json\",\n  TEXT: \"text\",\n  XML: \"xml\"\n};\nvar __extends$1u = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DragRotateAndZoom = function(_super) {\n  __extends$1u(DragRotateAndZoom2, _super);\n  function DragRotateAndZoom2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, options) || this;\n    _this.condition_ = options.condition ? options.condition : shiftKeyOnly;\n    _this.lastAngle_ = void 0;\n    _this.lastMagnitude_ = void 0;\n    _this.lastScaleDelta_ = 0;\n    _this.duration_ = options.duration !== void 0 ? options.duration : 400;\n    return _this;\n  }\n  DragRotateAndZoom2.prototype.handleDragEvent = function(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n    var map = mapBrowserEvent.map;\n    var size = map.getSize();\n    var offset2 = mapBrowserEvent.pixel;\n    var deltaX = offset2[0] - size[0] / 2;\n    var deltaY = size[1] / 2 - offset2[1];\n    var theta = Math.atan2(deltaY, deltaX);\n    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    var view = map.getView();\n    if (this.lastAngle_ !== void 0) {\n      var angleDelta = this.lastAngle_ - theta;\n      view.adjustRotationInternal(angleDelta);\n    }\n    this.lastAngle_ = theta;\n    if (this.lastMagnitude_ !== void 0) {\n      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);\n    }\n    if (this.lastMagnitude_ !== void 0) {\n      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;\n    }\n    this.lastMagnitude_ = magnitude;\n  };\n  DragRotateAndZoom2.prototype.handleUpEvent = function(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    var direction2 = this.lastScaleDelta_ > 1 ? 1 : -1;\n    view.endInteraction(this.duration_, direction2);\n    this.lastScaleDelta_ = 0;\n    return false;\n  };\n  DragRotateAndZoom2.prototype.handleDownEvent = function(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n    if (this.condition_(mapBrowserEvent)) {\n      mapBrowserEvent.map.getView().beginInteraction();\n      this.lastAngle_ = void 0;\n      this.lastMagnitude_ = void 0;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return DragRotateAndZoom2;\n}(ol_interaction_Pointer);\nvar DragRotateAndZoom$1 = DragRotateAndZoom;\nvar __extends$1t = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Circle$1 = function(_super) {\n  __extends$1t(Circle2, _super);\n  function Circle2(center, opt_radius, opt_layout) {\n    var _this = _super.call(this) || this;\n    if (opt_layout !== void 0 && opt_radius === void 0) {\n      _this.setFlatCoordinates(opt_layout, center);\n    } else {\n      var radius = opt_radius ? opt_radius : 0;\n      _this.setCenterAndRadius(center, radius, opt_layout);\n    }\n    return _this;\n  }\n  Circle2.prototype.clone = function() {\n    var circle = new Circle2(this.flatCoordinates.slice(), void 0, this.layout);\n    circle.applyProperties(this);\n    return circle;\n  };\n  Circle2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x2 - flatCoordinates[0];\n    var dy = y2 - flatCoordinates[1];\n    var squaredDistance2 = dx * dx + dy * dy;\n    if (squaredDistance2 < minSquaredDistance) {\n      if (squaredDistance2 === 0) {\n        for (var i2 = 0; i2 < this.stride; ++i2) {\n          closestPoint[i2] = flatCoordinates[i2];\n        }\n      } else {\n        var delta = this.getRadius() / Math.sqrt(squaredDistance2);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (var i2 = 2; i2 < this.stride; ++i2) {\n          closestPoint[i2] = flatCoordinates[i2];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance2;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  Circle2.prototype.containsXY = function(x2, y2) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x2 - flatCoordinates[0];\n    var dy = y2 - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  };\n  Circle2.prototype.getCenter = function() {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  Circle2.prototype.computeExtent = function(extent2) {\n    var flatCoordinates = this.flatCoordinates;\n    var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate$2(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent2);\n  };\n  Circle2.prototype.getRadius = function() {\n    return Math.sqrt(this.getRadiusSquared_());\n  };\n  Circle2.prototype.getRadiusSquared_ = function() {\n    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  };\n  Circle2.prototype.getType = function() {\n    return GeometryType.CIRCLE;\n  };\n  Circle2.prototype.intersectsExtent = function(extent2) {\n    var circleExtent = this.getExtent();\n    if (intersects$1(extent2, circleExtent)) {\n      var center = this.getCenter();\n      if (extent2[0] <= center[0] && extent2[2] >= center[0]) {\n        return true;\n      }\n      if (extent2[1] <= center[1] && extent2[3] >= center[1]) {\n        return true;\n      }\n      return forEachCorner(extent2, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  };\n  Circle2.prototype.setCenter = function(center) {\n    var stride = this.stride;\n    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    var flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (var i2 = 1; i2 < stride; ++i2) {\n      flatCoordinates[stride + i2] = center[i2];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  };\n  Circle2.prototype.setCenterAndRadius = function(center, radius, opt_layout) {\n    this.setLayout(opt_layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var flatCoordinates = this.flatCoordinates;\n    var offset2 = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset2++] = flatCoordinates[0] + radius;\n    for (var i2 = 1, ii = this.stride; i2 < ii; ++i2) {\n      flatCoordinates[offset2++] = flatCoordinates[i2];\n    }\n    flatCoordinates.length = offset2;\n    this.changed();\n  };\n  Circle2.prototype.getCoordinates = function() {\n    return null;\n  };\n  Circle2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n  };\n  Circle2.prototype.setRadius = function(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  };\n  Circle2.prototype.rotate = function(angle2, anchor) {\n    var center = this.getCenter();\n    var stride = this.getStride();\n    this.setCenter(rotate(center, 0, center.length, stride, angle2, anchor, center));\n    this.changed();\n  };\n  Circle2.prototype.translate = function(deltaX, deltaY) {\n    var center = this.getCenter();\n    var stride = this.getStride();\n    this.setCenter(translate(center, 0, center.length, stride, deltaX, deltaY, center));\n    this.changed();\n  };\n  return Circle2;\n}(SimpleGeometry$1);\nCircle$1.prototype.transform;\nvar ol_geom_Circle = Circle$1;\nvar __extends$1s = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Feature$1 = function(_super) {\n  __extends$1s(Feature2, _super);\n  function Feature2(opt_geometryOrProperties) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.id_ = void 0;\n    _this.geometryName_ = \"geometry\";\n    _this.style_ = null;\n    _this.styleFunction_ = void 0;\n    _this.geometryChangeKey_ = null;\n    _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);\n    if (opt_geometryOrProperties) {\n      if (typeof opt_geometryOrProperties.getSimplifiedGeometry === \"function\") {\n        var geometry = opt_geometryOrProperties;\n        _this.setGeometry(geometry);\n      } else {\n        var properties = opt_geometryOrProperties;\n        _this.setProperties(properties);\n      }\n    }\n    return _this;\n  }\n  Feature2.prototype.clone = function() {\n    var clone2 = new Feature2(this.hasProperties() ? this.getProperties() : null);\n    clone2.setGeometryName(this.getGeometryName());\n    var geometry = this.getGeometry();\n    if (geometry) {\n      clone2.setGeometry(geometry.clone());\n    }\n    var style2 = this.getStyle();\n    if (style2) {\n      clone2.setStyle(style2);\n    }\n    return clone2;\n  };\n  Feature2.prototype.getGeometry = function() {\n    return this.get(this.geometryName_);\n  };\n  Feature2.prototype.getId = function() {\n    return this.id_;\n  };\n  Feature2.prototype.getGeometryName = function() {\n    return this.geometryName_;\n  };\n  Feature2.prototype.getStyle = function() {\n    return this.style_;\n  };\n  Feature2.prototype.getStyleFunction = function() {\n    return this.styleFunction_;\n  };\n  Feature2.prototype.handleGeometryChange_ = function() {\n    this.changed();\n  };\n  Feature2.prototype.handleGeometryChanged_ = function() {\n    if (this.geometryChangeKey_) {\n      unlistenByKey(this.geometryChangeKey_);\n      this.geometryChangeKey_ = null;\n    }\n    var geometry = this.getGeometry();\n    if (geometry) {\n      this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);\n    }\n    this.changed();\n  };\n  Feature2.prototype.setGeometry = function(geometry) {\n    this.set(this.geometryName_, geometry);\n  };\n  Feature2.prototype.setStyle = function(opt_style) {\n    this.style_ = opt_style;\n    this.styleFunction_ = !opt_style ? void 0 : createStyleFunction(opt_style);\n    this.changed();\n  };\n  Feature2.prototype.setId = function(id) {\n    this.id_ = id;\n    this.changed();\n  };\n  Feature2.prototype.setGeometryName = function(name) {\n    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);\n    this.geometryName_ = name;\n    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);\n    this.handleGeometryChanged_();\n  };\n  return Feature2;\n}(ol_Object);\nfunction createStyleFunction(obj) {\n  if (typeof obj === \"function\") {\n    return obj;\n  } else {\n    var styles_1;\n    if (Array.isArray(obj)) {\n      styles_1 = obj;\n    } else {\n      assert(typeof obj.getZIndex === \"function\", 41);\n      var style2 = obj;\n      styles_1 = [style2];\n    }\n    return function() {\n      return styles_1;\n    };\n  }\n}\nvar feature = Feature$1;\nfunction interpolatePoint(flatCoordinates, offset2, end, stride, fraction, opt_dest, opt_dimension) {\n  var o2, t3;\n  var n2 = (end - offset2) / stride;\n  if (n2 === 1) {\n    o2 = offset2;\n  } else if (n2 === 2) {\n    o2 = offset2;\n    t3 = fraction;\n  } else if (n2 !== 0) {\n    var x1 = flatCoordinates[offset2];\n    var y1 = flatCoordinates[offset2 + 1];\n    var length_1 = 0;\n    var cumulativeLengths = [0];\n    for (var i2 = offset2 + stride; i2 < end; i2 += stride) {\n      var x2 = flatCoordinates[i2];\n      var y2 = flatCoordinates[i2 + 1];\n      length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length_1);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length_1;\n    var index2 = binarySearch(cumulativeLengths, target);\n    if (index2 < 0) {\n      t3 = (target - cumulativeLengths[-index2 - 2]) / (cumulativeLengths[-index2 - 1] - cumulativeLengths[-index2 - 2]);\n      o2 = offset2 + (-index2 - 2) * stride;\n    } else {\n      o2 = offset2 + index2 * stride;\n    }\n  }\n  var dimension = opt_dimension > 1 ? opt_dimension : 2;\n  var dest = opt_dest ? opt_dest : new Array(dimension);\n  for (var i2 = 0; i2 < dimension; ++i2) {\n    dest[i2] = o2 === void 0 ? NaN : t3 === void 0 ? flatCoordinates[o2 + i2] : lerp$1(flatCoordinates[o2 + i2], flatCoordinates[o2 + stride + i2], t3);\n  }\n  return dest;\n}\nfunction lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m2, extrapolate) {\n  if (end == offset2) {\n    return null;\n  }\n  var coordinate;\n  if (m2 < flatCoordinates[offset2 + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset2, offset2 + stride);\n      coordinate[stride - 1] = m2;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m2) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m2;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (m2 == flatCoordinates[offset2 + stride - 1]) {\n    return flatCoordinates.slice(offset2, offset2 + stride);\n  }\n  var lo = offset2 / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = lo + hi >> 1;\n    if (m2 < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m2 == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t3 = (m2 - m0) / (m1 - m0);\n  coordinate = [];\n  for (var i2 = 0; i2 < stride - 1; ++i2) {\n    coordinate.push(lerp$1(flatCoordinates[(lo - 1) * stride + i2], flatCoordinates[lo * stride + i2], t3));\n  }\n  coordinate.push(m2);\n  return coordinate;\n}\nfunction lineStringsCoordinateAtM(flatCoordinates, offset2, ends, stride, m2, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(flatCoordinates, offset2, ends[ends.length - 1], stride, m2, extrapolate);\n  }\n  var coordinate;\n  if (m2 < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m2;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m2) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m2;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n    var end = ends[i2];\n    if (offset2 == end) {\n      continue;\n    }\n    if (m2 < flatCoordinates[offset2 + stride - 1]) {\n      return null;\n    } else if (m2 <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m2, false);\n    }\n    offset2 = end;\n  }\n  return null;\n}\nfunction lineStringLength(flatCoordinates, offset2, end, stride) {\n  var x1 = flatCoordinates[offset2];\n  var y1 = flatCoordinates[offset2 + 1];\n  var length = 0;\n  for (var i2 = offset2 + stride; i2 < end; i2 += stride) {\n    var x2 = flatCoordinates[i2];\n    var y2 = flatCoordinates[i2 + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\nvar __extends$1r = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar LineString$1 = function(_super) {\n  __extends$1r(LineString2, _super);\n  function LineString2(coordinates2, opt_layout) {\n    var _this = _super.call(this) || this;\n    _this.flatMidpoint_ = null;\n    _this.flatMidpointRevision_ = -1;\n    _this.maxDelta_ = -1;\n    _this.maxDeltaRevision_ = -1;\n    if (opt_layout !== void 0 && !Array.isArray(coordinates2[0])) {\n      _this.setFlatCoordinates(opt_layout, coordinates2);\n    } else {\n      _this.setCoordinates(coordinates2, opt_layout);\n    }\n    return _this;\n  }\n  LineString2.prototype.appendCoordinate = function(coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      extend$3(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  };\n  LineString2.prototype.clone = function() {\n    var lineString = new LineString2(this.flatCoordinates.slice(), this.layout);\n    lineString.applyProperties(this);\n    return lineString;\n  };\n  LineString2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x2, y2, closestPoint, minSquaredDistance);\n  };\n  LineString2.prototype.forEachSegment = function(callback) {\n    return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n  };\n  LineString2.prototype.getCoordinateAtM = function(m2, opt_extrapolate) {\n    if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== void 0 ? opt_extrapolate : false;\n    return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m2, extrapolate);\n  };\n  LineString2.prototype.getCoordinates = function() {\n    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  LineString2.prototype.getCoordinateAt = function(fraction, opt_dest) {\n    return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);\n  };\n  LineString2.prototype.getLength = function() {\n    return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  LineString2.prototype.getFlatMidpoint = function() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  };\n  LineString2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LineString2(simplifiedFlatCoordinates, GeometryLayout.XY);\n  };\n  LineString2.prototype.getType = function() {\n    return GeometryType.LINE_STRING;\n  };\n  LineString2.prototype.intersectsExtent = function(extent2) {\n    return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent2);\n  };\n  LineString2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n    this.setLayout(opt_layout, coordinates2, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);\n    this.changed();\n  };\n  return LineString2;\n}(SimpleGeometry$1);\nvar LineString$2 = LineString$1;\nvar __extends$1q = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MultiLineString$1 = function(_super) {\n  __extends$1q(MultiLineString2, _super);\n  function MultiLineString2(coordinates2, opt_layout, opt_ends) {\n    var _this = _super.call(this) || this;\n    _this.ends_ = [];\n    _this.maxDelta_ = -1;\n    _this.maxDeltaRevision_ = -1;\n    if (Array.isArray(coordinates2[0])) {\n      _this.setCoordinates(coordinates2, opt_layout);\n    } else if (opt_layout !== void 0 && opt_ends) {\n      _this.setFlatCoordinates(opt_layout, coordinates2);\n      _this.ends_ = opt_ends;\n    } else {\n      var layout = _this.getLayout();\n      var lineStrings = coordinates2;\n      var flatCoordinates = [];\n      var ends = [];\n      for (var i2 = 0, ii = lineStrings.length; i2 < ii; ++i2) {\n        var lineString = lineStrings[i2];\n        if (i2 === 0) {\n          layout = lineString.getLayout();\n        }\n        extend$3(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      _this.setFlatCoordinates(layout, flatCoordinates);\n      _this.ends_ = ends;\n    }\n    return _this;\n  }\n  MultiLineString2.prototype.appendLineString = function(lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend$3(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  MultiLineString2.prototype.clone = function() {\n    var multiLineString = new MultiLineString2(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  };\n  MultiLineString2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x2, y2, closestPoint, minSquaredDistance);\n  };\n  MultiLineString2.prototype.getCoordinateAtM = function(m2, opt_extrapolate, opt_interpolate) {\n    if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM || this.flatCoordinates.length === 0) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== void 0 ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== void 0 ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m2, extrapolate, interpolate);\n  };\n  MultiLineString2.prototype.getCoordinates = function() {\n    return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n  MultiLineString2.prototype.getEnds = function() {\n    return this.ends_;\n  };\n  MultiLineString2.prototype.getLineString = function(index2) {\n    if (index2 < 0 || this.ends_.length <= index2) {\n      return null;\n    }\n    return new LineString$2(this.flatCoordinates.slice(index2 === 0 ? 0 : this.ends_[index2 - 1], this.ends_[index2]), this.layout);\n  };\n  MultiLineString2.prototype.getLineStrings = function() {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    var lineStrings = [];\n    var offset2 = 0;\n    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n      var end = ends[i2];\n      var lineString = new LineString$2(flatCoordinates.slice(offset2, end), layout);\n      lineStrings.push(lineString);\n      offset2 = end;\n    }\n    return lineStrings;\n  };\n  MultiLineString2.prototype.getFlatMidpoints = function() {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset2 = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n      var end = ends[i2];\n      var midpoint = interpolatePoint(flatCoordinates, offset2, end, stride, 0.5);\n      extend$3(midpoints, midpoint);\n      offset2 = end;\n    }\n    return midpoints;\n  };\n  MultiLineString2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString2(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n  MultiLineString2.prototype.getType = function() {\n    return GeometryType.MULTI_LINE_STRING;\n  };\n  MultiLineString2.prototype.intersectsExtent = function(extent2) {\n    return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent2);\n  };\n  MultiLineString2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n    this.setLayout(opt_layout, coordinates2, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n  return MultiLineString2;\n}(SimpleGeometry$1);\nvar MultiLineString$2 = MultiLineString$1;\nvar __extends$1p = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MultiPoint$1 = function(_super) {\n  __extends$1p(MultiPoint2, _super);\n  function MultiPoint2(coordinates2, opt_layout) {\n    var _this = _super.call(this) || this;\n    if (opt_layout && !Array.isArray(coordinates2[0])) {\n      _this.setFlatCoordinates(opt_layout, coordinates2);\n    } else {\n      _this.setCoordinates(coordinates2, opt_layout);\n    }\n    return _this;\n  }\n  MultiPoint2.prototype.appendPoint = function(point) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = point.getFlatCoordinates().slice();\n    } else {\n      extend$3(this.flatCoordinates, point.getFlatCoordinates());\n    }\n    this.changed();\n  };\n  MultiPoint2.prototype.clone = function() {\n    var multiPoint = new MultiPoint2(this.flatCoordinates.slice(), this.layout);\n    multiPoint.applyProperties(this);\n    return multiPoint;\n  };\n  MultiPoint2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {\n      return minSquaredDistance;\n    }\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {\n      var squaredDistance2 = squaredDistance$1(x2, y2, flatCoordinates[i2], flatCoordinates[i2 + 1]);\n      if (squaredDistance2 < minSquaredDistance) {\n        minSquaredDistance = squaredDistance2;\n        for (var j2 = 0; j2 < stride; ++j2) {\n          closestPoint[j2] = flatCoordinates[i2 + j2];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  };\n  MultiPoint2.prototype.getCoordinates = function() {\n    return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  MultiPoint2.prototype.getPoint = function(index2) {\n    var n2 = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\n    if (index2 < 0 || n2 <= index2) {\n      return null;\n    }\n    return new Point$4(this.flatCoordinates.slice(index2 * this.stride, (index2 + 1) * this.stride), this.layout);\n  };\n  MultiPoint2.prototype.getPoints = function() {\n    var flatCoordinates = this.flatCoordinates;\n    var layout = this.layout;\n    var stride = this.stride;\n    var points = [];\n    for (var i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {\n      var point = new Point$4(flatCoordinates.slice(i2, i2 + stride), layout);\n      points.push(point);\n    }\n    return points;\n  };\n  MultiPoint2.prototype.getType = function() {\n    return GeometryType.MULTI_POINT;\n  };\n  MultiPoint2.prototype.intersectsExtent = function(extent2) {\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {\n      var x2 = flatCoordinates[i2];\n      var y2 = flatCoordinates[i2 + 1];\n      if (containsXY(extent2, x2, y2)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  MultiPoint2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n    this.setLayout(opt_layout, coordinates2, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates2, this.stride);\n    this.changed();\n  };\n  return MultiPoint2;\n}(SimpleGeometry$1);\nvar MultiPoint$2 = MultiPoint$1;\nfunction linearRingss(flatCoordinates, offset2, endss, stride) {\n  var flatCenters = [];\n  var extent2 = createEmpty();\n  for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n    var ends = endss[i2];\n    extent2 = createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, ends[0], stride);\n    flatCenters.push((extent2[0] + extent2[2]) / 2, (extent2[1] + extent2[3]) / 2);\n    offset2 = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\nvar __extends$1o = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MultiPolygon$1 = function(_super) {\n  __extends$1o(MultiPolygon2, _super);\n  function MultiPolygon2(coordinates2, opt_layout, opt_endss) {\n    var _this = _super.call(this) || this;\n    _this.endss_ = [];\n    _this.flatInteriorPointsRevision_ = -1;\n    _this.flatInteriorPoints_ = null;\n    _this.maxDelta_ = -1;\n    _this.maxDeltaRevision_ = -1;\n    _this.orientedRevision_ = -1;\n    _this.orientedFlatCoordinates_ = null;\n    if (!opt_endss && !Array.isArray(coordinates2[0])) {\n      var layout = _this.getLayout();\n      var polygons = coordinates2;\n      var flatCoordinates = [];\n      var endss = [];\n      for (var i2 = 0, ii = polygons.length; i2 < ii; ++i2) {\n        var polygon = polygons[i2];\n        if (i2 === 0) {\n          layout = polygon.getLayout();\n        }\n        var offset2 = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j2 = 0, jj = ends.length; j2 < jj; ++j2) {\n          ends[j2] += offset2;\n        }\n        extend$3(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates2 = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== void 0 && opt_endss) {\n      _this.setFlatCoordinates(opt_layout, coordinates2);\n      _this.endss_ = opt_endss;\n    } else {\n      _this.setCoordinates(coordinates2, opt_layout);\n    }\n    return _this;\n  }\n  MultiPolygon2.prototype.appendPolygon = function(polygon) {\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset2 = this.flatCoordinates.length;\n      extend$3(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n        ends[i2] += offset2;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n  MultiPolygon2.prototype.clone = function() {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i2 = 0; i2 < len; ++i2) {\n      newEndss[i2] = this.endss_[i2].slice();\n    }\n    var multiPolygon = new MultiPolygon2(this.flatCoordinates.slice(), this.layout, newEndss);\n    multiPolygon.applyProperties(this);\n    return multiPolygon;\n  };\n  MultiPolygon2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x2, y2, closestPoint, minSquaredDistance);\n  };\n  MultiPolygon2.prototype.containsXY = function(x2, y2) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x2, y2);\n  };\n  MultiPolygon2.prototype.getArea = function() {\n    return linearRingss$1(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n  MultiPolygon2.prototype.getCoordinates = function(opt_right) {\n    var flatCoordinates;\n    if (opt_right !== void 0) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n  };\n  MultiPolygon2.prototype.getEndss = function() {\n    return this.endss_;\n  };\n  MultiPolygon2.prototype.getFlatInteriorPoints = function() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n  MultiPolygon2.prototype.getInteriorPoints = function() {\n    return new MultiPoint$2(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  };\n  MultiPolygon2.prototype.getOrientedFlatCoordinates = function() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n  MultiPolygon2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon2(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  };\n  MultiPolygon2.prototype.getPolygon = function(index2) {\n    if (index2 < 0 || this.endss_.length <= index2) {\n      return null;\n    }\n    var offset2;\n    if (index2 === 0) {\n      offset2 = 0;\n    } else {\n      var prevEnds = this.endss_[index2 - 1];\n      offset2 = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index2].slice();\n    var end = ends[ends.length - 1];\n    if (offset2 !== 0) {\n      for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n        ends[i2] -= offset2;\n      }\n    }\n    return new Polygon$2(this.flatCoordinates.slice(offset2, end), this.layout, ends);\n  };\n  MultiPolygon2.prototype.getPolygons = function() {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset2 = 0;\n    for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n      var ends = endss[i2].slice();\n      var end = ends[ends.length - 1];\n      if (offset2 !== 0) {\n        for (var j2 = 0, jj = ends.length; j2 < jj; ++j2) {\n          ends[j2] -= offset2;\n        }\n      }\n      var polygon = new Polygon$2(flatCoordinates.slice(offset2, end), layout, ends);\n      polygons.push(polygon);\n      offset2 = end;\n    }\n    return polygons;\n  };\n  MultiPolygon2.prototype.getType = function() {\n    return GeometryType.MULTI_POLYGON;\n  };\n  MultiPolygon2.prototype.intersectsExtent = function(extent2) {\n    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent2);\n  };\n  MultiPolygon2.prototype.setCoordinates = function(coordinates2, opt_layout) {\n    this.setLayout(opt_layout, coordinates2, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates2, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  };\n  return MultiPolygon2;\n}(SimpleGeometry$1);\nvar MultiPolygon$2 = MultiPolygon$1;\nfunction quickselect(arr, k2, left, right, compare) {\n  quickselectStep(arr, k2, left || 0, right || arr.length - 1, compare || defaultCompare);\n}\nfunction quickselectStep(arr, k2, left, right, compare) {\n  while (right > left) {\n    if (right - left > 600) {\n      var n2 = right - left + 1;\n      var m2 = k2 - left + 1;\n      var z2 = Math.log(n2);\n      var s2 = 0.5 * Math.exp(2 * z2 / 3);\n      var sd = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);\n      var newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n2 + sd));\n      var newRight = Math.min(right, Math.floor(k2 + (n2 - m2) * s2 / n2 + sd));\n      quickselectStep(arr, k2, newLeft, newRight, compare);\n    }\n    var t3 = arr[k2];\n    var i2 = left;\n    var j2 = right;\n    swap(arr, left, k2);\n    if (compare(arr[right], t3) > 0)\n      swap(arr, left, right);\n    while (i2 < j2) {\n      swap(arr, i2, j2);\n      i2++;\n      j2--;\n      while (compare(arr[i2], t3) < 0)\n        i2++;\n      while (compare(arr[j2], t3) > 0)\n        j2--;\n    }\n    if (compare(arr[left], t3) === 0)\n      swap(arr, left, j2);\n    else {\n      j2++;\n      swap(arr, j2, right);\n    }\n    if (j2 <= k2)\n      left = j2 + 1;\n    if (k2 <= j2)\n      right = j2 - 1;\n  }\n}\nfunction swap(arr, i2, j2) {\n  var tmp = arr[i2];\n  arr[i2] = arr[j2];\n  arr[j2] = tmp;\n}\nfunction defaultCompare(a2, b2) {\n  return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;\n}\nclass RBush$2 {\n  constructor(maxEntries = 9) {\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n  }\n  all() {\n    return this._all(this.data, []);\n  }\n  search(bbox2) {\n    let node2 = this.data;\n    const result = [];\n    if (!intersects(bbox2, node2))\n      return result;\n    const toBBox = this.toBBox;\n    const nodesToSearch = [];\n    while (node2) {\n      for (let i2 = 0; i2 < node2.children.length; i2++) {\n        const child = node2.children[i2];\n        const childBBox = node2.leaf ? toBBox(child) : child;\n        if (intersects(bbox2, childBBox)) {\n          if (node2.leaf)\n            result.push(child);\n          else if (contains$1(bbox2, childBBox))\n            this._all(child, result);\n          else\n            nodesToSearch.push(child);\n        }\n      }\n      node2 = nodesToSearch.pop();\n    }\n    return result;\n  }\n  collides(bbox2) {\n    let node2 = this.data;\n    if (!intersects(bbox2, node2))\n      return false;\n    const nodesToSearch = [];\n    while (node2) {\n      for (let i2 = 0; i2 < node2.children.length; i2++) {\n        const child = node2.children[i2];\n        const childBBox = node2.leaf ? this.toBBox(child) : child;\n        if (intersects(bbox2, childBBox)) {\n          if (node2.leaf || contains$1(bbox2, childBBox))\n            return true;\n          nodesToSearch.push(child);\n        }\n      }\n      node2 = nodesToSearch.pop();\n    }\n    return false;\n  }\n  load(data2) {\n    if (!(data2 && data2.length))\n      return this;\n    if (data2.length < this._minEntries) {\n      for (let i2 = 0; i2 < data2.length; i2++) {\n        this.insert(data2[i2]);\n      }\n      return this;\n    }\n    let node2 = this._build(data2.slice(), 0, data2.length - 1, 0);\n    if (!this.data.children.length) {\n      this.data = node2;\n    } else if (this.data.height === node2.height) {\n      this._splitRoot(this.data, node2);\n    } else {\n      if (this.data.height < node2.height) {\n        const tmpNode = this.data;\n        this.data = node2;\n        node2 = tmpNode;\n      }\n      this._insert(node2, this.data.height - node2.height - 1, true);\n    }\n    return this;\n  }\n  insert(item) {\n    if (item)\n      this._insert(item, this.data.height - 1);\n    return this;\n  }\n  clear() {\n    this.data = createNode([]);\n    return this;\n  }\n  remove(item, equalsFn) {\n    if (!item)\n      return this;\n    let node2 = this.data;\n    const bbox2 = this.toBBox(item);\n    const path = [];\n    const indexes = [];\n    let i2, parent, goingUp;\n    while (node2 || path.length) {\n      if (!node2) {\n        node2 = path.pop();\n        parent = path[path.length - 1];\n        i2 = indexes.pop();\n        goingUp = true;\n      }\n      if (node2.leaf) {\n        const index2 = findItem(item, node2.children, equalsFn);\n        if (index2 !== -1) {\n          node2.children.splice(index2, 1);\n          path.push(node2);\n          this._condense(path);\n          return this;\n        }\n      }\n      if (!goingUp && !node2.leaf && contains$1(node2, bbox2)) {\n        path.push(node2);\n        indexes.push(i2);\n        i2 = 0;\n        parent = node2;\n        node2 = node2.children[0];\n      } else if (parent) {\n        i2++;\n        node2 = parent.children[i2];\n        goingUp = false;\n      } else\n        node2 = null;\n    }\n    return this;\n  }\n  toBBox(item) {\n    return item;\n  }\n  compareMinX(a2, b2) {\n    return a2.minX - b2.minX;\n  }\n  compareMinY(a2, b2) {\n    return a2.minY - b2.minY;\n  }\n  toJSON() {\n    return this.data;\n  }\n  fromJSON(data2) {\n    this.data = data2;\n    return this;\n  }\n  _all(node2, result) {\n    const nodesToSearch = [];\n    while (node2) {\n      if (node2.leaf)\n        result.push(...node2.children);\n      else\n        nodesToSearch.push(...node2.children);\n      node2 = nodesToSearch.pop();\n    }\n    return result;\n  }\n  _build(items, left, right, height) {\n    const N2 = right - left + 1;\n    let M2 = this._maxEntries;\n    let node2;\n    if (N2 <= M2) {\n      node2 = createNode(items.slice(left, right + 1));\n      calcBBox(node2, this.toBBox);\n      return node2;\n    }\n    if (!height) {\n      height = Math.ceil(Math.log(N2) / Math.log(M2));\n      M2 = Math.ceil(N2 / Math.pow(M2, height - 1));\n    }\n    node2 = createNode([]);\n    node2.leaf = false;\n    node2.height = height;\n    const N22 = Math.ceil(N2 / M2);\n    const N1 = N22 * Math.ceil(Math.sqrt(M2));\n    multiSelect(items, left, right, N1, this.compareMinX);\n    for (let i2 = left; i2 <= right; i2 += N1) {\n      const right2 = Math.min(i2 + N1 - 1, right);\n      multiSelect(items, i2, right2, N22, this.compareMinY);\n      for (let j2 = i2; j2 <= right2; j2 += N22) {\n        const right3 = Math.min(j2 + N22 - 1, right2);\n        node2.children.push(this._build(items, j2, right3, height - 1));\n      }\n    }\n    calcBBox(node2, this.toBBox);\n    return node2;\n  }\n  _chooseSubtree(bbox2, node2, level, path) {\n    while (true) {\n      path.push(node2);\n      if (node2.leaf || path.length - 1 === level)\n        break;\n      let minArea = Infinity;\n      let minEnlargement = Infinity;\n      let targetNode;\n      for (let i2 = 0; i2 < node2.children.length; i2++) {\n        const child = node2.children[i2];\n        const area = bboxArea(child);\n        const enlargement = enlargedArea(bbox2, child) - area;\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n      node2 = targetNode || node2.children[0];\n    }\n    return node2;\n  }\n  _insert(item, level, isNode) {\n    const bbox2 = isNode ? item : this.toBBox(item);\n    const insertPath = [];\n    const node2 = this._chooseSubtree(bbox2, this.data, level, insertPath);\n    node2.children.push(item);\n    extend$1(node2, bbox2);\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n        level--;\n      } else\n        break;\n    }\n    this._adjustParentBBoxes(bbox2, insertPath, level);\n  }\n  _split(insertPath, level) {\n    const node2 = insertPath[level];\n    const M2 = node2.children.length;\n    const m2 = this._minEntries;\n    this._chooseSplitAxis(node2, m2, M2);\n    const splitIndex = this._chooseSplitIndex(node2, m2, M2);\n    const newNode = createNode(node2.children.splice(splitIndex, node2.children.length - splitIndex));\n    newNode.height = node2.height;\n    newNode.leaf = node2.leaf;\n    calcBBox(node2, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level)\n      insertPath[level - 1].children.push(newNode);\n    else\n      this._splitRoot(node2, newNode);\n  }\n  _splitRoot(node2, newNode) {\n    this.data = createNode([node2, newNode]);\n    this.data.height = node2.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  }\n  _chooseSplitIndex(node2, m2, M2) {\n    let index2;\n    let minOverlap = Infinity;\n    let minArea = Infinity;\n    for (let i2 = m2; i2 <= M2 - m2; i2++) {\n      const bbox1 = distBBox(node2, 0, i2, this.toBBox);\n      const bbox2 = distBBox(node2, i2, M2, this.toBBox);\n      const overlap = intersectionArea(bbox1, bbox2);\n      const area = bboxArea(bbox1) + bboxArea(bbox2);\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index2 = i2;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        if (area < minArea) {\n          minArea = area;\n          index2 = i2;\n        }\n      }\n    }\n    return index2 || M2 - m2;\n  }\n  _chooseSplitAxis(node2, m2, M2) {\n    const compareMinX = node2.leaf ? this.compareMinX : compareNodeMinX;\n    const compareMinY = node2.leaf ? this.compareMinY : compareNodeMinY;\n    const xMargin = this._allDistMargin(node2, m2, M2, compareMinX);\n    const yMargin = this._allDistMargin(node2, m2, M2, compareMinY);\n    if (xMargin < yMargin)\n      node2.children.sort(compareMinX);\n  }\n  _allDistMargin(node2, m2, M2, compare) {\n    node2.children.sort(compare);\n    const toBBox = this.toBBox;\n    const leftBBox = distBBox(node2, 0, m2, toBBox);\n    const rightBBox = distBBox(node2, M2 - m2, M2, toBBox);\n    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n    for (let i2 = m2; i2 < M2 - m2; i2++) {\n      const child = node2.children[i2];\n      extend$1(leftBBox, node2.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n    for (let i2 = M2 - m2 - 1; i2 >= m2; i2--) {\n      const child = node2.children[i2];\n      extend$1(rightBBox, node2.leaf ? toBBox(child) : child);\n      margin += bboxMargin(rightBBox);\n    }\n    return margin;\n  }\n  _adjustParentBBoxes(bbox2, path, level) {\n    for (let i2 = level; i2 >= 0; i2--) {\n      extend$1(path[i2], bbox2);\n    }\n  }\n  _condense(path) {\n    for (let i2 = path.length - 1, siblings; i2 >= 0; i2--) {\n      if (path[i2].children.length === 0) {\n        if (i2 > 0) {\n          siblings = path[i2 - 1].children;\n          siblings.splice(siblings.indexOf(path[i2]), 1);\n        } else\n          this.clear();\n      } else\n        calcBBox(path[i2], this.toBBox);\n    }\n  }\n}\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn)\n    return items.indexOf(item);\n  for (let i2 = 0; i2 < items.length; i2++) {\n    if (equalsFn(item, items[i2]))\n      return i2;\n  }\n  return -1;\n}\nfunction calcBBox(node2, toBBox) {\n  distBBox(node2, 0, node2.children.length, toBBox, node2);\n}\nfunction distBBox(node2, k2, p5, toBBox, destNode) {\n  if (!destNode)\n    destNode = createNode(null);\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n  for (let i2 = k2; i2 < p5; i2++) {\n    const child = node2.children[i2];\n    extend$1(destNode, node2.leaf ? toBBox(child) : child);\n  }\n  return destNode;\n}\nfunction extend$1(a2, b2) {\n  a2.minX = Math.min(a2.minX, b2.minX);\n  a2.minY = Math.min(a2.minY, b2.minY);\n  a2.maxX = Math.max(a2.maxX, b2.maxX);\n  a2.maxY = Math.max(a2.maxY, b2.maxY);\n  return a2;\n}\nfunction compareNodeMinX(a2, b2) {\n  return a2.minX - b2.minX;\n}\nfunction compareNodeMinY(a2, b2) {\n  return a2.minY - b2.minY;\n}\nfunction bboxArea(a2) {\n  return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);\n}\nfunction bboxMargin(a2) {\n  return a2.maxX - a2.minX + (a2.maxY - a2.minY);\n}\nfunction enlargedArea(a2, b2) {\n  return (Math.max(b2.maxX, a2.maxX) - Math.min(b2.minX, a2.minX)) * (Math.max(b2.maxY, a2.maxY) - Math.min(b2.minY, a2.minY));\n}\nfunction intersectionArea(a2, b2) {\n  const minX = Math.max(a2.minX, b2.minX);\n  const minY = Math.max(a2.minY, b2.minY);\n  const maxX = Math.min(a2.maxX, b2.maxX);\n  const maxY = Math.min(a2.maxY, b2.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\nfunction contains$1(a2, b2) {\n  return a2.minX <= b2.minX && a2.minY <= b2.minY && b2.maxX <= a2.maxX && b2.maxY <= a2.maxY;\n}\nfunction intersects(a2, b2) {\n  return b2.minX <= a2.maxX && b2.minY <= a2.maxY && b2.maxX >= a2.minX && b2.maxY >= a2.minY;\n}\nfunction createNode(children) {\n  return {\n    children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n}\nfunction multiSelect(arr, left, right, n2, compare) {\n  const stack = [left, right];\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n    if (right - left <= n2)\n      continue;\n    const mid = left + Math.ceil((right - left) / n2 / 2) * n2;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}\nvar ImageState = {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  ERROR: 3,\n  EMPTY: 4\n};\nvar ImageStyle = function() {\n  function ImageStyle2(options) {\n    this.opacity_ = options.opacity;\n    this.rotateWithView_ = options.rotateWithView;\n    this.rotation_ = options.rotation;\n    this.scale_ = options.scale;\n    this.scaleArray_ = toSize(options.scale);\n    this.displacement_ = options.displacement;\n  }\n  ImageStyle2.prototype.clone = function() {\n    var scale2 = this.getScale();\n    return new ImageStyle2({\n      opacity: this.getOpacity(),\n      scale: Array.isArray(scale2) ? scale2.slice() : scale2,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      displacement: this.getDisplacement().slice()\n    });\n  };\n  ImageStyle2.prototype.getOpacity = function() {\n    return this.opacity_;\n  };\n  ImageStyle2.prototype.getRotateWithView = function() {\n    return this.rotateWithView_;\n  };\n  ImageStyle2.prototype.getRotation = function() {\n    return this.rotation_;\n  };\n  ImageStyle2.prototype.getScale = function() {\n    return this.scale_;\n  };\n  ImageStyle2.prototype.getScaleArray = function() {\n    return this.scaleArray_;\n  };\n  ImageStyle2.prototype.getDisplacement = function() {\n    return this.displacement_;\n  };\n  ImageStyle2.prototype.getAnchor = function() {\n    return abstract();\n  };\n  ImageStyle2.prototype.getImage = function(pixelRatio) {\n    return abstract();\n  };\n  ImageStyle2.prototype.getHitDetectionImage = function() {\n    return abstract();\n  };\n  ImageStyle2.prototype.getPixelRatio = function(pixelRatio) {\n    return 1;\n  };\n  ImageStyle2.prototype.getImageState = function() {\n    return abstract();\n  };\n  ImageStyle2.prototype.getImageSize = function() {\n    return abstract();\n  };\n  ImageStyle2.prototype.getOrigin = function() {\n    return abstract();\n  };\n  ImageStyle2.prototype.getSize = function() {\n    return abstract();\n  };\n  ImageStyle2.prototype.setDisplacement = function(displacement) {\n    this.displacement_ = displacement;\n  };\n  ImageStyle2.prototype.setOpacity = function(opacity2) {\n    this.opacity_ = opacity2;\n  };\n  ImageStyle2.prototype.setRotateWithView = function(rotateWithView) {\n    this.rotateWithView_ = rotateWithView;\n  };\n  ImageStyle2.prototype.setRotation = function(rotation) {\n    this.rotation_ = rotation;\n  };\n  ImageStyle2.prototype.setScale = function(scale2) {\n    this.scale_ = scale2;\n    this.scaleArray_ = toSize(scale2);\n  };\n  ImageStyle2.prototype.listenImageChange = function(listener2) {\n    abstract();\n  };\n  ImageStyle2.prototype.load = function() {\n    abstract();\n  };\n  ImageStyle2.prototype.unlistenImageChange = function(listener2) {\n    abstract();\n  };\n  return ImageStyle2;\n}();\nvar ImageStyle$1 = ImageStyle;\nfunction asColorLike(color2) {\n  if (Array.isArray(color2)) {\n    return toString$c(color2);\n  } else {\n    return color2;\n  }\n}\nvar __extends$1n = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar RegularShape = function(_super) {\n  __extends$1n(RegularShape2, _super);\n  function RegularShape2(options) {\n    var _this = this;\n    var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;\n    _this = _super.call(this, {\n      opacity: 1,\n      rotateWithView,\n      rotation: options.rotation !== void 0 ? options.rotation : 0,\n      scale: options.scale !== void 0 ? options.scale : 1,\n      displacement: options.displacement !== void 0 ? options.displacement : [0, 0]\n    }) || this;\n    _this.canvas_ = void 0;\n    _this.hitDetectionCanvas_ = null;\n    _this.fill_ = options.fill !== void 0 ? options.fill : null;\n    _this.origin_ = [0, 0];\n    _this.points_ = options.points;\n    _this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;\n    _this.radius2_ = options.radius2;\n    _this.angle_ = options.angle !== void 0 ? options.angle : 0;\n    _this.stroke_ = options.stroke !== void 0 ? options.stroke : null;\n    _this.size_ = null;\n    _this.renderOptions_ = null;\n    _this.render();\n    return _this;\n  }\n  RegularShape2.prototype.clone = function() {\n    var scale2 = this.getScale();\n    var style2 = new RegularShape2({\n      fill: this.getFill() ? this.getFill().clone() : void 0,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : void 0,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      scale: Array.isArray(scale2) ? scale2.slice() : scale2,\n      displacement: this.getDisplacement().slice()\n    });\n    style2.setOpacity(this.getOpacity());\n    return style2;\n  };\n  RegularShape2.prototype.getAnchor = function() {\n    var size = this.size_;\n    if (!size) {\n      return null;\n    }\n    var displacement = this.getDisplacement();\n    return [size[0] / 2 - displacement[0], size[1] / 2 + displacement[1]];\n  };\n  RegularShape2.prototype.getAngle = function() {\n    return this.angle_;\n  };\n  RegularShape2.prototype.getFill = function() {\n    return this.fill_;\n  };\n  RegularShape2.prototype.getHitDetectionImage = function() {\n    if (!this.hitDetectionCanvas_) {\n      this.createHitDetectionCanvas_(this.renderOptions_);\n    }\n    return this.hitDetectionCanvas_;\n  };\n  RegularShape2.prototype.getImage = function(pixelRatio) {\n    var image2 = this.canvas_[pixelRatio];\n    if (!image2) {\n      var renderOptions = this.renderOptions_;\n      var context = createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);\n      this.draw_(renderOptions, context, pixelRatio);\n      image2 = context.canvas;\n      this.canvas_[pixelRatio] = image2;\n    }\n    return image2;\n  };\n  RegularShape2.prototype.getPixelRatio = function(pixelRatio) {\n    return pixelRatio;\n  };\n  RegularShape2.prototype.getImageSize = function() {\n    return this.size_;\n  };\n  RegularShape2.prototype.getImageState = function() {\n    return ImageState.LOADED;\n  };\n  RegularShape2.prototype.getOrigin = function() {\n    return this.origin_;\n  };\n  RegularShape2.prototype.getPoints = function() {\n    return this.points_;\n  };\n  RegularShape2.prototype.getRadius = function() {\n    return this.radius_;\n  };\n  RegularShape2.prototype.getRadius2 = function() {\n    return this.radius2_;\n  };\n  RegularShape2.prototype.getSize = function() {\n    return this.size_;\n  };\n  RegularShape2.prototype.getStroke = function() {\n    return this.stroke_;\n  };\n  RegularShape2.prototype.listenImageChange = function(listener2) {\n  };\n  RegularShape2.prototype.load = function() {\n  };\n  RegularShape2.prototype.unlistenImageChange = function(listener2) {\n  };\n  RegularShape2.prototype.calculateLineJoinSize_ = function(lineJoin, strokeWidth, miterLimit) {\n    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== \"bevel\" && lineJoin !== \"miter\") {\n      return strokeWidth;\n    }\n    var r1 = this.radius_;\n    var r2 = this.radius2_ === void 0 ? r1 : this.radius2_;\n    if (r1 < r2) {\n      var tmp = r1;\n      r1 = r2;\n      r2 = tmp;\n    }\n    var points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;\n    var alpha = 2 * Math.PI / points;\n    var a2 = r2 * Math.sin(alpha);\n    var b2 = Math.sqrt(r2 * r2 - a2 * a2);\n    var d2 = r1 - b2;\n    var e2 = Math.sqrt(a2 * a2 + d2 * d2);\n    var miterRatio = e2 / a2;\n    if (lineJoin === \"miter\" && miterRatio <= miterLimit) {\n      return miterRatio * strokeWidth;\n    }\n    var k2 = strokeWidth / 2 / miterRatio;\n    var l2 = strokeWidth / 2 * (d2 / e2);\n    var maxr = Math.sqrt((r1 + k2) * (r1 + k2) + l2 * l2);\n    var bevelAdd = maxr - r1;\n    if (this.radius2_ === void 0 || lineJoin === \"bevel\") {\n      return bevelAdd * 2;\n    }\n    var aa = r1 * Math.sin(alpha);\n    var bb = Math.sqrt(r1 * r1 - aa * aa);\n    var dd = r2 - bb;\n    var ee2 = Math.sqrt(aa * aa + dd * dd);\n    var innerMiterRatio = ee2 / aa;\n    if (innerMiterRatio <= miterLimit) {\n      var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;\n      return 2 * Math.max(bevelAdd, innerLength);\n    }\n    return bevelAdd * 2;\n  };\n  RegularShape2.prototype.createRenderOptions = function() {\n    var lineJoin = defaultLineJoin;\n    var miterLimit = 0;\n    var lineDash = null;\n    var lineDashOffset = 0;\n    var strokeStyle;\n    var strokeWidth = 0;\n    if (this.stroke_) {\n      strokeStyle = this.stroke_.getColor();\n      if (strokeStyle === null) {\n        strokeStyle = defaultStrokeStyle;\n      }\n      strokeStyle = asColorLike(strokeStyle);\n      strokeWidth = this.stroke_.getWidth();\n      if (strokeWidth === void 0) {\n        strokeWidth = defaultLineWidth;\n      }\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset();\n      lineJoin = this.stroke_.getLineJoin();\n      if (lineJoin === void 0) {\n        lineJoin = defaultLineJoin;\n      }\n      miterLimit = this.stroke_.getMiterLimit();\n      if (miterLimit === void 0) {\n        miterLimit = defaultMiterLimit;\n      }\n    }\n    var add2 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);\n    var maxRadius = Math.max(this.radius_, this.radius2_ || 0);\n    var size = Math.ceil(2 * maxRadius + add2);\n    return {\n      strokeStyle,\n      strokeWidth,\n      size,\n      lineDash,\n      lineDashOffset,\n      lineJoin,\n      miterLimit\n    };\n  };\n  RegularShape2.prototype.render = function() {\n    this.renderOptions_ = this.createRenderOptions();\n    var size = this.renderOptions_.size;\n    this.canvas_ = {};\n    this.size_ = [size, size];\n  };\n  RegularShape2.prototype.draw_ = function(renderOptions, context, pixelRatio) {\n    context.scale(pixelRatio, pixelRatio);\n    context.translate(renderOptions.size / 2, renderOptions.size / 2);\n    this.createPath_(context);\n    if (this.fill_) {\n      var color2 = this.fill_.getColor();\n      if (color2 === null) {\n        color2 = defaultFillStyle;\n      }\n      context.fillStyle = asColorLike(color2);\n      context.fill();\n    }\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (context.setLineDash && renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n  };\n  RegularShape2.prototype.createHitDetectionCanvas_ = function(renderOptions) {\n    if (this.fill_) {\n      var color2 = this.fill_.getColor();\n      var opacity2 = 0;\n      if (typeof color2 === \"string\") {\n        color2 = asArray(color2);\n      }\n      if (color2 === null) {\n        opacity2 = 1;\n      } else if (Array.isArray(color2)) {\n        opacity2 = color2.length === 4 ? color2[3] : 1;\n      }\n      if (opacity2 === 0) {\n        var context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n        this.hitDetectionCanvas_ = context.canvas;\n        this.drawHitDetectionCanvas_(renderOptions, context);\n      }\n    }\n    if (!this.hitDetectionCanvas_) {\n      this.hitDetectionCanvas_ = this.getImage(1);\n    }\n  };\n  RegularShape2.prototype.createPath_ = function(context) {\n    var points = this.points_;\n    var radius = this.radius_;\n    if (points === Infinity) {\n      context.arc(0, 0, radius, 0, 2 * Math.PI);\n    } else {\n      var radius2 = this.radius2_ === void 0 ? radius : this.radius2_;\n      if (this.radius2_ !== void 0) {\n        points *= 2;\n      }\n      var startAngle = this.angle_ - Math.PI / 2;\n      var step = 2 * Math.PI / points;\n      for (var i2 = 0; i2 < points; i2++) {\n        var angle0 = startAngle + i2 * step;\n        var radiusC = i2 % 2 === 0 ? radius : radius2;\n        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));\n      }\n      context.closePath();\n    }\n  };\n  RegularShape2.prototype.drawHitDetectionCanvas_ = function(renderOptions, context) {\n    context.translate(renderOptions.size / 2, renderOptions.size / 2);\n    this.createPath_(context);\n    context.fillStyle = defaultFillStyle;\n    context.fill();\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n  };\n  return RegularShape2;\n}(ImageStyle$1);\nvar ol_style_RegularShape = RegularShape;\nvar __extends$1m = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CircleStyle = function(_super) {\n  __extends$1m(CircleStyle2, _super);\n  function CircleStyle2(opt_options) {\n    var options = opt_options ? opt_options : {};\n    return _super.call(this, {\n      points: Infinity,\n      fill: options.fill,\n      radius: options.radius,\n      stroke: options.stroke,\n      scale: options.scale !== void 0 ? options.scale : 1,\n      rotation: options.rotation !== void 0 ? options.rotation : 0,\n      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,\n      displacement: options.displacement !== void 0 ? options.displacement : [0, 0]\n    }) || this;\n  }\n  CircleStyle2.prototype.clone = function() {\n    var scale2 = this.getScale();\n    var style2 = new CircleStyle2({\n      fill: this.getFill() ? this.getFill().clone() : void 0,\n      stroke: this.getStroke() ? this.getStroke().clone() : void 0,\n      radius: this.getRadius(),\n      scale: Array.isArray(scale2) ? scale2.slice() : scale2,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      displacement: this.getDisplacement().slice()\n    });\n    style2.setOpacity(this.getOpacity());\n    return style2;\n  };\n  CircleStyle2.prototype.setRadius = function(radius) {\n    this.radius_ = radius;\n    this.render();\n  };\n  return CircleStyle2;\n}(ol_style_RegularShape);\nvar ol_style_Circle = CircleStyle;\nvar Fill$1 = function() {\n  function Fill2(opt_options) {\n    var options = opt_options || {};\n    this.color_ = options.color !== void 0 ? options.color : null;\n  }\n  Fill2.prototype.clone = function() {\n    var color2 = this.getColor();\n    return new Fill2({\n      color: Array.isArray(color2) ? color2.slice() : color2 || void 0\n    });\n  };\n  Fill2.prototype.getColor = function() {\n    return this.color_;\n  };\n  Fill2.prototype.setColor = function(color2) {\n    this.color_ = color2;\n  };\n  return Fill2;\n}();\nvar Fill$2 = Fill$1;\nvar Stroke$1 = function() {\n  function Stroke2(opt_options) {\n    var options = opt_options || {};\n    this.color_ = options.color !== void 0 ? options.color : null;\n    this.lineCap_ = options.lineCap;\n    this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;\n    this.lineDashOffset_ = options.lineDashOffset;\n    this.lineJoin_ = options.lineJoin;\n    this.miterLimit_ = options.miterLimit;\n    this.width_ = options.width;\n  }\n  Stroke2.prototype.clone = function() {\n    var color2 = this.getColor();\n    return new Stroke2({\n      color: Array.isArray(color2) ? color2.slice() : color2 || void 0,\n      lineCap: this.getLineCap(),\n      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,\n      lineDashOffset: this.getLineDashOffset(),\n      lineJoin: this.getLineJoin(),\n      miterLimit: this.getMiterLimit(),\n      width: this.getWidth()\n    });\n  };\n  Stroke2.prototype.getColor = function() {\n    return this.color_;\n  };\n  Stroke2.prototype.getLineCap = function() {\n    return this.lineCap_;\n  };\n  Stroke2.prototype.getLineDash = function() {\n    return this.lineDash_;\n  };\n  Stroke2.prototype.getLineDashOffset = function() {\n    return this.lineDashOffset_;\n  };\n  Stroke2.prototype.getLineJoin = function() {\n    return this.lineJoin_;\n  };\n  Stroke2.prototype.getMiterLimit = function() {\n    return this.miterLimit_;\n  };\n  Stroke2.prototype.getWidth = function() {\n    return this.width_;\n  };\n  Stroke2.prototype.setColor = function(color2) {\n    this.color_ = color2;\n  };\n  Stroke2.prototype.setLineCap = function(lineCap) {\n    this.lineCap_ = lineCap;\n  };\n  Stroke2.prototype.setLineDash = function(lineDash) {\n    this.lineDash_ = lineDash;\n  };\n  Stroke2.prototype.setLineDashOffset = function(lineDashOffset) {\n    this.lineDashOffset_ = lineDashOffset;\n  };\n  Stroke2.prototype.setLineJoin = function(lineJoin) {\n    this.lineJoin_ = lineJoin;\n  };\n  Stroke2.prototype.setMiterLimit = function(miterLimit) {\n    this.miterLimit_ = miterLimit;\n  };\n  Stroke2.prototype.setWidth = function(width) {\n    this.width_ = width;\n  };\n  return Stroke2;\n}();\nvar Stroke$2 = Stroke$1;\nvar Style$1 = function() {\n  function Style2(opt_options) {\n    var options = opt_options || {};\n    this.geometry_ = null;\n    this.geometryFunction_ = defaultGeometryFunction;\n    if (options.geometry !== void 0) {\n      this.setGeometry(options.geometry);\n    }\n    this.fill_ = options.fill !== void 0 ? options.fill : null;\n    this.image_ = options.image !== void 0 ? options.image : null;\n    this.renderer_ = options.renderer !== void 0 ? options.renderer : null;\n    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;\n    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;\n    this.text_ = options.text !== void 0 ? options.text : null;\n    this.zIndex_ = options.zIndex;\n  }\n  Style2.prototype.clone = function() {\n    var geometry = this.getGeometry();\n    if (geometry && typeof geometry === \"object\") {\n      geometry = geometry.clone();\n    }\n    return new Style2({\n      geometry,\n      fill: this.getFill() ? this.getFill().clone() : void 0,\n      image: this.getImage() ? this.getImage().clone() : void 0,\n      renderer: this.getRenderer(),\n      stroke: this.getStroke() ? this.getStroke().clone() : void 0,\n      text: this.getText() ? this.getText().clone() : void 0,\n      zIndex: this.getZIndex()\n    });\n  };\n  Style2.prototype.getRenderer = function() {\n    return this.renderer_;\n  };\n  Style2.prototype.setRenderer = function(renderer) {\n    this.renderer_ = renderer;\n  };\n  Style2.prototype.setHitDetectionRenderer = function(renderer) {\n    this.hitDetectionRenderer_ = renderer;\n  };\n  Style2.prototype.getHitDetectionRenderer = function() {\n    return this.hitDetectionRenderer_;\n  };\n  Style2.prototype.getGeometry = function() {\n    return this.geometry_;\n  };\n  Style2.prototype.getGeometryFunction = function() {\n    return this.geometryFunction_;\n  };\n  Style2.prototype.getFill = function() {\n    return this.fill_;\n  };\n  Style2.prototype.setFill = function(fill) {\n    this.fill_ = fill;\n  };\n  Style2.prototype.getImage = function() {\n    return this.image_;\n  };\n  Style2.prototype.setImage = function(image2) {\n    this.image_ = image2;\n  };\n  Style2.prototype.getStroke = function() {\n    return this.stroke_;\n  };\n  Style2.prototype.setStroke = function(stroke) {\n    this.stroke_ = stroke;\n  };\n  Style2.prototype.getText = function() {\n    return this.text_;\n  };\n  Style2.prototype.setText = function(text2) {\n    this.text_ = text2;\n  };\n  Style2.prototype.getZIndex = function() {\n    return this.zIndex_;\n  };\n  Style2.prototype.setGeometry = function(geometry) {\n    if (typeof geometry === \"function\") {\n      this.geometryFunction_ = geometry;\n    } else if (typeof geometry === \"string\") {\n      this.geometryFunction_ = function(feature2) {\n        return feature2.get(geometry);\n      };\n    } else if (!geometry) {\n      this.geometryFunction_ = defaultGeometryFunction;\n    } else if (geometry !== void 0) {\n      this.geometryFunction_ = function() {\n        return geometry;\n      };\n    }\n    this.geometry_ = geometry;\n  };\n  Style2.prototype.setZIndex = function(zIndex2) {\n    this.zIndex_ = zIndex2;\n  };\n  return Style2;\n}();\nfunction toFunction(obj) {\n  var styleFunction;\n  if (typeof obj === \"function\") {\n    styleFunction = obj;\n  } else {\n    var styles_1;\n    if (Array.isArray(obj)) {\n      styles_1 = obj;\n    } else {\n      assert(typeof obj.getZIndex === \"function\", 41);\n      var style2 = obj;\n      styles_1 = [style2];\n    }\n    styleFunction = function() {\n      return styles_1;\n    };\n  }\n  return styleFunction;\n}\nvar defaultStyles = null;\nfunction createDefaultStyle(feature2, resolution) {\n  if (!defaultStyles) {\n    var fill = new Fill$2({\n      color: \"rgba(255,255,255,0.4)\"\n    });\n    var stroke = new Stroke$2({\n      color: \"#3399CC\",\n      width: 1.25\n    });\n    defaultStyles = [\n      new Style$1({\n        image: new ol_style_Circle({\n          fill,\n          stroke,\n          radius: 5\n        }),\n        fill,\n        stroke\n      })\n    ];\n  }\n  return defaultStyles;\n}\nfunction createEditingStyle() {\n  var styles = {};\n  var white = [255, 255, 255, 1];\n  var blue = [0, 153, 255, 1];\n  var width = 3;\n  styles[GeometryType.POLYGON] = [\n    new Style$1({\n      fill: new Fill$2({\n        color: [255, 255, 255, 0.5]\n      })\n    })\n  ];\n  styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];\n  styles[GeometryType.LINE_STRING] = [\n    new Style$1({\n      stroke: new Stroke$2({\n        color: white,\n        width: width + 2\n      })\n    }),\n    new Style$1({\n      stroke: new Stroke$2({\n        color: blue,\n        width\n      })\n    })\n  ];\n  styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];\n  styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);\n  styles[GeometryType.POINT] = [\n    new Style$1({\n      image: new ol_style_Circle({\n        radius: width * 2,\n        fill: new Fill$2({\n          color: blue\n        }),\n        stroke: new Stroke$2({\n          color: white,\n          width: width / 2\n        })\n      }),\n      zIndex: Infinity\n    })\n  ];\n  styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];\n  styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);\n  return styles;\n}\nfunction defaultGeometryFunction(feature2) {\n  return feature2.getGeometry();\n}\nvar Style$2 = Style$1;\nvar __extends$1l = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Property$3 = {\n  RENDER_ORDER: \"renderOrder\"\n};\nvar BaseVectorLayer = function(_super) {\n  __extends$1l(BaseVectorLayer2, _super);\n  function BaseVectorLayer2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({}, options);\n    delete baseOptions.style;\n    delete baseOptions.renderBuffer;\n    delete baseOptions.updateWhileAnimating;\n    delete baseOptions.updateWhileInteracting;\n    _this = _super.call(this, baseOptions) || this;\n    _this.declutter_ = options.declutter !== void 0 ? options.declutter : false;\n    _this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;\n    _this.style_ = null;\n    _this.styleFunction_ = void 0;\n    _this.setStyle(options.style);\n    _this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;\n    _this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;\n    return _this;\n  }\n  BaseVectorLayer2.prototype.getDeclutter = function() {\n    return this.declutter_;\n  };\n  BaseVectorLayer2.prototype.getFeatures = function(pixel) {\n    return _super.prototype.getFeatures.call(this, pixel);\n  };\n  BaseVectorLayer2.prototype.getRenderBuffer = function() {\n    return this.renderBuffer_;\n  };\n  BaseVectorLayer2.prototype.getRenderOrder = function() {\n    return this.get(Property$3.RENDER_ORDER);\n  };\n  BaseVectorLayer2.prototype.getStyle = function() {\n    return this.style_;\n  };\n  BaseVectorLayer2.prototype.getStyleFunction = function() {\n    return this.styleFunction_;\n  };\n  BaseVectorLayer2.prototype.getUpdateWhileAnimating = function() {\n    return this.updateWhileAnimating_;\n  };\n  BaseVectorLayer2.prototype.getUpdateWhileInteracting = function() {\n    return this.updateWhileInteracting_;\n  };\n  BaseVectorLayer2.prototype.renderDeclutter = function(frameState) {\n    if (!frameState.declutterTree) {\n      frameState.declutterTree = new RBush$2(9);\n    }\n    this.getRenderer().renderDeclutter(frameState);\n  };\n  BaseVectorLayer2.prototype.setRenderOrder = function(renderOrder) {\n    this.set(Property$3.RENDER_ORDER, renderOrder);\n  };\n  BaseVectorLayer2.prototype.setStyle = function(opt_style) {\n    this.style_ = opt_style !== void 0 ? opt_style : createDefaultStyle;\n    this.styleFunction_ = opt_style === null ? void 0 : toFunction(this.style_);\n    this.changed();\n  };\n  return BaseVectorLayer2;\n}(ol_layer_Base);\nvar BaseVector = BaseVectorLayer;\nvar Instruction = {\n  BEGIN_GEOMETRY: 0,\n  BEGIN_PATH: 1,\n  CIRCLE: 2,\n  CLOSE_PATH: 3,\n  CUSTOM: 4,\n  DRAW_CHARS: 5,\n  DRAW_IMAGE: 6,\n  END_GEOMETRY: 7,\n  FILL: 8,\n  MOVE_TO_LINE_TO: 9,\n  SET_FILL_STYLE: 10,\n  SET_STROKE_STYLE: 11,\n  STROKE: 12\n};\nvar fillInstruction = [Instruction.FILL];\nvar strokeInstruction = [Instruction.STROKE];\nvar beginPathInstruction = [Instruction.BEGIN_PATH];\nvar closePathInstruction = [Instruction.CLOSE_PATH];\nvar CanvasInstruction = Instruction;\nvar VectorContext = function() {\n  function VectorContext2() {\n  }\n  VectorContext2.prototype.drawCustom = function(geometry, feature2, renderer, hitDetectionRenderer) {\n  };\n  VectorContext2.prototype.drawGeometry = function(geometry) {\n  };\n  VectorContext2.prototype.setStyle = function(style2) {\n  };\n  VectorContext2.prototype.drawCircle = function(circleGeometry, feature2) {\n  };\n  VectorContext2.prototype.drawFeature = function(feature2, style2) {\n  };\n  VectorContext2.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature2) {\n  };\n  VectorContext2.prototype.drawLineString = function(lineStringGeometry, feature2) {\n  };\n  VectorContext2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature2) {\n  };\n  VectorContext2.prototype.drawMultiPoint = function(multiPointGeometry, feature2) {\n  };\n  VectorContext2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature2) {\n  };\n  VectorContext2.prototype.drawPoint = function(pointGeometry, feature2) {\n  };\n  VectorContext2.prototype.drawPolygon = function(polygonGeometry, feature2) {\n  };\n  VectorContext2.prototype.drawText = function(geometry, feature2) {\n  };\n  VectorContext2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n  };\n  VectorContext2.prototype.setImageStyle = function(imageStyle, opt_declutterImageWithText) {\n  };\n  VectorContext2.prototype.setTextStyle = function(textStyle, opt_declutterImageWithText) {\n  };\n  return VectorContext2;\n}();\nvar VectorContext$1 = VectorContext;\nvar __extends$1k = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CanvasBuilder = function(_super) {\n  __extends$1k(CanvasBuilder2, _super);\n  function CanvasBuilder2(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this) || this;\n    _this.tolerance = tolerance;\n    _this.maxExtent = maxExtent;\n    _this.pixelRatio = pixelRatio;\n    _this.maxLineWidth = 0;\n    _this.resolution = resolution;\n    _this.beginGeometryInstruction1_ = null;\n    _this.beginGeometryInstruction2_ = null;\n    _this.bufferedMaxExtent_ = null;\n    _this.instructions = [];\n    _this.coordinates = [];\n    _this.tmpCoordinate_ = [];\n    _this.hitDetectionInstructions = [];\n    _this.state = {};\n    return _this;\n  }\n  CanvasBuilder2.prototype.applyPixelRatio = function(dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {\n      return dash * pixelRatio;\n    });\n  };\n  CanvasBuilder2.prototype.appendFlatPointCoordinates = function(flatCoordinates, stride) {\n    var extent2 = this.getBufferedMaxExtent();\n    var tmpCoord = this.tmpCoordinate_;\n    var coordinates2 = this.coordinates;\n    var myEnd = coordinates2.length;\n    for (var i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += stride) {\n      tmpCoord[0] = flatCoordinates[i2];\n      tmpCoord[1] = flatCoordinates[i2 + 1];\n      if (containsCoordinate(extent2, tmpCoord)) {\n        coordinates2[myEnd++] = tmpCoord[0];\n        coordinates2[myEnd++] = tmpCoord[1];\n      }\n    }\n    return myEnd;\n  };\n  CanvasBuilder2.prototype.appendFlatLineCoordinates = function(flatCoordinates, offset2, end, stride, closed, skipFirst) {\n    var coordinates2 = this.coordinates;\n    var myEnd = coordinates2.length;\n    var extent2 = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset2 += stride;\n    }\n    var lastXCoord = flatCoordinates[offset2];\n    var lastYCoord = flatCoordinates[offset2 + 1];\n    var nextCoord = this.tmpCoordinate_;\n    var skipped = true;\n    var i2, lastRel, nextRel;\n    for (i2 = offset2 + stride; i2 < end; i2 += stride) {\n      nextCoord[0] = flatCoordinates[i2];\n      nextCoord[1] = flatCoordinates[i2 + 1];\n      nextRel = coordinateRelationship(extent2, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          coordinates2[myEnd++] = lastXCoord;\n          coordinates2[myEnd++] = lastYCoord;\n          skipped = false;\n        }\n        coordinates2[myEnd++] = nextCoord[0];\n        coordinates2[myEnd++] = nextCoord[1];\n      } else if (nextRel === Relationship.INTERSECTING) {\n        coordinates2[myEnd++] = nextCoord[0];\n        coordinates2[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastXCoord = nextCoord[0];\n      lastYCoord = nextCoord[1];\n      lastRel = nextRel;\n    }\n    if (closed && skipped || i2 === offset2 + stride) {\n      coordinates2[myEnd++] = lastXCoord;\n      coordinates2[myEnd++] = lastYCoord;\n    }\n    return myEnd;\n  };\n  CanvasBuilder2.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset2, ends, stride, builderEnds) {\n    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n      var end = ends[i2];\n      var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, false, false);\n      builderEnds.push(builderEnd);\n      offset2 = end;\n    }\n    return offset2;\n  };\n  CanvasBuilder2.prototype.drawCustom = function(geometry, feature2, renderer, hitDetectionRenderer) {\n    this.beginGeometry(geometry, feature2);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var builderBegin = this.coordinates.length;\n    var flatCoordinates, builderEnd, builderEnds, builderEndss;\n    var offset2;\n    switch (type) {\n      case GeometryType.MULTI_POLYGON:\n        flatCoordinates = geometry.getOrientedFlatCoordinates();\n        builderEndss = [];\n        var endss = geometry.getEndss();\n        offset2 = 0;\n        for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n          var myEnds = [];\n          offset2 = this.drawCustomCoordinates_(flatCoordinates, offset2, endss[i2], stride, myEnds);\n          builderEndss.push(myEnds);\n        }\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEndss,\n          geometry,\n          renderer,\n          inflateMultiCoordinatesArray\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEndss,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateMultiCoordinatesArray\n        ]);\n        break;\n      case GeometryType.POLYGON:\n      case GeometryType.MULTI_LINE_STRING:\n        builderEnds = [];\n        flatCoordinates = type == GeometryType.POLYGON ? geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n        offset2 = this.drawCustomCoordinates_(flatCoordinates, 0, geometry.getEnds(), stride, builderEnds);\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnds,\n          geometry,\n          renderer,\n          inflateCoordinatesArray\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnds,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateCoordinatesArray\n        ]);\n        break;\n      case GeometryType.LINE_STRING:\n      case GeometryType.CIRCLE:\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          renderer,\n          inflateCoordinates\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          hitDetectionRenderer || renderer,\n          inflateCoordinates\n        ]);\n        break;\n      case GeometryType.MULTI_POINT:\n        flatCoordinates = geometry.getFlatCoordinates();\n        builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n        if (builderEnd > builderBegin) {\n          this.instructions.push([\n            CanvasInstruction.CUSTOM,\n            builderBegin,\n            builderEnd,\n            geometry,\n            renderer,\n            inflateCoordinates\n          ]);\n          this.hitDetectionInstructions.push([\n            CanvasInstruction.CUSTOM,\n            builderBegin,\n            builderEnd,\n            geometry,\n            hitDetectionRenderer || renderer,\n            inflateCoordinates\n          ]);\n        }\n        break;\n      case GeometryType.POINT:\n        flatCoordinates = geometry.getFlatCoordinates();\n        this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n        builderEnd = this.coordinates.length;\n        this.instructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          renderer\n        ]);\n        this.hitDetectionInstructions.push([\n          CanvasInstruction.CUSTOM,\n          builderBegin,\n          builderEnd,\n          geometry,\n          hitDetectionRenderer || renderer\n        ]);\n        break;\n    }\n    this.endGeometry(feature2);\n  };\n  CanvasBuilder2.prototype.beginGeometry = function(geometry, feature2) {\n    this.beginGeometryInstruction1_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature2,\n      0,\n      geometry\n    ];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [\n      CanvasInstruction.BEGIN_GEOMETRY,\n      feature2,\n      0,\n      geometry\n    ];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  CanvasBuilder2.prototype.finish = function() {\n    return {\n      instructions: this.instructions,\n      hitDetectionInstructions: this.hitDetectionInstructions,\n      coordinates: this.coordinates\n    };\n  };\n  CanvasBuilder2.prototype.reverseHitDetectionInstructions = function() {\n    var hitDetectionInstructions = this.hitDetectionInstructions;\n    hitDetectionInstructions.reverse();\n    var i2;\n    var n2 = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n    for (i2 = 0; i2 < n2; ++i2) {\n      instruction = hitDetectionInstructions[i2];\n      type = instruction[0];\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i2;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i2;\n        reverseSubArray(this.hitDetectionInstructions, begin, i2);\n        begin = -1;\n      }\n    }\n  };\n  CanvasBuilder2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n    var state = this.state;\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = void 0;\n    }\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = void 0;\n      state.lineCap = void 0;\n      state.lineDash = null;\n      state.lineDashOffset = void 0;\n      state.lineJoin = void 0;\n      state.lineWidth = void 0;\n      state.miterLimit = void 0;\n    }\n  };\n  CanvasBuilder2.prototype.createFill = function(state) {\n    var fillStyle = state.fillStyle;\n    var fillInstruction2 = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== \"string\") {\n      fillInstruction2.push(true);\n    }\n    return fillInstruction2;\n  };\n  CanvasBuilder2.prototype.applyStroke = function(state) {\n    this.instructions.push(this.createStroke(state));\n  };\n  CanvasBuilder2.prototype.createStroke = function(state) {\n    return [\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle,\n      state.lineWidth * this.pixelRatio,\n      state.lineCap,\n      state.lineJoin,\n      state.miterLimit,\n      this.applyPixelRatio(state.lineDash),\n      state.lineDashOffset * this.pixelRatio\n    ];\n  };\n  CanvasBuilder2.prototype.updateFillStyle = function(state, createFill) {\n    var fillStyle = state.fillStyle;\n    if (typeof fillStyle !== \"string\" || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== void 0) {\n        this.instructions.push(createFill.call(this, state));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  CanvasBuilder2.prototype.updateStrokeStyle = function(state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals$2(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== void 0) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  CanvasBuilder2.prototype.endGeometry = function(feature2) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature2];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  CanvasBuilder2.prototype.getBufferedMaxExtent = function() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone$1(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer$1(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  };\n  return CanvasBuilder2;\n}(VectorContext$1);\nvar Builder = CanvasBuilder;\nvar __extends$1j = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CanvasImageBuilder = function(_super) {\n  __extends$1j(CanvasImageBuilder2, _super);\n  function CanvasImageBuilder2(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n    _this.hitDetectionImage_ = null;\n    _this.image_ = null;\n    _this.imagePixelRatio_ = void 0;\n    _this.anchorX_ = void 0;\n    _this.anchorY_ = void 0;\n    _this.height_ = void 0;\n    _this.opacity_ = void 0;\n    _this.originX_ = void 0;\n    _this.originY_ = void 0;\n    _this.rotateWithView_ = void 0;\n    _this.rotation_ = void 0;\n    _this.scale_ = void 0;\n    _this.width_ = void 0;\n    _this.declutterImageWithText_ = void 0;\n    return _this;\n  }\n  CanvasImageBuilder2.prototype.drawPoint = function(pointGeometry, feature2) {\n    if (!this.image_) {\n      return;\n    }\n    this.beginGeometry(pointGeometry, feature2);\n    var flatCoordinates = pointGeometry.getFlatCoordinates();\n    var stride = pointGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n    this.instructions.push([\n      CanvasInstruction.DRAW_IMAGE,\n      myBegin,\n      myEnd,\n      this.image_,\n      this.anchorX_ * this.imagePixelRatio_,\n      this.anchorY_ * this.imagePixelRatio_,\n      Math.ceil(this.height_ * this.imagePixelRatio_),\n      this.opacity_,\n      this.originX_,\n      this.originY_,\n      this.rotateWithView_,\n      this.rotation_,\n      [\n        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,\n        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_\n      ],\n      Math.ceil(this.width_ * this.imagePixelRatio_),\n      this.declutterImageWithText_\n    ]);\n    this.hitDetectionInstructions.push([\n      CanvasInstruction.DRAW_IMAGE,\n      myBegin,\n      myEnd,\n      this.hitDetectionImage_,\n      this.anchorX_,\n      this.anchorY_,\n      this.height_,\n      this.opacity_,\n      this.originX_,\n      this.originY_,\n      this.rotateWithView_,\n      this.rotation_,\n      this.scale_,\n      this.width_,\n      this.declutterImageWithText_\n    ]);\n    this.endGeometry(feature2);\n  };\n  CanvasImageBuilder2.prototype.drawMultiPoint = function(multiPointGeometry, feature2) {\n    if (!this.image_) {\n      return;\n    }\n    this.beginGeometry(multiPointGeometry, feature2);\n    var flatCoordinates = multiPointGeometry.getFlatCoordinates();\n    var stride = multiPointGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);\n    this.instructions.push([\n      CanvasInstruction.DRAW_IMAGE,\n      myBegin,\n      myEnd,\n      this.image_,\n      this.anchorX_ * this.imagePixelRatio_,\n      this.anchorY_ * this.imagePixelRatio_,\n      Math.ceil(this.height_ * this.imagePixelRatio_),\n      this.opacity_,\n      this.originX_,\n      this.originY_,\n      this.rotateWithView_,\n      this.rotation_,\n      [\n        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,\n        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_\n      ],\n      Math.ceil(this.width_ * this.imagePixelRatio_),\n      this.declutterImageWithText_\n    ]);\n    this.hitDetectionInstructions.push([\n      CanvasInstruction.DRAW_IMAGE,\n      myBegin,\n      myEnd,\n      this.hitDetectionImage_,\n      this.anchorX_,\n      this.anchorY_,\n      this.height_,\n      this.opacity_,\n      this.originX_,\n      this.originY_,\n      this.rotateWithView_,\n      this.rotation_,\n      this.scale_,\n      this.width_,\n      this.declutterImageWithText_\n    ]);\n    this.endGeometry(feature2);\n  };\n  CanvasImageBuilder2.prototype.finish = function() {\n    this.reverseHitDetectionInstructions();\n    this.anchorX_ = void 0;\n    this.anchorY_ = void 0;\n    this.hitDetectionImage_ = null;\n    this.image_ = null;\n    this.imagePixelRatio_ = void 0;\n    this.height_ = void 0;\n    this.scale_ = void 0;\n    this.opacity_ = void 0;\n    this.originX_ = void 0;\n    this.originY_ = void 0;\n    this.rotateWithView_ = void 0;\n    this.rotation_ = void 0;\n    this.width_ = void 0;\n    return _super.prototype.finish.call(this);\n  };\n  CanvasImageBuilder2.prototype.setImageStyle = function(imageStyle, opt_sharedData) {\n    var anchor = imageStyle.getAnchor();\n    var size = imageStyle.getSize();\n    var hitDetectionImage = imageStyle.getHitDetectionImage();\n    var image2 = imageStyle.getImage(this.pixelRatio);\n    var origin = imageStyle.getOrigin();\n    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);\n    this.anchorX_ = anchor[0];\n    this.anchorY_ = anchor[1];\n    this.hitDetectionImage_ = hitDetectionImage;\n    this.image_ = image2;\n    this.height_ = size[1];\n    this.opacity_ = imageStyle.getOpacity();\n    this.originX_ = origin[0] * this.imagePixelRatio_;\n    this.originY_ = origin[1] * this.imagePixelRatio_;\n    this.rotateWithView_ = imageStyle.getRotateWithView();\n    this.rotation_ = imageStyle.getRotation();\n    this.scale_ = imageStyle.getScaleArray();\n    this.width_ = size[0];\n    this.declutterImageWithText_ = opt_sharedData;\n  };\n  return CanvasImageBuilder2;\n}(Builder);\nvar ImageBuilder = CanvasImageBuilder;\nvar __extends$1i = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CanvasLineStringBuilder = function(_super) {\n  __extends$1i(CanvasLineStringBuilder2, _super);\n  function CanvasLineStringBuilder2(tolerance, maxExtent, resolution, pixelRatio) {\n    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n  }\n  CanvasLineStringBuilder2.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset2, end, stride) {\n    var myBegin = this.coordinates.length;\n    var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, false, false);\n    var moveToLineToInstruction = [\n      CanvasInstruction.MOVE_TO_LINE_TO,\n      myBegin,\n      myEnd\n    ];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n    return end;\n  };\n  CanvasLineStringBuilder2.prototype.drawLineString = function(lineStringGeometry, feature2) {\n    var state = this.state;\n    var strokeStyle = state.strokeStyle;\n    var lineWidth = state.lineWidth;\n    if (strokeStyle === void 0 || lineWidth === void 0) {\n      return;\n    }\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(lineStringGeometry, feature2);\n    this.hitDetectionInstructions.push([\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle,\n      state.lineWidth,\n      state.lineCap,\n      state.lineJoin,\n      state.miterLimit,\n      defaultLineDash,\n      defaultLineDashOffset\n    ], beginPathInstruction);\n    var flatCoordinates = lineStringGeometry.getFlatCoordinates();\n    var stride = lineStringGeometry.getStride();\n    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n    this.hitDetectionInstructions.push(strokeInstruction);\n    this.endGeometry(feature2);\n  };\n  CanvasLineStringBuilder2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature2) {\n    var state = this.state;\n    var strokeStyle = state.strokeStyle;\n    var lineWidth = state.lineWidth;\n    if (strokeStyle === void 0 || lineWidth === void 0) {\n      return;\n    }\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(multiLineStringGeometry, feature2);\n    this.hitDetectionInstructions.push([\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle,\n      state.lineWidth,\n      state.lineCap,\n      state.lineJoin,\n      state.miterLimit,\n      state.lineDash,\n      state.lineDashOffset\n    ], beginPathInstruction);\n    var ends = multiLineStringGeometry.getEnds();\n    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n    var stride = multiLineStringGeometry.getStride();\n    var offset2 = 0;\n    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n      offset2 = this.drawFlatCoordinates_(flatCoordinates, offset2, ends[i2], stride);\n    }\n    this.hitDetectionInstructions.push(strokeInstruction);\n    this.endGeometry(feature2);\n  };\n  CanvasLineStringBuilder2.prototype.finish = function() {\n    var state = this.state;\n    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {\n      this.instructions.push(strokeInstruction);\n    }\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    return _super.prototype.finish.call(this);\n  };\n  CanvasLineStringBuilder2.prototype.applyStroke = function(state) {\n    if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {\n      this.instructions.push(strokeInstruction);\n      state.lastStroke = this.coordinates.length;\n    }\n    state.lastStroke = 0;\n    _super.prototype.applyStroke.call(this, state);\n    this.instructions.push(beginPathInstruction);\n  };\n  return CanvasLineStringBuilder2;\n}(Builder);\nvar LineStringBuilder = CanvasLineStringBuilder;\nvar __extends$1h = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CanvasPolygonBuilder = function(_super) {\n  __extends$1h(CanvasPolygonBuilder2, _super);\n  function CanvasPolygonBuilder2(tolerance, maxExtent, resolution, pixelRatio) {\n    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n  }\n  CanvasPolygonBuilder2.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset2, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== void 0;\n    var stroke = state.strokeStyle !== void 0;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n    for (var i2 = 0; i2 < numEnds; ++i2) {\n      var end = ends[i2];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, true, !stroke);\n      var moveToLineToInstruction = [\n        CanvasInstruction.MOVE_TO_LINE_TO,\n        myBegin,\n        myEnd\n      ];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n      if (stroke) {\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n      offset2 = end;\n    }\n    if (fill) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (stroke) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    return offset2;\n  };\n  CanvasPolygonBuilder2.prototype.drawCircle = function(circleGeometry, feature2) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === void 0 && strokeStyle === void 0) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(circleGeometry, feature2);\n    if (state.fillStyle !== void 0) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle\n      ]);\n    }\n    if (state.strokeStyle !== void 0) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset\n      ]);\n    }\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    if (state.fillStyle !== void 0) {\n      this.instructions.push(fillInstruction);\n      this.hitDetectionInstructions.push(fillInstruction);\n    }\n    if (state.strokeStyle !== void 0) {\n      this.instructions.push(strokeInstruction);\n      this.hitDetectionInstructions.push(strokeInstruction);\n    }\n    this.endGeometry(feature2);\n  };\n  CanvasPolygonBuilder2.prototype.drawPolygon = function(polygonGeometry, feature2) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === void 0 && strokeStyle === void 0) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(polygonGeometry, feature2);\n    if (state.fillStyle !== void 0) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle\n      ]);\n    }\n    if (state.strokeStyle !== void 0) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset\n      ]);\n    }\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(feature2);\n  };\n  CanvasPolygonBuilder2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature2) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n    if (fillStyle === void 0 && strokeStyle === void 0) {\n      return;\n    }\n    this.setFillStrokeStyles_();\n    this.beginGeometry(multiPolygonGeometry, feature2);\n    if (state.fillStyle !== void 0) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_FILL_STYLE,\n        defaultFillStyle\n      ]);\n    }\n    if (state.strokeStyle !== void 0) {\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        state.lineDash,\n        state.lineDashOffset\n      ]);\n    }\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset2 = 0;\n    for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n      offset2 = this.drawFlatCoordinatess_(flatCoordinates, offset2, endss[i2], stride);\n    }\n    this.endGeometry(feature2);\n  };\n  CanvasPolygonBuilder2.prototype.finish = function() {\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    var tolerance = this.tolerance;\n    if (tolerance !== 0) {\n      var coordinates2 = this.coordinates;\n      for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {\n        coordinates2[i2] = snap(coordinates2[i2], tolerance);\n      }\n    }\n    return _super.prototype.finish.call(this);\n  };\n  CanvasPolygonBuilder2.prototype.setFillStrokeStyles_ = function() {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    if (fillStyle !== void 0) {\n      this.updateFillStyle(state, this.createFill);\n    }\n    if (state.strokeStyle !== void 0) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n  return CanvasPolygonBuilder2;\n}(Builder);\nvar PolygonBuilder = CanvasPolygonBuilder;\nvar TextPlacement = {\n  POINT: \"point\",\n  LINE: \"line\"\n};\nfunction matchingChunk(maxAngle, flatCoordinates, offset2, end, stride) {\n  var chunkStart = offset2;\n  var chunkEnd = offset2;\n  var chunkM = 0;\n  var m2 = 0;\n  var start2 = offset2;\n  var acos, i2, m12, m23, x1, y1, x12, y12, x23, y23;\n  for (i2 = offset2; i2 < end; i2 += stride) {\n    var x2 = flatCoordinates[i2];\n    var y2 = flatCoordinates[i2 + 1];\n    if (x1 !== void 0) {\n      x23 = x2 - x1;\n      y23 = y2 - y1;\n      m23 = Math.sqrt(x23 * x23 + y23 * y23);\n      if (x12 !== void 0) {\n        m2 += m12;\n        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n        if (acos > maxAngle) {\n          if (m2 > chunkM) {\n            chunkM = m2;\n            chunkStart = start2;\n            chunkEnd = i2;\n          }\n          m2 = 0;\n          start2 = i2 - stride;\n        }\n      }\n      m12 = m23;\n      x12 = x23;\n      y12 = y23;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  m2 += m23;\n  return m2 > chunkM ? [start2, i2] : [chunkStart, chunkEnd];\n}\nvar __extends$1g = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TEXT_ALIGN = {\n  \"left\": 0,\n  \"end\": 0,\n  \"center\": 0.5,\n  \"right\": 1,\n  \"start\": 1,\n  \"top\": 0,\n  \"middle\": 0.5,\n  \"hanging\": 0.2,\n  \"alphabetic\": 0.8,\n  \"ideographic\": 0.8,\n  \"bottom\": 1\n};\nvar CanvasTextBuilder = function(_super) {\n  __extends$1g(CanvasTextBuilder2, _super);\n  function CanvasTextBuilder2(tolerance, maxExtent, resolution, pixelRatio) {\n    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;\n    _this.labels_ = null;\n    _this.text_ = \"\";\n    _this.textOffsetX_ = 0;\n    _this.textOffsetY_ = 0;\n    _this.textRotateWithView_ = void 0;\n    _this.textRotation_ = 0;\n    _this.textFillState_ = null;\n    _this.fillStates = {};\n    _this.textStrokeState_ = null;\n    _this.strokeStates = {};\n    _this.textState_ = {};\n    _this.textStates = {};\n    _this.textKey_ = \"\";\n    _this.fillKey_ = \"\";\n    _this.strokeKey_ = \"\";\n    _this.declutterImageWithText_ = void 0;\n    return _this;\n  }\n  CanvasTextBuilder2.prototype.finish = function() {\n    var instructions = _super.prototype.finish.call(this);\n    instructions.textStates = this.textStates;\n    instructions.fillStates = this.fillStates;\n    instructions.strokeStates = this.strokeStates;\n    return instructions;\n  };\n  CanvasTextBuilder2.prototype.drawText = function(geometry, feature2) {\n    var fillState = this.textFillState_;\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    if (this.text_ === \"\" || !textState || !fillState && !strokeState) {\n      return;\n    }\n    var coordinates2 = this.coordinates;\n    var begin = coordinates2.length;\n    var geometryType = geometry.getType();\n    var flatCoordinates = null;\n    var stride = geometry.getStride();\n    if (textState.placement === TextPlacement.LINE && (geometryType == GeometryType.LINE_STRING || geometryType == GeometryType.MULTI_LINE_STRING || geometryType == GeometryType.POLYGON || geometryType == GeometryType.MULTI_POLYGON)) {\n      if (!intersects$1(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n      var ends = void 0;\n      flatCoordinates = geometry.getFlatCoordinates();\n      if (geometryType == GeometryType.LINE_STRING) {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == GeometryType.MULTI_LINE_STRING) {\n        ends = geometry.getEnds();\n      } else if (geometryType == GeometryType.POLYGON) {\n        ends = geometry.getEnds().slice(0, 1);\n      } else if (geometryType == GeometryType.MULTI_POLYGON) {\n        var endss = geometry.getEndss();\n        ends = [];\n        for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n          ends.push(endss[i2][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature2);\n      var textAlign2 = textState.textAlign;\n      var flatOffset = 0;\n      var flatEnd = void 0;\n      for (var o2 = 0, oo = ends.length; o2 < oo; ++o2) {\n        if (textAlign2 == void 0) {\n          var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o2], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o2];\n        }\n        for (var i2 = flatOffset; i2 < flatEnd; i2 += stride) {\n          coordinates2.push(flatCoordinates[i2], flatCoordinates[i2 + 1]);\n        }\n        var end = coordinates2.length;\n        flatOffset = ends[o2];\n        this.drawChars_(begin, end);\n        begin = end;\n      }\n      this.endGeometry(feature2);\n    } else {\n      var geometryWidths = textState.overflow ? null : [];\n      switch (geometryType) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n          flatCoordinates = geometry.getFlatCoordinates();\n          break;\n        case GeometryType.LINE_STRING:\n          flatCoordinates = geometry.getFlatMidpoint();\n          break;\n        case GeometryType.CIRCLE:\n          flatCoordinates = geometry.getCenter();\n          break;\n        case GeometryType.MULTI_LINE_STRING:\n          flatCoordinates = geometry.getFlatMidpoints();\n          stride = 2;\n          break;\n        case GeometryType.POLYGON:\n          flatCoordinates = geometry.getFlatInteriorPoint();\n          if (!textState.overflow) {\n            geometryWidths.push(flatCoordinates[2] / this.resolution);\n          }\n          stride = 3;\n          break;\n        case GeometryType.MULTI_POLYGON:\n          var interiorPoints = geometry.getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (var i2 = 0, ii = interiorPoints.length; i2 < ii; i2 += 3) {\n            if (!textState.overflow) {\n              geometryWidths.push(interiorPoints[i2 + 2] / this.resolution);\n            }\n            flatCoordinates.push(interiorPoints[i2], interiorPoints[i2 + 1]);\n          }\n          if (flatCoordinates.length === 0) {\n            return;\n          }\n          stride = 2;\n          break;\n      }\n      var end = this.appendFlatPointCoordinates(flatCoordinates, stride);\n      if (end === begin) {\n        return;\n      }\n      if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {\n        var beg_1 = begin / 2;\n        geometryWidths = geometryWidths.filter(function(w2, i3) {\n          var keep = coordinates2[(beg_1 + i3) * 2] === flatCoordinates[i3 * stride] && coordinates2[(beg_1 + i3) * 2 + 1] === flatCoordinates[i3 * stride + 1];\n          if (!keep) {\n            --beg_1;\n          }\n          return keep;\n        });\n      }\n      this.saveTextStates_();\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill);\n          this.hitDetectionInstructions.push(this.createFill(this.state));\n        }\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n      this.beginGeometry(geometry, feature2);\n      var padding = textState.padding;\n      if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {\n        var p0 = textState.padding[0];\n        var p12 = textState.padding[1];\n        var p22 = textState.padding[2];\n        var p32 = textState.padding[3];\n        if (textState.scale[0] < 0) {\n          p12 = -p12;\n          p32 = -p32;\n        }\n        if (textState.scale[1] < 0) {\n          p0 = -p0;\n          p22 = -p22;\n        }\n        padding = [p0, p12, p22, p32];\n      }\n      var pixelRatio_1 = this.pixelRatio;\n      this.instructions.push([\n        CanvasInstruction.DRAW_IMAGE,\n        begin,\n        end,\n        null,\n        NaN,\n        NaN,\n        NaN,\n        1,\n        0,\n        0,\n        this.textRotateWithView_,\n        this.textRotation_,\n        [1, 1],\n        NaN,\n        this.declutterImageWithText_,\n        padding == defaultPadding ? defaultPadding : padding.map(function(p5) {\n          return p5 * pixelRatio_1;\n        }),\n        !!textState.backgroundFill,\n        !!textState.backgroundStroke,\n        this.text_,\n        this.textKey_,\n        this.strokeKey_,\n        this.fillKey_,\n        this.textOffsetX_,\n        this.textOffsetY_,\n        geometryWidths\n      ]);\n      var scale2 = 1 / pixelRatio_1;\n      this.hitDetectionInstructions.push([\n        CanvasInstruction.DRAW_IMAGE,\n        begin,\n        end,\n        null,\n        NaN,\n        NaN,\n        NaN,\n        1,\n        0,\n        0,\n        this.textRotateWithView_,\n        this.textRotation_,\n        [scale2, scale2],\n        NaN,\n        this.declutterImageWithText_,\n        padding,\n        !!textState.backgroundFill,\n        !!textState.backgroundStroke,\n        this.text_,\n        this.textKey_,\n        this.strokeKey_,\n        this.fillKey_,\n        this.textOffsetX_,\n        this.textOffsetY_,\n        geometryWidths\n      ]);\n      this.endGeometry(feature2);\n    }\n  };\n  CanvasTextBuilder2.prototype.saveTextStates_ = function() {\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    var fillState = this.textFillState_;\n    var strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = {\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        };\n      }\n    }\n    var textKey = this.textKey_;\n    if (!(textKey in this.textStates)) {\n      this.textStates[textKey] = {\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        textBaseline: textState.textBaseline || defaultTextBaseline,\n        scale: textState.scale\n      };\n    }\n    var fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = {\n          fillStyle: fillState.fillStyle\n        };\n      }\n    }\n  };\n  CanvasTextBuilder2.prototype.drawChars_ = function(begin, end) {\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    var strokeKey = this.strokeKey_;\n    var textKey = this.textKey_;\n    var fillKey = this.fillKey_;\n    this.saveTextStates_();\n    var pixelRatio = this.pixelRatio;\n    var baseline = TEXT_ALIGN[textState.textBaseline];\n    var offsetY = this.textOffsetY_ * pixelRatio;\n    var text2 = this.text_;\n    var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;\n    this.instructions.push([\n      CanvasInstruction.DRAW_CHARS,\n      begin,\n      end,\n      baseline,\n      textState.overflow,\n      fillKey,\n      textState.maxAngle,\n      pixelRatio,\n      offsetY,\n      strokeKey,\n      strokeWidth * pixelRatio,\n      text2,\n      textKey,\n      1\n    ]);\n    this.hitDetectionInstructions.push([\n      CanvasInstruction.DRAW_CHARS,\n      begin,\n      end,\n      baseline,\n      textState.overflow,\n      fillKey,\n      textState.maxAngle,\n      1,\n      offsetY,\n      strokeKey,\n      strokeWidth,\n      text2,\n      textKey,\n      1 / pixelRatio\n    ]);\n  };\n  CanvasTextBuilder2.prototype.setTextStyle = function(textStyle, opt_sharedData) {\n    var textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = \"\";\n    } else {\n      var textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = null;\n        this.textFillState_ = fillState;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = {};\n          this.textFillState_ = fillState;\n        }\n        fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);\n      }\n      var textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = null;\n        this.textStrokeState_ = strokeState;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = {};\n          this.textStrokeState_ = strokeState;\n        }\n        var lineDash = textStrokeStyle.getLineDash();\n        var lineDashOffset = textStrokeStyle.getLineDashOffset();\n        var lineWidth = textStrokeStyle.getWidth();\n        var miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);\n      }\n      textState = this.textState_;\n      var font = textStyle.getFont() || defaultFont;\n      registerFont(font);\n      var textScale = textStyle.getScaleArray();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === void 0 ? [1, 1] : textScale;\n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || \"\";\n      this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;\n      this.textRotation_ = textRotation === void 0 ? 0 : textRotation;\n      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == \"string\" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + \"|\" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + \"[\" + strokeState.lineDash.join() + \"]\" : \"\";\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || \"?\") + (textState.textBaseline || \"?\");\n      this.fillKey_ = fillState ? typeof fillState.fillStyle == \"string\" ? fillState.fillStyle : \"|\" + getUid(fillState.fillStyle) : \"\";\n    }\n    this.declutterImageWithText_ = opt_sharedData;\n  };\n  return CanvasTextBuilder2;\n}(Builder);\nvar TextBuilder = CanvasTextBuilder;\nvar BATCH_CONSTRUCTORS = {\n  \"Circle\": PolygonBuilder,\n  \"Default\": Builder,\n  \"Image\": ImageBuilder,\n  \"LineString\": LineStringBuilder,\n  \"Polygon\": PolygonBuilder,\n  \"Text\": TextBuilder\n};\nvar BuilderGroup = function() {\n  function BuilderGroup2(tolerance, maxExtent, resolution, pixelRatio) {\n    this.tolerance_ = tolerance;\n    this.maxExtent_ = maxExtent;\n    this.pixelRatio_ = pixelRatio;\n    this.resolution_ = resolution;\n    this.buildersByZIndex_ = {};\n  }\n  BuilderGroup2.prototype.finish = function() {\n    var builderInstructions = {};\n    for (var zKey in this.buildersByZIndex_) {\n      builderInstructions[zKey] = builderInstructions[zKey] || {};\n      var builders = this.buildersByZIndex_[zKey];\n      for (var builderKey in builders) {\n        var builderInstruction = builders[builderKey].finish();\n        builderInstructions[zKey][builderKey] = builderInstruction;\n      }\n    }\n    return builderInstructions;\n  };\n  BuilderGroup2.prototype.getBuilder = function(zIndex2, builderType) {\n    var zIndexKey = zIndex2 !== void 0 ? zIndex2.toString() : \"0\";\n    var replays = this.buildersByZIndex_[zIndexKey];\n    if (replays === void 0) {\n      replays = {};\n      this.buildersByZIndex_[zIndexKey] = replays;\n    }\n    var replay = replays[builderType];\n    if (replay === void 0) {\n      var Constructor = BATCH_CONSTRUCTORS[builderType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);\n      replays[builderType] = replay;\n    }\n    return replay;\n  };\n  return BuilderGroup2;\n}();\nvar CanvasBuilderGroup = BuilderGroup;\nvar __extends$1f = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar LayerRenderer = function(_super) {\n  __extends$1f(LayerRenderer2, _super);\n  function LayerRenderer2(layer) {\n    var _this = _super.call(this) || this;\n    _this.ready = true;\n    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);\n    _this.layer_ = layer;\n    _this.declutterExecutorGroup = null;\n    return _this;\n  }\n  LayerRenderer2.prototype.getFeatures = function(pixel) {\n    return abstract();\n  };\n  LayerRenderer2.prototype.getData = function(pixel) {\n    return null;\n  };\n  LayerRenderer2.prototype.prepareFrame = function(frameState) {\n    return abstract();\n  };\n  LayerRenderer2.prototype.renderFrame = function(frameState, target) {\n    return abstract();\n  };\n  LayerRenderer2.prototype.loadedTileCallback = function(tiles, zoom, tile2) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile2.tileCoord.toString()] = tile2;\n    return void 0;\n  };\n  LayerRenderer2.prototype.createLoadedTileFinder = function(source, projection, tiles) {\n    return function(zoom, tileRange) {\n      var callback = this.loadedTileCallback.bind(this, tiles, zoom);\n      return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n    }.bind(this);\n  };\n  LayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {\n    return void 0;\n  };\n  LayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {\n    return null;\n  };\n  LayerRenderer2.prototype.getLayer = function() {\n    return this.layer_;\n  };\n  LayerRenderer2.prototype.handleFontsChanged = function() {\n  };\n  LayerRenderer2.prototype.handleImageChange_ = function(event) {\n    var image2 = event.target;\n    if (image2.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n  LayerRenderer2.prototype.loadImage = function(image2) {\n    var imageState = image2.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image2.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image2.load();\n      imageState = image2.getState();\n    }\n    return imageState == ImageState.LOADED;\n  };\n  LayerRenderer2.prototype.renderIfReadyAndVisible = function() {\n    var layer = this.getLayer();\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      layer.changed();\n    }\n  };\n  LayerRenderer2.prototype.disposeInternal = function() {\n    delete this.layer_;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return LayerRenderer2;\n}(Observable);\nvar LayerRenderer$1 = LayerRenderer;\nvar __extends$1e = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar pixelContext$1 = null;\nfunction createPixelContext$1() {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = 1;\n  pixelContext$1 = canvas.getContext(\"2d\");\n}\nvar CanvasLayerRenderer = function(_super) {\n  __extends$1e(CanvasLayerRenderer2, _super);\n  function CanvasLayerRenderer2(layer) {\n    var _this = _super.call(this, layer) || this;\n    _this.container = null;\n    _this.renderedResolution;\n    _this.tempTransform = create$6();\n    _this.pixelTransform = create$6();\n    _this.inversePixelTransform = create$6();\n    _this.context = null;\n    _this.containerReused = false;\n    _this.pixelContext_ = null;\n    _this.frameState = null;\n    return _this;\n  }\n  CanvasLayerRenderer2.prototype.getImageData = function(image2, col, row) {\n    if (!pixelContext$1) {\n      createPixelContext$1();\n    }\n    pixelContext$1.clearRect(0, 0, 1, 1);\n    var data2;\n    try {\n      pixelContext$1.drawImage(image2, col, row, 1, 1, 0, 0, 1, 1);\n      data2 = pixelContext$1.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      return null;\n    }\n    return data2;\n  };\n  CanvasLayerRenderer2.prototype.getBackground = function(frameState) {\n    var layer = this.getLayer();\n    var background = layer.getBackground();\n    if (typeof background === \"function\") {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || void 0;\n  };\n  CanvasLayerRenderer2.prototype.useContainer = function(target, transform2, opacity2, opt_backgroundColor) {\n    var layerClassName = this.getLayer().getClassName();\n    var container, context;\n    if (target && target.className === layerClassName && target.style.opacity === \"\" && opacity2 === 1 && (!opt_backgroundColor || target.style.backgroundColor && equals$2(asArray(target.style.backgroundColor), asArray(opt_backgroundColor)))) {\n      var canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext(\"2d\");\n      }\n    }\n    if (context && context.canvas.style.transform === transform2) {\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    }\n    if (!this.container) {\n      container = document.createElement(\"div\");\n      container.className = layerClassName;\n      var style2 = container.style;\n      style2.position = \"absolute\";\n      style2.width = \"100%\";\n      style2.height = \"100%\";\n      if (opt_backgroundColor) {\n        style2.backgroundColor = opt_backgroundColor;\n      }\n      context = createCanvasContext2D();\n      var canvas = context.canvas;\n      container.appendChild(canvas);\n      style2 = canvas.style;\n      style2.position = \"absolute\";\n      style2.left = \"0\";\n      style2.transformOrigin = \"top left\";\n      this.container = container;\n      this.context = context;\n    }\n  };\n  CanvasLayerRenderer2.prototype.clipUnrotated = function(context, frameState, extent2) {\n    var topLeft = getTopLeft(extent2);\n    var topRight = getTopRight(extent2);\n    var bottomRight = getBottomRight(extent2);\n    var bottomLeft = getBottomLeft(extent2);\n    apply$5(frameState.coordinateToPixelTransform, topLeft);\n    apply$5(frameState.coordinateToPixelTransform, topRight);\n    apply$5(frameState.coordinateToPixelTransform, bottomRight);\n    apply$5(frameState.coordinateToPixelTransform, bottomLeft);\n    var inverted = this.inversePixelTransform;\n    apply$5(inverted, topLeft);\n    apply$5(inverted, topRight);\n    apply$5(inverted, bottomRight);\n    apply$5(inverted, bottomLeft);\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  };\n  CanvasLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, context, frameState) {\n    var layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      var event_1 = new RenderEvent$1(type, this.inversePixelTransform, frameState, context);\n      layer.dispatchEvent(event_1);\n    }\n  };\n  CanvasLayerRenderer2.prototype.preRender = function(context, frameState) {\n    this.frameState = frameState;\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  };\n  CanvasLayerRenderer2.prototype.postRender = function(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  };\n  CanvasLayerRenderer2.prototype.getRenderTransform = function(center, resolution, rotation, pixelRatio, width, height, offsetX) {\n    var dx1 = width / 2;\n    var dy1 = height / 2;\n    var sx = pixelRatio / resolution;\n    var sy = -sx;\n    var dx2 = -center[0] + offsetX;\n    var dy2 = -center[1];\n    return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);\n  };\n  CanvasLayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {\n    var renderPixel = apply$5(this.inversePixelTransform, pixel.slice());\n    var context = this.context;\n    var layer = this.getLayer();\n    var layerExtent = layer.getExtent();\n    if (layerExtent) {\n      var renderCoordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());\n      if (!containsCoordinate(layerExtent, renderCoordinate)) {\n        return null;\n      }\n    }\n    var x2 = Math.round(renderPixel[0]);\n    var y2 = Math.round(renderPixel[1]);\n    var pixelContext2 = this.pixelContext_;\n    if (!pixelContext2) {\n      var pixelCanvas = document.createElement(\"canvas\");\n      pixelCanvas.width = 1;\n      pixelCanvas.height = 1;\n      pixelContext2 = pixelCanvas.getContext(\"2d\");\n      this.pixelContext_ = pixelContext2;\n    }\n    pixelContext2.clearRect(0, 0, 1, 1);\n    var data2;\n    try {\n      pixelContext2.drawImage(context.canvas, x2, y2, 1, 1, 0, 0, 1, 1);\n      data2 = pixelContext2.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      if (err.name === \"SecurityError\") {\n        this.pixelContext_ = null;\n        return new Uint8Array();\n      }\n      return data2;\n    }\n    if (data2[3] === 0) {\n      return null;\n    }\n    return data2;\n  };\n  CanvasLayerRenderer2.prototype.disposeInternal = function() {\n    delete this.frameState;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return CanvasLayerRenderer2;\n}(LayerRenderer$1);\nvar CanvasLayerRenderer$1 = CanvasLayerRenderer;\nvar ReplayType = {\n  CIRCLE: \"Circle\",\n  DEFAULT: \"Default\",\n  IMAGE: \"Image\",\n  LINE_STRING: \"LineString\",\n  POLYGON: \"Polygon\",\n  TEXT: \"Text\"\n};\nfunction drawTextOnPath(flatCoordinates, offset2, end, stride, text2, startM, maxAngle, scale2, measureAndCacheTextWidth2, font, cache2, rotation) {\n  var x2 = flatCoordinates[offset2];\n  var y2 = flatCoordinates[offset2 + 1];\n  var x1 = 0;\n  var y1 = 0;\n  var segmentLength = 0;\n  var segmentM = 0;\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset2 += stride;\n    x2 = flatCoordinates[offset2];\n    y2 = flatCoordinates[offset2 + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  do {\n    advance();\n  } while (offset2 < end - stride && segmentM + segmentLength < startM);\n  var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  var beginX = lerp$1(x1, x2, interpolate);\n  var beginY = lerp$1(y1, y2, interpolate);\n  var startOffset = offset2 - stride;\n  var startLength = segmentM;\n  var endM = startM + scale2 * measureAndCacheTextWidth2(font, text2, cache2);\n  while (offset2 < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  var endX = lerp$1(x1, x2, interpolate);\n  var endY = lerp$1(y1, y2, interpolate);\n  var reverse2;\n  if (rotation) {\n    var flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse2 = flat[0] > flat[2];\n  } else {\n    reverse2 = beginX > endX;\n  }\n  var PI = Math.PI;\n  var result = [];\n  var singleSegment = startOffset + stride === offset2;\n  offset2 = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset2];\n  y2 = flatCoordinates[offset2 + 1];\n  var previousAngle;\n  if (singleSegment) {\n    advance();\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse2) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n    var x3 = (endX + beginX) / 2;\n    var y3 = (endY + beginY) / 2;\n    result[0] = [x3, y3, (endM - startM) / 2, previousAngle, text2];\n    return result;\n  }\n  for (var i2 = 0, ii = text2.length; i2 < ii; ) {\n    advance();\n    var angle2 = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse2) {\n      angle2 += angle2 > 0 ? -PI : PI;\n    }\n    if (previousAngle !== void 0) {\n      var delta = angle2 - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle2;\n    var iStart = i2;\n    var charLength = 0;\n    for (; i2 < ii; ++i2) {\n      var index2 = reverse2 ? ii - i2 - 1 : i2;\n      var len = scale2 * measureAndCacheTextWidth2(font, text2[index2], cache2);\n      if (offset2 + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {\n        break;\n      }\n      charLength += len;\n    }\n    if (i2 === iStart) {\n      continue;\n    }\n    var chars2 = reverse2 ? text2.substring(ii - iStart, ii - i2) : text2.substring(iStart, i2);\n    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;\n    var x3 = lerp$1(x1, x2, interpolate);\n    var y3 = lerp$1(y1, y2, interpolate);\n    result.push([x3, y3, charLength / 2, angle2, chars2]);\n    startM += charLength;\n  }\n  return result;\n}\nvar tmpExtent = createEmpty();\nvar p1 = [];\nvar p2 = [];\nvar p3 = [];\nvar p4 = [];\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\nvar rtlRegEx = new RegExp(\"[\" + String.fromCharCode(1425) + \"-\" + String.fromCharCode(2303) + String.fromCharCode(64285) + \"-\" + String.fromCharCode(65023) + String.fromCharCode(65136) + \"-\" + String.fromCharCode(65276) + String.fromCharCode(67584) + \"-\" + String.fromCharCode(69631) + String.fromCharCode(124928) + \"-\" + String.fromCharCode(126975) + \"]\");\nfunction horizontalTextAlign(text2, align) {\n  if ((align === \"start\" || align === \"end\") && !rtlRegEx.test(text2)) {\n    align = align === \"start\" ? \"left\" : \"right\";\n  }\n  return TEXT_ALIGN[align];\n}\nfunction createTextChunks(acc, line, i2) {\n  if (i2 > 0) {\n    acc.push(\"\\n\", \"\");\n  }\n  acc.push(line, \"\");\n  return acc;\n}\nvar Executor = function() {\n  function Executor2(resolution, pixelRatio, overlaps, instructions) {\n    this.overlaps = overlaps;\n    this.pixelRatio = pixelRatio;\n    this.resolution = resolution;\n    this.alignFill_;\n    this.instructions = instructions.instructions;\n    this.coordinates = instructions.coordinates;\n    this.coordinateCache_ = {};\n    this.renderedTransform_ = create$6();\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n    this.pixelCoordinates_ = null;\n    this.viewRotation_ = 0;\n    this.fillStates = instructions.fillStates || {};\n    this.strokeStates = instructions.strokeStates || {};\n    this.textStates = instructions.textStates || {};\n    this.widths_ = {};\n    this.labels_ = {};\n  }\n  Executor2.prototype.createLabel = function(text2, textKey, fillKey, strokeKey) {\n    var key = text2 + textKey + fillKey + strokeKey;\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    var fillState = fillKey ? this.fillStates[fillKey] : null;\n    var textState = this.textStates[textKey];\n    var pixelRatio = this.pixelRatio;\n    var scale2 = [\n      textState.scale[0] * pixelRatio,\n      textState.scale[1] * pixelRatio\n    ];\n    var textIsArray = Array.isArray(text2);\n    var align = horizontalTextAlign(textIsArray ? text2[0] : text2, textState.textAlign || defaultTextAlign);\n    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var chunks = textIsArray ? text2 : text2.split(\"\\n\").reduce(createTextChunks, []);\n    var _a2 = getTextDimensions(textState, chunks), width = _a2.width, height = _a2.height, widths = _a2.widths, heights = _a2.heights, lineWidths = _a2.lineWidths;\n    var renderWidth = width + strokeWidth;\n    var contextInstructions = [];\n    var w2 = (renderWidth + 2) * scale2[0];\n    var h2 = (height + strokeWidth) * scale2[1];\n    var label = {\n      width: w2 < 0 ? Math.floor(w2) : Math.ceil(w2),\n      height: h2 < 0 ? Math.floor(h2) : Math.ceil(h2),\n      contextInstructions\n    };\n    if (scale2[0] != 1 || scale2[1] != 1) {\n      contextInstructions.push(\"scale\", scale2);\n    }\n    if (strokeKey) {\n      contextInstructions.push(\"strokeStyle\", strokeState.strokeStyle);\n      contextInstructions.push(\"lineWidth\", strokeWidth);\n      contextInstructions.push(\"lineCap\", strokeState.lineCap);\n      contextInstructions.push(\"lineJoin\", strokeState.lineJoin);\n      contextInstructions.push(\"miterLimit\", strokeState.miterLimit);\n      var Context2 = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n      if (Context2.prototype.setLineDash) {\n        contextInstructions.push(\"setLineDash\", [strokeState.lineDash]);\n        contextInstructions.push(\"lineDashOffset\", strokeState.lineDashOffset);\n      }\n    }\n    if (fillKey) {\n      contextInstructions.push(\"fillStyle\", fillState.fillStyle);\n    }\n    contextInstructions.push(\"textBaseline\", \"middle\");\n    contextInstructions.push(\"textAlign\", \"center\");\n    var leftRight = 0.5 - align;\n    var x2 = align * renderWidth + leftRight * strokeWidth;\n    var strokeInstructions = [];\n    var fillInstructions = [];\n    var lineHeight2 = 0;\n    var lineOffset = 0;\n    var widthHeightIndex = 0;\n    var lineWidthIndex = 0;\n    var previousFont;\n    for (var i2 = 0, ii = chunks.length; i2 < ii; i2 += 2) {\n      var text_1 = chunks[i2];\n      if (text_1 === \"\\n\") {\n        lineOffset += lineHeight2;\n        lineHeight2 = 0;\n        x2 = align * renderWidth + leftRight * strokeWidth;\n        ++lineWidthIndex;\n        continue;\n      }\n      var font = chunks[i2 + 1] || textState.font;\n      if (font !== previousFont) {\n        if (strokeKey) {\n          strokeInstructions.push(\"font\", font);\n        }\n        if (fillKey) {\n          fillInstructions.push(\"font\", font);\n        }\n        previousFont = font;\n      }\n      lineHeight2 = Math.max(lineHeight2, heights[widthHeightIndex]);\n      var fillStrokeArgs = [\n        text_1,\n        x2 + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),\n        0.5 * (strokeWidth + lineHeight2) + lineOffset\n      ];\n      x2 += widths[widthHeightIndex];\n      if (strokeKey) {\n        strokeInstructions.push(\"strokeText\", fillStrokeArgs);\n      }\n      if (fillKey) {\n        fillInstructions.push(\"fillText\", fillStrokeArgs);\n      }\n      ++widthHeightIndex;\n    }\n    Array.prototype.push.apply(contextInstructions, strokeInstructions);\n    Array.prototype.push.apply(contextInstructions, fillInstructions);\n    this.labels_[key] = label;\n    return label;\n  };\n  Executor2.prototype.replayTextBackground_ = function(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {\n    context.beginPath();\n    context.moveTo.apply(context, p12);\n    context.lineTo.apply(context, p22);\n    context.lineTo.apply(context, p32);\n    context.lineTo.apply(context, p42);\n    context.lineTo.apply(context, p12);\n    if (fillInstruction2) {\n      this.alignFill_ = fillInstruction2[2];\n      this.fill_(context);\n    }\n    if (strokeInstruction2) {\n      this.setStrokeStyle_(context, strokeInstruction2);\n      context.stroke();\n    }\n  };\n  Executor2.prototype.calculateImageOrLabelDimensions_ = function(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, fillStroke, feature2) {\n    anchorX *= scale2[0];\n    anchorY *= scale2[1];\n    var x2 = centerX - anchorX;\n    var y2 = centerY - anchorY;\n    var w2 = width + originX > sheetWidth ? sheetWidth - originX : width;\n    var h2 = height + originY > sheetHeight ? sheetHeight - originY : height;\n    var boxW = padding[3] + w2 * scale2[0] + padding[1];\n    var boxH = padding[0] + h2 * scale2[1] + padding[2];\n    var boxX = x2 - padding[3];\n    var boxY = y2 - padding[0];\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n    var transform2;\n    if (rotation !== 0) {\n      transform2 = compose(create$6(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      apply$5(transform2, p1);\n      apply$5(transform2, p2);\n      apply$5(transform2, p3);\n      apply$5(transform2, p4);\n      createOrUpdate$2(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      createOrUpdate$2(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n    }\n    if (snapToPixel) {\n      x2 = Math.round(x2);\n      y2 = Math.round(y2);\n    }\n    return {\n      drawImageX: x2,\n      drawImageY: y2,\n      drawImageW: w2,\n      drawImageH: h2,\n      originX,\n      originY,\n      declutterBox: {\n        minX: tmpExtent[0],\n        minY: tmpExtent[1],\n        maxX: tmpExtent[2],\n        maxY: tmpExtent[3],\n        value: feature2\n      },\n      canvasTransform: transform2,\n      scale: scale2\n    };\n  };\n  Executor2.prototype.replayImageOrLabel_ = function(context, contextScale, imageOrLabel, dimensions, opacity2, fillInstruction2, strokeInstruction2) {\n    var fillStroke = !!(fillInstruction2 || strokeInstruction2);\n    var box = dimensions.declutterBox;\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;\n    var intersects2 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;\n    if (intersects2) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4, fillInstruction2, strokeInstruction2);\n      }\n      drawImageOrLabel(context, dimensions.canvasTransform, opacity2, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n    }\n    return true;\n  };\n  Executor2.prototype.fill_ = function(context) {\n    if (this.alignFill_) {\n      var origin_1 = apply$5(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.restore();\n    }\n  };\n  Executor2.prototype.setStrokeStyle_ = function(context, instruction) {\n    context[\"strokeStyle\"] = instruction[1];\n    context.lineWidth = instruction[2];\n    context.lineCap = instruction[3];\n    context.lineJoin = instruction[4];\n    context.miterLimit = instruction[5];\n    if (context.setLineDash) {\n      context.lineDashOffset = instruction[7];\n      context.setLineDash(instruction[6]);\n    }\n  };\n  Executor2.prototype.drawLabelWithPointPlacement_ = function(text2, textKey, strokeKey, fillKey) {\n    var textState = this.textStates[textKey];\n    var label = this.createLabel(text2, textKey, fillKey, strokeKey);\n    var strokeState = this.strokeStates[strokeKey];\n    var pixelRatio = this.pixelRatio;\n    var align = horizontalTextAlign(Array.isArray(text2) ? text2[0] : text2, textState.textAlign || defaultTextAlign);\n    var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var width = label.width / pixelRatio - 2 * textState.scale[0];\n    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label,\n      anchorX,\n      anchorY\n    };\n  };\n  Executor2.prototype.execute_ = function(context, contextScale, transform2, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {\n    var pixelCoordinates;\n    if (this.pixelCoordinates_ && equals$2(transform2, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform2, this.pixelCoordinates_);\n      setFromArray(this.renderedTransform_, transform2);\n    }\n    var i2 = 0;\n    var ii = instructions.length;\n    var d2 = 0;\n    var dd;\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, image2, text2, textKey, strokeKey, fillKey;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;\n    var state = {\n      context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    };\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var feature2;\n    var x2, y2, currentGeometry;\n    while (i2 < ii) {\n      var instruction = instructions[i2];\n      var type = instruction[0];\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature2 = instruction[1];\n          currentGeometry = instruction[3];\n          if (!feature2.getGeometry()) {\n            i2 = instruction[2];\n          } else if (opt_hitExtent !== void 0 && !intersects$1(opt_hitExtent, currentGeometry.getExtent())) {\n            i2 = instruction[2] + 1;\n          } else {\n            ++i2;\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n          ++i2;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d2 = instruction[1];\n          var x1 = pixelCoordinates[d2];\n          var y1 = pixelCoordinates[d2 + 1];\n          var x22 = pixelCoordinates[d2 + 2];\n          var y22 = pixelCoordinates[d2 + 3];\n          var dx = x22 - x1;\n          var dy = y22 - y1;\n          var r2 = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r2, y1);\n          context.arc(x1, y1, r2, 0, 2 * Math.PI, true);\n          ++i2;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i2;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d2 = instruction[1];\n          dd = instruction[2];\n          var geometry = instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : void 0;\n          state.geometry = geometry;\n          state.feature = feature2;\n          if (!(i2 in coordinateCache)) {\n            coordinateCache[i2] = [];\n          }\n          var coords = coordinateCache[i2];\n          if (fn) {\n            fn(pixelCoordinates, d2, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d2];\n            coords[1] = pixelCoordinates[d2 + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i2;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d2 = instruction[1];\n          dd = instruction[2];\n          image2 = instruction[3];\n          anchorX = instruction[4];\n          anchorY = instruction[5];\n          var height = instruction[6];\n          var opacity2 = instruction[7];\n          var originX = instruction[8];\n          var originY = instruction[9];\n          var rotateWithView = instruction[10];\n          var rotation = instruction[11];\n          var scale2 = instruction[12];\n          var width = instruction[13];\n          var declutterImageWithText = instruction[14];\n          if (!image2 && instruction.length >= 19) {\n            text2 = instruction[18];\n            textKey = instruction[19];\n            strokeKey = instruction[20];\n            fillKey = instruction[21];\n            var labelWithAnchor = this.drawLabelWithPointPlacement_(text2, textKey, strokeKey, fillKey);\n            image2 = labelWithAnchor.label;\n            instruction[3] = image2;\n            var textOffsetX = instruction[22];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            var textOffsetY = instruction[23];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image2.height;\n            instruction[6] = height;\n            width = image2.width;\n            instruction[13] = width;\n          }\n          var geometryWidths = void 0;\n          if (instruction.length > 24) {\n            geometryWidths = instruction[24];\n          }\n          var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;\n          if (instruction.length > 16) {\n            padding = instruction[15];\n            backgroundFill = instruction[16];\n            backgroundStroke = instruction[17];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n          if (rotateWithView && viewRotationFromTransform) {\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            rotation -= viewRotation;\n          }\n          var widthIndex = 0;\n          for (; d2 < dd; d2 += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n            var dimensions = this.calculateImageOrLabelDimensions_(image2.width, image2.height, pixelCoordinates[d2], pixelCoordinates[d2 + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, backgroundFill || backgroundStroke, feature2);\n            var args = [\n              context,\n              contextScale,\n              image2,\n              dimensions,\n              opacity2,\n              backgroundFill ? lastFillInstruction : null,\n              backgroundStroke ? lastStrokeInstruction : null\n            ];\n            var imageArgs = void 0;\n            var imageDeclutterBox = void 0;\n            if (opt_declutterTree && declutterImageWithText) {\n              var index2 = dd - d2;\n              if (!declutterImageWithText[index2]) {\n                declutterImageWithText[index2] = args;\n                continue;\n              }\n              imageArgs = declutterImageWithText[index2];\n              delete declutterImageWithText[index2];\n              imageDeclutterBox = getDeclutterBox(imageArgs);\n              if (opt_declutterTree.collides(imageDeclutterBox)) {\n                continue;\n              }\n            }\n            if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n              continue;\n            }\n            if (imageArgs) {\n              if (opt_declutterTree) {\n                opt_declutterTree.insert(imageDeclutterBox);\n              }\n              this.replayImageOrLabel_.apply(this, imageArgs);\n            }\n            if (opt_declutterTree) {\n              opt_declutterTree.insert(dimensions.declutterBox);\n            }\n            this.replayImageOrLabel_.apply(this, args);\n          }\n          ++i2;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          var begin = instruction[1];\n          var end = instruction[2];\n          var baseline = instruction[3];\n          var overflow2 = instruction[4];\n          fillKey = instruction[5];\n          var maxAngle = instruction[6];\n          var measurePixelRatio = instruction[7];\n          var offsetY = instruction[8];\n          strokeKey = instruction[9];\n          var strokeWidth = instruction[10];\n          text2 = instruction[11];\n          textKey = instruction[12];\n          var pixelRatioScale = [\n            instruction[13],\n            instruction[13]\n          ];\n          var textState = this.textStates[textKey];\n          var font = textState.font;\n          var textScale = [\n            textState.scale[0] * measurePixelRatio,\n            textState.scale[1] * measurePixelRatio\n          ];\n          var cachedWidths = void 0;\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text2, cachedWidths);\n          if (overflow2 || textLength <= pathLength) {\n            var textAlign2 = this.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign2];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text2, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n            drawChars:\n              if (parts) {\n                var replayImageOrLabelArgs = [];\n                var c2 = void 0, cc = void 0, chars2 = void 0, label = void 0, part = void 0;\n                if (strokeKey) {\n                  for (c2 = 0, cc = parts.length; c2 < cc; ++c2) {\n                    part = parts[c2];\n                    chars2 = part[4];\n                    label = this.createLabel(chars2, textKey, \"\", strokeKey);\n                    anchorX = part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                    anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature2);\n                    if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n                      break drawChars;\n                    }\n                    replayImageOrLabelArgs.push([\n                      context,\n                      contextScale,\n                      label,\n                      dimensions,\n                      1,\n                      null,\n                      null\n                    ]);\n                  }\n                }\n                if (fillKey) {\n                  for (c2 = 0, cc = parts.length; c2 < cc; ++c2) {\n                    part = parts[c2];\n                    chars2 = part[4];\n                    label = this.createLabel(chars2, textKey, fillKey, \"\");\n                    anchorX = part[2];\n                    anchorY = baseline * label.height - offsetY;\n                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature2);\n                    if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n                      break drawChars;\n                    }\n                    replayImageOrLabelArgs.push([\n                      context,\n                      contextScale,\n                      label,\n                      dimensions,\n                      1,\n                      null,\n                      null\n                    ]);\n                  }\n                }\n                if (opt_declutterTree) {\n                  opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n                }\n                for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {\n                  this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);\n                }\n              }\n          }\n          ++i2;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (opt_featureCallback !== void 0) {\n            feature2 = instruction[1];\n            var result = opt_featureCallback(feature2, currentGeometry);\n            if (result) {\n              return result;\n            }\n          }\n          ++i2;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i2;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d2 = instruction[1];\n          dd = instruction[2];\n          x2 = pixelCoordinates[d2];\n          y2 = pixelCoordinates[d2 + 1];\n          roundX = x2 + 0.5 | 0;\n          roundY = y2 + 0.5 | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x2, y2);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d2 += 2; d2 < dd; d2 += 2) {\n            x2 = pixelCoordinates[d2];\n            y2 = pixelCoordinates[d2 + 1];\n            roundX = x2 + 0.5 | 0;\n            roundY = y2 + 0.5 | 0;\n            if (d2 == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x2, y2);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i2;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n          context.fillStyle = instruction[1];\n          ++i2;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, instruction);\n          ++i2;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i2;\n          break;\n        default:\n          ++i2;\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return void 0;\n  };\n  Executor2.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, contextScale, transform2, this.instructions, snapToPixel, void 0, void 0, opt_declutterTree);\n  };\n  Executor2.prototype.executeHitDetection = function(context, transform2, viewRotation, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, 1, transform2, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n  return Executor2;\n}();\nvar Executor$1 = Executor;\nvar ORDER = [\n  ReplayType.POLYGON,\n  ReplayType.CIRCLE,\n  ReplayType.LINE_STRING,\n  ReplayType.IMAGE,\n  ReplayType.TEXT,\n  ReplayType.DEFAULT\n];\nvar ExecutorGroup = function() {\n  function ExecutorGroup2(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {\n    this.maxExtent_ = maxExtent;\n    this.overlaps_ = overlaps;\n    this.pixelRatio_ = pixelRatio;\n    this.resolution_ = resolution;\n    this.renderBuffer_ = opt_renderBuffer;\n    this.executorsByZIndex_ = {};\n    this.hitDetectionContext_ = null;\n    this.hitDetectionTransform_ = create$6();\n    this.createExecutors_(allInstructions);\n  }\n  ExecutorGroup2.prototype.clip = function(context, transform2) {\n    var flatClipCoords = this.getClipCoords(transform2);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  ExecutorGroup2.prototype.createExecutors_ = function(allInstructions) {\n    for (var zIndex2 in allInstructions) {\n      var executors = this.executorsByZIndex_[zIndex2];\n      if (executors === void 0) {\n        executors = {};\n        this.executorsByZIndex_[zIndex2] = executors;\n      }\n      var instructionByZindex = allInstructions[zIndex2];\n      for (var builderType in instructionByZindex) {\n        var instructions = instructionByZindex[builderType];\n        executors[builderType] = new Executor$1(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);\n      }\n    }\n  };\n  ExecutorGroup2.prototype.hasExecutors = function(executors) {\n    for (var zIndex2 in this.executorsByZIndex_) {\n      var candidates = this.executorsByZIndex_[zIndex2];\n      for (var i2 = 0, ii = executors.length; i2 < ii; ++i2) {\n        if (executors[i2] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  ExecutorGroup2.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform2 = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    var newContext = !this.hitDetectionContext_;\n    if (newContext) {\n      this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);\n    }\n    var context = this.hitDetectionContext_;\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else if (!newContext) {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    var hitExtent;\n    if (this.renderBuffer_ !== void 0) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer$1(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n    var indexes = getPixelIndexArray(hitTolerance);\n    var builderType;\n    function featureCallback(feature2, geometry) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {\n        if (imageData[indexes[i_1]] > 0) {\n          if (!declutteredFeatures || builderType !== ReplayType.IMAGE && builderType !== ReplayType.TEXT || declutteredFeatures.indexOf(feature2) !== -1) {\n            var idx = (indexes[i_1] - 3) / 4;\n            var x2 = hitTolerance - idx % contextSize;\n            var y2 = hitTolerance - (idx / contextSize | 0);\n            var result_1 = callback(feature2, geometry, x2 * x2 + y2 * y2);\n            if (result_1) {\n              return result_1;\n            }\n          }\n          context.clearRect(0, 0, contextSize, contextSize);\n          break;\n        }\n      }\n      return void 0;\n    }\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var i2, j2, executors, executor, result;\n    for (i2 = zs.length - 1; i2 >= 0; --i2) {\n      var zIndexKey = zs[i2].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j2 = ORDER.length - 1; j2 >= 0; --j2) {\n        builderType = ORDER[j2];\n        executor = executors[builderType];\n        if (executor !== void 0) {\n          result = executor.executeHitDetection(context, transform2, rotation, featureCallback, hitExtent);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return void 0;\n  };\n  ExecutorGroup2.prototype.getClipCoords = function(transform2) {\n    var maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);\n    return flatClipCoords;\n  };\n  ExecutorGroup2.prototype.isEmpty = function() {\n    return isEmpty(this.executorsByZIndex_);\n  };\n  ExecutorGroup2.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    if (this.maxExtent_) {\n      context.save();\n      this.clip(context, transform2);\n    }\n    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n    var i2, ii, j2, jj, replays, replay;\n    if (opt_declutterTree) {\n      zs.reverse();\n    }\n    for (i2 = 0, ii = zs.length; i2 < ii; ++i2) {\n      var zIndexKey = zs[i2].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j2 = 0, jj = builderTypes.length; j2 < jj; ++j2) {\n        var builderType = builderTypes[j2];\n        replay = replays[builderType];\n        if (replay !== void 0) {\n          replay.execute(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree);\n        }\n      }\n    }\n    if (this.maxExtent_) {\n      context.restore();\n    }\n  };\n  return ExecutorGroup2;\n}();\nvar circlePixelIndexArrayCache = {};\nfunction getPixelIndexArray(radius) {\n  if (circlePixelIndexArrayCache[radius] !== void 0) {\n    return circlePixelIndexArrayCache[radius];\n  }\n  var size = radius * 2 + 1;\n  var maxDistanceSq = radius * radius;\n  var distances = new Array(maxDistanceSq + 1);\n  for (var i2 = 0; i2 <= radius; ++i2) {\n    for (var j2 = 0; j2 <= radius; ++j2) {\n      var distanceSq = i2 * i2 + j2 * j2;\n      if (distanceSq > maxDistanceSq) {\n        break;\n      }\n      var distance2 = distances[distanceSq];\n      if (!distance2) {\n        distance2 = [];\n        distances[distanceSq] = distance2;\n      }\n      distance2.push(((radius + i2) * size + (radius + j2)) * 4 + 3);\n      if (i2 > 0) {\n        distance2.push(((radius - i2) * size + (radius + j2)) * 4 + 3);\n      }\n      if (j2 > 0) {\n        distance2.push(((radius + i2) * size + (radius - j2)) * 4 + 3);\n        if (i2 > 0) {\n          distance2.push(((radius - i2) * size + (radius - j2)) * 4 + 3);\n        }\n      }\n    }\n  }\n  var pixelIndex = [];\n  for (var i2 = 0, ii = distances.length; i2 < ii; ++i2) {\n    if (distances[i2]) {\n      pixelIndex.push.apply(pixelIndex, distances[i2]);\n    }\n  }\n  circlePixelIndexArrayCache[radius] = pixelIndex;\n  return pixelIndex;\n}\nvar CanvasExecutorGroup = ExecutorGroup;\nvar __extends$1d = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CanvasImmediateRenderer = function(_super) {\n  __extends$1d(CanvasImmediateRenderer2, _super);\n  function CanvasImmediateRenderer2(context, pixelRatio, extent2, transform2, viewRotation, opt_squaredTolerance, opt_userTransform) {\n    var _this = _super.call(this) || this;\n    _this.context_ = context;\n    _this.pixelRatio_ = pixelRatio;\n    _this.extent_ = extent2;\n    _this.transform_ = transform2;\n    _this.viewRotation_ = viewRotation;\n    _this.squaredTolerance_ = opt_squaredTolerance;\n    _this.userTransform_ = opt_userTransform;\n    _this.contextFillState_ = null;\n    _this.contextStrokeState_ = null;\n    _this.contextTextState_ = null;\n    _this.fillState_ = null;\n    _this.strokeState_ = null;\n    _this.image_ = null;\n    _this.imageAnchorX_ = 0;\n    _this.imageAnchorY_ = 0;\n    _this.imageHeight_ = 0;\n    _this.imageOpacity_ = 0;\n    _this.imageOriginX_ = 0;\n    _this.imageOriginY_ = 0;\n    _this.imageRotateWithView_ = false;\n    _this.imageRotation_ = 0;\n    _this.imageScale_ = [0, 0];\n    _this.imageWidth_ = 0;\n    _this.text_ = \"\";\n    _this.textOffsetX_ = 0;\n    _this.textOffsetY_ = 0;\n    _this.textRotateWithView_ = false;\n    _this.textRotation_ = 0;\n    _this.textScale_ = [0, 0];\n    _this.textFillState_ = null;\n    _this.textStrokeState_ = null;\n    _this.textState_ = null;\n    _this.pixelCoordinates_ = [];\n    _this.tmpLocalTransform_ = create$6();\n    return _this;\n  }\n  CanvasImmediateRenderer2.prototype.drawImages_ = function(flatCoordinates, offset2, end, stride) {\n    if (!this.image_) {\n      return;\n    }\n    var pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);\n    var context = this.context_;\n    var localTransform = this.tmpLocalTransform_;\n    var alpha = context.globalAlpha;\n    if (this.imageOpacity_ != 1) {\n      context.globalAlpha = alpha * this.imageOpacity_;\n    }\n    var rotation = this.imageRotation_;\n    if (this.imageRotateWithView_) {\n      rotation += this.viewRotation_;\n    }\n    for (var i2 = 0, ii = pixelCoordinates.length; i2 < ii; i2 += 2) {\n      var x2 = pixelCoordinates[i2] - this.imageAnchorX_;\n      var y2 = pixelCoordinates[i2 + 1] - this.imageAnchorY_;\n      if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {\n        var centerX = x2 + this.imageAnchorX_;\n        var centerY = y2 + this.imageAnchorY_;\n        compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n        context.setTransform.apply(context, localTransform);\n        context.translate(centerX, centerY);\n        context.scale(this.imageScale_[0], this.imageScale_[1]);\n        context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);\n        context.setTransform(1, 0, 0, 1, 0, 0);\n      } else {\n        context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x2, y2, this.imageWidth_, this.imageHeight_);\n      }\n    }\n    if (this.imageOpacity_ != 1) {\n      context.globalAlpha = alpha;\n    }\n  };\n  CanvasImmediateRenderer2.prototype.drawText_ = function(flatCoordinates, offset2, end, stride) {\n    if (!this.textState_ || this.text_ === \"\") {\n      return;\n    }\n    if (this.textFillState_) {\n      this.setContextFillState_(this.textFillState_);\n    }\n    if (this.textStrokeState_) {\n      this.setContextStrokeState_(this.textStrokeState_);\n    }\n    this.setContextTextState_(this.textState_);\n    var pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);\n    var context = this.context_;\n    var rotation = this.textRotation_;\n    if (this.textRotateWithView_) {\n      rotation += this.viewRotation_;\n    }\n    for (; offset2 < end; offset2 += stride) {\n      var x2 = pixelCoordinates[offset2] + this.textOffsetX_;\n      var y2 = pixelCoordinates[offset2 + 1] + this.textOffsetY_;\n      if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {\n        var localTransform = compose(this.tmpLocalTransform_, x2, y2, 1, 1, rotation, -x2, -y2);\n        context.setTransform.apply(context, localTransform);\n        context.translate(x2, y2);\n        context.scale(this.textScale_[0], this.textScale_[1]);\n        if (this.textStrokeState_) {\n          context.strokeText(this.text_, 0, 0);\n        }\n        if (this.textFillState_) {\n          context.fillText(this.text_, 0, 0);\n        }\n        context.setTransform(1, 0, 0, 1, 0, 0);\n      } else {\n        if (this.textStrokeState_) {\n          context.strokeText(this.text_, x2, y2);\n        }\n        if (this.textFillState_) {\n          context.fillText(this.text_, x2, y2);\n        }\n      }\n    }\n  };\n  CanvasImmediateRenderer2.prototype.moveToLineTo_ = function(flatCoordinates, offset2, end, stride, close) {\n    var context = this.context_;\n    var pixelCoordinates = transform2D(flatCoordinates, offset2, end, stride, this.transform_, this.pixelCoordinates_);\n    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);\n    var length = pixelCoordinates.length;\n    if (close) {\n      length -= 2;\n    }\n    for (var i2 = 2; i2 < length; i2 += 2) {\n      context.lineTo(pixelCoordinates[i2], pixelCoordinates[i2 + 1]);\n    }\n    if (close) {\n      context.closePath();\n    }\n    return end;\n  };\n  CanvasImmediateRenderer2.prototype.drawRings_ = function(flatCoordinates, offset2, ends, stride) {\n    for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n      offset2 = this.moveToLineTo_(flatCoordinates, offset2, ends[i2], stride, true);\n    }\n    return offset2;\n  };\n  CanvasImmediateRenderer2.prototype.drawCircle = function(geometry) {\n    if (!intersects$1(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    if (this.fillState_ || this.strokeState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n      var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);\n      var dx = pixelCoordinates[2] - pixelCoordinates[0];\n      var dy = pixelCoordinates[3] - pixelCoordinates[1];\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      var context = this.context_;\n      context.beginPath();\n      context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);\n      if (this.fillState_) {\n        context.fill();\n      }\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n    if (this.text_ !== \"\") {\n      this.drawText_(geometry.getCenter(), 0, 2, 2);\n    }\n  };\n  CanvasImmediateRenderer2.prototype.setStyle = function(style2) {\n    this.setFillStrokeStyle(style2.getFill(), style2.getStroke());\n    this.setImageStyle(style2.getImage());\n    this.setTextStyle(style2.getText());\n  };\n  CanvasImmediateRenderer2.prototype.setTransform = function(transform2) {\n    this.transform_ = transform2;\n  };\n  CanvasImmediateRenderer2.prototype.drawGeometry = function(geometry) {\n    var type = geometry.getType();\n    switch (type) {\n      case GeometryType.POINT:\n        this.drawPoint(geometry);\n        break;\n      case GeometryType.LINE_STRING:\n        this.drawLineString(geometry);\n        break;\n      case GeometryType.POLYGON:\n        this.drawPolygon(geometry);\n        break;\n      case GeometryType.MULTI_POINT:\n        this.drawMultiPoint(geometry);\n        break;\n      case GeometryType.MULTI_LINE_STRING:\n        this.drawMultiLineString(geometry);\n        break;\n      case GeometryType.MULTI_POLYGON:\n        this.drawMultiPolygon(geometry);\n        break;\n      case GeometryType.GEOMETRY_COLLECTION:\n        this.drawGeometryCollection(geometry);\n        break;\n      case GeometryType.CIRCLE:\n        this.drawCircle(geometry);\n        break;\n    }\n  };\n  CanvasImmediateRenderer2.prototype.drawFeature = function(feature2, style2) {\n    var geometry = style2.getGeometryFunction()(feature2);\n    if (!geometry || !intersects$1(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    this.setStyle(style2);\n    this.drawGeometry(geometry);\n  };\n  CanvasImmediateRenderer2.prototype.drawGeometryCollection = function(geometry) {\n    var geometries = geometry.getGeometriesArray();\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      this.drawGeometry(geometries[i2]);\n    }\n  };\n  CanvasImmediateRenderer2.prototype.drawPoint = function(geometry) {\n    if (this.squaredTolerance_) {\n      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n    }\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n    if (this.image_) {\n      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n    if (this.text_ !== \"\") {\n      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n  };\n  CanvasImmediateRenderer2.prototype.drawMultiPoint = function(geometry) {\n    if (this.squaredTolerance_) {\n      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n    }\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n    if (this.image_) {\n      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n    if (this.text_ !== \"\") {\n      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n  };\n  CanvasImmediateRenderer2.prototype.drawLineString = function(geometry) {\n    if (this.squaredTolerance_) {\n      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n    }\n    if (!intersects$1(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    if (this.strokeState_) {\n      this.setContextStrokeState_(this.strokeState_);\n      var context = this.context_;\n      var flatCoordinates = geometry.getFlatCoordinates();\n      context.beginPath();\n      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);\n      context.stroke();\n    }\n    if (this.text_ !== \"\") {\n      var flatMidpoint = geometry.getFlatMidpoint();\n      this.drawText_(flatMidpoint, 0, 2, 2);\n    }\n  };\n  CanvasImmediateRenderer2.prototype.drawMultiLineString = function(geometry) {\n    if (this.squaredTolerance_) {\n      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n    }\n    var geometryExtent = geometry.getExtent();\n    if (!intersects$1(this.extent_, geometryExtent)) {\n      return;\n    }\n    if (this.strokeState_) {\n      this.setContextStrokeState_(this.strokeState_);\n      var context = this.context_;\n      var flatCoordinates = geometry.getFlatCoordinates();\n      var offset2 = 0;\n      var ends = geometry.getEnds();\n      var stride = geometry.getStride();\n      context.beginPath();\n      for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n        offset2 = this.moveToLineTo_(flatCoordinates, offset2, ends[i2], stride, false);\n      }\n      context.stroke();\n    }\n    if (this.text_ !== \"\") {\n      var flatMidpoints = geometry.getFlatMidpoints();\n      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);\n    }\n  };\n  CanvasImmediateRenderer2.prototype.drawPolygon = function(geometry) {\n    if (this.squaredTolerance_) {\n      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n    }\n    if (!intersects$1(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    if (this.strokeState_ || this.fillState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n      var context = this.context_;\n      context.beginPath();\n      this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());\n      if (this.fillState_) {\n        context.fill();\n      }\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n    if (this.text_ !== \"\") {\n      var flatInteriorPoint = geometry.getFlatInteriorPoint();\n      this.drawText_(flatInteriorPoint, 0, 2, 2);\n    }\n  };\n  CanvasImmediateRenderer2.prototype.drawMultiPolygon = function(geometry) {\n    if (this.squaredTolerance_) {\n      geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);\n    }\n    if (!intersects$1(this.extent_, geometry.getExtent())) {\n      return;\n    }\n    if (this.strokeState_ || this.fillState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n      var context = this.context_;\n      var flatCoordinates = geometry.getOrientedFlatCoordinates();\n      var offset2 = 0;\n      var endss = geometry.getEndss();\n      var stride = geometry.getStride();\n      context.beginPath();\n      for (var i2 = 0, ii = endss.length; i2 < ii; ++i2) {\n        var ends = endss[i2];\n        offset2 = this.drawRings_(flatCoordinates, offset2, ends, stride);\n      }\n      if (this.fillState_) {\n        context.fill();\n      }\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n    if (this.text_ !== \"\") {\n      var flatInteriorPoints = geometry.getFlatInteriorPoints();\n      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);\n    }\n  };\n  CanvasImmediateRenderer2.prototype.setContextFillState_ = function(fillState) {\n    var context = this.context_;\n    var contextFillState = this.contextFillState_;\n    if (!contextFillState) {\n      context.fillStyle = fillState.fillStyle;\n      this.contextFillState_ = {\n        fillStyle: fillState.fillStyle\n      };\n    } else {\n      if (contextFillState.fillStyle != fillState.fillStyle) {\n        contextFillState.fillStyle = fillState.fillStyle;\n        context.fillStyle = fillState.fillStyle;\n      }\n    }\n  };\n  CanvasImmediateRenderer2.prototype.setContextStrokeState_ = function(strokeState) {\n    var context = this.context_;\n    var contextStrokeState = this.contextStrokeState_;\n    if (!contextStrokeState) {\n      context.lineCap = strokeState.lineCap;\n      if (context.setLineDash) {\n        context.setLineDash(strokeState.lineDash);\n        context.lineDashOffset = strokeState.lineDashOffset;\n      }\n      context.lineJoin = strokeState.lineJoin;\n      context.lineWidth = strokeState.lineWidth;\n      context.miterLimit = strokeState.miterLimit;\n      context.strokeStyle = strokeState.strokeStyle;\n      this.contextStrokeState_ = {\n        lineCap: strokeState.lineCap,\n        lineDash: strokeState.lineDash,\n        lineDashOffset: strokeState.lineDashOffset,\n        lineJoin: strokeState.lineJoin,\n        lineWidth: strokeState.lineWidth,\n        miterLimit: strokeState.miterLimit,\n        strokeStyle: strokeState.strokeStyle\n      };\n    } else {\n      if (contextStrokeState.lineCap != strokeState.lineCap) {\n        contextStrokeState.lineCap = strokeState.lineCap;\n        context.lineCap = strokeState.lineCap;\n      }\n      if (context.setLineDash) {\n        if (!equals$2(contextStrokeState.lineDash, strokeState.lineDash)) {\n          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);\n        }\n        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {\n          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;\n          context.lineDashOffset = strokeState.lineDashOffset;\n        }\n      }\n      if (contextStrokeState.lineJoin != strokeState.lineJoin) {\n        contextStrokeState.lineJoin = strokeState.lineJoin;\n        context.lineJoin = strokeState.lineJoin;\n      }\n      if (contextStrokeState.lineWidth != strokeState.lineWidth) {\n        contextStrokeState.lineWidth = strokeState.lineWidth;\n        context.lineWidth = strokeState.lineWidth;\n      }\n      if (contextStrokeState.miterLimit != strokeState.miterLimit) {\n        contextStrokeState.miterLimit = strokeState.miterLimit;\n        context.miterLimit = strokeState.miterLimit;\n      }\n      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {\n        contextStrokeState.strokeStyle = strokeState.strokeStyle;\n        context.strokeStyle = strokeState.strokeStyle;\n      }\n    }\n  };\n  CanvasImmediateRenderer2.prototype.setContextTextState_ = function(textState) {\n    var context = this.context_;\n    var contextTextState = this.contextTextState_;\n    var textAlign2 = textState.textAlign ? textState.textAlign : defaultTextAlign;\n    if (!contextTextState) {\n      context.font = textState.font;\n      context.textAlign = textAlign2;\n      context.textBaseline = textState.textBaseline;\n      this.contextTextState_ = {\n        font: textState.font,\n        textAlign: textAlign2,\n        textBaseline: textState.textBaseline\n      };\n    } else {\n      if (contextTextState.font != textState.font) {\n        contextTextState.font = textState.font;\n        context.font = textState.font;\n      }\n      if (contextTextState.textAlign != textAlign2) {\n        contextTextState.textAlign = textAlign2;\n        context.textAlign = textAlign2;\n      }\n      if (contextTextState.textBaseline != textState.textBaseline) {\n        contextTextState.textBaseline = textState.textBaseline;\n        context.textBaseline = textState.textBaseline;\n      }\n    }\n  };\n  CanvasImmediateRenderer2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n    var _this = this;\n    if (!fillStyle) {\n      this.fillState_ = null;\n    } else {\n      var fillStyleColor = fillStyle.getColor();\n      this.fillState_ = {\n        fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)\n      };\n    }\n    if (!strokeStyle) {\n      this.strokeState_ = null;\n    } else {\n      var strokeStyleColor = strokeStyle.getColor();\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      var strokeStyleWidth = strokeStyle.getWidth();\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      var lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;\n      this.strokeState_ = {\n        lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,\n        lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function(n2) {\n          return n2 * _this.pixelRatio_;\n        }),\n        lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,\n        lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,\n        lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,\n        miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,\n        strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)\n      };\n    }\n  };\n  CanvasImmediateRenderer2.prototype.setImageStyle = function(imageStyle) {\n    var imageSize;\n    if (!imageStyle || !(imageSize = imageStyle.getSize())) {\n      this.image_ = null;\n      return;\n    }\n    var imageAnchor = imageStyle.getAnchor();\n    var imageOrigin = imageStyle.getOrigin();\n    this.image_ = imageStyle.getImage(this.pixelRatio_);\n    this.imageAnchorX_ = imageAnchor[0] * this.pixelRatio_;\n    this.imageAnchorY_ = imageAnchor[1] * this.pixelRatio_;\n    this.imageHeight_ = imageSize[1] * this.pixelRatio_;\n    this.imageOpacity_ = imageStyle.getOpacity();\n    this.imageOriginX_ = imageOrigin[0];\n    this.imageOriginY_ = imageOrigin[1];\n    this.imageRotateWithView_ = imageStyle.getRotateWithView();\n    this.imageRotation_ = imageStyle.getRotation();\n    this.imageScale_ = imageStyle.getScaleArray();\n    this.imageWidth_ = imageSize[0] * this.pixelRatio_;\n  };\n  CanvasImmediateRenderer2.prototype.setTextStyle = function(textStyle) {\n    if (!textStyle) {\n      this.text_ = \"\";\n    } else {\n      var textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        this.textFillState_ = null;\n      } else {\n        var textFillStyleColor = textFillStyle.getColor();\n        this.textFillState_ = {\n          fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)\n        };\n      }\n      var textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        this.textStrokeState_ = null;\n      } else {\n        var textStrokeStyleColor = textStrokeStyle.getColor();\n        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();\n        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();\n        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();\n        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();\n        var textStrokeStyleWidth = textStrokeStyle.getWidth();\n        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();\n        this.textStrokeState_ = {\n          lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,\n          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,\n          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,\n          lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,\n          lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,\n          miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,\n          strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)\n        };\n      }\n      var textFont = textStyle.getFont();\n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      var textScale = textStyle.getScaleArray();\n      var textText = textStyle.getText();\n      var textTextAlign = textStyle.getTextAlign();\n      var textTextBaseline = textStyle.getTextBaseline();\n      this.textState_ = {\n        font: textFont !== void 0 ? textFont : defaultFont,\n        textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,\n        textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline\n      };\n      this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce(function(acc, t3, i2) {\n        return acc += i2 % 2 ? \" \" : t3;\n      }, \"\") : textText : \"\";\n      this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;\n      this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;\n      this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;\n      this.textRotation_ = textRotation !== void 0 ? textRotation : 0;\n      this.textScale_ = [\n        this.pixelRatio_ * textScale[0],\n        this.pixelRatio_ * textScale[1]\n      ];\n    }\n  };\n  return CanvasImmediateRenderer2;\n}(VectorContext$1);\nvar CanvasImmediateRenderer$1 = CanvasImmediateRenderer;\nvar IconAnchorUnits = {\n  FRACTION: \"fraction\",\n  PIXELS: \"pixels\"\n};\nvar IconOrigin = {\n  BOTTOM_LEFT: \"bottom-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  TOP_LEFT: \"top-left\",\n  TOP_RIGHT: \"top-right\"\n};\nvar __extends$1c = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ImageBase = function(_super) {\n  __extends$1c(ImageBase2, _super);\n  function ImageBase2(extent2, resolution, pixelRatio, state) {\n    var _this = _super.call(this) || this;\n    _this.extent = extent2;\n    _this.pixelRatio_ = pixelRatio;\n    _this.resolution = resolution;\n    _this.state = state;\n    return _this;\n  }\n  ImageBase2.prototype.changed = function() {\n    this.dispatchEvent(EventType.CHANGE);\n  };\n  ImageBase2.prototype.getExtent = function() {\n    return this.extent;\n  };\n  ImageBase2.prototype.getImage = function() {\n    return abstract();\n  };\n  ImageBase2.prototype.getPixelRatio = function() {\n    return this.pixelRatio_;\n  };\n  ImageBase2.prototype.getResolution = function() {\n    return this.resolution;\n  };\n  ImageBase2.prototype.getState = function() {\n    return this.state;\n  };\n  ImageBase2.prototype.load = function() {\n    abstract();\n  };\n  return ImageBase2;\n}(EventTarget);\nvar ImageBase$1 = ImageBase;\nvar __extends$1b = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ImageWrapper = function(_super) {\n  __extends$1b(ImageWrapper2, _super);\n  function ImageWrapper2(extent2, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {\n    var _this = _super.call(this, extent2, resolution, pixelRatio, ImageState.IDLE) || this;\n    _this.src_ = src;\n    _this.image_ = new Image();\n    if (crossOrigin !== null) {\n      _this.image_.crossOrigin = crossOrigin;\n    }\n    _this.unlisten_ = null;\n    _this.state = ImageState.IDLE;\n    _this.imageLoadFunction_ = imageLoadFunction;\n    return _this;\n  }\n  ImageWrapper2.prototype.getImage = function() {\n    return this.image_;\n  };\n  ImageWrapper2.prototype.handleImageError_ = function() {\n    this.state = ImageState.ERROR;\n    this.unlistenImage_();\n    this.changed();\n  };\n  ImageWrapper2.prototype.handleImageLoad_ = function() {\n    if (this.resolution === void 0) {\n      this.resolution = getHeight(this.extent) / this.image_.height;\n    }\n    this.state = ImageState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  };\n  ImageWrapper2.prototype.load = function() {\n    if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      this.imageLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));\n    }\n  };\n  ImageWrapper2.prototype.setImage = function(image2) {\n    this.image_ = image2;\n    this.resolution = getHeight(this.extent) / this.image_.height;\n  };\n  ImageWrapper2.prototype.unlistenImage_ = function() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  };\n  return ImageWrapper2;\n}(ImageBase$1);\nfunction listenImage(image2, loadHandler, errorHandler) {\n  var img = image2;\n  var listening = true;\n  var decoding = false;\n  var loaded = false;\n  var listenerKeys = [\n    listenOnce(img, EventType.LOAD, function() {\n      loaded = true;\n      if (!decoding) {\n        loadHandler();\n      }\n    })\n  ];\n  if (img.src && IMAGE_DECODE) {\n    decoding = true;\n    img.decode().then(function() {\n      if (listening) {\n        loadHandler();\n      }\n    }).catch(function(error) {\n      if (listening) {\n        if (loaded) {\n          loadHandler();\n        } else {\n          errorHandler();\n        }\n      }\n    });\n  } else {\n    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));\n  }\n  return function unlisten() {\n    listening = false;\n    listenerKeys.forEach(unlistenByKey);\n  };\n}\nvar ImageWrapper$1 = ImageWrapper;\nvar __extends$1a = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar taintedTestContext = null;\nvar IconImage = function(_super) {\n  __extends$1a(IconImage2, _super);\n  function IconImage2(image2, src, size, crossOrigin, imageState, color2) {\n    var _this = _super.call(this) || this;\n    _this.hitDetectionImage_ = null;\n    _this.image_ = !image2 ? new Image() : image2;\n    if (crossOrigin !== null) {\n      _this.image_.crossOrigin = crossOrigin;\n    }\n    _this.canvas_ = {};\n    _this.color_ = color2;\n    _this.unlisten_ = null;\n    _this.imageState_ = imageState;\n    _this.size_ = size;\n    _this.src_ = src;\n    _this.tainted_;\n    return _this;\n  }\n  IconImage2.prototype.isTainted_ = function() {\n    if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {\n      if (!taintedTestContext) {\n        taintedTestContext = createCanvasContext2D(1, 1);\n      }\n      taintedTestContext.drawImage(this.image_, 0, 0);\n      try {\n        taintedTestContext.getImageData(0, 0, 1, 1);\n        this.tainted_ = false;\n      } catch (e2) {\n        taintedTestContext = null;\n        this.tainted_ = true;\n      }\n    }\n    return this.tainted_ === true;\n  };\n  IconImage2.prototype.dispatchChangeEvent_ = function() {\n    this.dispatchEvent(EventType.CHANGE);\n  };\n  IconImage2.prototype.handleImageError_ = function() {\n    this.imageState_ = ImageState.ERROR;\n    this.unlistenImage_();\n    this.dispatchChangeEvent_();\n  };\n  IconImage2.prototype.handleImageLoad_ = function() {\n    this.imageState_ = ImageState.LOADED;\n    if (this.size_) {\n      this.image_.width = this.size_[0];\n      this.image_.height = this.size_[1];\n    } else {\n      this.size_ = [this.image_.width, this.image_.height];\n    }\n    this.unlistenImage_();\n    this.dispatchChangeEvent_();\n  };\n  IconImage2.prototype.getImage = function(pixelRatio) {\n    this.replaceColor_(pixelRatio);\n    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;\n  };\n  IconImage2.prototype.getPixelRatio = function(pixelRatio) {\n    this.replaceColor_(pixelRatio);\n    return this.canvas_[pixelRatio] ? pixelRatio : 1;\n  };\n  IconImage2.prototype.getImageState = function() {\n    return this.imageState_;\n  };\n  IconImage2.prototype.getHitDetectionImage = function() {\n    if (!this.hitDetectionImage_) {\n      if (this.isTainted_()) {\n        var width = this.size_[0];\n        var height = this.size_[1];\n        var context = createCanvasContext2D(width, height);\n        context.fillRect(0, 0, width, height);\n        this.hitDetectionImage_ = context.canvas;\n      } else {\n        this.hitDetectionImage_ = this.image_;\n      }\n    }\n    return this.hitDetectionImage_;\n  };\n  IconImage2.prototype.getSize = function() {\n    return this.size_;\n  };\n  IconImage2.prototype.getSrc = function() {\n    return this.src_;\n  };\n  IconImage2.prototype.load = function() {\n    if (this.imageState_ == ImageState.IDLE) {\n      this.imageState_ = ImageState.LOADING;\n      try {\n        this.image_.src = this.src_;\n      } catch (e2) {\n        this.handleImageError_();\n      }\n      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));\n    }\n  };\n  IconImage2.prototype.replaceColor_ = function(pixelRatio) {\n    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState.LOADED) {\n      return;\n    }\n    var canvas = document.createElement(\"canvas\");\n    this.canvas_[pixelRatio] = canvas;\n    canvas.width = Math.ceil(this.image_.width * pixelRatio);\n    canvas.height = Math.ceil(this.image_.height * pixelRatio);\n    var ctx = canvas.getContext(\"2d\");\n    ctx.scale(pixelRatio, pixelRatio);\n    ctx.drawImage(this.image_, 0, 0);\n    ctx.globalCompositeOperation = \"multiply\";\n    if (ctx.globalCompositeOperation === \"multiply\" || this.isTainted_()) {\n      ctx.fillStyle = asString$1(this.color_);\n      ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);\n      ctx.globalCompositeOperation = \"destination-in\";\n      ctx.drawImage(this.image_, 0, 0);\n    } else {\n      var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      var data2 = imgData.data;\n      var r2 = this.color_[0] / 255;\n      var g2 = this.color_[1] / 255;\n      var b2 = this.color_[2] / 255;\n      var a2 = this.color_[3];\n      for (var i2 = 0, ii = data2.length; i2 < ii; i2 += 4) {\n        data2[i2] *= r2;\n        data2[i2 + 1] *= g2;\n        data2[i2 + 2] *= b2;\n        data2[i2 + 3] *= a2;\n      }\n      ctx.putImageData(imgData, 0, 0);\n    }\n  };\n  IconImage2.prototype.unlistenImage_ = function() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  };\n  return IconImage2;\n}(EventTarget);\nfunction get$2(image2, src, size, crossOrigin, imageState, color2) {\n  var iconImage = shared$5.get(src, crossOrigin, color2);\n  if (!iconImage) {\n    iconImage = new IconImage(image2, src, size, crossOrigin, imageState, color2);\n    shared$5.set(src, crossOrigin, color2, iconImage);\n  }\n  return iconImage;\n}\nvar __extends$19 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Icon$1 = function(_super) {\n  __extends$19(Icon2, _super);\n  function Icon2(opt_options) {\n    var _this = this;\n    var options = opt_options || {};\n    var opacity2 = options.opacity !== void 0 ? options.opacity : 1;\n    var rotation = options.rotation !== void 0 ? options.rotation : 0;\n    var scale2 = options.scale !== void 0 ? options.scale : 1;\n    var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;\n    _this = _super.call(this, {\n      opacity: opacity2,\n      rotation,\n      scale: scale2,\n      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],\n      rotateWithView\n    }) || this;\n    _this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];\n    _this.normalizedAnchor_ = null;\n    _this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : IconOrigin.TOP_LEFT;\n    _this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : IconAnchorUnits.FRACTION;\n    _this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : IconAnchorUnits.FRACTION;\n    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;\n    var image2 = options.img !== void 0 ? options.img : null;\n    _this.imgSize_ = options.imgSize;\n    var src = options.src;\n    assert(!(src !== void 0 && image2), 4);\n    assert(!image2 || image2 && _this.imgSize_, 5);\n    if ((src === void 0 || src.length === 0) && image2) {\n      src = image2.src || getUid(image2);\n    }\n    assert(src !== void 0 && src.length > 0, 6);\n    var imageState = options.src !== void 0 ? ImageState.IDLE : ImageState.LOADED;\n    _this.color_ = options.color !== void 0 ? asArray(options.color) : null;\n    _this.iconImage_ = get$2(image2, src, _this.imgSize_ !== void 0 ? _this.imgSize_ : null, _this.crossOrigin_, imageState, _this.color_);\n    _this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];\n    _this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : IconOrigin.TOP_LEFT;\n    _this.origin_ = null;\n    _this.size_ = options.size !== void 0 ? options.size : null;\n    return _this;\n  }\n  Icon2.prototype.clone = function() {\n    var scale2 = this.getScale();\n    return new Icon2({\n      anchor: this.anchor_.slice(),\n      anchorOrigin: this.anchorOrigin_,\n      anchorXUnits: this.anchorXUnits_,\n      anchorYUnits: this.anchorYUnits_,\n      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,\n      crossOrigin: this.crossOrigin_,\n      imgSize: this.imgSize_,\n      offset: this.offset_.slice(),\n      offsetOrigin: this.offsetOrigin_,\n      opacity: this.getOpacity(),\n      rotateWithView: this.getRotateWithView(),\n      rotation: this.getRotation(),\n      scale: Array.isArray(scale2) ? scale2.slice() : scale2,\n      size: this.size_ !== null ? this.size_.slice() : void 0,\n      src: this.getSrc()\n    });\n  };\n  Icon2.prototype.getAnchor = function() {\n    var anchor = this.normalizedAnchor_;\n    if (!anchor) {\n      anchor = this.anchor_;\n      var size = this.getSize();\n      if (this.anchorXUnits_ == IconAnchorUnits.FRACTION || this.anchorYUnits_ == IconAnchorUnits.FRACTION) {\n        if (!size) {\n          return null;\n        }\n        anchor = this.anchor_.slice();\n        if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {\n          anchor[0] *= size[0];\n        }\n        if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {\n          anchor[1] *= size[1];\n        }\n      }\n      if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {\n        if (!size) {\n          return null;\n        }\n        if (anchor === this.anchor_) {\n          anchor = this.anchor_.slice();\n        }\n        if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {\n          anchor[0] = -anchor[0] + size[0];\n        }\n        if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {\n          anchor[1] = -anchor[1] + size[1];\n        }\n      }\n      this.normalizedAnchor_ = anchor;\n    }\n    var displacement = this.getDisplacement();\n    return [anchor[0] - displacement[0], anchor[1] + displacement[1]];\n  };\n  Icon2.prototype.setAnchor = function(anchor) {\n    this.anchor_ = anchor;\n    this.normalizedAnchor_ = null;\n  };\n  Icon2.prototype.getColor = function() {\n    return this.color_;\n  };\n  Icon2.prototype.getImage = function(pixelRatio) {\n    return this.iconImage_.getImage(pixelRatio);\n  };\n  Icon2.prototype.getPixelRatio = function(pixelRatio) {\n    return this.iconImage_.getPixelRatio(pixelRatio);\n  };\n  Icon2.prototype.getImageSize = function() {\n    return this.iconImage_.getSize();\n  };\n  Icon2.prototype.getImageState = function() {\n    return this.iconImage_.getImageState();\n  };\n  Icon2.prototype.getHitDetectionImage = function() {\n    return this.iconImage_.getHitDetectionImage();\n  };\n  Icon2.prototype.getOrigin = function() {\n    if (this.origin_) {\n      return this.origin_;\n    }\n    var offset2 = this.offset_;\n    if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {\n      var size = this.getSize();\n      var iconImageSize = this.iconImage_.getSize();\n      if (!size || !iconImageSize) {\n        return null;\n      }\n      offset2 = offset2.slice();\n      if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {\n        offset2[0] = iconImageSize[0] - size[0] - offset2[0];\n      }\n      if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {\n        offset2[1] = iconImageSize[1] - size[1] - offset2[1];\n      }\n    }\n    this.origin_ = offset2;\n    return this.origin_;\n  };\n  Icon2.prototype.getSrc = function() {\n    return this.iconImage_.getSrc();\n  };\n  Icon2.prototype.getSize = function() {\n    return !this.size_ ? this.iconImage_.getSize() : this.size_;\n  };\n  Icon2.prototype.listenImageChange = function(listener2) {\n    this.iconImage_.addEventListener(EventType.CHANGE, listener2);\n  };\n  Icon2.prototype.load = function() {\n    this.iconImage_.load();\n  };\n  Icon2.prototype.unlistenImageChange = function(listener2) {\n    this.iconImage_.removeEventListener(EventType.CHANGE, listener2);\n  };\n  return Icon2;\n}(ImageStyle$1);\nvar Icon$2 = Icon$1;\nvar DEFAULT_FILL_COLOR = \"#333\";\nvar Text$1 = function() {\n  function Text2(opt_options) {\n    var options = opt_options || {};\n    this.font_ = options.font;\n    this.rotation_ = options.rotation;\n    this.rotateWithView_ = options.rotateWithView;\n    this.scale_ = options.scale;\n    this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);\n    this.text_ = options.text;\n    this.textAlign_ = options.textAlign;\n    this.textBaseline_ = options.textBaseline;\n    this.fill_ = options.fill !== void 0 ? options.fill : new Fill$2({ color: DEFAULT_FILL_COLOR });\n    this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;\n    this.placement_ = options.placement !== void 0 ? options.placement : TextPlacement.POINT;\n    this.overflow_ = !!options.overflow;\n    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;\n    this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;\n    this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;\n    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;\n    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;\n    this.padding_ = options.padding === void 0 ? null : options.padding;\n  }\n  Text2.prototype.clone = function() {\n    var scale2 = this.getScale();\n    return new Text2({\n      font: this.getFont(),\n      placement: this.getPlacement(),\n      maxAngle: this.getMaxAngle(),\n      overflow: this.getOverflow(),\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      scale: Array.isArray(scale2) ? scale2.slice() : scale2,\n      text: this.getText(),\n      textAlign: this.getTextAlign(),\n      textBaseline: this.getTextBaseline(),\n      fill: this.getFill() ? this.getFill().clone() : void 0,\n      stroke: this.getStroke() ? this.getStroke().clone() : void 0,\n      offsetX: this.getOffsetX(),\n      offsetY: this.getOffsetY(),\n      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,\n      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,\n      padding: this.getPadding() || void 0\n    });\n  };\n  Text2.prototype.getOverflow = function() {\n    return this.overflow_;\n  };\n  Text2.prototype.getFont = function() {\n    return this.font_;\n  };\n  Text2.prototype.getMaxAngle = function() {\n    return this.maxAngle_;\n  };\n  Text2.prototype.getPlacement = function() {\n    return this.placement_;\n  };\n  Text2.prototype.getOffsetX = function() {\n    return this.offsetX_;\n  };\n  Text2.prototype.getOffsetY = function() {\n    return this.offsetY_;\n  };\n  Text2.prototype.getFill = function() {\n    return this.fill_;\n  };\n  Text2.prototype.getRotateWithView = function() {\n    return this.rotateWithView_;\n  };\n  Text2.prototype.getRotation = function() {\n    return this.rotation_;\n  };\n  Text2.prototype.getScale = function() {\n    return this.scale_;\n  };\n  Text2.prototype.getScaleArray = function() {\n    return this.scaleArray_;\n  };\n  Text2.prototype.getStroke = function() {\n    return this.stroke_;\n  };\n  Text2.prototype.getText = function() {\n    return this.text_;\n  };\n  Text2.prototype.getTextAlign = function() {\n    return this.textAlign_;\n  };\n  Text2.prototype.getTextBaseline = function() {\n    return this.textBaseline_;\n  };\n  Text2.prototype.getBackgroundFill = function() {\n    return this.backgroundFill_;\n  };\n  Text2.prototype.getBackgroundStroke = function() {\n    return this.backgroundStroke_;\n  };\n  Text2.prototype.getPadding = function() {\n    return this.padding_;\n  };\n  Text2.prototype.setOverflow = function(overflow2) {\n    this.overflow_ = overflow2;\n  };\n  Text2.prototype.setFont = function(font) {\n    this.font_ = font;\n  };\n  Text2.prototype.setMaxAngle = function(maxAngle) {\n    this.maxAngle_ = maxAngle;\n  };\n  Text2.prototype.setOffsetX = function(offsetX) {\n    this.offsetX_ = offsetX;\n  };\n  Text2.prototype.setOffsetY = function(offsetY) {\n    this.offsetY_ = offsetY;\n  };\n  Text2.prototype.setPlacement = function(placement) {\n    this.placement_ = placement;\n  };\n  Text2.prototype.setRotateWithView = function(rotateWithView) {\n    this.rotateWithView_ = rotateWithView;\n  };\n  Text2.prototype.setFill = function(fill) {\n    this.fill_ = fill;\n  };\n  Text2.prototype.setRotation = function(rotation) {\n    this.rotation_ = rotation;\n  };\n  Text2.prototype.setScale = function(scale2) {\n    this.scale_ = scale2;\n    this.scaleArray_ = toSize(scale2 !== void 0 ? scale2 : 1);\n  };\n  Text2.prototype.setStroke = function(stroke) {\n    this.stroke_ = stroke;\n  };\n  Text2.prototype.setText = function(text2) {\n    this.text_ = text2;\n  };\n  Text2.prototype.setTextAlign = function(textAlign2) {\n    this.textAlign_ = textAlign2;\n  };\n  Text2.prototype.setTextBaseline = function(textBaseline) {\n    this.textBaseline_ = textBaseline;\n  };\n  Text2.prototype.setBackgroundFill = function(fill) {\n    this.backgroundFill_ = fill;\n  };\n  Text2.prototype.setBackgroundStroke = function(stroke) {\n    this.backgroundStroke_ = stroke;\n  };\n  Text2.prototype.setPadding = function(padding) {\n    this.padding_ = padding;\n  };\n  return Text2;\n}();\nvar Text$2 = Text$1;\nvar HIT_DETECT_RESOLUTION = 0.5;\nfunction createHitDetectionImageData(size, transforms2, features, styleFunction, extent2, resolution, rotation) {\n  var width = size[0] * HIT_DETECT_RESOLUTION;\n  var height = size[1] * HIT_DETECT_RESOLUTION;\n  var context = createCanvasContext2D(width, height);\n  context.imageSmoothingEnabled = false;\n  var canvas = context.canvas;\n  var renderer = new CanvasImmediateRenderer$1(context, HIT_DETECT_RESOLUTION, extent2, null, rotation);\n  var featureCount = features.length;\n  var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);\n  var featuresByZIndex = {};\n  for (var i2 = 1; i2 <= featureCount; ++i2) {\n    var feature2 = features[i2 - 1];\n    var featureStyleFunction = feature2.getStyleFunction() || styleFunction;\n    if (!styleFunction) {\n      continue;\n    }\n    var styles = featureStyleFunction(feature2, resolution);\n    if (!styles) {\n      continue;\n    }\n    if (!Array.isArray(styles)) {\n      styles = [styles];\n    }\n    var index2 = i2 * indexFactor;\n    var color2 = \"#\" + (\"000000\" + index2.toString(16)).slice(-6);\n    for (var j2 = 0, jj = styles.length; j2 < jj; ++j2) {\n      var originalStyle = styles[j2];\n      var geometry = originalStyle.getGeometryFunction()(feature2);\n      if (!geometry || !intersects$1(extent2, geometry.getExtent())) {\n        continue;\n      }\n      var style2 = originalStyle.clone();\n      var fill = style2.getFill();\n      if (fill) {\n        fill.setColor(color2);\n      }\n      var stroke = style2.getStroke();\n      if (stroke) {\n        stroke.setColor(color2);\n        stroke.setLineDash(null);\n      }\n      style2.setText(void 0);\n      var image2 = originalStyle.getImage();\n      if (image2 && image2.getOpacity() !== 0) {\n        var imgSize = image2.getImageSize();\n        if (!imgSize) {\n          continue;\n        }\n        var imgContext = createCanvasContext2D(imgSize[0], imgSize[1], void 0, { alpha: false });\n        var img = imgContext.canvas;\n        imgContext.fillStyle = color2;\n        imgContext.fillRect(0, 0, img.width, img.height);\n        style2.setImage(new Icon$2({\n          img,\n          imgSize,\n          anchor: image2.getAnchor(),\n          anchorXUnits: IconAnchorUnits.PIXELS,\n          anchorYUnits: IconAnchorUnits.PIXELS,\n          offset: image2.getOrigin(),\n          opacity: 1,\n          size: image2.getSize(),\n          scale: image2.getScale(),\n          rotation: image2.getRotation(),\n          rotateWithView: image2.getRotateWithView()\n        }));\n      }\n      var zIndex2 = style2.getZIndex() || 0;\n      var byGeometryType = featuresByZIndex[zIndex2];\n      if (!byGeometryType) {\n        byGeometryType = {};\n        featuresByZIndex[zIndex2] = byGeometryType;\n        byGeometryType[GeometryType.POLYGON] = [];\n        byGeometryType[GeometryType.CIRCLE] = [];\n        byGeometryType[GeometryType.LINE_STRING] = [];\n        byGeometryType[GeometryType.POINT] = [];\n      }\n      byGeometryType[geometry.getType().replace(\"Multi\", \"\")].push(geometry, style2);\n    }\n  }\n  var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(numberSafeCompareFunction);\n  for (var i2 = 0, ii = zIndexKeys.length; i2 < ii; ++i2) {\n    var byGeometryType = featuresByZIndex[zIndexKeys[i2]];\n    for (var type in byGeometryType) {\n      var geomAndStyle = byGeometryType[type];\n      for (var j2 = 0, jj = geomAndStyle.length; j2 < jj; j2 += 2) {\n        renderer.setStyle(geomAndStyle[j2 + 1]);\n        for (var k2 = 0, kk = transforms2.length; k2 < kk; ++k2) {\n          renderer.setTransform(transforms2[k2]);\n          renderer.drawGeometry(geomAndStyle[j2]);\n        }\n      }\n    }\n  }\n  return context.getImageData(0, 0, canvas.width, canvas.height);\n}\nfunction hitDetect(pixel, features, imageData) {\n  var resultFeatures = [];\n  if (imageData) {\n    var x2 = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);\n    var y2 = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);\n    var index2 = (clamp(x2, 0, imageData.width - 1) + clamp(y2, 0, imageData.height - 1) * imageData.width) * 4;\n    var r2 = imageData.data[index2];\n    var g2 = imageData.data[index2 + 1];\n    var b2 = imageData.data[index2 + 2];\n    var i2 = b2 + 256 * (g2 + 256 * r2);\n    var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);\n    if (i2 && i2 % indexFactor === 0) {\n      resultFeatures.push(features[i2 / indexFactor - 1]);\n    }\n  }\n  return resultFeatures;\n}\nvar SIMPLIFY_TOLERANCE = 0.5;\nvar GEOMETRY_RENDERERS = {\n  \"Point\": renderPointGeometry,\n  \"LineString\": renderLineStringGeometry,\n  \"Polygon\": renderPolygonGeometry,\n  \"MultiPoint\": renderMultiPointGeometry,\n  \"MultiLineString\": renderMultiLineStringGeometry,\n  \"MultiPolygon\": renderMultiPolygonGeometry,\n  \"GeometryCollection\": renderGeometryCollectionGeometry,\n  \"Circle\": renderCircleGeometry\n};\nfunction defaultOrder(feature1, feature2) {\n  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\nfunction getSquaredTolerance(resolution, pixelRatio) {\n  var tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\nfunction getTolerance(resolution, pixelRatio) {\n  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;\n}\nfunction renderCircleGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {\n  var fillStyle = style2.getFill();\n  var strokeStyle = style2.getStroke();\n  if (fillStyle || strokeStyle) {\n    var circleReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.CIRCLE);\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature2);\n  }\n  var textStyle = style2.getText();\n  if (textStyle && textStyle.getText()) {\n    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature2);\n  }\n}\nfunction renderFeature(replayGroup, feature2, style2, squaredTolerance, listener2, opt_transform, opt_declutterBuilderGroup) {\n  var loading = false;\n  var imageStyle = style2.getImage();\n  if (imageStyle) {\n    var imageState = imageStyle.getImageState();\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n      imageStyle.unlistenImageChange(listener2);\n    } else {\n      if (imageState == ImageState.IDLE) {\n        imageStyle.load();\n      }\n      imageState = imageStyle.getImageState();\n      imageStyle.listenImageChange(listener2);\n      loading = true;\n    }\n  }\n  renderFeatureInternal(replayGroup, feature2, style2, squaredTolerance, opt_transform, opt_declutterBuilderGroup);\n  return loading;\n}\nfunction renderFeatureInternal(replayGroup, feature2, style2, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {\n  var geometry = style2.getGeometryFunction()(feature2);\n  if (!geometry) {\n    return;\n  }\n  var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);\n  var renderer = style2.getRenderer();\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style2, feature2);\n  } else {\n    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(replayGroup, simplifiedGeometry, style2, feature2, opt_declutterBuilderGroup);\n  }\n}\nfunction renderGeometry(replayGroup, geometry, style2, feature2) {\n  if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n    var geometries = geometry.getGeometries();\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      renderGeometry(replayGroup, geometries[i2], style2, feature2);\n    }\n    return;\n  }\n  var replay = replayGroup.getBuilder(style2.getZIndex(), ReplayType.DEFAULT);\n  replay.drawCustom(geometry, feature2, style2.getRenderer(), style2.getHitDetectionRenderer());\n}\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {\n  var geometries = geometry.getGeometriesArray();\n  var i2, ii;\n  for (i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i2].getType()];\n    geometryRenderer(replayGroup, geometries[i2], style2, feature2, opt_declutterBuilderGroup);\n  }\n}\nfunction renderLineStringGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {\n  var strokeStyle = style2.getStroke();\n  if (strokeStyle) {\n    var lineStringReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.LINE_STRING);\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature2);\n  }\n  var textStyle = style2.getText();\n  if (textStyle && textStyle.getText()) {\n    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature2);\n  }\n}\nfunction renderMultiLineStringGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {\n  var strokeStyle = style2.getStroke();\n  if (strokeStyle) {\n    var lineStringReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.LINE_STRING);\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature2);\n  }\n  var textStyle = style2.getText();\n  if (textStyle && textStyle.getText()) {\n    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature2);\n  }\n}\nfunction renderMultiPolygonGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {\n  var fillStyle = style2.getFill();\n  var strokeStyle = style2.getStroke();\n  if (strokeStyle || fillStyle) {\n    var polygonReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.POLYGON);\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature2);\n  }\n  var textStyle = style2.getText();\n  if (textStyle && textStyle.getText()) {\n    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature2);\n  }\n}\nfunction renderPointGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {\n  var imageStyle = style2.getImage();\n  var textStyle = style2.getText();\n  var declutterImageWithText;\n  if (opt_declutterBuilderGroup) {\n    builderGroup = opt_declutterBuilderGroup;\n    declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;\n  }\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    var imageReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.IMAGE);\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawPoint(geometry, feature2);\n  }\n  if (textStyle && textStyle.getText()) {\n    var textReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.TEXT);\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature2);\n  }\n}\nfunction renderMultiPointGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {\n  var imageStyle = style2.getImage();\n  var textStyle = style2.getText();\n  var declutterImageWithText;\n  if (opt_declutterBuilderGroup) {\n    builderGroup = opt_declutterBuilderGroup;\n    declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;\n  }\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    var imageReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.IMAGE);\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawMultiPoint(geometry, feature2);\n  }\n  if (textStyle && textStyle.getText()) {\n    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature2);\n  }\n}\nfunction renderPolygonGeometry(builderGroup, geometry, style2, feature2, opt_declutterBuilderGroup) {\n  var fillStyle = style2.getFill();\n  var strokeStyle = style2.getStroke();\n  if (fillStyle || strokeStyle) {\n    var polygonReplay = builderGroup.getBuilder(style2.getZIndex(), ReplayType.POLYGON);\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature2);\n  }\n  var textStyle = style2.getText();\n  if (textStyle && textStyle.getText()) {\n    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style2.getZIndex(), ReplayType.TEXT);\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature2);\n  }\n}\nvar __extends$18 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CanvasVectorLayerRenderer = function(_super) {\n  __extends$18(CanvasVectorLayerRenderer2, _super);\n  function CanvasVectorLayerRenderer2(vectorLayer) {\n    var _this = _super.call(this, vectorLayer) || this;\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n    _this.animatingOrInteracting_;\n    _this.dirty_ = false;\n    _this.hitDetectionImageData_ = null;\n    _this.renderedFeatures_ = null;\n    _this.renderedRevision_ = -1;\n    _this.renderedResolution_ = NaN;\n    _this.renderedExtent_ = createEmpty();\n    _this.wrappedRenderedExtent_ = createEmpty();\n    _this.renderedRotation_;\n    _this.renderedCenter_ = null;\n    _this.renderedProjection_ = null;\n    _this.renderedRenderOrder_ = null;\n    _this.replayGroup_ = null;\n    _this.replayGroupChanged = true;\n    _this.declutterExecutorGroup = null;\n    _this.clipping = true;\n    return _this;\n  }\n  CanvasVectorLayerRenderer2.prototype.renderWorlds = function(executorGroup, frameState, opt_declutterTree) {\n    var extent2 = frameState.extent;\n    var viewState = frameState.viewState;\n    var center = viewState.center;\n    var resolution = viewState.resolution;\n    var projection = viewState.projection;\n    var rotation = viewState.rotation;\n    var projectionExtent = projection.getExtent();\n    var vectorSource = this.getLayer().getSource();\n    var pixelRatio = frameState.pixelRatio;\n    var viewHints = frameState.viewHints;\n    var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    var context = this.context;\n    var width = Math.round(frameState.size[0] * pixelRatio);\n    var height = Math.round(frameState.size[1] * pixelRatio);\n    var multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    var worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    var endWorld = multiWorld ? Math.ceil((extent2[2] - projectionExtent[2]) / worldWidth) + 1 : 1;\n    var world = multiWorld ? Math.floor((extent2[0] - projectionExtent[0]) / worldWidth) : 0;\n    do {\n      var transform2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);\n      executorGroup.execute(context, 1, transform2, rotation, snapToPixel, void 0, opt_declutterTree);\n    } while (++world < endWorld);\n  };\n  CanvasVectorLayerRenderer2.prototype.renderDeclutter = function(frameState) {\n    if (this.declutterExecutorGroup) {\n      this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);\n    }\n  };\n  CanvasVectorLayerRenderer2.prototype.renderFrame = function(frameState, target) {\n    var pixelRatio = frameState.pixelRatio;\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    var canvasTransform = toString$d(this.pixelTransform);\n    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));\n    var context = this.context;\n    var canvas = context.canvas;\n    var replayGroup = this.replayGroup_;\n    var declutterExecutorGroup = this.declutterExecutorGroup;\n    if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {\n      return null;\n    }\n    var width = Math.round(frameState.size[0] * pixelRatio);\n    var height = Math.round(frameState.size[1] * pixelRatio);\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n      if (canvas.style.transform !== canvasTransform) {\n        canvas.style.transform = canvasTransform;\n      }\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n    this.preRender(context, frameState);\n    var viewState = frameState.viewState;\n    viewState.projection;\n    var clipped = false;\n    var render2 = true;\n    if (layerState.extent && this.clipping) {\n      var layerExtent = fromUserExtent(layerState.extent);\n      render2 = intersects$1(layerExtent, frameState.extent);\n      clipped = render2 && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n    if (render2) {\n      this.renderWorlds(replayGroup, frameState);\n    }\n    if (clipped) {\n      context.restore();\n    }\n    this.postRender(context, frameState);\n    var opacity2 = cssOpacity(layerState.opacity);\n    var container = this.container;\n    if (opacity2 !== container.style.opacity) {\n      container.style.opacity = opacity2;\n    }\n    if (this.renderedRotation_ !== viewState.rotation) {\n      this.renderedRotation_ = viewState.rotation;\n      this.hitDetectionImageData_ = null;\n    }\n    return this.container;\n  };\n  CanvasVectorLayerRenderer2.prototype.getFeatures = function(pixel) {\n    return new Promise(function(resolve2) {\n      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {\n        var size = [this.context.canvas.width, this.context.canvas.height];\n        apply$5(this.pixelTransform, size);\n        var center = this.renderedCenter_;\n        var resolution = this.renderedResolution_;\n        var rotation = this.renderedRotation_;\n        var projection = this.renderedProjection_;\n        var extent2 = this.wrappedRenderedExtent_;\n        var layer = this.getLayer();\n        var transforms2 = [];\n        var width = size[0] * HIT_DETECT_RESOLUTION;\n        var height = size[1] * HIT_DETECT_RESOLUTION;\n        transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, 0).slice());\n        var source = layer.getSource();\n        var projectionExtent = projection.getExtent();\n        if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent2)) {\n          var startX = extent2[0];\n          var worldWidth = getWidth(projectionExtent);\n          var world = 0;\n          var offsetX = void 0;\n          while (startX < projectionExtent[0]) {\n            --world;\n            offsetX = worldWidth * world;\n            transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());\n            startX += worldWidth;\n          }\n          world = 0;\n          startX = extent2[2];\n          while (startX > projectionExtent[2]) {\n            ++world;\n            offsetX = worldWidth * world;\n            transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());\n            startX -= worldWidth;\n          }\n        }\n        this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms2, this.renderedFeatures_, layer.getStyleFunction(), extent2, resolution, rotation);\n      }\n      resolve2(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));\n    }.bind(this));\n  };\n  CanvasVectorLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {\n    var _this = this;\n    if (!this.replayGroup_) {\n      return void 0;\n    }\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    var layer = this.getLayer();\n    var features = {};\n    var featureCallback = function(feature2, geometry, distanceSq) {\n      var key = getUid(feature2);\n      var match2 = features[key];\n      if (!match2) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature2, layer, geometry);\n        }\n        matches.push(features[key] = {\n          feature: feature2,\n          layer,\n          geometry,\n          distanceSq,\n          callback\n        });\n      } else if (match2 !== true && distanceSq < match2.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match2), 1);\n          return callback(feature2, layer, geometry);\n        }\n        match2.geometry = geometry;\n        match2.distanceSq = distanceSq;\n      }\n      return void 0;\n    };\n    var result;\n    var executorGroups = [this.replayGroup_];\n    if (this.declutterExecutorGroup) {\n      executorGroups.push(this.declutterExecutorGroup);\n    }\n    executorGroups.some(function(executorGroup) {\n      return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map(function(item) {\n        return item.value;\n      }) : null);\n    });\n    return result;\n  };\n  CanvasVectorLayerRenderer2.prototype.handleFontsChanged = function() {\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  };\n  CanvasVectorLayerRenderer2.prototype.handleStyleImageChange_ = function(event) {\n    this.renderIfReadyAndVisible();\n  };\n  CanvasVectorLayerRenderer2.prototype.prepareFrame = function(frameState) {\n    var vectorLayer = this.getLayer();\n    var vectorSource = vectorLayer.getSource();\n    if (!vectorSource) {\n      return false;\n    }\n    var animating = frameState.viewHints[ViewHint.ANIMATING];\n    var interacting = frameState.viewHints[ViewHint.INTERACTING];\n    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {\n      this.animatingOrInteracting_ = true;\n      return true;\n    }\n    this.animatingOrInteracting_ = false;\n    var frameStateExtent = frameState.extent;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var vectorLayerRevision = vectorLayer.getRevision();\n    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n    if (vectorLayerRenderOrder === void 0) {\n      vectorLayerRenderOrder = defaultOrder;\n    }\n    var center = viewState.center.slice();\n    var extent2 = buffer$1(frameStateExtent, vectorLayerRenderBuffer * resolution);\n    var renderedExtent = extent2.slice();\n    var loadExtents = [extent2.slice()];\n    var projectionExtent = projection.getExtent();\n    if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {\n      var worldWidth = getWidth(projectionExtent);\n      var gutter = Math.max(getWidth(extent2) / 2, worldWidth);\n      extent2[0] = projectionExtent[0] - gutter;\n      extent2[2] = projectionExtent[2] + gutter;\n      wrapX$1(center, projection);\n      var loadExtent = wrapX$2(loadExtents[0], projection);\n      if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {\n        loadExtents.push([\n          loadExtent[0] + worldWidth,\n          loadExtent[1],\n          loadExtent[2] + worldWidth,\n          loadExtent[3]\n        ]);\n      } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {\n        loadExtents.push([\n          loadExtent[0] - worldWidth,\n          loadExtent[1],\n          loadExtent[2] - worldWidth,\n          loadExtent[3]\n        ]);\n      }\n    }\n    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent2)) {\n      if (!equals$2(this.renderedExtent_, renderedExtent)) {\n        this.hitDetectionImageData_ = null;\n        this.renderedExtent_ = renderedExtent;\n      }\n      this.renderedCenter_ = center;\n      this.replayGroupChanged = false;\n      return true;\n    }\n    this.replayGroup_ = null;\n    this.dirty_ = false;\n    var replayGroup = new CanvasBuilderGroup(getTolerance(resolution, pixelRatio), extent2, resolution, pixelRatio);\n    var declutterBuilderGroup;\n    if (this.getLayer().getDeclutter()) {\n      declutterBuilderGroup = new CanvasBuilderGroup(getTolerance(resolution, pixelRatio), extent2, resolution, pixelRatio);\n    }\n    var userTransform;\n    var i2, ii;\n    {\n      for (var i2 = 0, ii = loadExtents.length; i2 < ii; ++i2) {\n        vectorSource.loadFeatures(loadExtents[i2], resolution, projection);\n      }\n    }\n    var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);\n    var render2 = function(feature2) {\n      var styles;\n      var styleFunction = feature2.getStyleFunction() || vectorLayer.getStyleFunction();\n      if (styleFunction) {\n        styles = styleFunction(feature2, resolution);\n      }\n      if (styles) {\n        var dirty = this.renderFeature(feature2, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n    var userExtent = toUserExtent(extent2);\n    var features = vectorSource.getFeaturesInExtent(userExtent);\n    if (vectorLayerRenderOrder) {\n      features.sort(vectorLayerRenderOrder);\n    }\n    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {\n      render2(features[i2]);\n    }\n    this.renderedFeatures_ = features;\n    var replayGroupInstructions = replayGroup.finish();\n    var executorGroup = new CanvasExecutorGroup(extent2, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());\n    if (declutterBuilderGroup) {\n      this.declutterExecutorGroup = new CanvasExecutorGroup(extent2, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());\n    }\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = renderedExtent;\n    this.wrappedRenderedExtent_ = extent2;\n    this.renderedCenter_ = center;\n    this.renderedProjection_ = projection;\n    this.replayGroup_ = executorGroup;\n    this.hitDetectionImageData_ = null;\n    this.replayGroupChanged = true;\n    return true;\n  };\n  CanvasVectorLayerRenderer2.prototype.renderFeature = function(feature2, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i2 = 0, ii = styles.length; i2 < ii; ++i2) {\n        loading = renderFeature(builderGroup, feature2, styles[i2], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;\n      }\n    } else {\n      loading = renderFeature(builderGroup, feature2, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);\n    }\n    return loading;\n  };\n  return CanvasVectorLayerRenderer2;\n}(CanvasLayerRenderer$1);\nvar CanvasVectorLayerRenderer$1 = CanvasVectorLayerRenderer;\nvar __extends$17 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar VectorLayer$1 = function(_super) {\n  __extends$17(VectorLayer2, _super);\n  function VectorLayer2(opt_options) {\n    return _super.call(this, opt_options) || this;\n  }\n  VectorLayer2.prototype.createRenderer = function() {\n    return new CanvasVectorLayerRenderer$1(this);\n  };\n  return VectorLayer2;\n}(BaseVector);\nvar ol_layer_Vector = VectorLayer$1;\nvar RBush = function() {\n  function RBush2(opt_maxEntries) {\n    this.rbush_ = new RBush$2(opt_maxEntries);\n    this.items_ = {};\n  }\n  RBush2.prototype.insert = function(extent2, value) {\n    var item = {\n      minX: extent2[0],\n      minY: extent2[1],\n      maxX: extent2[2],\n      maxY: extent2[3],\n      value\n    };\n    this.rbush_.insert(item);\n    this.items_[getUid(value)] = item;\n  };\n  RBush2.prototype.load = function(extents, values2) {\n    var items = new Array(values2.length);\n    for (var i2 = 0, l2 = values2.length; i2 < l2; i2++) {\n      var extent2 = extents[i2];\n      var value = values2[i2];\n      var item = {\n        minX: extent2[0],\n        minY: extent2[1],\n        maxX: extent2[2],\n        maxY: extent2[3],\n        value\n      };\n      items[i2] = item;\n      this.items_[getUid(value)] = item;\n    }\n    this.rbush_.load(items);\n  };\n  RBush2.prototype.remove = function(value) {\n    var uid2 = getUid(value);\n    var item = this.items_[uid2];\n    delete this.items_[uid2];\n    return this.rbush_.remove(item) !== null;\n  };\n  RBush2.prototype.update = function(extent2, value) {\n    var item = this.items_[getUid(value)];\n    var bbox2 = [item.minX, item.minY, item.maxX, item.maxY];\n    if (!equals$1(bbox2, extent2)) {\n      this.remove(value);\n      this.insert(extent2, value);\n    }\n  };\n  RBush2.prototype.getAll = function() {\n    var items = this.rbush_.all();\n    return items.map(function(item) {\n      return item.value;\n    });\n  };\n  RBush2.prototype.getInExtent = function(extent2) {\n    var bbox2 = {\n      minX: extent2[0],\n      minY: extent2[1],\n      maxX: extent2[2],\n      maxY: extent2[3]\n    };\n    var items = this.rbush_.search(bbox2);\n    return items.map(function(item) {\n      return item.value;\n    });\n  };\n  RBush2.prototype.forEach = function(callback) {\n    return this.forEach_(this.getAll(), callback);\n  };\n  RBush2.prototype.forEachInExtent = function(extent2, callback) {\n    return this.forEach_(this.getInExtent(extent2), callback);\n  };\n  RBush2.prototype.forEach_ = function(values2, callback) {\n    var result;\n    for (var i2 = 0, l2 = values2.length; i2 < l2; i2++) {\n      result = callback(values2[i2]);\n      if (result) {\n        return result;\n      }\n    }\n    return result;\n  };\n  RBush2.prototype.isEmpty = function() {\n    return isEmpty(this.items_);\n  };\n  RBush2.prototype.clear = function() {\n    this.rbush_.clear();\n    this.items_ = {};\n  };\n  RBush2.prototype.getExtent = function(opt_extent) {\n    var data2 = this.rbush_.toJSON();\n    return createOrUpdate$2(data2.minX, data2.minY, data2.maxX, data2.maxY, opt_extent);\n  };\n  RBush2.prototype.concat = function(rbush) {\n    this.rbush_.load(rbush.rbush_.all());\n    for (var i2 in rbush.items_) {\n      this.items_[i2] = rbush.items_[i2];\n    }\n  };\n  return RBush2;\n}();\nvar RBush$1 = RBush;\nvar __extends$16 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Source = function(_super) {\n  __extends$16(Source2, _super);\n  function Source2(options) {\n    var _this = _super.call(this) || this;\n    _this.projection = get$3(options.projection);\n    _this.attributions_ = adaptAttributions(options.attributions);\n    _this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;\n    _this.loading = false;\n    _this.state_ = options.state !== void 0 ? options.state : SourceState.READY;\n    _this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;\n    _this.interpolate_ = !!options.interpolate;\n    _this.viewResolver = null;\n    _this.viewRejector = null;\n    var self2 = _this;\n    _this.viewPromise_ = new Promise(function(resolve2, reject2) {\n      self2.viewResolver = resolve2;\n      self2.viewRejector = reject2;\n    });\n    return _this;\n  }\n  Source2.prototype.getAttributions = function() {\n    return this.attributions_;\n  };\n  Source2.prototype.getAttributionsCollapsible = function() {\n    return this.attributionsCollapsible_;\n  };\n  Source2.prototype.getProjection = function() {\n    return this.projection;\n  };\n  Source2.prototype.getResolutions = function() {\n    return abstract();\n  };\n  Source2.prototype.getView = function() {\n    return this.viewPromise_;\n  };\n  Source2.prototype.getState = function() {\n    return this.state_;\n  };\n  Source2.prototype.getWrapX = function() {\n    return this.wrapX_;\n  };\n  Source2.prototype.getInterpolate = function() {\n    return this.interpolate_;\n  };\n  Source2.prototype.refresh = function() {\n    this.changed();\n  };\n  Source2.prototype.setAttributions = function(attributions) {\n    this.attributions_ = adaptAttributions(attributions);\n    this.changed();\n  };\n  Source2.prototype.setState = function(state) {\n    this.state_ = state;\n    this.changed();\n  };\n  return Source2;\n}(ol_Object);\nfunction adaptAttributions(attributionLike) {\n  if (!attributionLike) {\n    return null;\n  }\n  if (Array.isArray(attributionLike)) {\n    return function(frameState) {\n      return attributionLike;\n    };\n  }\n  if (typeof attributionLike === \"function\") {\n    return attributionLike;\n  }\n  return function(frameState) {\n    return [attributionLike];\n  };\n}\nvar ol_source_Source = Source;\nvar VectorEventType = {\n  ADDFEATURE: \"addfeature\",\n  CHANGEFEATURE: \"changefeature\",\n  CLEAR: \"clear\",\n  REMOVEFEATURE: \"removefeature\",\n  FEATURESLOADSTART: \"featuresloadstart\",\n  FEATURESLOADEND: \"featuresloadend\",\n  FEATURESLOADERROR: \"featuresloaderror\"\n};\nfunction all(extent2, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\nfunction bbox$1(extent2, resolution) {\n  return [extent2];\n}\nfunction tile(tileGrid) {\n  return function(extent2, resolution, projection) {\n    var z2 = tileGrid.getZForResolution(fromUserResolution(resolution));\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(fromUserExtent(extent2), z2);\n    var extents = [];\n    var tileCoord = [z2, 0, 0];\n    for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {\n      for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {\n        extents.push(toUserExtent(tileGrid.getTileCoordExtent(tileCoord)));\n      }\n    }\n    return extents;\n  };\n}\nvar loadingstrategy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  all,\n  bbox: bbox$1,\n  tile\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar withCredentials = false;\nfunction loadFeaturesXhr(url, format2, extent2, resolution, projection, success, failure) {\n  var xhr2 = new XMLHttpRequest();\n  xhr2.open(\"GET\", typeof url === \"function\" ? url(extent2, resolution, projection) : url, true);\n  if (format2.getType() == FormatType.ARRAY_BUFFER) {\n    xhr2.responseType = \"arraybuffer\";\n  }\n  xhr2.withCredentials = withCredentials;\n  xhr2.onload = function(event) {\n    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {\n      var type = format2.getType();\n      var source = void 0;\n      if (type == FormatType.JSON || type == FormatType.TEXT) {\n        source = xhr2.responseText;\n      } else if (type == FormatType.XML) {\n        source = xhr2.responseXML;\n        if (!source) {\n          source = new DOMParser().parseFromString(xhr2.responseText, \"application/xml\");\n        }\n      } else if (type == FormatType.ARRAY_BUFFER) {\n        source = xhr2.response;\n      }\n      if (source) {\n        success(format2.readFeatures(source, {\n          extent: extent2,\n          featureProjection: projection\n        }), format2.readProjection(source));\n      } else {\n        failure();\n      }\n    } else {\n      failure();\n    }\n  };\n  xhr2.onerror = failure;\n  xhr2.send();\n}\nfunction xhr(url, format2) {\n  return function(extent2, resolution, projection, success, failure) {\n    var source = this;\n    loadFeaturesXhr(url, format2, extent2, resolution, projection, function(features, dataProjection) {\n      source.addFeatures(features);\n      if (success !== void 0) {\n        success(features);\n      }\n    }, failure ? failure : VOID);\n  };\n}\nvar __extends$15 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar VectorSourceEvent = function(_super) {\n  __extends$15(VectorSourceEvent2, _super);\n  function VectorSourceEvent2(type, opt_feature, opt_features) {\n    var _this = _super.call(this, type) || this;\n    _this.feature = opt_feature;\n    _this.features = opt_features;\n    return _this;\n  }\n  return VectorSourceEvent2;\n}(Event$1);\nvar VectorSource = function(_super) {\n  __extends$15(VectorSource2, _super);\n  function VectorSource2(opt_options) {\n    var _this = this;\n    var options = opt_options || {};\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      interpolate: true,\n      projection: void 0,\n      state: SourceState.READY,\n      wrapX: options.wrapX !== void 0 ? options.wrapX : true\n    }) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.loader_ = VOID;\n    _this.format_ = options.format;\n    _this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;\n    _this.url_ = options.url;\n    if (options.loader !== void 0) {\n      _this.loader_ = options.loader;\n    } else if (_this.url_ !== void 0) {\n      assert(_this.format_, 7);\n      _this.loader_ = xhr(_this.url_, _this.format_);\n    }\n    _this.strategy_ = options.strategy !== void 0 ? options.strategy : all;\n    var useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;\n    _this.featuresRtree_ = useSpatialIndex ? new RBush$1() : null;\n    _this.loadedExtentsRtree_ = new RBush$1();\n    _this.loadingExtentsCount_ = 0;\n    _this.nullGeometryFeatures_ = {};\n    _this.idIndex_ = {};\n    _this.uidIndex_ = {};\n    _this.featureChangeKeys_ = {};\n    _this.featuresCollection_ = null;\n    var collection, features;\n    if (Array.isArray(options.features)) {\n      features = options.features;\n    } else if (options.features) {\n      collection = options.features;\n      features = collection.getArray();\n    }\n    if (!useSpatialIndex && collection === void 0) {\n      collection = new ol_Collection(features);\n    }\n    if (features !== void 0) {\n      _this.addFeaturesInternal(features);\n    }\n    if (collection !== void 0) {\n      _this.bindFeaturesCollection_(collection);\n    }\n    return _this;\n  }\n  VectorSource2.prototype.addFeature = function(feature2) {\n    this.addFeatureInternal(feature2);\n    this.changed();\n  };\n  VectorSource2.prototype.addFeatureInternal = function(feature2) {\n    var featureKey = getUid(feature2);\n    if (!this.addToIndex_(featureKey, feature2)) {\n      if (this.featuresCollection_) {\n        this.featuresCollection_.remove(feature2);\n      }\n      return;\n    }\n    this.setupChangeEvents_(featureKey, feature2);\n    var geometry = feature2.getGeometry();\n    if (geometry) {\n      var extent2 = geometry.getExtent();\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent2, feature2);\n      }\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature2;\n    }\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature2));\n  };\n  VectorSource2.prototype.setupChangeEvents_ = function(featureKey, feature2) {\n    this.featureChangeKeys_[featureKey] = [\n      listen(feature2, EventType.CHANGE, this.handleFeatureChange_, this),\n      listen(feature2, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)\n    ];\n  };\n  VectorSource2.prototype.addToIndex_ = function(featureKey, feature2) {\n    var valid = true;\n    var id = feature2.getId();\n    if (id !== void 0) {\n      if (!(id.toString() in this.idIndex_)) {\n        this.idIndex_[id.toString()] = feature2;\n      } else {\n        valid = false;\n      }\n    }\n    if (valid) {\n      assert(!(featureKey in this.uidIndex_), 30);\n      this.uidIndex_[featureKey] = feature2;\n    }\n    return valid;\n  };\n  VectorSource2.prototype.addFeatures = function(features) {\n    this.addFeaturesInternal(features);\n    this.changed();\n  };\n  VectorSource2.prototype.addFeaturesInternal = function(features) {\n    var extents = [];\n    var newFeatures = [];\n    var geometryFeatures = [];\n    for (var i2 = 0, length_1 = features.length; i2 < length_1; i2++) {\n      var feature2 = features[i2];\n      var featureKey = getUid(feature2);\n      if (this.addToIndex_(featureKey, feature2)) {\n        newFeatures.push(feature2);\n      }\n    }\n    for (var i2 = 0, length_2 = newFeatures.length; i2 < length_2; i2++) {\n      var feature2 = newFeatures[i2];\n      var featureKey = getUid(feature2);\n      this.setupChangeEvents_(featureKey, feature2);\n      var geometry = feature2.getGeometry();\n      if (geometry) {\n        var extent2 = geometry.getExtent();\n        extents.push(extent2);\n        geometryFeatures.push(feature2);\n      } else {\n        this.nullGeometryFeatures_[featureKey] = feature2;\n      }\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.load(extents, geometryFeatures);\n    }\n    if (this.hasListener(VectorEventType.ADDFEATURE)) {\n      for (var i2 = 0, length_3 = newFeatures.length; i2 < length_3; i2++) {\n        this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i2]));\n      }\n    }\n  };\n  VectorSource2.prototype.bindFeaturesCollection_ = function(collection) {\n    var modifyingCollection = false;\n    this.addEventListener(VectorEventType.ADDFEATURE, function(evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        collection.push(evt.feature);\n        modifyingCollection = false;\n      }\n    });\n    this.addEventListener(VectorEventType.REMOVEFEATURE, function(evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        collection.remove(evt.feature);\n        modifyingCollection = false;\n      }\n    });\n    collection.addEventListener(CollectionEventType.ADD, function(evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        this.addFeature(evt.element);\n        modifyingCollection = false;\n      }\n    }.bind(this));\n    collection.addEventListener(CollectionEventType.REMOVE, function(evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        this.removeFeature(evt.element);\n        modifyingCollection = false;\n      }\n    }.bind(this));\n    this.featuresCollection_ = collection;\n  };\n  VectorSource2.prototype.clear = function(opt_fast) {\n    if (opt_fast) {\n      for (var featureId in this.featureChangeKeys_) {\n        var keys3 = this.featureChangeKeys_[featureId];\n        keys3.forEach(unlistenByKey);\n      }\n      if (!this.featuresCollection_) {\n        this.featureChangeKeys_ = {};\n        this.idIndex_ = {};\n        this.uidIndex_ = {};\n      }\n    } else {\n      if (this.featuresRtree_) {\n        var removeAndIgnoreReturn = function(feature2) {\n          this.removeFeatureInternal(feature2);\n        }.bind(this);\n        this.featuresRtree_.forEach(removeAndIgnoreReturn);\n        for (var id in this.nullGeometryFeatures_) {\n          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n        }\n      }\n    }\n    if (this.featuresCollection_) {\n      this.featuresCollection_.clear();\n    }\n    if (this.featuresRtree_) {\n      this.featuresRtree_.clear();\n    }\n    this.nullGeometryFeatures_ = {};\n    var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\n    this.dispatchEvent(clearEvent);\n    this.changed();\n  };\n  VectorSource2.prototype.forEachFeature = function(callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEach(callback);\n    } else if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  };\n  VectorSource2.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {\n    var extent2 = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n    return this.forEachFeatureInExtent(extent2, function(feature2) {\n      var geometry = feature2.getGeometry();\n      if (geometry.intersectsCoordinate(coordinate)) {\n        return callback(feature2);\n      } else {\n        return void 0;\n      }\n    });\n  };\n  VectorSource2.prototype.forEachFeatureInExtent = function(extent2, callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEachInExtent(extent2, callback);\n    } else if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  };\n  VectorSource2.prototype.forEachFeatureIntersectingExtent = function(extent2, callback) {\n    return this.forEachFeatureInExtent(extent2, function(feature2) {\n      var geometry = feature2.getGeometry();\n      if (geometry.intersectsExtent(extent2)) {\n        var result = callback(feature2);\n        if (result) {\n          return result;\n        }\n      }\n    });\n  };\n  VectorSource2.prototype.getFeaturesCollection = function() {\n    return this.featuresCollection_;\n  };\n  VectorSource2.prototype.getFeatures = function() {\n    var features;\n    if (this.featuresCollection_) {\n      features = this.featuresCollection_.getArray().slice(0);\n    } else if (this.featuresRtree_) {\n      features = this.featuresRtree_.getAll();\n      if (!isEmpty(this.nullGeometryFeatures_)) {\n        extend$3(features, getValues(this.nullGeometryFeatures_));\n      }\n    }\n    return features;\n  };\n  VectorSource2.prototype.getFeaturesAtCoordinate = function(coordinate) {\n    var features = [];\n    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature2) {\n      features.push(feature2);\n    });\n    return features;\n  };\n  VectorSource2.prototype.getFeaturesInExtent = function(extent2) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.getInExtent(extent2);\n    } else if (this.featuresCollection_) {\n      return this.featuresCollection_.getArray().slice(0);\n    } else {\n      return [];\n    }\n  };\n  VectorSource2.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {\n    var x2 = coordinate[0];\n    var y2 = coordinate[1];\n    var closestFeature = null;\n    var closestPoint = [NaN, NaN];\n    var minSquaredDistance = Infinity;\n    var extent2 = [-Infinity, -Infinity, Infinity, Infinity];\n    var filter = opt_filter ? opt_filter : TRUE;\n    this.featuresRtree_.forEachInExtent(extent2, function(feature2) {\n      if (filter(feature2)) {\n        var geometry = feature2.getGeometry();\n        var previousMinSquaredDistance = minSquaredDistance;\n        minSquaredDistance = geometry.closestPointXY(x2, y2, closestPoint, minSquaredDistance);\n        if (minSquaredDistance < previousMinSquaredDistance) {\n          closestFeature = feature2;\n          var minDistance = Math.sqrt(minSquaredDistance);\n          extent2[0] = x2 - minDistance;\n          extent2[1] = y2 - minDistance;\n          extent2[2] = x2 + minDistance;\n          extent2[3] = y2 + minDistance;\n        }\n      }\n    });\n    return closestFeature;\n  };\n  VectorSource2.prototype.getExtent = function(opt_extent) {\n    return this.featuresRtree_.getExtent(opt_extent);\n  };\n  VectorSource2.prototype.getFeatureById = function(id) {\n    var feature2 = this.idIndex_[id.toString()];\n    return feature2 !== void 0 ? feature2 : null;\n  };\n  VectorSource2.prototype.getFeatureByUid = function(uid2) {\n    var feature2 = this.uidIndex_[uid2];\n    return feature2 !== void 0 ? feature2 : null;\n  };\n  VectorSource2.prototype.getFormat = function() {\n    return this.format_;\n  };\n  VectorSource2.prototype.getOverlaps = function() {\n    return this.overlaps_;\n  };\n  VectorSource2.prototype.getUrl = function() {\n    return this.url_;\n  };\n  VectorSource2.prototype.handleFeatureChange_ = function(event) {\n    var feature2 = event.target;\n    var featureKey = getUid(feature2);\n    var geometry = feature2.getGeometry();\n    if (!geometry) {\n      if (!(featureKey in this.nullGeometryFeatures_)) {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.remove(feature2);\n        }\n        this.nullGeometryFeatures_[featureKey] = feature2;\n      }\n    } else {\n      var extent2 = geometry.getExtent();\n      if (featureKey in this.nullGeometryFeatures_) {\n        delete this.nullGeometryFeatures_[featureKey];\n        if (this.featuresRtree_) {\n          this.featuresRtree_.insert(extent2, feature2);\n        }\n      } else {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.update(extent2, feature2);\n        }\n      }\n    }\n    var id = feature2.getId();\n    if (id !== void 0) {\n      var sid = id.toString();\n      if (this.idIndex_[sid] !== feature2) {\n        this.removeFromIdIndex_(feature2);\n        this.idIndex_[sid] = feature2;\n      }\n    } else {\n      this.removeFromIdIndex_(feature2);\n      this.uidIndex_[featureKey] = feature2;\n    }\n    this.changed();\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature2));\n  };\n  VectorSource2.prototype.hasFeature = function(feature2) {\n    var id = feature2.getId();\n    if (id !== void 0) {\n      return id in this.idIndex_;\n    } else {\n      return getUid(feature2) in this.uidIndex_;\n    }\n  };\n  VectorSource2.prototype.isEmpty = function() {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);\n    }\n    if (this.featuresCollection_) {\n      return this.featuresCollection_.getLength() === 0;\n    }\n    return true;\n  };\n  VectorSource2.prototype.loadFeatures = function(extent2, resolution, projection) {\n    var loadedExtentsRtree = this.loadedExtentsRtree_;\n    var extentsToLoad = this.strategy_(extent2, resolution, projection);\n    var _loop_1 = function(i3, ii2) {\n      var extentToLoad = extentsToLoad[i3];\n      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, function(object) {\n        return containsExtent(object.extent, extentToLoad);\n      });\n      if (!alreadyLoaded) {\n        ++this_1.loadingExtentsCount_;\n        this_1.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));\n        this_1.loader_.call(this_1, extentToLoad, resolution, projection, function(features) {\n          --this.loadingExtentsCount_;\n          this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, void 0, features));\n        }.bind(this_1), function() {\n          --this.loadingExtentsCount_;\n          this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));\n        }.bind(this_1));\n        loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });\n      }\n    };\n    var this_1 = this;\n    for (var i2 = 0, ii = extentsToLoad.length; i2 < ii; ++i2) {\n      _loop_1(i2);\n    }\n    this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;\n  };\n  VectorSource2.prototype.refresh = function() {\n    this.clear(true);\n    this.loadedExtentsRtree_.clear();\n    _super.prototype.refresh.call(this);\n  };\n  VectorSource2.prototype.removeLoadedExtent = function(extent2) {\n    var loadedExtentsRtree = this.loadedExtentsRtree_;\n    var obj;\n    loadedExtentsRtree.forEachInExtent(extent2, function(object) {\n      if (equals$1(object.extent, extent2)) {\n        obj = object;\n        return true;\n      }\n    });\n    if (obj) {\n      loadedExtentsRtree.remove(obj);\n    }\n  };\n  VectorSource2.prototype.removeFeature = function(feature2) {\n    if (!feature2) {\n      return;\n    }\n    var featureKey = getUid(feature2);\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature2);\n      }\n    }\n    var result = this.removeFeatureInternal(feature2);\n    if (result) {\n      this.changed();\n    }\n  };\n  VectorSource2.prototype.removeFeatureInternal = function(feature2) {\n    var featureKey = getUid(feature2);\n    var featureChangeKeys = this.featureChangeKeys_[featureKey];\n    if (!featureChangeKeys) {\n      return;\n    }\n    featureChangeKeys.forEach(unlistenByKey);\n    delete this.featureChangeKeys_[featureKey];\n    var id = feature2.getId();\n    if (id !== void 0) {\n      delete this.idIndex_[id.toString()];\n    }\n    delete this.uidIndex_[featureKey];\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature2));\n    return feature2;\n  };\n  VectorSource2.prototype.removeFromIdIndex_ = function(feature2) {\n    var removed = false;\n    for (var id in this.idIndex_) {\n      if (this.idIndex_[id] === feature2) {\n        delete this.idIndex_[id];\n        removed = true;\n        break;\n      }\n    }\n    return removed;\n  };\n  VectorSource2.prototype.setLoader = function(loader) {\n    this.loader_ = loader;\n  };\n  VectorSource2.prototype.setUrl = function(url) {\n    assert(this.format_, 7);\n    this.url_ = url;\n    this.setLoader(xhr(url, this.format_));\n  };\n  return VectorSource2;\n}(ol_source_Source);\nvar ol_source_Vector = VectorSource;\nvar __extends$14 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Mode = {\n  POINT: \"Point\",\n  LINE_STRING: \"LineString\",\n  POLYGON: \"Polygon\",\n  CIRCLE: \"Circle\"\n};\nvar DrawEventType = {\n  DRAWSTART: \"drawstart\",\n  DRAWEND: \"drawend\",\n  DRAWABORT: \"drawabort\"\n};\nvar DrawEvent = function(_super) {\n  __extends$14(DrawEvent2, _super);\n  function DrawEvent2(type, feature2) {\n    var _this = _super.call(this, type) || this;\n    _this.feature = feature2;\n    return _this;\n  }\n  return DrawEvent2;\n}(Event$1);\nvar Draw = function(_super) {\n  __extends$14(Draw2, _super);\n  function Draw2(options) {\n    var _this = this;\n    var pointerOptions = options;\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this = _super.call(this, pointerOptions) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.shouldHandle_ = false;\n    _this.downPx_ = null;\n    _this.downTimeout_;\n    _this.lastDragTime_;\n    _this.pointerType_;\n    _this.freehand_ = false;\n    _this.source_ = options.source ? options.source : null;\n    _this.features_ = options.features ? options.features : null;\n    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n    _this.type_ = options.type;\n    _this.mode_ = getMode(_this.type_);\n    _this.stopClick_ = !!options.stopClick;\n    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;\n    _this.maxPoints_ = _this.mode_ === Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;\n    _this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;\n    var geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      var mode_1 = _this.mode_;\n      if (mode_1 === Mode.CIRCLE) {\n        geometryFunction = function(coordinates2, geometry, projection) {\n          var circle = geometry ? geometry : new ol_geom_Circle([NaN, NaN]);\n          var center = fromUserCoordinate(coordinates2[0]);\n          var squaredLength = squaredDistance(center, fromUserCoordinate(coordinates2[coordinates2.length - 1]));\n          circle.setCenterAndRadius(center, Math.sqrt(squaredLength));\n          return circle;\n        };\n      } else {\n        var Constructor_1;\n        if (mode_1 === Mode.POINT) {\n          Constructor_1 = Point$4;\n        } else if (mode_1 === Mode.LINE_STRING) {\n          Constructor_1 = LineString$2;\n        } else if (mode_1 === Mode.POLYGON) {\n          Constructor_1 = Polygon$2;\n        }\n        geometryFunction = function(coordinates2, geometry, projection) {\n          if (geometry) {\n            if (mode_1 === Mode.POLYGON) {\n              if (coordinates2[0].length) {\n                geometry.setCoordinates([\n                  coordinates2[0].concat([coordinates2[0][0]])\n                ]);\n              } else {\n                geometry.setCoordinates([]);\n              }\n            } else {\n              geometry.setCoordinates(coordinates2);\n            }\n          } else {\n            geometry = new Constructor_1(coordinates2);\n          }\n          return geometry;\n        };\n      }\n    }\n    _this.geometryFunction_ = geometryFunction;\n    _this.dragVertexDelay_ = options.dragVertexDelay !== void 0 ? options.dragVertexDelay : 500;\n    _this.finishCoordinate_ = null;\n    _this.sketchFeature_ = null;\n    _this.sketchPoint_ = null;\n    _this.sketchCoords_ = null;\n    _this.sketchLine_ = null;\n    _this.sketchLineCoords_ = null;\n    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;\n    _this.overlay_ = new ol_layer_Vector({\n      source: new ol_source_Vector({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction$2(),\n      updateWhileInteracting: true\n    });\n    _this.geometryName_ = options.geometryName;\n    _this.condition_ = options.condition ? options.condition : noModifierKeys;\n    _this.freehandCondition_;\n    if (options.freehand) {\n      _this.freehandCondition_ = always;\n    } else {\n      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;\n    }\n    _this.addChangeListener(InteractionProperty.ACTIVE, _this.updateState_);\n    return _this;\n  }\n  Draw2.prototype.setMap = function(map) {\n    _super.prototype.setMap.call(this, map);\n    this.updateState_();\n  };\n  Draw2.prototype.getOverlay = function() {\n    return this.overlay_;\n  };\n  Draw2.prototype.handleEvent = function(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n    var move = event.type === MapBrowserEventType.POINTERMOVE;\n    var pass = true;\n    if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {\n      var now2 = Date.now();\n      if (now2 - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = void 0;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== void 0) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = void 0;\n      }\n    }\n    if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          event.originalEvent.preventDefault();\n        }\n      } else if (event.originalEvent.pointerType === \"mouse\" || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === void 0) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n    return _super.prototype.handleEvent.call(this, event) && pass;\n  };\n  Draw2.prototype.handleDownEvent = function(event) {\n    this.shouldHandle_ = !this.freehand_;\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    } else if (this.condition_(event)) {\n      this.lastDragTime_ = Date.now();\n      this.downTimeout_ = setTimeout(function() {\n        this.handlePointerMove_(new MapBrowserEvent$1(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));\n      }.bind(this), this.dragVertexDelay_);\n      this.downPx_ = event.pixel;\n      return true;\n    } else {\n      this.lastDragTime_ = void 0;\n      return false;\n    }\n  };\n  Draw2.prototype.handleUpEvent = function(event) {\n    var pass = true;\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = void 0;\n      }\n      this.handlePointerMove_(event);\n      if (this.shouldHandle_) {\n        var startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (!this.freehand_ && (!startingToDraw || this.mode_ === Mode.POINT)) {\n          if (this.atFinish_(event.pixel)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  };\n  Draw2.prototype.handlePointerMove_ = function(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {\n      var downPx = this.downPx_;\n      var clickPx = event.pixel;\n      var dx = downPx[0] - clickPx[0];\n      var dy = downPx[1] - clickPx[1];\n      var squaredDistance2 = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_ ? squaredDistance2 > this.squaredClickTolerance_ : squaredDistance2 <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n    if (this.finishCoordinate_) {\n      this.modifyDrawing_(event.coordinate);\n    } else {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n    }\n  };\n  Draw2.prototype.atFinish_ = function(pixel) {\n    var at2 = false;\n    if (this.sketchFeature_) {\n      var potentiallyDone = false;\n      var potentiallyFinishCoordinates = [this.finishCoordinate_];\n      var mode2 = this.mode_;\n      if (mode2 === Mode.POINT) {\n        at2 = true;\n      } else if (mode2 === Mode.CIRCLE) {\n        at2 = this.sketchCoords_.length === 2;\n      } else if (mode2 === Mode.LINE_STRING) {\n        potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n      } else if (mode2 === Mode.POLYGON) {\n        var sketchCoords = this.sketchCoords_;\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2]\n        ];\n      }\n      if (potentiallyDone) {\n        var map = this.getMap();\n        for (var i2 = 0, ii = potentiallyFinishCoordinates.length; i2 < ii; i2++) {\n          var finishCoordinate = potentiallyFinishCoordinates[i2];\n          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          var dx = pixel[0] - finishPixel[0];\n          var dy = pixel[1] - finishPixel[1];\n          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at2 = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at2) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at2;\n  };\n  Draw2.prototype.createOrUpdateSketchPoint_ = function(coordinates2) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new feature(new Point$4(coordinates2));\n      this.updateSketchFeatures_();\n    } else {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates2);\n    }\n  };\n  Draw2.prototype.createOrUpdateCustomSketchLine_ = function(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new feature();\n    }\n    var ring = geometry.getLinearRing(0);\n    var sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString$2(ring.getFlatCoordinates(), ring.getLayout());\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n      sketchLineGeom.changed();\n    }\n  };\n  Draw2.prototype.startDrawing_ = function(start2) {\n    var projection = this.getMap().getView().getProjection();\n    this.finishCoordinate_ = start2;\n    if (this.mode_ === Mode.POINT) {\n      this.sketchCoords_ = start2.slice();\n    } else if (this.mode_ === Mode.POLYGON) {\n      this.sketchCoords_ = [[start2.slice(), start2.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start2.slice(), start2.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new feature(new LineString$2(this.sketchLineCoords_));\n    }\n    var geometry = this.geometryFunction_(this.sketchCoords_, void 0, projection);\n    this.sketchFeature_ = new feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  Draw2.prototype.modifyDrawing_ = function(coordinate) {\n    var map = this.getMap();\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = map.getView().getProjection();\n    var coordinates2, last;\n    if (this.mode_ === Mode.POINT) {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates2 = this.sketchCoords_[0];\n      last = coordinates2[coordinates2.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates2 = this.sketchCoords_;\n      last = coordinates2[coordinates2.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    if (this.sketchPoint_) {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === GeometryType.POLYGON && this.mode_ !== Mode.POLYGON) {\n      this.createOrUpdateCustomSketchLine_(geometry);\n    } else if (this.sketchLineCoords_) {\n      var sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  };\n  Draw2.prototype.addToDrawing_ = function(coordinate) {\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n    var done;\n    var coordinates2;\n    var mode2 = this.mode_;\n    if (mode2 === Mode.LINE_STRING || mode2 === Mode.CIRCLE) {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates2 = this.sketchCoords_;\n      if (coordinates2.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates2.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates2.push(coordinate.slice());\n      this.geometryFunction_(coordinates2, geometry, projection);\n    } else if (mode2 === Mode.POLYGON) {\n      coordinates2 = this.sketchCoords_[0];\n      if (coordinates2.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates2.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates2.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates2[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  };\n  Draw2.prototype.removeLastPoint = function() {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    var geometry = this.sketchFeature_.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n    var coordinates2;\n    var mode2 = this.mode_;\n    if (mode2 === Mode.LINE_STRING || mode2 === Mode.CIRCLE) {\n      coordinates2 = this.sketchCoords_;\n      coordinates2.splice(-2, 1);\n      if (coordinates2.length >= 2) {\n        this.finishCoordinate_ = coordinates2[coordinates2.length - 2].slice();\n        var finishCoordinate = this.finishCoordinate_.slice();\n        coordinates2[coordinates2.length - 1] = finishCoordinate;\n        this.createOrUpdateSketchPoint_(finishCoordinate);\n      }\n      this.geometryFunction_(coordinates2, geometry, projection);\n      if (geometry.getType() === GeometryType.POLYGON && this.sketchLine_) {\n        this.createOrUpdateCustomSketchLine_(geometry);\n      }\n    } else if (mode2 === Mode.POLYGON) {\n      coordinates2 = this.sketchCoords_[0];\n      coordinates2.splice(-2, 1);\n      var sketchLineGeom = this.sketchLine_.getGeometry();\n      if (coordinates2.length >= 2) {\n        var finishCoordinate = coordinates2[coordinates2.length - 2].slice();\n        coordinates2[coordinates2.length - 1] = finishCoordinate;\n        this.createOrUpdateSketchPoint_(finishCoordinate);\n      }\n      sketchLineGeom.setCoordinates(coordinates2);\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    if (coordinates2.length === 1) {\n      this.abortDrawing();\n    }\n    this.updateSketchFeatures_();\n  };\n  Draw2.prototype.finishDrawing = function() {\n    var sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return;\n    }\n    var coordinates2 = this.sketchCoords_;\n    var geometry = sketchFeature.getGeometry();\n    var projection = this.getMap().getView().getProjection();\n    if (this.mode_ === Mode.LINE_STRING) {\n      coordinates2.pop();\n      this.geometryFunction_(coordinates2, geometry, projection);\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates2[0].pop();\n      this.geometryFunction_(coordinates2, geometry, projection);\n      coordinates2 = geometry.getCoordinates();\n    }\n    if (this.type_ === GeometryType.MULTI_POINT) {\n      sketchFeature.setGeometry(new MultiPoint$2([coordinates2]));\n    } else if (this.type_ === GeometryType.MULTI_LINE_STRING) {\n      sketchFeature.setGeometry(new MultiLineString$2([coordinates2]));\n    } else if (this.type_ === GeometryType.MULTI_POLYGON) {\n      sketchFeature.setGeometry(new MultiPolygon$2([coordinates2]));\n    }\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  };\n  Draw2.prototype.abortDrawing_ = function() {\n    this.finishCoordinate_ = null;\n    var sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    return sketchFeature;\n  };\n  Draw2.prototype.abortDrawing = function() {\n    var sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  };\n  Draw2.prototype.appendCoordinates = function(coordinates2) {\n    var mode2 = this.mode_;\n    var newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates2[0]);\n    }\n    var sketchCoords;\n    if (mode2 === Mode.LINE_STRING || mode2 === Mode.CIRCLE) {\n      sketchCoords = this.sketchCoords_;\n    } else if (mode2 === Mode.POLYGON) {\n      sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];\n    } else {\n      return;\n    }\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n    sketchCoords.pop();\n    for (var i2 = 0; i2 < coordinates2.length; i2++) {\n      this.addToDrawing_(coordinates2[i2]);\n    }\n    var ending = coordinates2[coordinates2.length - 1];\n    this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  };\n  Draw2.prototype.extend = function(feature$1) {\n    var geometry = feature$1.getGeometry();\n    var lineString = geometry;\n    this.sketchFeature_ = feature$1;\n    this.sketchCoords_ = lineString.getCoordinates();\n    var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new feature(new Point$4(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  Draw2.prototype.updateSketchFeatures_ = function() {\n    var sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    var overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  };\n  Draw2.prototype.updateState_ = function() {\n    var map = this.getMap();\n    var active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  };\n  return Draw2;\n}(ol_interaction_Pointer);\nfunction getDefaultStyleFunction$2() {\n  var styles = createEditingStyle();\n  return function(feature2, resolution) {\n    return styles[feature2.getGeometry().getType()];\n  };\n}\nfunction getMode(type) {\n  switch (type) {\n    case GeometryType.POINT:\n    case GeometryType.MULTI_POINT:\n      return Mode.POINT;\n    case GeometryType.LINE_STRING:\n    case GeometryType.MULTI_LINE_STRING:\n      return Mode.LINE_STRING;\n    case GeometryType.POLYGON:\n    case GeometryType.MULTI_POLYGON:\n      return Mode.POLYGON;\n    case GeometryType.CIRCLE:\n      return Mode.CIRCLE;\n    default:\n      throw new Error(\"Invalid type: \" + type);\n  }\n}\nvar Draw$1 = Draw;\nvar __extends$13 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CIRCLE_CENTER_INDEX = 0;\nvar CIRCLE_CIRCUMFERENCE_INDEX = 1;\nvar tempExtent = [0, 0, 0, 0];\nvar tempSegment$1 = [];\nvar ModifyEventType = {\n  MODIFYSTART: \"modifystart\",\n  MODIFYEND: \"modifyend\"\n};\nvar ModifyEvent = function(_super) {\n  __extends$13(ModifyEvent2, _super);\n  function ModifyEvent2(type, features, mapBrowserEvent) {\n    var _this = _super.call(this, type) || this;\n    _this.features = features;\n    _this.mapBrowserEvent = mapBrowserEvent;\n    return _this;\n  }\n  return ModifyEvent2;\n}(Event$1);\nvar Modify = function(_super) {\n  __extends$13(Modify2, _super);\n  function Modify2(options) {\n    var _this = _super.call(this, options) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);\n    _this.condition_ = options.condition ? options.condition : primaryAction;\n    _this.defaultDeleteCondition_ = function(mapBrowserEvent) {\n      return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\n    };\n    _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;\n    _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : always;\n    _this.vertexFeature_ = null;\n    _this.vertexSegments_ = null;\n    _this.lastPixel_ = [0, 0];\n    _this.ignoreNextSingleClick_ = false;\n    _this.featuresBeingModified_ = null;\n    _this.rBush_ = new RBush$1();\n    _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;\n    _this.snappedToVertex_ = false;\n    _this.changingFeature_ = false;\n    _this.dragSegments_ = [];\n    _this.overlay_ = new ol_layer_Vector({\n      source: new ol_source_Vector({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction$1(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true\n    });\n    _this.SEGMENT_WRITERS_ = {\n      \"Point\": _this.writePointGeometry_.bind(_this),\n      \"LineString\": _this.writeLineStringGeometry_.bind(_this),\n      \"LinearRing\": _this.writeLineStringGeometry_.bind(_this),\n      \"Polygon\": _this.writePolygonGeometry_.bind(_this),\n      \"MultiPoint\": _this.writeMultiPointGeometry_.bind(_this),\n      \"MultiLineString\": _this.writeMultiLineStringGeometry_.bind(_this),\n      \"MultiPolygon\": _this.writeMultiPolygonGeometry_.bind(_this),\n      \"Circle\": _this.writeCircleGeometry_.bind(_this),\n      \"GeometryCollection\": _this.writeGeometryCollectionGeometry_.bind(_this)\n    };\n    _this.source_ = null;\n    _this.hitDetection_ = null;\n    var features;\n    if (options.features) {\n      features = options.features;\n    } else if (options.source) {\n      _this.source_ = options.source;\n      features = new ol_Collection(_this.source_.getFeatures());\n      _this.source_.addEventListener(VectorEventType.ADDFEATURE, _this.handleSourceAdd_.bind(_this));\n      _this.source_.addEventListener(VectorEventType.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));\n    }\n    if (!features) {\n      throw new Error(\"The modify interaction requires features, a source or a layer\");\n    }\n    if (options.hitDetection) {\n      _this.hitDetection_ = options.hitDetection;\n    }\n    _this.features_ = features;\n    _this.features_.forEach(_this.addFeature_.bind(_this));\n    _this.features_.addEventListener(CollectionEventType.ADD, _this.handleFeatureAdd_.bind(_this));\n    _this.features_.addEventListener(CollectionEventType.REMOVE, _this.handleFeatureRemove_.bind(_this));\n    _this.lastPointerEvent_ = null;\n    _this.delta_ = [0, 0];\n    _this.snapToPointer_ = options.snapToPointer === void 0 ? !_this.hitDetection_ : options.snapToPointer;\n    return _this;\n  }\n  Modify2.prototype.addFeature_ = function(feature2) {\n    var geometry = feature2.getGeometry();\n    if (geometry) {\n      var writer = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (writer) {\n        writer(feature2, geometry);\n      }\n    }\n    var map = this.getMap();\n    if (map && map.isRendered() && this.getActive()) {\n      this.handlePointerAtPixel_(this.lastPixel_, map);\n    }\n    feature2.addEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);\n  };\n  Modify2.prototype.willModifyFeatures_ = function(evt, segments) {\n    if (!this.featuresBeingModified_) {\n      this.featuresBeingModified_ = new ol_Collection();\n      var features = this.featuresBeingModified_.getArray();\n      for (var i2 = 0, ii = segments.length; i2 < ii; ++i2) {\n        var segment = segments[i2];\n        for (var s2 = 0, ss = segment.length; s2 < ss; ++s2) {\n          var feature2 = segment[s2].feature;\n          if (feature2 && features.indexOf(feature2) === -1) {\n            this.featuresBeingModified_.push(feature2);\n          }\n        }\n      }\n      if (this.featuresBeingModified_.getLength() === 0) {\n        this.featuresBeingModified_ = null;\n      } else {\n        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));\n      }\n    }\n  };\n  Modify2.prototype.removeFeature_ = function(feature2) {\n    this.removeFeatureSegmentData_(feature2);\n    if (this.vertexFeature_ && this.features_.getLength() === 0) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    feature2.removeEventListener(EventType.CHANGE, this.boundHandleFeatureChange_);\n  };\n  Modify2.prototype.removeFeatureSegmentData_ = function(feature2) {\n    var rBush = this.rBush_;\n    var nodesToRemove = [];\n    rBush.forEach(function(node2) {\n      if (feature2 === node2.feature) {\n        nodesToRemove.push(node2);\n      }\n    });\n    for (var i2 = nodesToRemove.length - 1; i2 >= 0; --i2) {\n      var nodeToRemove = nodesToRemove[i2];\n      for (var j2 = this.dragSegments_.length - 1; j2 >= 0; --j2) {\n        if (this.dragSegments_[j2][0] === nodeToRemove) {\n          this.dragSegments_.splice(j2, 1);\n        }\n      }\n      rBush.remove(nodeToRemove);\n    }\n  };\n  Modify2.prototype.setActive = function(active) {\n    if (this.vertexFeature_ && !active) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n    _super.prototype.setActive.call(this, active);\n  };\n  Modify2.prototype.setMap = function(map) {\n    this.overlay_.setMap(map);\n    _super.prototype.setMap.call(this, map);\n  };\n  Modify2.prototype.getOverlay = function() {\n    return this.overlay_;\n  };\n  Modify2.prototype.handleSourceAdd_ = function(event) {\n    if (event.feature) {\n      this.features_.push(event.feature);\n    }\n  };\n  Modify2.prototype.handleSourceRemove_ = function(event) {\n    if (event.feature) {\n      this.features_.remove(event.feature);\n    }\n  };\n  Modify2.prototype.handleFeatureAdd_ = function(evt) {\n    this.addFeature_(evt.element);\n  };\n  Modify2.prototype.handleFeatureChange_ = function(evt) {\n    if (!this.changingFeature_) {\n      var feature2 = evt.target;\n      this.removeFeature_(feature2);\n      this.addFeature_(feature2);\n    }\n  };\n  Modify2.prototype.handleFeatureRemove_ = function(evt) {\n    var feature2 = evt.element;\n    this.removeFeature_(feature2);\n  };\n  Modify2.prototype.writePointGeometry_ = function(feature2, geometry) {\n    var coordinates2 = geometry.getCoordinates();\n    var segmentData = {\n      feature: feature2,\n      geometry,\n      segment: [coordinates2, coordinates2]\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n  Modify2.prototype.writeMultiPointGeometry_ = function(feature2, geometry) {\n    var points = geometry.getCoordinates();\n    for (var i2 = 0, ii = points.length; i2 < ii; ++i2) {\n      var coordinates2 = points[i2];\n      var segmentData = {\n        feature: feature2,\n        geometry,\n        depth: [i2],\n        index: i2,\n        segment: [coordinates2, coordinates2]\n      };\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n  Modify2.prototype.writeLineStringGeometry_ = function(feature2, geometry) {\n    var coordinates2 = geometry.getCoordinates();\n    for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n      var segment = coordinates2.slice(i2, i2 + 2);\n      var segmentData = {\n        feature: feature2,\n        geometry,\n        index: i2,\n        segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n  Modify2.prototype.writeMultiLineStringGeometry_ = function(feature2, geometry) {\n    var lines = geometry.getCoordinates();\n    for (var j2 = 0, jj = lines.length; j2 < jj; ++j2) {\n      var coordinates2 = lines[j2];\n      for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n        var segment = coordinates2.slice(i2, i2 + 2);\n        var segmentData = {\n          feature: feature2,\n          geometry,\n          depth: [j2],\n          index: i2,\n          segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  Modify2.prototype.writePolygonGeometry_ = function(feature2, geometry) {\n    var rings = geometry.getCoordinates();\n    for (var j2 = 0, jj = rings.length; j2 < jj; ++j2) {\n      var coordinates2 = rings[j2];\n      for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n        var segment = coordinates2.slice(i2, i2 + 2);\n        var segmentData = {\n          feature: feature2,\n          geometry,\n          depth: [j2],\n          index: i2,\n          segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  Modify2.prototype.writeMultiPolygonGeometry_ = function(feature2, geometry) {\n    var polygons = geometry.getCoordinates();\n    for (var k2 = 0, kk = polygons.length; k2 < kk; ++k2) {\n      var rings = polygons[k2];\n      for (var j2 = 0, jj = rings.length; j2 < jj; ++j2) {\n        var coordinates2 = rings[j2];\n        for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n          var segment = coordinates2.slice(i2, i2 + 2);\n          var segmentData = {\n            feature: feature2,\n            geometry,\n            depth: [j2, k2],\n            index: i2,\n            segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n  Modify2.prototype.writeCircleGeometry_ = function(feature2, geometry) {\n    var coordinates2 = geometry.getCenter();\n    var centerSegmentData = {\n      feature: feature2,\n      geometry,\n      index: CIRCLE_CENTER_INDEX,\n      segment: [coordinates2, coordinates2]\n    };\n    var circumferenceSegmentData = {\n      feature: feature2,\n      geometry,\n      index: CIRCLE_CIRCUMFERENCE_INDEX,\n      segment: [coordinates2, coordinates2]\n    };\n    var featureSegments = [centerSegmentData, circumferenceSegmentData];\n    centerSegmentData.featureSegments = featureSegments;\n    circumferenceSegmentData.featureSegments = featureSegments;\n    this.rBush_.insert(createOrUpdateFromCoordinate(coordinates2), centerSegmentData);\n    var circleGeometry = geometry;\n    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);\n  };\n  Modify2.prototype.writeGeometryCollectionGeometry_ = function(feature2, geometry) {\n    var geometries = geometry.getGeometriesArray();\n    for (var i2 = 0; i2 < geometries.length; ++i2) {\n      var geometry_1 = geometries[i2];\n      var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];\n      writer(feature2, geometry_1);\n    }\n  };\n  Modify2.prototype.createOrUpdateVertexFeature_ = function(coordinates2, features, geometries) {\n    var vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new feature(new Point$4(coordinates2));\n      this.vertexFeature_ = vertexFeature;\n      this.overlay_.getSource().addFeature(vertexFeature);\n    } else {\n      var geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(coordinates2);\n    }\n    vertexFeature.set(\"features\", features);\n    vertexFeature.set(\"geometries\", geometries);\n    return vertexFeature;\n  };\n  Modify2.prototype.handleEvent = function(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n    this.lastPointerEvent_ = mapBrowserEvent;\n    var handled;\n    if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n      if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {\n        handled = this.removePoint();\n      } else {\n        handled = true;\n      }\n    }\n    if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\n      this.ignoreNextSingleClick_ = false;\n    }\n    return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;\n  };\n  Modify2.prototype.handleDragEvent = function(evt) {\n    this.ignoreNextSingleClick_ = false;\n    this.willModifyFeatures_(evt, this.dragSegments_);\n    var vertex = [\n      evt.coordinate[0] + this.delta_[0],\n      evt.coordinate[1] + this.delta_[1]\n    ];\n    var features = [];\n    var geometries = [];\n    for (var i2 = 0, ii = this.dragSegments_.length; i2 < ii; ++i2) {\n      var dragSegment = this.dragSegments_[i2];\n      var segmentData = dragSegment[0];\n      var feature2 = segmentData.feature;\n      if (features.indexOf(feature2) === -1) {\n        features.push(feature2);\n      }\n      var geometry = segmentData.geometry;\n      if (geometries.indexOf(geometry) === -1) {\n        geometries.push(geometry);\n      }\n      var depth = segmentData.depth;\n      var coordinates2 = void 0;\n      var segment = segmentData.segment;\n      var index2 = dragSegment[1];\n      while (vertex.length < geometry.getStride()) {\n        vertex.push(segment[index2][vertex.length]);\n      }\n      switch (geometry.getType()) {\n        case GeometryType.POINT:\n          coordinates2 = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case GeometryType.MULTI_POINT:\n          coordinates2 = geometry.getCoordinates();\n          coordinates2[segmentData.index] = vertex;\n          segment[0] = vertex;\n          segment[1] = vertex;\n          break;\n        case GeometryType.LINE_STRING:\n          coordinates2 = geometry.getCoordinates();\n          coordinates2[segmentData.index + index2] = vertex;\n          segment[index2] = vertex;\n          break;\n        case GeometryType.MULTI_LINE_STRING:\n          coordinates2 = geometry.getCoordinates();\n          coordinates2[depth[0]][segmentData.index + index2] = vertex;\n          segment[index2] = vertex;\n          break;\n        case GeometryType.POLYGON:\n          coordinates2 = geometry.getCoordinates();\n          coordinates2[depth[0]][segmentData.index + index2] = vertex;\n          segment[index2] = vertex;\n          break;\n        case GeometryType.MULTI_POLYGON:\n          coordinates2 = geometry.getCoordinates();\n          coordinates2[depth[1]][depth[0]][segmentData.index + index2] = vertex;\n          segment[index2] = vertex;\n          break;\n        case GeometryType.CIRCLE:\n          segment[0] = vertex;\n          segment[1] = vertex;\n          if (segmentData.index === CIRCLE_CENTER_INDEX) {\n            this.changingFeature_ = true;\n            geometry.setCenter(vertex);\n            this.changingFeature_ = false;\n          } else {\n            this.changingFeature_ = true;\n            var projection = evt.map.getView().getProjection();\n            var radius = distance$1(fromUserCoordinate(geometry.getCenter()), fromUserCoordinate(vertex));\n            var userProjection2 = getUserProjection();\n            if (userProjection2) {\n              var circleGeometry = geometry.clone().transform(userProjection2, projection);\n              circleGeometry.setRadius(radius);\n              radius = circleGeometry.transform(projection, userProjection2).getRadius();\n            }\n            geometry.setRadius(radius);\n            this.changingFeature_ = false;\n          }\n          break;\n      }\n      if (coordinates2) {\n        this.setGeometryCoordinates_(geometry, coordinates2);\n      }\n    }\n    this.createOrUpdateVertexFeature_(vertex, features, geometries);\n  };\n  Modify2.prototype.handleDownEvent = function(evt) {\n    if (!this.condition_(evt)) {\n      return false;\n    }\n    var pixelCoordinate = evt.coordinate;\n    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);\n    this.dragSegments_.length = 0;\n    this.featuresBeingModified_ = null;\n    var vertexFeature = this.vertexFeature_;\n    if (vertexFeature) {\n      var projection = evt.map.getView().getProjection();\n      var insertVertices = [];\n      var vertex = vertexFeature.getGeometry().getCoordinates();\n      var vertexExtent = boundingExtent([vertex]);\n      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n      var componentSegments = {};\n      segmentDataMatches.sort(compareIndexes);\n      for (var i2 = 0, ii = segmentDataMatches.length; i2 < ii; ++i2) {\n        var segmentDataMatch = segmentDataMatches[i2];\n        var segment = segmentDataMatch.segment;\n        var uid2 = getUid(segmentDataMatch.geometry);\n        var depth = segmentDataMatch.depth;\n        if (depth) {\n          uid2 += \"-\" + depth.join(\"-\");\n        }\n        if (!componentSegments[uid2]) {\n          componentSegments[uid2] = new Array(2);\n        }\n        if (segmentDataMatch.geometry.getType() === GeometryType.CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n          var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);\n          if (equals(closestVertex, vertex) && !componentSegments[uid2][0]) {\n            this.dragSegments_.push([segmentDataMatch, 0]);\n            componentSegments[uid2][0] = segmentDataMatch;\n          }\n          continue;\n        }\n        if (equals(segment[0], vertex) && !componentSegments[uid2][0]) {\n          this.dragSegments_.push([segmentDataMatch, 0]);\n          componentSegments[uid2][0] = segmentDataMatch;\n          continue;\n        }\n        if (equals(segment[1], vertex) && !componentSegments[uid2][1]) {\n          if ((segmentDataMatch.geometry.getType() === GeometryType.LINE_STRING || segmentDataMatch.geometry.getType() === GeometryType.MULTI_LINE_STRING) && componentSegments[uid2][0] && componentSegments[uid2][0].index === 0) {\n            continue;\n          }\n          this.dragSegments_.push([segmentDataMatch, 1]);\n          componentSegments[uid2][1] = segmentDataMatch;\n          continue;\n        }\n        if (getUid(segment) in this.vertexSegments_ && !componentSegments[uid2][0] && !componentSegments[uid2][1] && this.insertVertexCondition_(evt)) {\n          insertVertices.push(segmentDataMatch);\n        }\n      }\n      if (insertVertices.length) {\n        this.willModifyFeatures_(evt, [insertVertices]);\n      }\n      for (var j2 = insertVertices.length - 1; j2 >= 0; --j2) {\n        this.insertVertex_(insertVertices[j2], vertex);\n      }\n    }\n    return !!this.vertexFeature_;\n  };\n  Modify2.prototype.handleUpEvent = function(evt) {\n    for (var i2 = this.dragSegments_.length - 1; i2 >= 0; --i2) {\n      var segmentData = this.dragSegments_[i2][0];\n      var geometry = segmentData.geometry;\n      if (geometry.getType() === GeometryType.CIRCLE) {\n        var coordinates2 = geometry.getCenter();\n        var centerSegmentData = segmentData.featureSegments[0];\n        var circumferenceSegmentData = segmentData.featureSegments[1];\n        centerSegmentData.segment[0] = coordinates2;\n        centerSegmentData.segment[1] = coordinates2;\n        circumferenceSegmentData.segment[0] = coordinates2;\n        circumferenceSegmentData.segment[1] = coordinates2;\n        this.rBush_.update(createOrUpdateFromCoordinate(coordinates2), centerSegmentData);\n        var circleGeometry = geometry;\n        var userProjection2 = getUserProjection();\n        if (userProjection2) {\n          var projection = evt.map.getView().getProjection();\n          circleGeometry = circleGeometry.clone().transform(userProjection2, projection);\n          circleGeometry = fromCircle(circleGeometry).transform(projection, userProjection2);\n        }\n        this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);\n      } else {\n        this.rBush_.update(boundingExtent(segmentData.segment), segmentData);\n      }\n    }\n    if (this.featuresBeingModified_) {\n      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));\n      this.featuresBeingModified_ = null;\n    }\n    return false;\n  };\n  Modify2.prototype.handlePointerMove_ = function(evt) {\n    this.lastPixel_ = evt.pixel;\n    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);\n  };\n  Modify2.prototype.handlePointerAtPixel_ = function(pixel, map, opt_coordinate) {\n    var _this = this;\n    var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);\n    var projection = map.getView().getProjection();\n    var sortByDistance = function(a2, b2) {\n      return projectedDistanceToSegmentDataSquared(pixelCoordinate, a2, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b2, projection);\n    };\n    var nodes;\n    var hitPointGeometry;\n    if (this.hitDetection_) {\n      var layerFilter = typeof this.hitDetection_ === \"object\" ? function(layer) {\n        return layer === _this.hitDetection_;\n      } : void 0;\n      map.forEachFeatureAtPixel(pixel, function(feature2, layer, geometry) {\n        geometry = geometry || feature2.getGeometry();\n        if (geometry.getType() === GeometryType.POINT && includes(_this.features_.getArray(), feature2)) {\n          hitPointGeometry = geometry;\n          var coordinate = geometry.getFlatCoordinates().slice(0, 2);\n          nodes = [\n            {\n              feature: feature2,\n              geometry,\n              segment: [coordinate, coordinate]\n            }\n          ];\n        }\n        return true;\n      }, { layerFilter });\n    }\n    if (!nodes) {\n      var viewExtent = fromUserExtent(createOrUpdateFromCoordinate(pixelCoordinate, tempExtent));\n      var buffer2 = map.getView().getResolution() * this.pixelTolerance_;\n      var box = toUserExtent(buffer$1(viewExtent, buffer2, tempExtent));\n      nodes = this.rBush_.getInExtent(box);\n    }\n    if (nodes && nodes.length > 0) {\n      var node2 = nodes.sort(sortByDistance)[0];\n      var closestSegment = node2.segment;\n      var vertex = closestOnSegmentData(pixelCoordinate, node2, projection);\n      var vertexPixel = map.getPixelFromCoordinate(vertex);\n      var dist = distance$1(pixel, vertexPixel);\n      if (hitPointGeometry || dist <= this.pixelTolerance_) {\n        var vertexSegments = {};\n        vertexSegments[getUid(closestSegment)] = true;\n        if (!this.snapToPointer_) {\n          this.delta_[0] = vertex[0] - pixelCoordinate[0];\n          this.delta_[1] = vertex[1] - pixelCoordinate[1];\n        }\n        if (node2.geometry.getType() === GeometryType.CIRCLE && node2.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n          this.snappedToVertex_ = true;\n          this.createOrUpdateVertexFeature_(vertex, [node2.feature], [node2.geometry]);\n        } else {\n          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n          var squaredDist1 = squaredDistance(vertexPixel, pixel1);\n          var squaredDist2 = squaredDistance(vertexPixel, pixel2);\n          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n          this.snappedToVertex_ = dist <= this.pixelTolerance_;\n          if (this.snappedToVertex_) {\n            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          }\n          this.createOrUpdateVertexFeature_(vertex, [node2.feature], [node2.geometry]);\n          var geometries = {};\n          geometries[getUid(node2.geometry)] = true;\n          for (var i2 = 1, ii = nodes.length; i2 < ii; ++i2) {\n            var segment = nodes[i2].segment;\n            if (equals(closestSegment[0], segment[0]) && equals(closestSegment[1], segment[1]) || equals(closestSegment[0], segment[1]) && equals(closestSegment[1], segment[0])) {\n              var geometryUid = getUid(nodes[i2].geometry);\n              if (!(geometryUid in geometries)) {\n                geometries[geometryUid] = true;\n                vertexSegments[getUid(segment)] = true;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n        this.vertexSegments_ = vertexSegments;\n        return;\n      }\n    }\n    if (this.vertexFeature_) {\n      this.overlay_.getSource().removeFeature(this.vertexFeature_);\n      this.vertexFeature_ = null;\n    }\n  };\n  Modify2.prototype.insertVertex_ = function(segmentData, vertex) {\n    var segment = segmentData.segment;\n    var feature2 = segmentData.feature;\n    var geometry = segmentData.geometry;\n    var depth = segmentData.depth;\n    var index2 = segmentData.index;\n    var coordinates2;\n    while (vertex.length < geometry.getStride()) {\n      vertex.push(0);\n    }\n    switch (geometry.getType()) {\n      case GeometryType.MULTI_LINE_STRING:\n        coordinates2 = geometry.getCoordinates();\n        coordinates2[depth[0]].splice(index2 + 1, 0, vertex);\n        break;\n      case GeometryType.POLYGON:\n        coordinates2 = geometry.getCoordinates();\n        coordinates2[depth[0]].splice(index2 + 1, 0, vertex);\n        break;\n      case GeometryType.MULTI_POLYGON:\n        coordinates2 = geometry.getCoordinates();\n        coordinates2[depth[1]][depth[0]].splice(index2 + 1, 0, vertex);\n        break;\n      case GeometryType.LINE_STRING:\n        coordinates2 = geometry.getCoordinates();\n        coordinates2.splice(index2 + 1, 0, vertex);\n        break;\n      default:\n        return;\n    }\n    this.setGeometryCoordinates_(geometry, coordinates2);\n    var rTree = this.rBush_;\n    rTree.remove(segmentData);\n    this.updateSegmentIndices_(geometry, index2, depth, 1);\n    var newSegmentData = {\n      segment: [segment[0], vertex],\n      feature: feature2,\n      geometry,\n      depth,\n      index: index2\n    };\n    rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);\n    this.dragSegments_.push([newSegmentData, 1]);\n    var newSegmentData2 = {\n      segment: [vertex, segment[1]],\n      feature: feature2,\n      geometry,\n      depth,\n      index: index2 + 1\n    };\n    rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\n    this.dragSegments_.push([newSegmentData2, 0]);\n    this.ignoreNextSingleClick_ = true;\n  };\n  Modify2.prototype.removePoint = function() {\n    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {\n      var evt = this.lastPointerEvent_;\n      this.willModifyFeatures_(evt, this.dragSegments_);\n      var removed = this.removeVertex_();\n      if (this.featuresBeingModified_) {\n        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));\n      }\n      this.featuresBeingModified_ = null;\n      return removed;\n    }\n    return false;\n  };\n  Modify2.prototype.removeVertex_ = function() {\n    var dragSegments = this.dragSegments_;\n    var segmentsByFeature = {};\n    var deleted = false;\n    var component, coordinates2, dragSegment, geometry, i2, index2, left;\n    var newIndex, right, segmentData, uid2;\n    for (i2 = dragSegments.length - 1; i2 >= 0; --i2) {\n      dragSegment = dragSegments[i2];\n      segmentData = dragSegment[0];\n      uid2 = getUid(segmentData.feature);\n      if (segmentData.depth) {\n        uid2 += \"-\" + segmentData.depth.join(\"-\");\n      }\n      if (!(uid2 in segmentsByFeature)) {\n        segmentsByFeature[uid2] = {};\n      }\n      if (dragSegment[1] === 0) {\n        segmentsByFeature[uid2].right = segmentData;\n        segmentsByFeature[uid2].index = segmentData.index;\n      } else if (dragSegment[1] == 1) {\n        segmentsByFeature[uid2].left = segmentData;\n        segmentsByFeature[uid2].index = segmentData.index + 1;\n      }\n    }\n    for (uid2 in segmentsByFeature) {\n      right = segmentsByFeature[uid2].right;\n      left = segmentsByFeature[uid2].left;\n      index2 = segmentsByFeature[uid2].index;\n      newIndex = index2 - 1;\n      if (left !== void 0) {\n        segmentData = left;\n      } else {\n        segmentData = right;\n      }\n      if (newIndex < 0) {\n        newIndex = 0;\n      }\n      geometry = segmentData.geometry;\n      coordinates2 = geometry.getCoordinates();\n      component = coordinates2;\n      deleted = false;\n      switch (geometry.getType()) {\n        case GeometryType.MULTI_LINE_STRING:\n          if (coordinates2[segmentData.depth[0]].length > 2) {\n            coordinates2[segmentData.depth[0]].splice(index2, 1);\n            deleted = true;\n          }\n          break;\n        case GeometryType.LINE_STRING:\n          if (coordinates2.length > 2) {\n            coordinates2.splice(index2, 1);\n            deleted = true;\n          }\n          break;\n        case GeometryType.MULTI_POLYGON:\n          component = component[segmentData.depth[1]];\n        case GeometryType.POLYGON:\n          component = component[segmentData.depth[0]];\n          if (component.length > 4) {\n            if (index2 == component.length - 1) {\n              index2 = 0;\n            }\n            component.splice(index2, 1);\n            deleted = true;\n            if (index2 === 0) {\n              component.pop();\n              component.push(component[0]);\n              newIndex = component.length - 1;\n            }\n          }\n          break;\n      }\n      if (deleted) {\n        this.setGeometryCoordinates_(geometry, coordinates2);\n        var segments = [];\n        if (left !== void 0) {\n          this.rBush_.remove(left);\n          segments.push(left.segment[0]);\n        }\n        if (right !== void 0) {\n          this.rBush_.remove(right);\n          segments.push(right.segment[1]);\n        }\n        if (left !== void 0 && right !== void 0) {\n          var newSegmentData = {\n            depth: segmentData.depth,\n            feature: segmentData.feature,\n            geometry: segmentData.geometry,\n            index: newIndex,\n            segment: segments\n          };\n          this.rBush_.insert(boundingExtent(newSegmentData.segment), newSegmentData);\n        }\n        this.updateSegmentIndices_(geometry, index2, segmentData.depth, -1);\n        if (this.vertexFeature_) {\n          this.overlay_.getSource().removeFeature(this.vertexFeature_);\n          this.vertexFeature_ = null;\n        }\n        dragSegments.length = 0;\n      }\n    }\n    return deleted;\n  };\n  Modify2.prototype.setGeometryCoordinates_ = function(geometry, coordinates2) {\n    this.changingFeature_ = true;\n    geometry.setCoordinates(coordinates2);\n    this.changingFeature_ = false;\n  };\n  Modify2.prototype.updateSegmentIndices_ = function(geometry, index2, depth, delta) {\n    this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {\n      if (segmentDataMatch.geometry === geometry && (depth === void 0 || segmentDataMatch.depth === void 0 || equals$2(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index2) {\n        segmentDataMatch.index += delta;\n      }\n    });\n  };\n  return Modify2;\n}(ol_interaction_Pointer);\nfunction compareIndexes(a2, b2) {\n  return a2.index - b2.index;\n}\nfunction projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {\n  var geometry = segmentData.geometry;\n  if (geometry.getType() === GeometryType.CIRCLE) {\n    var circleGeometry = geometry;\n    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n      var userProjection2 = getUserProjection();\n      if (userProjection2) {\n        circleGeometry = circleGeometry.clone().transform(userProjection2, projection);\n      }\n      var distanceToCenterSquared = squaredDistance(circleGeometry.getCenter(), fromUserCoordinate(pointCoordinates));\n      var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n      return distanceToCircumference * distanceToCircumference;\n    }\n  }\n  var coordinate = fromUserCoordinate(pointCoordinates);\n  tempSegment$1[0] = fromUserCoordinate(segmentData.segment[0]);\n  tempSegment$1[1] = fromUserCoordinate(segmentData.segment[1]);\n  return squaredDistanceToSegment(coordinate, tempSegment$1);\n}\nfunction closestOnSegmentData(pointCoordinates, segmentData, projection) {\n  var geometry = segmentData.geometry;\n  if (geometry.getType() === GeometryType.CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {\n    var circleGeometry = geometry;\n    var userProjection2 = getUserProjection();\n    if (userProjection2) {\n      circleGeometry = circleGeometry.clone().transform(userProjection2, projection);\n    }\n    return toUserCoordinate(circleGeometry.getClosestPoint(fromUserCoordinate(pointCoordinates)));\n  }\n  var coordinate = fromUserCoordinate(pointCoordinates);\n  tempSegment$1[0] = fromUserCoordinate(segmentData.segment[0]);\n  tempSegment$1[1] = fromUserCoordinate(segmentData.segment[1]);\n  return toUserCoordinate(closestOnSegment(coordinate, tempSegment$1));\n}\nfunction getDefaultStyleFunction$1() {\n  var style2 = createEditingStyle();\n  return function(feature2, resolution) {\n    return style2[GeometryType.POINT];\n  };\n}\nvar Modify$1 = Modify;\nvar __extends$12 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar SelectEventType = {\n  SELECT: \"select\"\n};\nvar SelectEvent = function(_super) {\n  __extends$12(SelectEvent2, _super);\n  function SelectEvent2(type, selected, deselected, mapBrowserEvent) {\n    var _this = _super.call(this, type) || this;\n    _this.selected = selected;\n    _this.deselected = deselected;\n    _this.mapBrowserEvent = mapBrowserEvent;\n    return _this;\n  }\n  return SelectEvent2;\n}(Event$1);\nvar originalFeatureStyles = {};\nvar Select = function(_super) {\n  __extends$12(Select2, _super);\n  function Select2(opt_options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    var options = opt_options ? opt_options : {};\n    _this.boundAddFeature_ = _this.addFeature_.bind(_this);\n    _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);\n    _this.condition_ = options.condition ? options.condition : singleClick;\n    _this.addCondition_ = options.addCondition ? options.addCondition : never;\n    _this.removeCondition_ = options.removeCondition ? options.removeCondition : never;\n    _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;\n    _this.multi_ = options.multi ? options.multi : false;\n    _this.filter_ = options.filter ? options.filter : TRUE;\n    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n    _this.style_ = options.style !== void 0 ? options.style : getDefaultStyleFunction();\n    _this.features_ = options.features || new ol_Collection();\n    var layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === \"function\") {\n        layerFilter = options.layers;\n      } else {\n        var layers_1 = options.layers;\n        layerFilter = function(layer) {\n          return includes(layers_1, layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n    _this.layerFilter_ = layerFilter;\n    _this.featureLayerAssociation_ = {};\n    return _this;\n  }\n  Select2.prototype.addFeatureLayerAssociation_ = function(feature2, layer) {\n    this.featureLayerAssociation_[getUid(feature2)] = layer;\n  };\n  Select2.prototype.getFeatures = function() {\n    return this.features_;\n  };\n  Select2.prototype.getHitTolerance = function() {\n    return this.hitTolerance_;\n  };\n  Select2.prototype.getLayer = function(feature2) {\n    return this.featureLayerAssociation_[getUid(feature2)];\n  };\n  Select2.prototype.setHitTolerance = function(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  };\n  Select2.prototype.setMap = function(map) {\n    var currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    _super.prototype.setMap.call(this, map);\n    if (map) {\n      this.features_.addEventListener(CollectionEventType.ADD, this.boundAddFeature_);\n      this.features_.addEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(CollectionEventType.ADD, this.boundAddFeature_);\n      this.features_.removeEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);\n    }\n  };\n  Select2.prototype.addFeature_ = function(evt) {\n    var feature2 = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature2);\n    }\n    if (!this.getLayer(feature2)) {\n      var layer = this.getMap().getAllLayers().find(function(layer2) {\n        if (layer2 instanceof ol_layer_Vector && layer2.getSource() && layer2.getSource().hasFeature(feature2)) {\n          return layer2;\n        }\n      });\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature2, layer);\n      }\n    }\n  };\n  Select2.prototype.removeFeature_ = function(evt) {\n    var feature2 = evt.element;\n    if (this.style_) {\n      this.restorePreviousStyle_(feature2);\n    }\n  };\n  Select2.prototype.getStyle = function() {\n    return this.style_;\n  };\n  Select2.prototype.applySelectedStyle_ = function(feature2) {\n    var key = getUid(feature2);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature2.getStyle();\n    }\n    feature2.setStyle(this.style_);\n  };\n  Select2.prototype.restorePreviousStyle_ = function(feature2) {\n    var interactions = this.getMap().getInteractions().getArray();\n    for (var i2 = interactions.length - 1; i2 >= 0; --i2) {\n      var interaction = interactions[i2];\n      if (interaction !== this && interaction instanceof Select2 && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature2) !== -1) {\n        feature2.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n    var key = getUid(feature2);\n    feature2.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  };\n  Select2.prototype.removeFeatureLayerAssociation_ = function(feature2) {\n    delete this.featureLayerAssociation_[getUid(feature2)];\n  };\n  Select2.prototype.handleEvent = function(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    var add2 = this.addCondition_(mapBrowserEvent);\n    var remove = this.removeCondition_(mapBrowserEvent);\n    var toggle2 = this.toggleCondition_(mapBrowserEvent);\n    var set2 = !add2 && !remove && !toggle2;\n    var map = mapBrowserEvent.map;\n    var features = this.getFeatures();\n    var deselected = [];\n    var selected = [];\n    if (set2) {\n      clear$1(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function(feature3, layer) {\n        if (this.filter_(feature3, layer)) {\n          this.addFeatureLayerAssociation_(feature3, layer);\n          selected.push(feature3);\n          return !this.multi_;\n        }\n      }.bind(this), {\n        layerFilter: this.layerFilter_,\n        hitTolerance: this.hitTolerance_\n      });\n      for (var i2 = features.getLength() - 1; i2 >= 0; --i2) {\n        var feature2 = features.item(i2);\n        var index2 = selected.indexOf(feature2);\n        if (index2 > -1) {\n          selected.splice(index2, 1);\n        } else {\n          features.remove(feature2);\n          deselected.push(feature2);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function(feature3, layer) {\n        if (this.filter_(feature3, layer)) {\n          if ((add2 || toggle2) && !includes(features.getArray(), feature3)) {\n            this.addFeatureLayerAssociation_(feature3, layer);\n            selected.push(feature3);\n          } else if ((remove || toggle2) && includes(features.getArray(), feature3)) {\n            deselected.push(feature3);\n            this.removeFeatureLayerAssociation_(feature3);\n          }\n          return !this.multi_;\n        }\n      }.bind(this), {\n        layerFilter: this.layerFilter_,\n        hitTolerance: this.hitTolerance_\n      });\n      for (var j2 = deselected.length - 1; j2 >= 0; --j2) {\n        features.remove(deselected[j2]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));\n    }\n    return true;\n  };\n  return Select2;\n}(Interaction$1);\nfunction getDefaultStyleFunction() {\n  var styles = createEditingStyle();\n  extend$3(styles[GeometryType.POLYGON], styles[GeometryType.LINE_STRING]);\n  extend$3(styles[GeometryType.GEOMETRY_COLLECTION], styles[GeometryType.LINE_STRING]);\n  return function(feature2) {\n    if (!feature2.getGeometry()) {\n      return null;\n    }\n    return styles[feature2.getGeometry().getType()];\n  };\n}\nvar ol_interaction_Select = Select;\nvar __extends$11 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nfunction getFeatureFromEvent(evt) {\n  if (evt.feature) {\n    return evt.feature;\n  } else if (evt.element) {\n    return evt.element;\n  }\n}\nvar tempSegment = [];\nvar Snap = function(_super) {\n  __extends$11(Snap2, _super);\n  function Snap2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = options;\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    _this = _super.call(this, pointerOptions) || this;\n    _this.source_ = options.source ? options.source : null;\n    _this.vertex_ = options.vertex !== void 0 ? options.vertex : true;\n    _this.edge_ = options.edge !== void 0 ? options.edge : true;\n    _this.features_ = options.features ? options.features : null;\n    _this.featuresListenerKeys_ = [];\n    _this.featureChangeListenerKeys_ = {};\n    _this.indexedFeaturesExtents_ = {};\n    _this.pendingFeatures_ = {};\n    _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;\n    _this.rBush_ = new RBush$1();\n    _this.GEOMETRY_SEGMENTERS_ = {\n      \"Point\": _this.segmentPointGemetry_.bind(_this),\n      \"LineString\": _this.segmentLineStringGemetry_.bind(_this),\n      \"LinearRing\": _this.segmentLineStringGemetry_.bind(_this),\n      \"Polygon\": _this.segmentPolygonGemetry_.bind(_this),\n      \"MultiPoint\": _this.segmentMultiPointGemetry_.bind(_this),\n      \"MultiLineString\": _this.segmentMultiLineStringGemetry_.bind(_this),\n      \"MultiPolygon\": _this.segmentMultiPolygonGemetry_.bind(_this),\n      \"GeometryCollection\": _this.segmentGeometryCollectionGemetry_.bind(_this),\n      \"Circle\": _this.segmentCircleGemetry_.bind(_this)\n    };\n    return _this;\n  }\n  Snap2.prototype.addFeature = function(feature2, opt_listen) {\n    var register2 = opt_listen !== void 0 ? opt_listen : true;\n    var feature_uid = getUid(feature2);\n    var geometry = feature2.getGeometry();\n    if (geometry) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        var segments = [];\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature2,\n            segment: segments[0]\n          });\n        } else if (segments.length > 1) {\n          var extents = segments.map(function(s2) {\n            return boundingExtent(s2);\n          });\n          var segmentsData = segments.map(function(segment) {\n            return {\n              feature: feature2,\n              segment\n            };\n          });\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n    if (register2) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature2, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  Snap2.prototype.forEachFeatureAdd_ = function(feature2) {\n    this.addFeature(feature2);\n  };\n  Snap2.prototype.forEachFeatureRemove_ = function(feature2) {\n    this.removeFeature(feature2);\n  };\n  Snap2.prototype.getFeatures_ = function() {\n    var features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  };\n  Snap2.prototype.handleEvent = function(evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return _super.prototype.handleEvent.call(this, evt);\n  };\n  Snap2.prototype.handleFeatureAdd_ = function(evt) {\n    var feature2 = getFeatureFromEvent(evt);\n    this.addFeature(feature2);\n  };\n  Snap2.prototype.handleFeatureRemove_ = function(evt) {\n    var feature2 = getFeatureFromEvent(evt);\n    this.removeFeature(feature2);\n  };\n  Snap2.prototype.handleFeatureChange_ = function(evt) {\n    var feature2 = evt.target;\n    if (this.handlingDownUpSequence) {\n      var uid2 = getUid(feature2);\n      if (!(uid2 in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid2] = feature2;\n      }\n    } else {\n      this.updateFeature_(feature2);\n    }\n  };\n  Snap2.prototype.handleUpEvent = function(evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  };\n  Snap2.prototype.removeFeature = function(feature2, opt_unlisten) {\n    var unregister = opt_unlisten !== void 0 ? opt_unlisten : true;\n    var feature_uid = getUid(feature2);\n    var extent2 = this.indexedFeaturesExtents_[feature_uid];\n    if (extent2) {\n      var rBush = this.rBush_;\n      var nodesToRemove_1 = [];\n      rBush.forEachInExtent(extent2, function(node2) {\n        if (feature2 === node2.feature) {\n          nodesToRemove_1.push(node2);\n        }\n      });\n      for (var i2 = nodesToRemove_1.length - 1; i2 >= 0; --i2) {\n        rBush.remove(nodesToRemove_1[i2]);\n      }\n    }\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  Snap2.prototype.setMap = function(map) {\n    var currentMap = this.getMap();\n    var keys3 = this.featuresListenerKeys_;\n    var features = this.getFeatures_();\n    if (currentMap) {\n      keys3.forEach(unlistenByKey);\n      keys3.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    _super.prototype.setMap.call(this, map);\n    if (map) {\n      if (this.features_) {\n        keys3.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys3.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  Snap2.prototype.snapTo = function(pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([\n      pixel[0] - this.pixelTolerance_,\n      pixel[1] + this.pixelTolerance_\n    ]);\n    var upperRight = map.getCoordinateFromPixel([\n      pixel[0] + this.pixelTolerance_,\n      pixel[1] - this.pixelTolerance_\n    ]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n    var segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n    var projection = map.getView().getProjection();\n    var projectedCoordinate = fromUserCoordinate(pixelCoordinate);\n    var closestVertex;\n    var minSquaredDistance = Infinity;\n    var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    var getResult = function() {\n      if (closestVertex) {\n        var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1])\n            ]\n          };\n        }\n      }\n      return null;\n    };\n    if (this.vertex_) {\n      for (var i2 = 0; i2 < segmentsLength; ++i2) {\n        var segmentData = segments[i2];\n        if (segmentData.feature.getGeometry().getType() !== GeometryType.CIRCLE) {\n          segmentData.segment.forEach(function(vertex2) {\n            var tempVertexCoord = fromUserCoordinate(vertex2);\n            var delta2 = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta2 < minSquaredDistance) {\n              closestVertex = vertex2;\n              minSquaredDistance = delta2;\n            }\n          });\n        }\n      }\n      var result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n    if (this.edge_) {\n      for (var i2 = 0; i2 < segmentsLength; ++i2) {\n        var vertex = null;\n        var segmentData = segments[i2];\n        if (segmentData.feature.getGeometry().getType() === GeometryType.CIRCLE) {\n          var circleGeometry = segmentData.feature.getGeometry();\n          var userProjection2 = getUserProjection();\n          if (userProjection2) {\n            circleGeometry = circleGeometry.clone().transform(userProjection2, projection);\n          }\n          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, circleGeometry));\n        } else {\n          var _a2 = segmentData.segment, segmentStart = _a2[0], segmentEnd = _a2[1];\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart);\n            tempSegment[1] = fromUserCoordinate(segmentEnd);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          var delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n      var result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  };\n  Snap2.prototype.updateFeature_ = function(feature2) {\n    this.removeFeature(feature2, false);\n    this.addFeature(feature2, false);\n  };\n  Snap2.prototype.segmentCircleGemetry_ = function(segments, geometry) {\n    this.getMap().getView().getProjection();\n    var circleGeometry = geometry;\n    var polygon = fromCircle(circleGeometry);\n    var coordinates2 = polygon.getCoordinates()[0];\n    for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n      segments.push(coordinates2.slice(i2, i2 + 2));\n    }\n  };\n  Snap2.prototype.segmentGeometryCollectionGemetry_ = function(segments, geometry) {\n    var geometries = geometry.getGeometriesArray();\n    for (var i2 = 0; i2 < geometries.length; ++i2) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i2].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i2]);\n      }\n    }\n  };\n  Snap2.prototype.segmentLineStringGemetry_ = function(segments, geometry) {\n    var coordinates2 = geometry.getCoordinates();\n    for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n      segments.push(coordinates2.slice(i2, i2 + 2));\n    }\n  };\n  Snap2.prototype.segmentMultiLineStringGemetry_ = function(segments, geometry) {\n    var lines = geometry.getCoordinates();\n    for (var j2 = 0, jj = lines.length; j2 < jj; ++j2) {\n      var coordinates2 = lines[j2];\n      for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n        segments.push(coordinates2.slice(i2, i2 + 2));\n      }\n    }\n  };\n  Snap2.prototype.segmentMultiPointGemetry_ = function(segments, geometry) {\n    geometry.getCoordinates().forEach(function(point) {\n      segments.push([point]);\n    });\n  };\n  Snap2.prototype.segmentMultiPolygonGemetry_ = function(segments, geometry) {\n    var polygons = geometry.getCoordinates();\n    for (var k2 = 0, kk = polygons.length; k2 < kk; ++k2) {\n      var rings = polygons[k2];\n      for (var j2 = 0, jj = rings.length; j2 < jj; ++j2) {\n        var coordinates2 = rings[j2];\n        for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n          segments.push(coordinates2.slice(i2, i2 + 2));\n        }\n      }\n    }\n  };\n  Snap2.prototype.segmentPointGemetry_ = function(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  };\n  Snap2.prototype.segmentPolygonGemetry_ = function(segments, geometry) {\n    var rings = geometry.getCoordinates();\n    for (var j2 = 0, jj = rings.length; j2 < jj; ++j2) {\n      var coordinates2 = rings[j2];\n      for (var i2 = 0, ii = coordinates2.length - 1; i2 < ii; ++i2) {\n        segments.push(coordinates2.slice(i2, i2 + 2));\n      }\n    }\n  };\n  return Snap2;\n}(ol_interaction_Pointer);\nvar Snap$1 = Snap;\nfunction defaults(opt_options) {\n  var options = opt_options ? opt_options : {};\n  var interactions = new ol_Collection();\n  var kinetic = new Kinetic$1(-5e-3, 0.05, 100);\n  var altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;\n  if (altShiftDragRotate) {\n    interactions.push(new DragRotate$1());\n  }\n  var doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;\n  if (doubleClickZoom) {\n    interactions.push(new DoubleClickZoom$1({\n      delta: options.zoomDelta,\n      duration: options.zoomDuration\n    }));\n  }\n  var dragPan = options.dragPan !== void 0 ? options.dragPan : true;\n  if (dragPan) {\n    interactions.push(new DragPan$1({\n      onFocusOnly: options.onFocusOnly,\n      kinetic\n    }));\n  }\n  var pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;\n  if (pinchRotate) {\n    interactions.push(new PinchRotate$1());\n  }\n  var pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;\n  if (pinchZoom) {\n    interactions.push(new PinchZoom$1({\n      duration: options.zoomDuration\n    }));\n  }\n  var keyboard = options.keyboard !== void 0 ? options.keyboard : true;\n  if (keyboard) {\n    interactions.push(new KeyboardPan$1());\n    interactions.push(new KeyboardZoom$1({\n      delta: options.zoomDelta,\n      duration: options.zoomDuration\n    }));\n  }\n  var mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;\n  if (mouseWheelZoom) {\n    interactions.push(new MouseWheelZoom$1({\n      onFocusOnly: options.onFocusOnly,\n      duration: options.zoomDuration\n    }));\n  }\n  var shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;\n  if (shiftDragZoom) {\n    interactions.push(new DragZoom$1({\n      duration: options.zoomDuration\n    }));\n  }\n  return interactions;\n}\nvar __extends$10 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Map$3 = function(_super) {\n  __extends$10(Map2, _super);\n  function Map2(options) {\n    options = assign({}, options);\n    if (!options.controls) {\n      options.controls = defaults$1();\n    }\n    if (!options.interactions) {\n      options.interactions = defaults({\n        onFocusOnly: true\n      });\n    }\n    return _super.call(this, options) || this;\n  }\n  Map2.prototype.createRenderer = function() {\n    return new CompositeMapRenderer$1(this);\n  };\n  return Map2;\n}(PluggableMap$1);\nvar ol_Map = Map$3;\nfunction usePropsAsObjectProperties(props, ignoredKeys = []) {\n  let options = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(props);\n  Object.keys(options).forEach((key) => {\n    options[key] = options[key].value;\n  });\n  const properties = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)(__spreadValues({}, options));\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(props, () => {\n    options = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(props);\n    Object.keys(options).forEach((key) => {\n      if (properties[key] != options[key].value && !ignoredKeys.includes(key)) {\n        properties[key] = options[key].value;\n      }\n    });\n  });\n  return {\n    properties\n  };\n}\nvar _export_sfc = (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n};\nconst _sfc_main$15 = {\n  name: \"ol-map\",\n  setup(props, {\n    emit\n  }) {\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const mapRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);\n    let map = new ol_Map(properties);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      map.setProperties(properties);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.setTarget(mapRef.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.setTarget(null);\n      map = null;\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"map\", map);\n    const focus2 = () => map.focus();\n    const forEachFeatureAtPixel = (pixel, callback, options = {}) => map.forEachFeatureAtPixel(pixel, callback, options);\n    const forEachLayerAtPixel = (pixel, callback, layerFilter) => map.forEachLayerAtPixel(pixel, callback, layerFilter);\n    const getCoordinateFromPixel = (pixel) => map.getCoordinateFromPixel(pixel);\n    const refresh = () => map.refresh();\n    const render2 = () => map.render();\n    const updateSize = () => map.updateSize();\n    map.on(\"click\", (event) => emit(\"click\", event));\n    map.on(\"dblclick\", (event) => emit(\"dblclick\", event));\n    map.on(\"singleclick\", (event) => emit(\"singleclick\", event));\n    map.on(\"pointerdrag\", (event) => emit(\"pointerdrag\", event));\n    map.on(\"pointermove\", (event) => emit(\"pointermove\", event));\n    map.on(\"movestart\", (event) => emit(\"movestart\", event));\n    map.on(\"moveend\", (event) => emit(\"moveend\", event));\n    map.on(\"postrender\", (event) => emit(\"postrender\", event));\n    map.on(\"precompose\", (event) => emit(\"precompose\", event));\n    map.on(\"postcompose\", (event) => emit(\"postcompose\", event));\n    return {\n      map,\n      mapRef,\n      focus: focus2,\n      forEachFeatureAtPixel,\n      forEachLayerAtPixel,\n      getCoordinateFromPixel,\n      refresh,\n      render: render2,\n      updateSize\n    };\n  },\n  props: {\n    loadTilesWhileAnimating: {\n      type: Boolean,\n      default: false\n    },\n    loadTilesWhileInteracting: {\n      type: Boolean,\n      default: false\n    },\n    moveTolerance: {\n      type: Number,\n      default: 1\n    },\n    pixelRatio: {\n      type: Number,\n      default: 1\n    },\n    controls: {\n      type: Array,\n      default: () => []\n    }\n  }\n};\nfunction _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", {\n    ref: (el) => $setup.mapRef = el\n  }, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ], 512);\n}\nvar Map$2 = /* @__PURE__ */ _export_sfc(_sfc_main$15, [[\"render\", _sfc_render$15]]);\nfunction useView(props, emit) {\n  const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n  const {\n    properties\n  } = usePropsAsObjectProperties(props);\n  const createProp = () => {\n    return __spreadProps(__spreadValues({}, properties), {\n      projection: typeof properties.projection == \"string\" ? properties.projection : new Projection$3(__spreadValues({}, properties.projection))\n    });\n  };\n  let view = new ol_View(createProp());\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n    map.setView(view);\n  });\n  view.on(\"change:center\", () => {\n    emit(\"centerChanged\", getCenter2());\n    emit(\"zoomChanged\", getZoom());\n  });\n  view.on(\"change:resolution\", () => emit(\"resolutionChanged\", getResolution()));\n  view.on(\"change:rotation\", () => emit(\"rotationChanged\", getRotation()));\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n    let pr = createProp();\n    view.setProperties(pr);\n    view.applyOptions_(pr);\n  });\n  const adjustCenter = (deltaCoordinates) => view.adjustCenter(deltaCoordinates);\n  const adjustResolution = (ratio, opt_anchor) => view.adjustResolution(ratio, opt_anchor);\n  const adjustRotation = (delta, opt_anchor) => view.adjustRotation(delta, opt_anchor);\n  const adjustZoom = (delta, opt_anchor) => view.adjustZoom(delta, opt_anchor);\n  const animate = (var_args) => view.animate(var_args);\n  const beginInteraction = () => view.beginInteraction();\n  const calculateExtent = (opt_size) => view.calculateExtent(opt_size);\n  const cancelAnimations = () => view.cancelAnimations();\n  const centerOn = (coordinate, size, position2) => view.centerOn(coordinate, size, position2);\n  const changed = () => view.changed();\n  const dispatchEvent2 = (event) => view.dispatchEvent(event);\n  const endInteraction = (opt_duration, opt_resolutionDirection, opt_anchor) => view.endInteraction(opt_duration, opt_resolutionDirection, opt_anchor);\n  const fit = (geometryOrExtent, opt_options) => view.fit(geometryOrExtent, opt_options);\n  const get2 = (key) => view.get(key);\n  const getAnimating = () => view.getAnimating();\n  const getCenter2 = () => view.getCenter();\n  const getInteracting = () => view.getInteracting();\n  const getKeys = () => view.getKeys();\n  const getMaxResolution = () => view.getMaxResolution();\n  const getMaxZoom = () => view.getMaxZoom();\n  const getMinResolution = () => view.getMinResolution();\n  const getMinZoom = () => view.getMinZoom();\n  const getProjection = () => view.getProjection();\n  const getProperties = () => view.getProperties();\n  const getResolution = () => view.getResolution();\n  const getResolutionForExtent = (extent2, opt_size) => view.getResolutionForExtent(extent2, opt_size);\n  const getResolutionForZoom = (zoom) => view.getResolutionForZoom(zoom);\n  const getResolutions = () => view.getResolutions();\n  const getRevision = () => view.getRevision();\n  const getRotation = () => view.getRotation();\n  const getZoom = () => view.getZoom();\n  const getZoomForResolution = (resolution) => view.getZoomForResolution(resolution);\n  const setCenter = (center) => view.setCenter(center);\n  const setConstrainResolution = (enabled) => view.setConstrainResolution(enabled);\n  const setMaxZoom = (zoom) => view.setMaxZoom(zoom);\n  const setMinZoom = (zoom) => view.setMinZoom(zoom);\n  const setResolution = (resolution) => view.setResolution(resolution);\n  const setRotation = (rotation) => view.setRotation(rotation);\n  const setZoom = (zoom) => view.setZoom(zoom);\n  return {\n    view,\n    adjustCenter,\n    adjustResolution,\n    adjustRotation,\n    adjustZoom,\n    animate,\n    beginInteraction,\n    calculateExtent,\n    cancelAnimations,\n    centerOn,\n    changed,\n    dispatchEvent: dispatchEvent2,\n    endInteraction,\n    fit,\n    get: get2,\n    getAnimating,\n    getCenter: getCenter2,\n    getInteracting,\n    getKeys,\n    getMaxResolution,\n    getMaxZoom,\n    getMinResolution,\n    getMinZoom,\n    getProjection,\n    getProperties,\n    getResolution,\n    getResolutionForExtent,\n    getResolutionForZoom,\n    getResolutions,\n    getRevision,\n    getRotation,\n    getZoom,\n    getZoomForResolution,\n    setCenter,\n    setConstrainResolution,\n    setMaxZoom,\n    setMinZoom,\n    setResolution,\n    setRotation,\n    setZoom\n  };\n}\nconst _sfc_main$14 = {\n  name: \"ol-view\",\n  setup(props, {\n    emit\n  }) {\n    const view = useView(props, emit);\n    return __spreadValues({}, view);\n  },\n  props: {\n    center: {\n      type: Array,\n      default: () => [0, 0]\n    },\n    constrainRotation: {\n      type: Boolean,\n      default: true\n    },\n    enableRotation: {\n      type: Boolean,\n      default: true\n    },\n    extent: {\n      type: Array\n    },\n    constrainOnlyCenter: {\n      type: Boolean,\n      default: false\n    },\n    smoothExtentConstraint: {\n      type: Boolean,\n      default: true\n    },\n    maxResolution: {\n      type: Number\n    },\n    minResolution: {\n      type: Number\n    },\n    maxZoom: {\n      type: Number,\n      default: 28\n    },\n    minZoom: {\n      type: Number,\n      default: 0\n    },\n    multiWorld: {\n      type: Boolean,\n      default: false\n    },\n    constrainResolution: {\n      type: Boolean,\n      default: false\n    },\n    smoothResolutionConstraint: {\n      type: Boolean,\n      default: true\n    },\n    showFullExtent: {\n      type: Boolean,\n      default: false\n    },\n    projection: {\n      type: [String, Object],\n      default: \"EPSG:3857\"\n    },\n    resolution: {\n      type: Number\n    },\n    resolutions: {\n      type: Array\n    },\n    rotation: {\n      type: Number\n    },\n    zoom: {\n      type: Number,\n      default: 0\n    },\n    zoomFactor: {\n      type: Number,\n      default: 2\n    },\n    padding: {\n      type: Array,\n      default: () => [0, 0, 0, 0]\n    }\n  }\n};\nfunction _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar View = /* @__PURE__ */ _export_sfc(_sfc_main$14, [[\"render\", _sfc_render$14]]);\nconst _sfc_main$13 = {\n  name: \"ol-feature\",\n  setup(props) {\n    const vectorSource = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"vectorSource\");\n    const vectorLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"vectorLayer\");\n    const animation = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"animation\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let feature$1 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let f2 = new feature(__spreadValues({}, properties.properties));\n      return f2;\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(feature$1, (newVal, oldVal) => {\n      vectorSource.value.removeFeature(oldVal);\n      vectorSource.value.addFeature(newVal);\n      vectorSource.value.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(vectorSource, (newVal, oldVal) => {\n      oldVal.removeFeature(feature$1.value);\n      newVal.addFeature(feature$1.value);\n      newVal.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      vectorSource.value.addFeature(feature$1.value);\n      if (animation != null) {\n        vectorLayer.value.animateFeature(feature$1.value, animation.value);\n      }\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      vectorSource.value.removeFeature(feature$1.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"feature\", feature$1);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"stylable\", feature$1);\n    return {\n      feature: feature$1\n    };\n  },\n  props: {\n    properties: {\n      type: [Geometry$1, Object, Array]\n    }\n  }\n};\nfunction _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar Feature = /* @__PURE__ */ _export_sfc(_sfc_main$13, [[\"render\", _sfc_render$13]]);\nfunction useOverlay(props, emit) {\n  const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n  const htmlContent = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);\n  const {\n    properties\n  } = usePropsAsObjectProperties(props);\n  let overlay = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new Overlay$2(properties));\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n    map.addOverlay(overlay.value);\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n    map.removeOverlay(overlay.value);\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(overlay, (newVal, oldVal) => {\n    map.removeOverlay(oldVal);\n    map.addOverlay(newVal);\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(() => {\n    setElement(htmlContent.value);\n  }, {\n    flush: \"post\"\n  });\n  overlay.value.on(\"change:element\", () => emit(\"elementChanged\", getElement()));\n  overlay.value.on(\"change:offset\", () => emit(\"offsetChanged\", getOffset()));\n  overlay.value.on(\"change:position\", () => emit(\"positionChanged\", getPosition()));\n  overlay.value.on(\"change:positioning\", () => emit(\"positioningChanged\", getPositioning()));\n  const getElement = () => overlay.value.getElement();\n  const getOffset = () => overlay.value.getOffset();\n  const getPosition = () => overlay.value.getPosition();\n  const getPositioning = () => overlay.value.getPositioning();\n  const panIntoView = (opt_panIntoViewOptions) => overlay.value.panIntoView(opt_panIntoViewOptions);\n  const setElement = (element) => overlay.value.setElement(element);\n  const setOffset = (offset2) => overlay.value.setOffset(offset2);\n  const setPosition = (position2) => overlay.value.setPosition(position2);\n  const setPositioning = (positioning) => overlay.value.setPositioning(positioning);\n  return {\n    overlay,\n    htmlContent,\n    getOffset,\n    getPosition,\n    getPositioning,\n    panIntoView,\n    setElement,\n    setOffset,\n    setPosition,\n    setPositioning\n  };\n}\nconst _sfc_main$12 = {\n  name: \"ol-overlay\",\n  setup(props, { emit }) {\n    const overlay = new useOverlay(props, emit);\n    return __spreadValues({}, overlay);\n  },\n  props: {\n    position: {\n      type: Array\n    },\n    offset: {\n      type: Array\n    },\n    positioning: {\n      type: String\n    },\n    stopEvent: {\n      type: Boolean,\n      default: true\n    },\n    insertFirst: {\n      type: Boolean,\n      default: true\n    },\n    autoPan: {\n      type: Boolean,\n      default: false\n    },\n    autoPanMargin: {\n      type: Number,\n      default: 20\n    },\n    autoPanAnimation: {\n      type: Object,\n      default: void 0\n    }\n  }\n};\nconst _hoisted_1 = { ref: \"htmlContent\" };\nfunction _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_1, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\", { position: $props.position })\n  ], 512);\n}\nvar Overlay = /* @__PURE__ */ _export_sfc(_sfc_main$12, [[\"render\", _sfc_render$12]]);\nvar __extends$$ = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Property$2 = {\n  ACCURACY: \"accuracy\",\n  ACCURACY_GEOMETRY: \"accuracyGeometry\",\n  ALTITUDE: \"altitude\",\n  ALTITUDE_ACCURACY: \"altitudeAccuracy\",\n  HEADING: \"heading\",\n  POSITION: \"position\",\n  PROJECTION: \"projection\",\n  SPEED: \"speed\",\n  TRACKING: \"tracking\",\n  TRACKING_OPTIONS: \"trackingOptions\"\n};\nvar GeolocationError = function(_super) {\n  __extends$$(GeolocationError2, _super);\n  function GeolocationError2(error) {\n    var _this = _super.call(this, EventType.ERROR) || this;\n    _this.code = error.code;\n    _this.message = error.message;\n    return _this;\n  }\n  return GeolocationError2;\n}(Event$1);\nvar Geolocation = function(_super) {\n  __extends$$(Geolocation2, _super);\n  function Geolocation2(opt_options) {\n    var _this = _super.call(this) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    var options = opt_options || {};\n    _this.position_ = null;\n    _this.transform_ = identityTransform;\n    _this.watchId_ = void 0;\n    _this.addChangeListener(Property$2.PROJECTION, _this.handleProjectionChanged_);\n    _this.addChangeListener(Property$2.TRACKING, _this.handleTrackingChanged_);\n    if (options.projection !== void 0) {\n      _this.setProjection(options.projection);\n    }\n    if (options.trackingOptions !== void 0) {\n      _this.setTrackingOptions(options.trackingOptions);\n    }\n    _this.setTracking(options.tracking !== void 0 ? options.tracking : false);\n    return _this;\n  }\n  Geolocation2.prototype.disposeInternal = function() {\n    this.setTracking(false);\n    _super.prototype.disposeInternal.call(this);\n  };\n  Geolocation2.prototype.handleProjectionChanged_ = function() {\n    var projection = this.getProjection();\n    if (projection) {\n      this.transform_ = getTransformFromProjections(get$3(\"EPSG:4326\"), projection);\n      if (this.position_) {\n        this.set(Property$2.POSITION, this.transform_(this.position_));\n      }\n    }\n  };\n  Geolocation2.prototype.handleTrackingChanged_ = function() {\n    if (\"geolocation\" in navigator) {\n      var tracking = this.getTracking();\n      if (tracking && this.watchId_ === void 0) {\n        this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());\n      } else if (!tracking && this.watchId_ !== void 0) {\n        navigator.geolocation.clearWatch(this.watchId_);\n        this.watchId_ = void 0;\n      }\n    }\n  };\n  Geolocation2.prototype.positionChange_ = function(position2) {\n    var coords = position2.coords;\n    this.set(Property$2.ACCURACY, coords.accuracy);\n    this.set(Property$2.ALTITUDE, coords.altitude === null ? void 0 : coords.altitude);\n    this.set(Property$2.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? void 0 : coords.altitudeAccuracy);\n    this.set(Property$2.HEADING, coords.heading === null ? void 0 : toRadians(coords.heading));\n    if (!this.position_) {\n      this.position_ = [coords.longitude, coords.latitude];\n    } else {\n      this.position_[0] = coords.longitude;\n      this.position_[1] = coords.latitude;\n    }\n    var projectedPosition = this.transform_(this.position_);\n    this.set(Property$2.POSITION, projectedPosition);\n    this.set(Property$2.SPEED, coords.speed === null ? void 0 : coords.speed);\n    var geometry = circular(this.position_, coords.accuracy);\n    geometry.applyTransform(this.transform_);\n    this.set(Property$2.ACCURACY_GEOMETRY, geometry);\n    this.changed();\n  };\n  Geolocation2.prototype.positionError_ = function(error) {\n    this.dispatchEvent(new GeolocationError(error));\n  };\n  Geolocation2.prototype.getAccuracy = function() {\n    return this.get(Property$2.ACCURACY);\n  };\n  Geolocation2.prototype.getAccuracyGeometry = function() {\n    return this.get(Property$2.ACCURACY_GEOMETRY) || null;\n  };\n  Geolocation2.prototype.getAltitude = function() {\n    return this.get(Property$2.ALTITUDE);\n  };\n  Geolocation2.prototype.getAltitudeAccuracy = function() {\n    return this.get(Property$2.ALTITUDE_ACCURACY);\n  };\n  Geolocation2.prototype.getHeading = function() {\n    return this.get(Property$2.HEADING);\n  };\n  Geolocation2.prototype.getPosition = function() {\n    return this.get(Property$2.POSITION);\n  };\n  Geolocation2.prototype.getProjection = function() {\n    return this.get(Property$2.PROJECTION);\n  };\n  Geolocation2.prototype.getSpeed = function() {\n    return this.get(Property$2.SPEED);\n  };\n  Geolocation2.prototype.getTracking = function() {\n    return this.get(Property$2.TRACKING);\n  };\n  Geolocation2.prototype.getTrackingOptions = function() {\n    return this.get(Property$2.TRACKING_OPTIONS);\n  };\n  Geolocation2.prototype.setProjection = function(projection) {\n    this.set(Property$2.PROJECTION, get$3(projection));\n  };\n  Geolocation2.prototype.setTracking = function(tracking) {\n    this.set(Property$2.TRACKING, tracking);\n  };\n  Geolocation2.prototype.setTrackingOptions = function(options) {\n    this.set(Property$2.TRACKING_OPTIONS, options);\n  };\n  return Geolocation2;\n}(ol_Object);\nvar Geolocation$1 = Geolocation;\nconst _sfc_main$11 = {\n  name: \"ol-geolocation\",\n  emits: [\"positionChanged\", \"speedChanged\", \"headingChanged\", \"altitudeChanged\", \"altitudeAccuracyChanged\", \"accuracyGeometryChanged\"],\n  setup(props, {\n    emit\n  }) {\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let geoLoc = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let g2 = new Geolocation$1(properties);\n      g2.on(\"change\", changeEvt);\n      return g2;\n    });\n    const position2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)([]);\n    const accuracy = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n    const altitude = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n    const altitudeAccuracy = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n    const speed = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n    const heading = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0);\n    const accuracyGeometry = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(position2, () => {\n      emit(\"positionChanged\", position2.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(speed, () => {\n      emit(\"speedChanged\", speed.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(heading, () => {\n      emit(\"headingChanged\", heading.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(altitude, () => {\n      emit(\"altitudeChanged\", altitude.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(altitudeAccuracy, () => {\n      emit(\"altitudeAccuracyChanged\", altitudeAccuracy.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(accuracyGeometry, () => {\n      emit(\"accuracyGeometryChanged\", accuracyGeometry.value);\n    });\n    const changeEvt = () => {\n      position2.value = geoLoc.value.getPosition();\n      speed.value = geoLoc.value.getSpeed();\n      heading.value = geoLoc.value.getHeading();\n      accuracy.value = geoLoc.value.getAccuracy();\n      altitude.value = geoLoc.value.getAltitude();\n      altitudeAccuracy.value = geoLoc.value.getAltitudeAccuracy();\n      accuracyGeometry.value = geoLoc.value.getAccuracyGeometry();\n    };\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(geoLoc, (newVal, oldVal) => {\n      oldVal.un(\"change\", changeEvt);\n      newVal.on(\"change\", changeEvt);\n    });\n    return {\n      geoLoc,\n      position: position2,\n      accuracy,\n      altitude,\n      altitudeAccuracy,\n      speed,\n      heading,\n      accuracyGeometry\n    };\n  },\n  props: {\n    projection: {\n      type: [String, Object],\n      default: \"EPSG:3857\"\n    },\n    tracking: {\n      type: Boolean,\n      default: true\n    },\n    trackingOptions: {\n      type: Object,\n      default: () => {\n        return {\n          enableHighAccuracy: true\n        };\n      }\n    }\n  }\n};\nfunction _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\", {\n    position: $setup.position,\n    speed: $setup.speed,\n    heading: $setup.heading,\n    accuracy: $setup.accuracy,\n    altitude: $setup.altitude,\n    altitudeAccuracy: $setup.altitudeAccuracy,\n    accuracyGeometry: $setup.accuracyGeometry\n  });\n}\nvar GeoLocation = /* @__PURE__ */ _export_sfc(_sfc_main$11, [[\"render\", _sfc_render$11]]);\nfunction globals(defs2) {\n  defs2(\"EPSG:4326\", \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  defs2(\"EPSG:4269\", \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  defs2(\"EPSG:3857\", \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n  defs2.WGS84 = defs2[\"EPSG:4326\"];\n  defs2[\"EPSG:3785\"] = defs2[\"EPSG:3857\"];\n  defs2.GOOGLE = defs2[\"EPSG:3857\"];\n  defs2[\"EPSG:900913\"] = defs2[\"EPSG:3857\"];\n  defs2[\"EPSG:102113\"] = defs2[\"EPSG:3857\"];\n}\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_GRIDSHIFT = 3;\nvar PJD_WGS84 = 4;\nvar PJD_NODATUM = 5;\nvar SRS_WGS84_SEMIMAJOR = 6378137;\nvar SRS_WGS84_SEMIMINOR = 6356752314e-3;\nvar SRS_WGS84_ESQUARED = 0.0066943799901413165;\nvar SEC_TO_RAD = 484813681109536e-20;\nvar HALF_PI = Math.PI / 2;\nvar SIXTH = 0.16666666666666666;\nvar RA4 = 0.04722222222222222;\nvar RA6 = 0.022156084656084655;\nvar EPSLN = 1e-10;\nvar D2R$1 = 0.017453292519943295;\nvar R2D = 57.29577951308232;\nvar FORTPI = Math.PI / 4;\nvar TWO_PI = Math.PI * 2;\nvar SPI = 3.14159265359;\nvar exports$2 = {};\nexports$2.greenwich = 0;\nexports$2.lisbon = -9.131906111111;\nexports$2.paris = 2.337229166667;\nexports$2.bogota = -74.080916666667;\nexports$2.madrid = -3.687938888889;\nexports$2.rome = 12.452333333333;\nexports$2.bern = 7.439583333333;\nexports$2.jakarta = 106.807719444444;\nexports$2.ferro = -17.666666666667;\nexports$2.brussels = 4.367975;\nexports$2.stockholm = 18.058277777778;\nexports$2.athens = 23.7163375;\nexports$2.oslo = 10.722916666667;\nvar units = {\n  ft: { to_meter: 0.3048 },\n  \"us-ft\": { to_meter: 1200 / 3937 }\n};\nvar ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction match$1(obj, key) {\n  if (obj[key]) {\n    return obj[key];\n  }\n  var keys3 = Object.keys(obj);\n  var lkey = key.toLowerCase().replace(ignoredChar, \"\");\n  var i2 = -1;\n  var testkey, processedKey;\n  while (++i2 < keys3.length) {\n    testkey = keys3[i2];\n    processedKey = testkey.toLowerCase().replace(ignoredChar, \"\");\n    if (processedKey === lkey) {\n      return obj[testkey];\n    }\n  }\n}\nfunction projStr(defData) {\n  var self2 = {};\n  var paramObj = defData.split(\"+\").map(function(v2) {\n    return v2.trim();\n  }).filter(function(a2) {\n    return a2;\n  }).reduce(function(p5, a2) {\n    var split2 = a2.split(\"=\");\n    split2.push(true);\n    p5[split2[0].toLowerCase()] = split2[1];\n    return p5;\n  }, {});\n  var paramName, paramVal, paramOutname;\n  var params2 = {\n    proj: \"projName\",\n    datum: \"datumCode\",\n    rf: function(v2) {\n      self2.rf = parseFloat(v2);\n    },\n    lat_0: function(v2) {\n      self2.lat0 = v2 * D2R$1;\n    },\n    lat_1: function(v2) {\n      self2.lat1 = v2 * D2R$1;\n    },\n    lat_2: function(v2) {\n      self2.lat2 = v2 * D2R$1;\n    },\n    lat_ts: function(v2) {\n      self2.lat_ts = v2 * D2R$1;\n    },\n    lon_0: function(v2) {\n      self2.long0 = v2 * D2R$1;\n    },\n    lon_1: function(v2) {\n      self2.long1 = v2 * D2R$1;\n    },\n    lon_2: function(v2) {\n      self2.long2 = v2 * D2R$1;\n    },\n    alpha: function(v2) {\n      self2.alpha = parseFloat(v2) * D2R$1;\n    },\n    gamma: function(v2) {\n      self2.rectified_grid_angle = parseFloat(v2);\n    },\n    lonc: function(v2) {\n      self2.longc = v2 * D2R$1;\n    },\n    x_0: function(v2) {\n      self2.x0 = parseFloat(v2);\n    },\n    y_0: function(v2) {\n      self2.y0 = parseFloat(v2);\n    },\n    k_0: function(v2) {\n      self2.k0 = parseFloat(v2);\n    },\n    k: function(v2) {\n      self2.k0 = parseFloat(v2);\n    },\n    a: function(v2) {\n      self2.a = parseFloat(v2);\n    },\n    b: function(v2) {\n      self2.b = parseFloat(v2);\n    },\n    r_a: function() {\n      self2.R_A = true;\n    },\n    zone: function(v2) {\n      self2.zone = parseInt(v2, 10);\n    },\n    south: function() {\n      self2.utmSouth = true;\n    },\n    towgs84: function(v2) {\n      self2.datum_params = v2.split(\",\").map(function(a2) {\n        return parseFloat(a2);\n      });\n    },\n    to_meter: function(v2) {\n      self2.to_meter = parseFloat(v2);\n    },\n    units: function(v2) {\n      self2.units = v2;\n      var unit = match$1(units, v2);\n      if (unit) {\n        self2.to_meter = unit.to_meter;\n      }\n    },\n    from_greenwich: function(v2) {\n      self2.from_greenwich = v2 * D2R$1;\n    },\n    pm: function(v2) {\n      var pm = match$1(exports$2, v2);\n      self2.from_greenwich = (pm ? pm : parseFloat(v2)) * D2R$1;\n    },\n    nadgrids: function(v2) {\n      if (v2 === \"@null\") {\n        self2.datumCode = \"none\";\n      } else {\n        self2.nadgrids = v2;\n      }\n    },\n    axis: function(v2) {\n      var legalAxis = \"ewnsud\";\n      if (v2.length === 3 && legalAxis.indexOf(v2.substr(0, 1)) !== -1 && legalAxis.indexOf(v2.substr(1, 1)) !== -1 && legalAxis.indexOf(v2.substr(2, 1)) !== -1) {\n        self2.axis = v2;\n      }\n    },\n    approx: function() {\n      self2.approx = true;\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params2) {\n      paramOutname = params2[paramName];\n      if (typeof paramOutname === \"function\") {\n        paramOutname(paramVal);\n      } else {\n        self2[paramOutname] = paramVal;\n      }\n    } else {\n      self2[paramName] = paramVal;\n    }\n  }\n  if (typeof self2.datumCode === \"string\" && self2.datumCode !== \"WGS84\") {\n    self2.datumCode = self2.datumCode.toLowerCase();\n  }\n  return self2;\n}\nvar NEUTRAL = 1;\nvar KEYWORD = 2;\nvar NUMBER = 3;\nvar QUOTED = 4;\nvar AFTERQUOTE = 5;\nvar ENDED = -1;\nvar whitespace$1 = /\\s/;\nvar latin = /[A-Za-z]/;\nvar keyword = /[A-Za-z84_]/;\nvar endThings = /[,\\]]/;\nvar digets = /[\\d\\.E\\-\\+]/;\nfunction Parser$3(text2) {\n  if (typeof text2 !== \"string\") {\n    throw new Error(\"not a string\");\n  }\n  this.text = text2.trim();\n  this.level = 0;\n  this.place = 0;\n  this.root = null;\n  this.stack = [];\n  this.currentObject = null;\n  this.state = NEUTRAL;\n}\nParser$3.prototype.readCharicter = function() {\n  var char = this.text[this.place++];\n  if (this.state !== QUOTED) {\n    while (whitespace$1.test(char)) {\n      if (this.place >= this.text.length) {\n        return;\n      }\n      char = this.text[this.place++];\n    }\n  }\n  switch (this.state) {\n    case NEUTRAL:\n      return this.neutral(char);\n    case KEYWORD:\n      return this.keyword(char);\n    case QUOTED:\n      return this.quoted(char);\n    case AFTERQUOTE:\n      return this.afterquote(char);\n    case NUMBER:\n      return this.number(char);\n    case ENDED:\n      return;\n  }\n};\nParser$3.prototype.afterquote = function(char) {\n  if (char === '\"') {\n    this.word += '\"';\n    this.state = QUOTED;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = this.word.trim();\n    this.afterItem(char);\n    return;\n  }\n  throw new Error(`havn't handled \"` + char + '\" in afterquote yet, index ' + this.place);\n};\nParser$3.prototype.afterItem = function(char) {\n  if (char === \",\") {\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n    }\n    this.word = null;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (char === \"]\") {\n    this.level--;\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n      this.word = null;\n    }\n    this.state = NEUTRAL;\n    this.currentObject = this.stack.pop();\n    if (!this.currentObject) {\n      this.state = ENDED;\n    }\n    return;\n  }\n};\nParser$3.prototype.number = function(char) {\n  if (digets.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = parseFloat(this.word);\n    this.afterItem(char);\n    return;\n  }\n  throw new Error(`havn't handled \"` + char + '\" in number yet, index ' + this.place);\n};\nParser$3.prototype.quoted = function(char) {\n  if (char === '\"') {\n    this.state = AFTERQUOTE;\n    return;\n  }\n  this.word += char;\n  return;\n};\nParser$3.prototype.keyword = function(char) {\n  if (keyword.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (char === \"[\") {\n    var newObjects = [];\n    newObjects.push(this.word);\n    this.level++;\n    if (this.root === null) {\n      this.root = newObjects;\n    } else {\n      this.currentObject.push(newObjects);\n    }\n    this.stack.push(this.currentObject);\n    this.currentObject = newObjects;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error(`havn't handled \"` + char + '\" in keyword yet, index ' + this.place);\n};\nParser$3.prototype.neutral = function(char) {\n  if (latin.test(char)) {\n    this.word = char;\n    this.state = KEYWORD;\n    return;\n  }\n  if (char === '\"') {\n    this.word = \"\";\n    this.state = QUOTED;\n    return;\n  }\n  if (digets.test(char)) {\n    this.word = char;\n    this.state = NUMBER;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error(`havn't handled \"` + char + '\" in neutral yet, index ' + this.place);\n};\nParser$3.prototype.output = function() {\n  while (this.place < this.text.length) {\n    this.readCharicter();\n  }\n  if (this.state === ENDED) {\n    return this.root;\n  }\n  throw new Error('unable to parse string \"' + this.text + '\". State is ' + this.state);\n};\nfunction parseString(txt) {\n  var parser = new Parser$3(txt);\n  return parser.output();\n}\nfunction mapit(obj, key, value) {\n  if (Array.isArray(key)) {\n    value.unshift(key);\n    key = null;\n  }\n  var thing = key ? {} : obj;\n  var out = value.reduce(function(newObj, item) {\n    sExpr(item, newObj);\n    return newObj;\n  }, thing);\n  if (key) {\n    obj[key] = out;\n  }\n}\nfunction sExpr(v2, obj) {\n  if (!Array.isArray(v2)) {\n    obj[v2] = true;\n    return;\n  }\n  var key = v2.shift();\n  if (key === \"PARAMETER\") {\n    key = v2.shift();\n  }\n  if (v2.length === 1) {\n    if (Array.isArray(v2[0])) {\n      obj[key] = {};\n      sExpr(v2[0], obj[key]);\n      return;\n    }\n    obj[key] = v2[0];\n    return;\n  }\n  if (!v2.length) {\n    obj[key] = true;\n    return;\n  }\n  if (key === \"TOWGS84\") {\n    obj[key] = v2;\n    return;\n  }\n  if (key === \"AXIS\") {\n    if (!(key in obj)) {\n      obj[key] = [];\n    }\n    obj[key].push(v2);\n    return;\n  }\n  if (!Array.isArray(key)) {\n    obj[key] = {};\n  }\n  var i2;\n  switch (key) {\n    case \"UNIT\":\n    case \"PRIMEM\":\n    case \"VERT_DATUM\":\n      obj[key] = {\n        name: v2[0].toLowerCase(),\n        convert: v2[1]\n      };\n      if (v2.length === 3) {\n        sExpr(v2[2], obj[key]);\n      }\n      return;\n    case \"SPHEROID\":\n    case \"ELLIPSOID\":\n      obj[key] = {\n        name: v2[0],\n        a: v2[1],\n        rf: v2[2]\n      };\n      if (v2.length === 4) {\n        sExpr(v2[3], obj[key]);\n      }\n      return;\n    case \"PROJECTEDCRS\":\n    case \"PROJCRS\":\n    case \"GEOGCS\":\n    case \"GEOCCS\":\n    case \"PROJCS\":\n    case \"LOCAL_CS\":\n    case \"GEODCRS\":\n    case \"GEODETICCRS\":\n    case \"GEODETICDATUM\":\n    case \"EDATUM\":\n    case \"ENGINEERINGDATUM\":\n    case \"VERT_CS\":\n    case \"VERTCRS\":\n    case \"VERTICALCRS\":\n    case \"COMPD_CS\":\n    case \"COMPOUNDCRS\":\n    case \"ENGINEERINGCRS\":\n    case \"ENGCRS\":\n    case \"FITTED_CS\":\n    case \"LOCAL_DATUM\":\n    case \"DATUM\":\n      v2[0] = [\"name\", v2[0]];\n      mapit(obj, key, v2);\n      return;\n    default:\n      i2 = -1;\n      while (++i2 < v2.length) {\n        if (!Array.isArray(v2[i2])) {\n          return sExpr(v2, obj[key]);\n        }\n      }\n      return mapit(obj, key, v2);\n  }\n}\nvar D2R = 0.017453292519943295;\nfunction rename(obj, params2) {\n  var outName = params2[0];\n  var inName = params2[1];\n  if (!(outName in obj) && inName in obj) {\n    obj[outName] = obj[inName];\n    if (params2.length === 3) {\n      obj[outName] = params2[2](obj[outName]);\n    }\n  }\n}\nfunction d2r(input) {\n  return input * D2R;\n}\nfunction cleanWKT(wkt2) {\n  if (wkt2.type === \"GEOGCS\") {\n    wkt2.projName = \"longlat\";\n  } else if (wkt2.type === \"LOCAL_CS\") {\n    wkt2.projName = \"identity\";\n    wkt2.local = true;\n  } else {\n    if (typeof wkt2.PROJECTION === \"object\") {\n      wkt2.projName = Object.keys(wkt2.PROJECTION)[0];\n    } else {\n      wkt2.projName = wkt2.PROJECTION;\n    }\n  }\n  if (wkt2.AXIS) {\n    var axisOrder = \"\";\n    for (var i2 = 0, ii = wkt2.AXIS.length; i2 < ii; ++i2) {\n      var axis = [wkt2.AXIS[i2][0].toLowerCase(), wkt2.AXIS[i2][1].toLowerCase()];\n      if (axis[0].indexOf(\"north\") !== -1 || (axis[0] === \"y\" || axis[0] === \"lat\") && axis[1] === \"north\") {\n        axisOrder += \"n\";\n      } else if (axis[0].indexOf(\"south\") !== -1 || (axis[0] === \"y\" || axis[0] === \"lat\") && axis[1] === \"south\") {\n        axisOrder += \"s\";\n      } else if (axis[0].indexOf(\"east\") !== -1 || (axis[0] === \"x\" || axis[0] === \"lon\") && axis[1] === \"east\") {\n        axisOrder += \"e\";\n      } else if (axis[0].indexOf(\"west\") !== -1 || (axis[0] === \"x\" || axis[0] === \"lon\") && axis[1] === \"west\") {\n        axisOrder += \"w\";\n      }\n    }\n    if (axisOrder.length === 2) {\n      axisOrder += \"u\";\n    }\n    if (axisOrder.length === 3) {\n      wkt2.axis = axisOrder;\n    }\n  }\n  if (wkt2.UNIT) {\n    wkt2.units = wkt2.UNIT.name.toLowerCase();\n    if (wkt2.units === \"metre\") {\n      wkt2.units = \"meter\";\n    }\n    if (wkt2.UNIT.convert) {\n      if (wkt2.type === \"GEOGCS\") {\n        if (wkt2.DATUM && wkt2.DATUM.SPHEROID) {\n          wkt2.to_meter = wkt2.UNIT.convert * wkt2.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt2.to_meter = wkt2.UNIT.convert;\n      }\n    }\n  }\n  var geogcs = wkt2.GEOGCS;\n  if (wkt2.type === \"GEOGCS\") {\n    geogcs = wkt2;\n  }\n  if (geogcs) {\n    if (geogcs.DATUM) {\n      wkt2.datumCode = geogcs.DATUM.name.toLowerCase();\n    } else {\n      wkt2.datumCode = geogcs.name.toLowerCase();\n    }\n    if (wkt2.datumCode.slice(0, 2) === \"d_\") {\n      wkt2.datumCode = wkt2.datumCode.slice(2);\n    }\n    if (wkt2.datumCode === \"new_zealand_geodetic_datum_1949\" || wkt2.datumCode === \"new_zealand_1949\") {\n      wkt2.datumCode = \"nzgd49\";\n    }\n    if (wkt2.datumCode === \"wgs_1984\" || wkt2.datumCode === \"world_geodetic_system_1984\") {\n      if (wkt2.PROJECTION === \"Mercator_Auxiliary_Sphere\") {\n        wkt2.sphere = true;\n      }\n      wkt2.datumCode = \"wgs84\";\n    }\n    if (wkt2.datumCode.slice(-6) === \"_ferro\") {\n      wkt2.datumCode = wkt2.datumCode.slice(0, -6);\n    }\n    if (wkt2.datumCode.slice(-8) === \"_jakarta\") {\n      wkt2.datumCode = wkt2.datumCode.slice(0, -8);\n    }\n    if (~wkt2.datumCode.indexOf(\"belge\")) {\n      wkt2.datumCode = \"rnb72\";\n    }\n    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n      wkt2.ellps = geogcs.DATUM.SPHEROID.name.replace(\"_19\", \"\").replace(/[Cc]larke\\_18/, \"clrk\");\n      if (wkt2.ellps.toLowerCase().slice(0, 13) === \"international\") {\n        wkt2.ellps = \"intl\";\n      }\n      wkt2.a = geogcs.DATUM.SPHEROID.a;\n      wkt2.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n    }\n    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {\n      wkt2.datum_params = geogcs.DATUM.TOWGS84;\n    }\n    if (~wkt2.datumCode.indexOf(\"osgb_1936\")) {\n      wkt2.datumCode = \"osgb36\";\n    }\n    if (~wkt2.datumCode.indexOf(\"osni_1952\")) {\n      wkt2.datumCode = \"osni52\";\n    }\n    if (~wkt2.datumCode.indexOf(\"tm65\") || ~wkt2.datumCode.indexOf(\"geodetic_datum_of_1965\")) {\n      wkt2.datumCode = \"ire65\";\n    }\n    if (wkt2.datumCode === \"ch1903+\") {\n      wkt2.datumCode = \"ch1903\";\n    }\n    if (~wkt2.datumCode.indexOf(\"israel\")) {\n      wkt2.datumCode = \"isr93\";\n    }\n  }\n  if (wkt2.b && !isFinite(wkt2.b)) {\n    wkt2.b = wkt2.a;\n  }\n  function toMeter(input) {\n    var ratio = wkt2.to_meter || 1;\n    return input * ratio;\n  }\n  var renamer = function(a2) {\n    return rename(wkt2, a2);\n  };\n  var list = [\n    [\"standard_parallel_1\", \"Standard_Parallel_1\"],\n    [\"standard_parallel_1\", \"Latitude of 1st standard parallel\"],\n    [\"standard_parallel_2\", \"Standard_Parallel_2\"],\n    [\"standard_parallel_2\", \"Latitude of 2nd standard parallel\"],\n    [\"false_easting\", \"False_Easting\"],\n    [\"false_easting\", \"False easting\"],\n    [\"false-easting\", \"Easting at false origin\"],\n    [\"false_northing\", \"False_Northing\"],\n    [\"false_northing\", \"False northing\"],\n    [\"false_northing\", \"Northing at false origin\"],\n    [\"central_meridian\", \"Central_Meridian\"],\n    [\"central_meridian\", \"Longitude of natural origin\"],\n    [\"central_meridian\", \"Longitude of false origin\"],\n    [\"latitude_of_origin\", \"Latitude_Of_Origin\"],\n    [\"latitude_of_origin\", \"Central_Parallel\"],\n    [\"latitude_of_origin\", \"Latitude of natural origin\"],\n    [\"latitude_of_origin\", \"Latitude of false origin\"],\n    [\"scale_factor\", \"Scale_Factor\"],\n    [\"k0\", \"scale_factor\"],\n    [\"latitude_of_center\", \"Latitude_Of_Center\"],\n    [\"latitude_of_center\", \"Latitude_of_center\"],\n    [\"lat0\", \"latitude_of_center\", d2r],\n    [\"longitude_of_center\", \"Longitude_Of_Center\"],\n    [\"longitude_of_center\", \"Longitude_of_center\"],\n    [\"longc\", \"longitude_of_center\", d2r],\n    [\"x0\", \"false_easting\", toMeter],\n    [\"y0\", \"false_northing\", toMeter],\n    [\"long0\", \"central_meridian\", d2r],\n    [\"lat0\", \"latitude_of_origin\", d2r],\n    [\"lat0\", \"standard_parallel_1\", d2r],\n    [\"lat1\", \"standard_parallel_1\", d2r],\n    [\"lat2\", \"standard_parallel_2\", d2r],\n    [\"azimuth\", \"Azimuth\"],\n    [\"alpha\", \"azimuth\", d2r],\n    [\"srsCode\", \"name\"]\n  ];\n  list.forEach(renamer);\n  if (!wkt2.long0 && wkt2.longc && (wkt2.projName === \"Albers_Conic_Equal_Area\" || wkt2.projName === \"Lambert_Azimuthal_Equal_Area\")) {\n    wkt2.long0 = wkt2.longc;\n  }\n  if (!wkt2.lat_ts && wkt2.lat1 && (wkt2.projName === \"Stereographic_South_Pole\" || wkt2.projName === \"Polar Stereographic (variant B)\")) {\n    wkt2.lat0 = d2r(wkt2.lat1 > 0 ? 90 : -90);\n    wkt2.lat_ts = wkt2.lat1;\n  }\n}\nfunction wkt(wkt2) {\n  var lisp = parseString(wkt2);\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift([\"name\", name]);\n  lisp.unshift([\"type\", type]);\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj);\n  return obj;\n}\nfunction defs(name) {\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === \"string\") {\n      if (def.charAt(0) === \"+\") {\n        defs[name] = projStr(arguments[1]);\n      } else {\n        defs[name] = wkt(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  } else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v2) {\n        if (Array.isArray(v2)) {\n          defs.apply(that, v2);\n        } else {\n          defs(v2);\n        }\n      });\n    } else if (typeof name === \"string\") {\n      if (name in defs) {\n        return defs[name];\n      }\n    } else if (\"EPSG\" in name) {\n      defs[\"EPSG:\" + name.EPSG] = name;\n    } else if (\"ESRI\" in name) {\n      defs[\"ESRI:\" + name.ESRI] = name;\n    } else if (\"IAU2000\" in name) {\n      defs[\"IAU2000:\" + name.IAU2000] = name;\n    } else {\n      console.log(name);\n    }\n    return;\n  }\n}\nglobals(defs);\nfunction testObj(code) {\n  return typeof code === \"string\";\n}\nfunction testDef(code) {\n  return code in defs;\n}\nvar codeWords = [\"PROJECTEDCRS\", \"PROJCRS\", \"GEOGCS\", \"GEOCCS\", \"PROJCS\", \"LOCAL_CS\", \"GEODCRS\", \"GEODETICCRS\", \"GEODETICDATUM\", \"ENGCRS\", \"ENGINEERINGCRS\"];\nfunction testWKT(code) {\n  return codeWords.some(function(word) {\n    return code.indexOf(word) > -1;\n  });\n}\nvar codes = [\"3857\", \"900913\", \"3785\", \"102113\"];\nfunction checkMercator(item) {\n  var auth = match$1(item, \"authority\");\n  if (!auth) {\n    return;\n  }\n  var code = match$1(auth, \"epsg\");\n  return code && codes.indexOf(code) > -1;\n}\nfunction checkProjStr(item) {\n  var ext = match$1(item, \"extension\");\n  if (!ext) {\n    return;\n  }\n  return match$1(ext, \"proj4\");\n}\nfunction testProj(code) {\n  return code[0] === \"+\";\n}\nfunction parse$2(code) {\n  if (testObj(code)) {\n    if (testDef(code)) {\n      return defs[code];\n    }\n    if (testWKT(code)) {\n      var out = wkt(code);\n      if (checkMercator(out)) {\n        return defs[\"EPSG:3857\"];\n      }\n      var maybeProjStr = checkProjStr(out);\n      if (maybeProjStr) {\n        return projStr(maybeProjStr);\n      }\n      return out;\n    }\n    if (testProj(code)) {\n      return projStr(code);\n    }\n  } else {\n    return code;\n  }\n}\nfunction extend(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== void 0) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n}\nfunction msfnz(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / Math.sqrt(1 - con * con);\n}\nfunction sign(x2) {\n  return x2 < 0 ? -1 : 1;\n}\nfunction adjust_lon(x2) {\n  return Math.abs(x2) <= SPI ? x2 : x2 - sign(x2) * TWO_PI;\n}\nfunction tsfnz(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow((1 - con) / (1 + con), com);\n  return Math.tan(0.5 * (HALF_PI - phi)) / con;\n}\nfunction phi2z(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = HALF_PI - 2 * Math.atan(ts);\n  for (var i2 = 0; i2 <= 15; i2++) {\n    con = eccent * Math.sin(phi);\n    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 1e-10) {\n      return phi;\n    }\n  }\n  return -9999;\n}\nfunction init$u() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if (!(\"x0\" in this)) {\n    this.x0 = 0;\n  }\n  if (!(\"y0\" in this)) {\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    } else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  } else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      } else {\n        this.k0 = 1;\n      }\n    }\n  }\n}\nfunction forward$t(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n  var x2, y2;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  } else {\n    if (this.sphere) {\n      x2 = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    } else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x2 = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y2 = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p5.x = x2;\n    p5.y = y2;\n    return p5;\n  }\n}\nfunction inverse$t(p5) {\n  var x2 = p5.x - this.x0;\n  var y2 = p5.y - this.y0;\n  var lon, lat;\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y2 / (this.a * this.k0)));\n  } else {\n    var ts = Math.exp(-y2 / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x2 / (this.a * this.k0));\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$v = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\nvar merc = {\n  init: init$u,\n  forward: forward$t,\n  inverse: inverse$t,\n  names: names$v\n};\nfunction init$t() {\n}\nfunction identity(pt2) {\n  return pt2;\n}\nvar names$u = [\"longlat\", \"identity\"];\nvar longlat = {\n  init: init$t,\n  forward: identity,\n  inverse: identity,\n  names: names$u\n};\nvar projs = [merc, longlat];\nvar names$t = {};\nvar projStore = [];\nfunction add(proj, i2) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i2);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n2) {\n    names$t[n2.toLowerCase()] = len;\n  });\n  return this;\n}\nfunction get$1(name) {\n  if (!name) {\n    return false;\n  }\n  var n2 = name.toLowerCase();\n  if (typeof names$t[n2] !== \"undefined\" && projStore[names$t[n2]]) {\n    return projStore[names$t[n2]];\n  }\n}\nfunction start() {\n  projs.forEach(add);\n}\nvar projections = {\n  start,\n  add,\n  get: get$1\n};\nvar exports$1 = {};\nexports$1.MERIT = {\n  a: 6378137,\n  rf: 298.257,\n  ellipseName: \"MERIT 1983\"\n};\nexports$1.SGS85 = {\n  a: 6378136,\n  rf: 298.257,\n  ellipseName: \"Soviet Geodetic System 85\"\n};\nexports$1.GRS80 = {\n  a: 6378137,\n  rf: 298.257222101,\n  ellipseName: \"GRS 1980(IUGG, 1980)\"\n};\nexports$1.IAU76 = {\n  a: 6378140,\n  rf: 298.257,\n  ellipseName: \"IAU 1976\"\n};\nexports$1.airy = {\n  a: 6377563396e-3,\n  b: 635625691e-2,\n  ellipseName: \"Airy 1830\"\n};\nexports$1.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: \"Appl. Physics. 1965\"\n};\nexports$1.NWL9D = {\n  a: 6378145,\n  rf: 298.25,\n  ellipseName: \"Naval Weapons Lab., 1965\"\n};\nexports$1.mod_airy = {\n  a: 6377340189e-3,\n  b: 6356034446e-3,\n  ellipseName: \"Modified Airy\"\n};\nexports$1.andrae = {\n  a: 637710443e-2,\n  rf: 300,\n  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n};\nexports$1.aust_SA = {\n  a: 6378160,\n  rf: 298.25,\n  ellipseName: \"Australian Natl & S. Amer. 1969\"\n};\nexports$1.GRS67 = {\n  a: 6378160,\n  rf: 298.247167427,\n  ellipseName: \"GRS 67(IUGG 1967)\"\n};\nexports$1.bessel = {\n  a: 6377397155e-3,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841\"\n};\nexports$1.bess_nam = {\n  a: 6377483865e-3,\n  rf: 299.1528128,\n  ellipseName: \"Bessel 1841 (Namibia)\"\n};\nexports$1.clrk66 = {\n  a: 63782064e-1,\n  b: 63565838e-1,\n  ellipseName: \"Clarke 1866\"\n};\nexports$1.clrk80 = {\n  a: 6378249145e-3,\n  rf: 293.4663,\n  ellipseName: \"Clarke 1880 mod.\"\n};\nexports$1.clrk58 = {\n  a: 6378293645208759e-9,\n  rf: 294.2606763692654,\n  ellipseName: \"Clarke 1858\"\n};\nexports$1.CPM = {\n  a: 63757387e-1,\n  rf: 334.29,\n  ellipseName: \"Comm. des Poids et Mesures 1799\"\n};\nexports$1.delmbr = {\n  a: 6376428,\n  rf: 311.5,\n  ellipseName: \"Delambre 1810 (Belgium)\"\n};\nexports$1.engelis = {\n  a: 637813605e-2,\n  rf: 298.2566,\n  ellipseName: \"Engelis 1985\"\n};\nexports$1.evrst30 = {\n  a: 6377276345e-3,\n  rf: 300.8017,\n  ellipseName: \"Everest 1830\"\n};\nexports$1.evrst48 = {\n  a: 6377304063e-3,\n  rf: 300.8017,\n  ellipseName: \"Everest 1948\"\n};\nexports$1.evrst56 = {\n  a: 6377301243e-3,\n  rf: 300.8017,\n  ellipseName: \"Everest 1956\"\n};\nexports$1.evrst69 = {\n  a: 6377295664e-3,\n  rf: 300.8017,\n  ellipseName: \"Everest 1969\"\n};\nexports$1.evrstSS = {\n  a: 6377298556e-3,\n  rf: 300.8017,\n  ellipseName: \"Everest (Sabah & Sarawak)\"\n};\nexports$1.fschr60 = {\n  a: 6378166,\n  rf: 298.3,\n  ellipseName: \"Fischer (Mercury Datum) 1960\"\n};\nexports$1.fschr60m = {\n  a: 6378155,\n  rf: 298.3,\n  ellipseName: \"Fischer 1960\"\n};\nexports$1.fschr68 = {\n  a: 6378150,\n  rf: 298.3,\n  ellipseName: \"Fischer 1968\"\n};\nexports$1.helmert = {\n  a: 6378200,\n  rf: 298.3,\n  ellipseName: \"Helmert 1906\"\n};\nexports$1.hough = {\n  a: 6378270,\n  rf: 297,\n  ellipseName: \"Hough\"\n};\nexports$1.intl = {\n  a: 6378388,\n  rf: 297,\n  ellipseName: \"International 1909 (Hayford)\"\n};\nexports$1.kaula = {\n  a: 6378163,\n  rf: 298.24,\n  ellipseName: \"Kaula 1961\"\n};\nexports$1.lerch = {\n  a: 6378139,\n  rf: 298.257,\n  ellipseName: \"Lerch 1979\"\n};\nexports$1.mprts = {\n  a: 6397300,\n  rf: 191,\n  ellipseName: \"Maupertius 1738\"\n};\nexports$1.new_intl = {\n  a: 63781575e-1,\n  b: 63567722e-1,\n  ellipseName: \"New International 1967\"\n};\nexports$1.plessis = {\n  a: 6376523,\n  rf: 6355863,\n  ellipseName: \"Plessis 1817 (France)\"\n};\nexports$1.krass = {\n  a: 6378245,\n  rf: 298.3,\n  ellipseName: \"Krassovsky, 1942\"\n};\nexports$1.SEasia = {\n  a: 6378155,\n  b: 63567733205e-4,\n  ellipseName: \"Southeast Asia\"\n};\nexports$1.walbeck = {\n  a: 6376896,\n  b: 63558348467e-4,\n  ellipseName: \"Walbeck\"\n};\nexports$1.WGS60 = {\n  a: 6378165,\n  rf: 298.3,\n  ellipseName: \"WGS 60\"\n};\nexports$1.WGS66 = {\n  a: 6378145,\n  rf: 298.25,\n  ellipseName: \"WGS 66\"\n};\nexports$1.WGS7 = {\n  a: 6378135,\n  rf: 298.26,\n  ellipseName: \"WGS 72\"\n};\nvar WGS84 = exports$1.WGS84 = {\n  a: 6378137,\n  rf: 298.257223563,\n  ellipseName: \"WGS 84\"\n};\nexports$1.sphere = {\n  a: 6370997,\n  b: 6370997,\n  ellipseName: \"Normal Sphere (r=6370997)\"\n};\nfunction eccentricity(a2, b2, rf, R_A) {\n  var a22 = a2 * a2;\n  var b22 = b2 * b2;\n  var es = (a22 - b22) / a22;\n  var e2 = 0;\n  if (R_A) {\n    a2 *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n    a22 = a2 * a2;\n    es = 0;\n  } else {\n    e2 = Math.sqrt(es);\n  }\n  var ep2 = (a22 - b22) / b22;\n  return {\n    es,\n    e: e2,\n    ep2\n  };\n}\nfunction sphere(a2, b2, rf, ellps, sphere2) {\n  if (!a2) {\n    var ellipse = match$1(exports$1, ellps);\n    if (!ellipse) {\n      ellipse = WGS84;\n    }\n    a2 = ellipse.a;\n    b2 = ellipse.b;\n    rf = ellipse.rf;\n  }\n  if (rf && !b2) {\n    b2 = (1 - 1 / rf) * a2;\n  }\n  if (rf === 0 || Math.abs(a2 - b2) < EPSLN) {\n    sphere2 = true;\n    b2 = a2;\n  }\n  return {\n    a: a2,\n    b: b2,\n    rf,\n    sphere: sphere2\n  };\n}\nvar exports = {};\nexports.wgs84 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"WGS84\",\n  datumName: \"WGS84\"\n};\nexports.ch1903 = {\n  towgs84: \"674.374,15.056,405.346\",\n  ellipse: \"bessel\",\n  datumName: \"swiss\"\n};\nexports.ggrs87 = {\n  towgs84: \"-199.87,74.79,246.62\",\n  ellipse: \"GRS80\",\n  datumName: \"Greek_Geodetic_Reference_System_1987\"\n};\nexports.nad83 = {\n  towgs84: \"0,0,0\",\n  ellipse: \"GRS80\",\n  datumName: \"North_American_Datum_1983\"\n};\nexports.nad27 = {\n  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n  ellipse: \"clrk66\",\n  datumName: \"North_American_Datum_1927\"\n};\nexports.potsdam = {\n  towgs84: \"598.1,73.7,418.2,0.202,0.045,-2.455,6.7\",\n  ellipse: \"bessel\",\n  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n};\nexports.carthage = {\n  towgs84: \"-263.0,6.0,431.0\",\n  ellipse: \"clark80\",\n  datumName: \"Carthage 1934 Tunisia\"\n};\nexports.hermannskogel = {\n  towgs84: \"577.326,90.129,463.919,5.137,1.474,5.297,2.4232\",\n  ellipse: \"bessel\",\n  datumName: \"Hermannskogel\"\n};\nexports.osni52 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"airy\",\n  datumName: \"Irish National\"\n};\nexports.ire65 = {\n  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n  ellipse: \"mod_airy\",\n  datumName: \"Ireland 1965\"\n};\nexports.rassadiran = {\n  towgs84: \"-133.63,-157.5,-158.62\",\n  ellipse: \"intl\",\n  datumName: \"Rassadiran\"\n};\nexports.nzgd49 = {\n  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n  ellipse: \"intl\",\n  datumName: \"New Zealand Geodetic Datum 1949\"\n};\nexports.osgb36 = {\n  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n  ellipse: \"airy\",\n  datumName: \"Airy 1830\"\n};\nexports.s_jtsk = {\n  towgs84: \"589,76,480\",\n  ellipse: \"bessel\",\n  datumName: \"S-JTSK (Ferro)\"\n};\nexports.beduaram = {\n  towgs84: \"-106,-87,188\",\n  ellipse: \"clrk80\",\n  datumName: \"Beduaram\"\n};\nexports.gunung_segara = {\n  towgs84: \"-403,684,41\",\n  ellipse: \"bessel\",\n  datumName: \"Gunung Segara Jakarta\"\n};\nexports.rnb72 = {\n  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n  ellipse: \"intl\",\n  datumName: \"Reseau National Belge 1972\"\n};\nfunction datum(datumCode, datum_params, a2, b2, es, ep2, nadgrids) {\n  var out = {};\n  if (datumCode === void 0 || datumCode === \"none\") {\n    out.datum_type = PJD_NODATUM;\n  } else {\n    out.datum_type = PJD_WGS84;\n  }\n  if (datum_params) {\n    out.datum_params = datum_params.map(parseFloat);\n    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n      out.datum_type = PJD_3PARAM;\n    }\n    if (out.datum_params.length > 3) {\n      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n        out.datum_type = PJD_7PARAM;\n        out.datum_params[3] *= SEC_TO_RAD;\n        out.datum_params[4] *= SEC_TO_RAD;\n        out.datum_params[5] *= SEC_TO_RAD;\n        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;\n      }\n    }\n  }\n  if (nadgrids) {\n    out.datum_type = PJD_GRIDSHIFT;\n    out.grids = nadgrids;\n  }\n  out.a = a2;\n  out.b = b2;\n  out.es = es;\n  out.ep2 = ep2;\n  return out;\n}\nvar loadedNadgrids = {};\nfunction nadgrid(key, data2) {\n  var view = new DataView(data2);\n  var isLittleEndian = detectLittleEndian(view);\n  var header = readHeader(view, isLittleEndian);\n  if (header.nSubgrids > 1) {\n    console.log(\"Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored\");\n  }\n  var subgrids = readSubgrids(view, header, isLittleEndian);\n  var nadgrid2 = { header, subgrids };\n  loadedNadgrids[key] = nadgrid2;\n  return nadgrid2;\n}\nfunction getNadgrids(nadgrids) {\n  if (nadgrids === void 0) {\n    return null;\n  }\n  var grids = nadgrids.split(\",\");\n  return grids.map(parseNadgridString);\n}\nfunction parseNadgridString(value) {\n  if (value.length === 0) {\n    return null;\n  }\n  var optional = value[0] === \"@\";\n  if (optional) {\n    value = value.slice(1);\n  }\n  if (value === \"null\") {\n    return { name: \"null\", mandatory: !optional, grid: null, isNull: true };\n  }\n  return {\n    name: value,\n    mandatory: !optional,\n    grid: loadedNadgrids[value] || null,\n    isNull: false\n  };\n}\nfunction secondsToRadians(seconds) {\n  return seconds / 3600 * Math.PI / 180;\n}\nfunction detectLittleEndian(view) {\n  var nFields = view.getInt32(8, false);\n  if (nFields === 11) {\n    return false;\n  }\n  nFields = view.getInt32(8, true);\n  if (nFields !== 11) {\n    console.warn(\"Failed to detect nadgrid endian-ness, defaulting to little-endian\");\n  }\n  return true;\n}\nfunction readHeader(view, isLittleEndian) {\n  return {\n    nFields: view.getInt32(8, isLittleEndian),\n    nSubgridFields: view.getInt32(24, isLittleEndian),\n    nSubgrids: view.getInt32(40, isLittleEndian),\n    shiftType: decodeString(view, 56, 56 + 8).trim(),\n    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),\n    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),\n    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),\n    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)\n  };\n}\nfunction decodeString(view, start2, end) {\n  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));\n}\nfunction readSubgrids(view, header, isLittleEndian) {\n  var gridOffset = 176;\n  var grids = [];\n  for (var i2 = 0; i2 < header.nSubgrids; i2++) {\n    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);\n    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);\n    var lngColumnCount = Math.round(1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);\n    var latColumnCount = Math.round(1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);\n    grids.push({\n      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],\n      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],\n      lim: [lngColumnCount, latColumnCount],\n      count: subHeader.gridNodeCount,\n      cvs: mapNodes(nodes)\n    });\n  }\n  return grids;\n}\nfunction mapNodes(nodes) {\n  return nodes.map(function(r2) {\n    return [secondsToRadians(r2.longitudeShift), secondsToRadians(r2.latitudeShift)];\n  });\n}\nfunction readGridHeader(view, offset2, isLittleEndian) {\n  return {\n    name: decodeString(view, offset2 + 8, offset2 + 16).trim(),\n    parent: decodeString(view, offset2 + 24, offset2 + 24 + 8).trim(),\n    lowerLatitude: view.getFloat64(offset2 + 72, isLittleEndian),\n    upperLatitude: view.getFloat64(offset2 + 88, isLittleEndian),\n    lowerLongitude: view.getFloat64(offset2 + 104, isLittleEndian),\n    upperLongitude: view.getFloat64(offset2 + 120, isLittleEndian),\n    latitudeInterval: view.getFloat64(offset2 + 136, isLittleEndian),\n    longitudeInterval: view.getFloat64(offset2 + 152, isLittleEndian),\n    gridNodeCount: view.getInt32(offset2 + 168, isLittleEndian)\n  };\n}\nfunction readGridNodes(view, offset2, gridHeader, isLittleEndian) {\n  var nodesOffset = offset2 + 176;\n  var gridRecordLength = 16;\n  var gridShiftRecords = [];\n  for (var i2 = 0; i2 < gridHeader.gridNodeCount; i2++) {\n    var record = {\n      latitudeShift: view.getFloat32(nodesOffset + i2 * gridRecordLength, isLittleEndian),\n      longitudeShift: view.getFloat32(nodesOffset + i2 * gridRecordLength + 4, isLittleEndian),\n      latitudeAccuracy: view.getFloat32(nodesOffset + i2 * gridRecordLength + 8, isLittleEndian),\n      longitudeAccuracy: view.getFloat32(nodesOffset + i2 * gridRecordLength + 12, isLittleEndian)\n    };\n    gridShiftRecords.push(record);\n  }\n  return gridShiftRecords;\n}\nfunction Projection$1(srsCode, callback) {\n  if (!(this instanceof Projection$1)) {\n    return new Projection$1(srsCode);\n  }\n  callback = callback || function(error) {\n    if (error) {\n      throw error;\n    }\n  };\n  var json = parse$2(srsCode);\n  if (typeof json !== \"object\") {\n    callback(srsCode);\n    return;\n  }\n  var ourProj = Projection$1.projections.get(json.projName);\n  if (!ourProj) {\n    callback(srsCode);\n    return;\n  }\n  if (json.datumCode && json.datumCode !== \"none\") {\n    var datumDef = match$1(exports, json.datumCode);\n    if (datumDef) {\n      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(\",\") : null);\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  json.k0 = json.k0 || 1;\n  json.axis = json.axis || \"enu\";\n  json.ellps = json.ellps || \"wgs84\";\n  json.lat1 = json.lat1 || json.lat0;\n  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\n  var nadgrids = getNadgrids(json.nadgrids);\n  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2, nadgrids);\n  extend(this, json);\n  extend(this, ourProj);\n  this.a = sphere_.a;\n  this.b = sphere_.b;\n  this.rf = sphere_.rf;\n  this.sphere = sphere_.sphere;\n  this.es = ecc.es;\n  this.e = ecc.e;\n  this.ep2 = ecc.ep2;\n  this.datum = datumObj;\n  this.init();\n  callback(null, this);\n}\nProjection$1.projections = projections;\nProjection$1.projections.start();\nfunction compareDatums(source, dest) {\n  if (source.datum_type !== dest.datum_type) {\n    return false;\n  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {\n    return false;\n  } else if (source.datum_type === PJD_3PARAM) {\n    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];\n  } else if (source.datum_type === PJD_7PARAM) {\n    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];\n  } else {\n    return true;\n  }\n}\nfunction geodeticToGeocentric(p5, es, a2) {\n  var Longitude = p5.x;\n  var Latitude = p5.y;\n  var Height = p5.z ? p5.z : 0;\n  var Rn;\n  var Sin_Lat;\n  var Sin2_Lat;\n  var Cos_Lat;\n  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n    Latitude = -HALF_PI;\n  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n    Latitude = HALF_PI;\n  } else if (Latitude < -HALF_PI) {\n    return { x: -Infinity, y: -Infinity, z: p5.z };\n  } else if (Latitude > HALF_PI) {\n    return { x: Infinity, y: Infinity, z: p5.z };\n  }\n  if (Longitude > Math.PI) {\n    Longitude -= 2 * Math.PI;\n  }\n  Sin_Lat = Math.sin(Latitude);\n  Cos_Lat = Math.cos(Latitude);\n  Sin2_Lat = Sin_Lat * Sin_Lat;\n  Rn = a2 / Math.sqrt(1 - es * Sin2_Lat);\n  return {\n    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n    z: (Rn * (1 - es) + Height) * Sin_Lat\n  };\n}\nfunction geocentricToGeodetic(p5, es, a2, b2) {\n  var genau = 1e-12;\n  var genau2 = genau * genau;\n  var maxiter = 30;\n  var P2;\n  var RR;\n  var CT;\n  var ST;\n  var RX;\n  var RK;\n  var RN;\n  var CPHI0;\n  var SPHI0;\n  var CPHI;\n  var SPHI;\n  var SDPHI;\n  var iter;\n  var X2 = p5.x;\n  var Y2 = p5.y;\n  var Z2 = p5.z ? p5.z : 0;\n  var Longitude;\n  var Latitude;\n  var Height;\n  P2 = Math.sqrt(X2 * X2 + Y2 * Y2);\n  RR = Math.sqrt(X2 * X2 + Y2 * Y2 + Z2 * Z2);\n  if (P2 / a2 < genau) {\n    Longitude = 0;\n    if (RR / a2 < genau) {\n      Latitude = HALF_PI;\n      Height = -b2;\n      return {\n        x: p5.x,\n        y: p5.y,\n        z: p5.z\n      };\n    }\n  } else {\n    Longitude = Math.atan2(Y2, X2);\n  }\n  CT = Z2 / RR;\n  ST = P2 / RR;\n  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);\n  CPHI0 = ST * (1 - es) * RX;\n  SPHI0 = CT * RX;\n  iter = 0;\n  do {\n    iter++;\n    RN = a2 / Math.sqrt(1 - es * SPHI0 * SPHI0);\n    Height = P2 * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);\n    RK = es * RN / (RN + Height);\n    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);\n    CPHI = ST * (1 - RK) * RX;\n    SPHI = CT * RX;\n    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n    CPHI0 = CPHI;\n    SPHI0 = SPHI;\n  } while (SDPHI * SDPHI > genau2 && iter < maxiter);\n  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n  return {\n    x: Longitude,\n    y: Latitude,\n    z: Height\n  };\n}\nfunction geocentricToWgs84(p5, datum_type, datum_params) {\n  if (datum_type === PJD_3PARAM) {\n    return {\n      x: p5.x + datum_params[0],\n      y: p5.y + datum_params[1],\n      z: p5.z + datum_params[2]\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    return {\n      x: M_BF * (p5.x - Rz_BF * p5.y + Ry_BF * p5.z) + Dx_BF,\n      y: M_BF * (Rz_BF * p5.x + p5.y - Rx_BF * p5.z) + Dy_BF,\n      z: M_BF * (-Ry_BF * p5.x + Rx_BF * p5.y + p5.z) + Dz_BF\n    };\n  }\n}\nfunction geocentricFromWgs84(p5, datum_type, datum_params) {\n  if (datum_type === PJD_3PARAM) {\n    return {\n      x: p5.x - datum_params[0],\n      y: p5.y - datum_params[1],\n      z: p5.z - datum_params[2]\n    };\n  } else if (datum_type === PJD_7PARAM) {\n    var Dx_BF = datum_params[0];\n    var Dy_BF = datum_params[1];\n    var Dz_BF = datum_params[2];\n    var Rx_BF = datum_params[3];\n    var Ry_BF = datum_params[4];\n    var Rz_BF = datum_params[5];\n    var M_BF = datum_params[6];\n    var x_tmp = (p5.x - Dx_BF) / M_BF;\n    var y_tmp = (p5.y - Dy_BF) / M_BF;\n    var z_tmp = (p5.z - Dz_BF) / M_BF;\n    return {\n      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n    };\n  }\n}\nfunction checkParams(type) {\n  return type === PJD_3PARAM || type === PJD_7PARAM;\n}\nfunction datum_transform(source, dest, point) {\n  if (compareDatums(source, dest)) {\n    return point;\n  }\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return void 0;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\n    return point;\n  }\n  point = geodeticToGeocentric(point, source_es, source_a);\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return void 0;\n    }\n  }\n  return point;\n}\nfunction applyGridShift(source, inverse2, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log(\"Grid shift grids not found\");\n    return -1;\n  }\n  var input = { x: -point.x, y: point.y };\n  var output = { x: Number.NaN, y: Number.NaN };\n  var attemptedGrids = [];\n  for (var i2 = 0; i2 < source.grids.length; i2++) {\n    var grid = source.grids[i2];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n      continue;\n    }\n    var subgrid = grid.grid.subgrids[0];\n    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;\n    var minX = subgrid.ll[0] - epsilon;\n    var minY = subgrid.ll[1] - epsilon;\n    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {\n      continue;\n    }\n    output = applySubgridShift(input, inverse2, subgrid);\n    if (!isNaN(output.x)) {\n      break;\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\" + -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\nfunction applySubgridShift(pin, inverse2, ct2) {\n  var val = { x: Number.NaN, y: Number.NaN };\n  if (isNaN(pin.x)) {\n    return val;\n  }\n  var tb = { x: pin.x, y: pin.y };\n  tb.x -= ct2.ll[0];\n  tb.y -= ct2.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t3 = nadInterpolate(tb, ct2);\n  if (inverse2) {\n    if (isNaN(t3.x)) {\n      return val;\n    }\n    t3.x = tb.x - t3.x;\n    t3.y = tb.y - t3.y;\n    var i2 = 9, tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t3, ct2);\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n      dif = { x: tb.x - (del.x + t3.x), y: tb.y - (del.y + t3.y) };\n      t3.x += dif.x;\n      t3.y += dif.y;\n    } while (i2-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i2 < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n    val.x = adjust_lon(t3.x + ct2.ll[0]);\n    val.y = t3.y + ct2.ll[1];\n  } else {\n    if (!isNaN(t3.x)) {\n      val.x = pin.x + t3.x;\n      val.y = pin.y + t3.y;\n    }\n  }\n  return val;\n}\nfunction nadInterpolate(pin, ct2) {\n  var t3 = { x: pin.x / ct2.del[0], y: pin.y / ct2.del[1] };\n  var indx = { x: Math.floor(t3.x), y: Math.floor(t3.y) };\n  var frct = { x: t3.x - 1 * indx.x, y: t3.y - 1 * indx.y };\n  var val = { x: Number.NaN, y: Number.NaN };\n  var inx;\n  if (indx.x < 0 || indx.x >= ct2.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct2.lim[1]) {\n    return val;\n  }\n  inx = indx.y * ct2.lim[0] + indx.x;\n  var f00 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };\n  inx++;\n  var f10 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };\n  inx += ct2.lim[0];\n  var f11 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };\n  inx--;\n  var f01 = { x: ct2.cvs[inx][0], y: ct2.cvs[inx][1] };\n  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;\n  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;\n  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;\n  return val;\n}\nfunction adjust_axis(crs, denorm, point) {\n  var xin = point.x, yin = point.y, zin = point.z || 0;\n  var v2, t3, i2;\n  var out = {};\n  for (i2 = 0; i2 < 3; i2++) {\n    if (denorm && i2 === 2 && point.z === void 0) {\n      continue;\n    }\n    if (i2 === 0) {\n      v2 = xin;\n      if (\"ew\".indexOf(crs.axis[i2]) !== -1) {\n        t3 = \"x\";\n      } else {\n        t3 = \"y\";\n      }\n    } else if (i2 === 1) {\n      v2 = yin;\n      if (\"ns\".indexOf(crs.axis[i2]) !== -1) {\n        t3 = \"y\";\n      } else {\n        t3 = \"x\";\n      }\n    } else {\n      v2 = zin;\n      t3 = \"z\";\n    }\n    switch (crs.axis[i2]) {\n      case \"e\":\n        out[t3] = v2;\n        break;\n      case \"w\":\n        out[t3] = -v2;\n        break;\n      case \"n\":\n        out[t3] = v2;\n        break;\n      case \"s\":\n        out[t3] = -v2;\n        break;\n      case \"u\":\n        if (point[t3] !== void 0) {\n          out.z = v2;\n        }\n        break;\n      case \"d\":\n        if (point[t3] !== void 0) {\n          out.z = -v2;\n        }\n        break;\n      default:\n        return null;\n    }\n  }\n  return out;\n}\nfunction common(array) {\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length > 2) {\n    out.z = array[2];\n  }\n  if (array.length > 3) {\n    out.m = array[3];\n  }\n  return out;\n}\nfunction checkSanity(point) {\n  checkCoord(point.x);\n  checkCoord(point.y);\n}\nfunction checkCoord(num) {\n  if (typeof Number.isFinite === \"function\") {\n    if (Number.isFinite(num)) {\n      return;\n    }\n    throw new TypeError(\"coordinates must be finite numbers\");\n  }\n  if (typeof num !== \"number\" || num !== num || !isFinite(num)) {\n    throw new TypeError(\"coordinates must be finite numbers\");\n  }\n}\nfunction checkNotWGS(source, dest) {\n  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== \"WGS84\" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== \"WGS84\";\n}\nfunction transform$2(source, dest, point, enforceAxis) {\n  var wgs842;\n  if (Array.isArray(point)) {\n    point = common(point);\n  }\n  checkSanity(point);\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs842 = new Projection$1(\"WGS84\");\n    point = transform$2(source, wgs842, point, enforceAxis);\n    source = wgs842;\n  }\n  if (enforceAxis && source.axis !== \"enu\") {\n    point = adjust_axis(source, false, point);\n  }\n  if (source.projName === \"longlat\") {\n    point = {\n      x: point.x * D2R$1,\n      y: point.y * D2R$1,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point);\n    if (!point) {\n      return;\n    }\n  }\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n  point = datum_transform(source.datum, dest.datum, point);\n  if (!point) {\n    return;\n  }\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n  if (dest.projName === \"longlat\") {\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else {\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n  if (enforceAxis && dest.axis !== \"enu\") {\n    return adjust_axis(dest, true, point);\n  }\n  return point;\n}\nvar wgs84 = Projection$1(\"WGS84\");\nfunction transformer(from, to, coords, enforceAxis) {\n  var transformedArray, out, keys3;\n  if (Array.isArray(coords)) {\n    transformedArray = transform$2(from, to, coords, enforceAxis) || { x: NaN, y: NaN };\n    if (coords.length > 2) {\n      if (typeof from.name !== \"undefined\" && from.name === \"geocent\" || typeof to.name !== \"undefined\" && to.name === \"geocent\") {\n        if (typeof transformedArray.z === \"number\") {\n          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));\n        } else {\n          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));\n        }\n      } else {\n        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));\n      }\n    } else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  } else {\n    out = transform$2(from, to, coords, enforceAxis);\n    keys3 = Object.keys(coords);\n    if (keys3.length === 2) {\n      return out;\n    }\n    keys3.forEach(function(key) {\n      if (typeof from.name !== \"undefined\" && from.name === \"geocent\" || typeof to.name !== \"undefined\" && to.name === \"geocent\") {\n        if (key === \"x\" || key === \"y\" || key === \"z\") {\n          return;\n        }\n      } else {\n        if (key === \"x\" || key === \"y\") {\n          return;\n        }\n      }\n      out[key] = coords[key];\n    });\n    return out;\n  }\n}\nfunction checkProj(item) {\n  if (item instanceof Projection$1) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return Projection$1(item);\n}\nfunction proj4(fromProj, toProj, coord) {\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === \"undefined\") {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  } else if (typeof toProj.x !== \"undefined\" || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  } else {\n    obj = {\n      forward: function(coords, enforceAxis) {\n        return transformer(fromProj, toProj, coords, enforceAxis);\n      },\n      inverse: function(coords, enforceAxis) {\n        return transformer(toProj, fromProj, coords, enforceAxis);\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\nvar NUM_100K_SETS = 6;\nvar SET_ORIGIN_COLUMN_LETTERS = \"AJSAJS\";\nvar SET_ORIGIN_ROW_LETTERS = \"AFAFAF\";\nvar A$2 = 65;\nvar I$1 = 73;\nvar O$2 = 79;\nvar V$2 = 86;\nvar Z$3 = 90;\nvar mgrs = {\n  forward: forward$s,\n  inverse: inverse$s,\n  toPoint\n};\nfunction forward$s(ll, accuracy) {\n  accuracy = accuracy || 5;\n  return encode$1(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n}\nfunction inverse$s(mgrs2) {\n  var bbox2 = UTMtoLL(decode$2(mgrs2.toUpperCase()));\n  if (bbox2.lat && bbox2.lon) {\n    return [bbox2.lon, bbox2.lat, bbox2.lon, bbox2.lat];\n  }\n  return [bbox2.left, bbox2.bottom, bbox2.right, bbox2.top];\n}\nfunction toPoint(mgrs2) {\n  var bbox2 = UTMtoLL(decode$2(mgrs2.toUpperCase()));\n  if (bbox2.lat && bbox2.lon) {\n    return [bbox2.lon, bbox2.lat];\n  }\n  return [(bbox2.left + bbox2.right) / 2, (bbox2.top + bbox2.bottom) / 2];\n}\nfunction degToRad(deg2) {\n  return deg2 * (Math.PI / 180);\n}\nfunction radToDeg(rad) {\n  return 180 * (rad / Math.PI);\n}\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a2 = 6378137;\n  var eccSquared = 669438e-8;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N2, T2, C2, A2, M2;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {\n    ZoneNumber = 32;\n  }\n  if (Lat >= 72 && Lat < 84) {\n    if (Long >= 0 && Long < 9) {\n      ZoneNumber = 31;\n    } else if (Long >= 9 && Long < 21) {\n      ZoneNumber = 33;\n    } else if (Long >= 21 && Long < 33) {\n      ZoneNumber = 35;\n    } else if (Long >= 33 && Long < 42) {\n      ZoneNumber = 37;\n    }\n  }\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;\n  LongOriginRad = degToRad(LongOrigin);\n  eccPrimeSquared = eccSquared / (1 - eccSquared);\n  N2 = a2 / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T2 = Math.tan(LatRad) * Math.tan(LatRad);\n  C2 = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);\n  M2 = a2 * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));\n  var UTMEasting = k0 * N2 * (A2 + (1 - T2 + C2) * A2 * A2 * A2 / 6 + (5 - 18 * T2 + T2 * T2 + 72 * C2 - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;\n  var UTMNorthing = k0 * (M2 + N2 * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T2 + 9 * C2 + 4 * C2 * C2) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T2 + T2 * T2 + 600 * C2 - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));\n  if (Lat < 0) {\n    UTMNorthing += 1e7;\n  }\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\nfunction UTMtoLL(utm2) {\n  var UTMNorthing = utm2.northing;\n  var UTMEasting = utm2.easting;\n  var zoneLetter = utm2.zoneLetter;\n  var zoneNumber = utm2.zoneNumber;\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n  var k0 = 0.9996;\n  var a2 = 6378137;\n  var eccSquared = 669438e-8;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C12, R1, D2, M2;\n  var LongOrigin;\n  var mu, phi1Rad;\n  var x2 = UTMEasting - 5e5;\n  var y2 = UTMNorthing;\n  if (zoneLetter < \"N\") {\n    y2 -= 1e7;\n  }\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;\n  eccPrimeSquared = eccSquared / (1 - eccSquared);\n  M2 = y2 / k0;\n  mu = M2 / (a2 * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);\n  N1 = a2 / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a2 * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D2 = x2 / (N1 * k0);\n  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D2 * D2 / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D2 * D2 * D2 * D2 / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D2 * D2 * D2 * D2 * D2 * D2 / 720);\n  lat = radToDeg(lat);\n  var lon = (D2 - (1 + 2 * T1 + C12) * D2 * D2 * D2 / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D2 * D2 * D2 * D2 * D2 / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n  var result;\n  if (utm2.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm2.northing + utm2.accuracy,\n      easting: utm2.easting + utm2.accuracy,\n      zoneLetter: utm2.zoneLetter,\n      zoneNumber: utm2.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  } else {\n    result = {\n      lat,\n      lon\n    };\n  }\n  return result;\n}\nfunction getLetterDesignator(lat) {\n  var LetterDesignator = \"Z\";\n  if (84 >= lat && lat >= 72) {\n    LetterDesignator = \"X\";\n  } else if (72 > lat && lat >= 64) {\n    LetterDesignator = \"W\";\n  } else if (64 > lat && lat >= 56) {\n    LetterDesignator = \"V\";\n  } else if (56 > lat && lat >= 48) {\n    LetterDesignator = \"U\";\n  } else if (48 > lat && lat >= 40) {\n    LetterDesignator = \"T\";\n  } else if (40 > lat && lat >= 32) {\n    LetterDesignator = \"S\";\n  } else if (32 > lat && lat >= 24) {\n    LetterDesignator = \"R\";\n  } else if (24 > lat && lat >= 16) {\n    LetterDesignator = \"Q\";\n  } else if (16 > lat && lat >= 8) {\n    LetterDesignator = \"P\";\n  } else if (8 > lat && lat >= 0) {\n    LetterDesignator = \"N\";\n  } else if (0 > lat && lat >= -8) {\n    LetterDesignator = \"M\";\n  } else if (-8 > lat && lat >= -16) {\n    LetterDesignator = \"L\";\n  } else if (-16 > lat && lat >= -24) {\n    LetterDesignator = \"K\";\n  } else if (-24 > lat && lat >= -32) {\n    LetterDesignator = \"J\";\n  } else if (-32 > lat && lat >= -40) {\n    LetterDesignator = \"H\";\n  } else if (-40 > lat && lat >= -48) {\n    LetterDesignator = \"G\";\n  } else if (-48 > lat && lat >= -56) {\n    LetterDesignator = \"F\";\n  } else if (-56 > lat && lat >= -64) {\n    LetterDesignator = \"E\";\n  } else if (-64 > lat && lat >= -72) {\n    LetterDesignator = \"D\";\n  } else if (-72 > lat && lat >= -80) {\n    LetterDesignator = \"C\";\n  }\n  return LetterDesignator;\n}\nfunction encode$1(utm2, accuracy) {\n  var seasting = \"00000\" + utm2.easting, snorthing = \"00000\" + utm2.northing;\n  return utm2.zoneNumber + utm2.zoneLetter + get100kID(utm2.easting, utm2.northing, utm2.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 1e5);\n  var setRow = Math.floor(northing / 1e5) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\nfunction get100kSetForZone(i2) {\n  var setParm = i2 % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n  return setParm;\n}\nfunction getLetter100kID(column, row, parm) {\n  var index2 = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index2);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index2);\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n  if (colInt > Z$3) {\n    colInt = colInt - Z$3 + A$2 - 1;\n    rollover = true;\n  }\n  if (colInt === I$1 || colOrigin < I$1 && colInt > I$1 || (colInt > I$1 || colOrigin < I$1) && rollover) {\n    colInt++;\n  }\n  if (colInt === O$2 || colOrigin < O$2 && colInt > O$2 || (colInt > O$2 || colOrigin < O$2) && rollover) {\n    colInt++;\n    if (colInt === I$1) {\n      colInt++;\n    }\n  }\n  if (colInt > Z$3) {\n    colInt = colInt - Z$3 + A$2 - 1;\n  }\n  if (rowInt > V$2) {\n    rowInt = rowInt - V$2 + A$2 - 1;\n    rollover = true;\n  } else {\n    rollover = false;\n  }\n  if (rowInt === I$1 || rowOrigin < I$1 && rowInt > I$1 || (rowInt > I$1 || rowOrigin < I$1) && rollover) {\n    rowInt++;\n  }\n  if (rowInt === O$2 || rowOrigin < O$2 && rowInt > O$2 || (rowInt > O$2 || rowOrigin < O$2) && rollover) {\n    rowInt++;\n    if (rowInt === I$1) {\n      rowInt++;\n    }\n  }\n  if (rowInt > V$2) {\n    rowInt = rowInt - V$2 + A$2 - 1;\n  }\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\nfunction decode$2(mgrsString) {\n  if (mgrsString && mgrsString.length === 0) {\n    throw \"MGRSPoint coverting from nothing\";\n  }\n  var length = mgrsString.length;\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i2 = 0;\n  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i2))) {\n    if (i2 >= 2) {\n      throw \"MGRSPoint bad conversion from: \" + mgrsString;\n    }\n    sb += testChar;\n    i2++;\n  }\n  var zoneNumber = parseInt(sb, 10);\n  if (i2 === 0 || i2 + 3 > length) {\n    throw \"MGRSPoint bad conversion from: \" + mgrsString;\n  }\n  var zoneLetter = mgrsString.charAt(i2++);\n  if (zoneLetter <= \"A\" || zoneLetter === \"B\" || zoneLetter === \"Y\" || zoneLetter >= \"Z\" || zoneLetter === \"I\" || zoneLetter === \"O\") {\n    throw \"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString;\n  }\n  hunK = mgrsString.substring(i2, i2 += 2);\n  var set2 = get100kSetForZone(zoneNumber);\n  var east100k = getEastingFromChar(hunK.charAt(0), set2);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set2);\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2e6;\n  }\n  var remainder = length - i2;\n  if (remainder % 2 !== 0) {\n    throw \"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString;\n  }\n  var sep = remainder / 2;\n  var sepEasting = 0;\n  var sepNorthing = 0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 1e5 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i2, i2 + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i2 + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n  return {\n    easting,\n    northing,\n    zoneLetter,\n    zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\nfunction getEastingFromChar(e2, set2) {\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set2 - 1);\n  var eastingValue = 1e5;\n  var rewindMarker = false;\n  while (curCol !== e2.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I$1) {\n      curCol++;\n    }\n    if (curCol === O$2) {\n      curCol++;\n    }\n    if (curCol > Z$3) {\n      if (rewindMarker) {\n        throw \"Bad character: \" + e2;\n      }\n      curCol = A$2;\n      rewindMarker = true;\n    }\n    eastingValue += 1e5;\n  }\n  return eastingValue;\n}\nfunction getNorthingFromChar(n2, set2) {\n  if (n2 > \"V\") {\n    throw \"MGRSPoint given invalid Northing \" + n2;\n  }\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set2 - 1);\n  var northingValue = 0;\n  var rewindMarker = false;\n  while (curRow !== n2.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I$1) {\n      curRow++;\n    }\n    if (curRow === O$2) {\n      curRow++;\n    }\n    if (curRow > V$2) {\n      if (rewindMarker) {\n        throw \"Bad character: \" + n2;\n      }\n      curRow = A$2;\n      rewindMarker = true;\n    }\n    northingValue += 1e5;\n  }\n  return northingValue;\n}\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n    case \"C\":\n      northing = 11e5;\n      break;\n    case \"D\":\n      northing = 2e6;\n      break;\n    case \"E\":\n      northing = 28e5;\n      break;\n    case \"F\":\n      northing = 37e5;\n      break;\n    case \"G\":\n      northing = 46e5;\n      break;\n    case \"H\":\n      northing = 55e5;\n      break;\n    case \"J\":\n      northing = 64e5;\n      break;\n    case \"K\":\n      northing = 73e5;\n      break;\n    case \"L\":\n      northing = 82e5;\n      break;\n    case \"M\":\n      northing = 91e5;\n      break;\n    case \"N\":\n      northing = 0;\n      break;\n    case \"P\":\n      northing = 8e5;\n      break;\n    case \"Q\":\n      northing = 17e5;\n      break;\n    case \"R\":\n      northing = 26e5;\n      break;\n    case \"S\":\n      northing = 35e5;\n      break;\n    case \"T\":\n      northing = 44e5;\n      break;\n    case \"U\":\n      northing = 53e5;\n      break;\n    case \"V\":\n      northing = 62e5;\n      break;\n    case \"W\":\n      northing = 7e6;\n      break;\n    case \"X\":\n      northing = 79e5;\n      break;\n    default:\n      northing = -1;\n  }\n  if (northing >= 0) {\n    return northing;\n  } else {\n    throw \"Invalid zone letter: \" + zoneLetter;\n  }\n}\nfunction Point$2(x2, y2, z2) {\n  if (!(this instanceof Point$2)) {\n    return new Point$2(x2, y2, z2);\n  }\n  if (Array.isArray(x2)) {\n    this.x = x2[0];\n    this.y = x2[1];\n    this.z = x2[2] || 0;\n  } else if (typeof x2 === \"object\") {\n    this.x = x2.x;\n    this.y = x2.y;\n    this.z = x2.z || 0;\n  } else if (typeof x2 === \"string\" && typeof y2 === \"undefined\") {\n    var coords = x2.split(\",\");\n    this.x = parseFloat(coords[0], 10);\n    this.y = parseFloat(coords[1], 10);\n    this.z = parseFloat(coords[2], 10) || 0;\n  } else {\n    this.x = x2;\n    this.y = y2;\n    this.z = z2 || 0;\n  }\n  console.warn(\"proj4.Point will be removed in version 3, use proj4.toPoint\");\n}\nPoint$2.fromMGRS = function(mgrsStr) {\n  return new Point$2(toPoint(mgrsStr));\n};\nPoint$2.prototype.toMGRS = function(accuracy) {\n  return forward$s([this.x, this.y], accuracy);\n};\nvar C00 = 1;\nvar C02 = 0.25;\nvar C04 = 0.046875;\nvar C06 = 0.01953125;\nvar C08 = 0.01068115234375;\nvar C22 = 0.75;\nvar C44 = 0.46875;\nvar C46 = 0.013020833333333334;\nvar C48 = 0.007120768229166667;\nvar C66 = 0.3645833333333333;\nvar C68 = 0.005696614583333333;\nvar C88 = 0.3076171875;\nfunction pj_enfn(es) {\n  var en = [];\n  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));\n  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));\n  var t3 = es * es;\n  en[2] = t3 * (C44 - es * (C46 + es * C48));\n  t3 *= es;\n  en[3] = t3 * (C66 - es * C68);\n  en[4] = t3 * es * C88;\n  return en;\n}\nfunction pj_mlfn(phi, sphi, cphi, en) {\n  cphi *= sphi;\n  sphi *= sphi;\n  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));\n}\nvar MAX_ITER$3 = 20;\nfunction pj_inv_mlfn(arg, es, en) {\n  var k2 = 1 / (1 - es);\n  var phi = arg;\n  for (var i2 = MAX_ITER$3; i2; --i2) {\n    var s2 = Math.sin(phi);\n    var t3 = 1 - es * s2 * s2;\n    t3 = (pj_mlfn(phi, s2, Math.cos(phi), en) - arg) * (t3 * Math.sqrt(t3)) * k2;\n    phi -= t3;\n    if (Math.abs(t3) < EPSLN) {\n      return phi;\n    }\n  }\n  return phi;\n}\nfunction init$s() {\n  this.x0 = this.x0 !== void 0 ? this.x0 : 0;\n  this.y0 = this.y0 !== void 0 ? this.y0 : 0;\n  this.long0 = this.long0 !== void 0 ? this.long0 : 0;\n  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;\n  if (this.es) {\n    this.en = pj_enfn(this.es);\n    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);\n  }\n}\nfunction forward$r(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  var con;\n  var x2, y2;\n  var sin_phi = Math.sin(lat);\n  var cos_phi = Math.cos(lat);\n  if (!this.es) {\n    var b2 = cos_phi * Math.sin(delta_lon);\n    if (Math.abs(Math.abs(b2) - 1) < EPSLN) {\n      return 93;\n    } else {\n      x2 = 0.5 * this.a * this.k0 * Math.log((1 + b2) / (1 - b2)) + this.x0;\n      y2 = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b2, 2));\n      b2 = Math.abs(y2);\n      if (b2 >= 1) {\n        if (b2 - 1 > EPSLN) {\n          return 93;\n        } else {\n          y2 = 0;\n        }\n      } else {\n        y2 = Math.acos(y2);\n      }\n      if (lat < 0) {\n        y2 = -y2;\n      }\n      y2 = this.a * this.k0 * (y2 - this.lat0) + this.y0;\n    }\n  } else {\n    var al = cos_phi * delta_lon;\n    var als = Math.pow(al, 2);\n    var c2 = this.ep2 * Math.pow(cos_phi, 2);\n    var cs = Math.pow(c2, 2);\n    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;\n    var t3 = Math.pow(tq, 2);\n    var ts = Math.pow(t3, 2);\n    con = 1 - this.es * Math.pow(sin_phi, 2);\n    al = al / Math.sqrt(con);\n    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);\n    x2 = this.a * (this.k0 * al * (1 + als / 6 * (1 - t3 + c2 + als / 20 * (5 - 18 * t3 + ts + 14 * c2 - 58 * t3 * c2 + als / 42 * (61 + 179 * ts - ts * t3 - 479 * t3))))) + this.x0;\n    y2 = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t3 + 9 * c2 + 4 * cs + als / 30 * (61 + ts - 58 * t3 + 270 * c2 - 330 * t3 * c2 + als / 56 * (1385 + 543 * ts - ts * t3 - 3111 * t3)))))) + this.y0;\n  }\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$r(p5) {\n  var con, phi;\n  var lat, lon;\n  var x2 = (p5.x - this.x0) * (1 / this.a);\n  var y2 = (p5.y - this.y0) * (1 / this.a);\n  if (!this.es) {\n    var f2 = Math.exp(x2 / this.k0);\n    var g2 = 0.5 * (f2 - 1 / f2);\n    var temp = this.lat0 + y2 / this.k0;\n    var h2 = Math.cos(temp);\n    con = Math.sqrt((1 - Math.pow(h2, 2)) / (1 + Math.pow(g2, 2)));\n    lat = Math.asin(con);\n    if (y2 < 0) {\n      lat = -lat;\n    }\n    if (g2 === 0 && h2 === 0) {\n      lon = 0;\n    } else {\n      lon = adjust_lon(Math.atan2(g2, h2) + this.long0);\n    }\n  } else {\n    con = this.ml0 + y2 / this.k0;\n    phi = pj_inv_mlfn(con, this.es, this.en);\n    if (Math.abs(phi) < HALF_PI) {\n      var sin_phi = Math.sin(phi);\n      var cos_phi = Math.cos(phi);\n      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;\n      var c2 = this.ep2 * Math.pow(cos_phi, 2);\n      var cs = Math.pow(c2, 2);\n      var t3 = Math.pow(tan_phi, 2);\n      var ts = Math.pow(t3, 2);\n      con = 1 - this.es * Math.pow(sin_phi, 2);\n      var d2 = x2 * Math.sqrt(con) / this.k0;\n      var ds = Math.pow(d2, 2);\n      con = con * tan_phi;\n      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t3 - 9 * c2 * t3 + c2 - 4 * cs - ds / 30 * (61 + 90 * t3 - 252 * c2 * t3 + 45 * ts + 46 * c2 - ds / 56 * (1385 + 3633 * t3 + 4095 * ts + 1574 * ts * t3))));\n      lon = adjust_lon(this.long0 + d2 * (1 - ds / 6 * (1 + 2 * t3 + c2 - ds / 20 * (5 + 28 * t3 + 24 * ts + 8 * c2 * t3 + 6 * c2 - ds / 42 * (61 + 662 * t3 + 1320 * ts + 720 * ts * t3)))) / cos_phi);\n    } else {\n      lat = HALF_PI * sign(y2);\n      lon = 0;\n    }\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$s = [\"Fast_Transverse_Mercator\", \"Fast Transverse Mercator\"];\nvar tmerc = {\n  init: init$s,\n  forward: forward$r,\n  inverse: inverse$r,\n  names: names$s\n};\nfunction sinh(x2) {\n  var r2 = Math.exp(x2);\n  r2 = (r2 - 1 / r2) / 2;\n  return r2;\n}\nfunction hypot(x2, y2) {\n  x2 = Math.abs(x2);\n  y2 = Math.abs(y2);\n  var a2 = Math.max(x2, y2);\n  var b2 = Math.min(x2, y2) / (a2 ? a2 : 1);\n  return a2 * Math.sqrt(1 + Math.pow(b2, 2));\n}\nfunction log1py(x2) {\n  var y2 = 1 + x2;\n  var z2 = y2 - 1;\n  return z2 === 0 ? x2 : x2 * Math.log(y2) / z2;\n}\nfunction asinhy(x2) {\n  var y2 = Math.abs(x2);\n  y2 = log1py(y2 * (1 + y2 / (hypot(1, y2) + 1)));\n  return x2 < 0 ? -y2 : y2;\n}\nfunction gatg(pp, B3) {\n  var cos_2B = 2 * Math.cos(2 * B3);\n  var i2 = pp.length - 1;\n  var h1 = pp[i2];\n  var h2 = 0;\n  var h3;\n  while (--i2 >= 0) {\n    h3 = -h2 + cos_2B * h1 + pp[i2];\n    h2 = h1;\n    h1 = h3;\n  }\n  return B3 + h3 * Math.sin(2 * B3);\n}\nfunction clens(pp, arg_r) {\n  var r2 = 2 * Math.cos(arg_r);\n  var i2 = pp.length - 1;\n  var hr1 = pp[i2];\n  var hr2 = 0;\n  var hr;\n  while (--i2 >= 0) {\n    hr = -hr2 + r2 * hr1 + pp[i2];\n    hr2 = hr1;\n    hr1 = hr;\n  }\n  return Math.sin(arg_r) * hr;\n}\nfunction cosh(x2) {\n  var r2 = Math.exp(x2);\n  r2 = (r2 + 1 / r2) / 2;\n  return r2;\n}\nfunction clens_cmplx(pp, arg_r, arg_i) {\n  var sin_arg_r = Math.sin(arg_r);\n  var cos_arg_r = Math.cos(arg_r);\n  var sinh_arg_i = sinh(arg_i);\n  var cosh_arg_i = cosh(arg_i);\n  var r2 = 2 * cos_arg_r * cosh_arg_i;\n  var i2 = -2 * sin_arg_r * sinh_arg_i;\n  var j2 = pp.length - 1;\n  var hr = pp[j2];\n  var hi1 = 0;\n  var hr1 = 0;\n  var hi = 0;\n  var hr2;\n  var hi2;\n  while (--j2 >= 0) {\n    hr2 = hr1;\n    hi2 = hi1;\n    hr1 = hr;\n    hi1 = hi;\n    hr = -hr2 + r2 * hr1 - i2 * hi1 + pp[j2];\n    hi = -hi2 + i2 * hr1 + r2 * hi1;\n  }\n  r2 = sin_arg_r * cosh_arg_i;\n  i2 = cos_arg_r * sinh_arg_i;\n  return [r2 * hr - i2 * hi, r2 * hi + i2 * hr];\n}\nfunction init$r() {\n  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {\n    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION[\"Fast_Transverse_Mercator\"] in the WKT.');\n  }\n  if (this.approx) {\n    tmerc.init.apply(this);\n    this.forward = tmerc.forward;\n    this.inverse = tmerc.inverse;\n  }\n  this.x0 = this.x0 !== void 0 ? this.x0 : 0;\n  this.y0 = this.y0 !== void 0 ? this.y0 : 0;\n  this.long0 = this.long0 !== void 0 ? this.long0 : 0;\n  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;\n  this.cgb = [];\n  this.cbg = [];\n  this.utg = [];\n  this.gtu = [];\n  var f2 = this.es / (1 + Math.sqrt(1 - this.es));\n  var n2 = f2 / (2 - f2);\n  var np = n2;\n  this.cgb[0] = n2 * (2 + n2 * (-2 / 3 + n2 * (-2 + n2 * (116 / 45 + n2 * (26 / 45 + n2 * (-2854 / 675))))));\n  this.cbg[0] = n2 * (-2 + n2 * (2 / 3 + n2 * (4 / 3 + n2 * (-82 / 45 + n2 * (32 / 45 + n2 * (4642 / 4725))))));\n  np = np * n2;\n  this.cgb[1] = np * (7 / 3 + n2 * (-8 / 5 + n2 * (-227 / 45 + n2 * (2704 / 315 + n2 * (2323 / 945)))));\n  this.cbg[1] = np * (5 / 3 + n2 * (-16 / 15 + n2 * (-13 / 9 + n2 * (904 / 315 + n2 * (-1522 / 945)))));\n  np = np * n2;\n  this.cgb[2] = np * (56 / 15 + n2 * (-136 / 35 + n2 * (-1262 / 105 + n2 * (73814 / 2835))));\n  this.cbg[2] = np * (-26 / 15 + n2 * (34 / 21 + n2 * (8 / 5 + n2 * (-12686 / 2835))));\n  np = np * n2;\n  this.cgb[3] = np * (4279 / 630 + n2 * (-332 / 35 + n2 * (-399572 / 14175)));\n  this.cbg[3] = np * (1237 / 630 + n2 * (-12 / 5 + n2 * (-24832 / 14175)));\n  np = np * n2;\n  this.cgb[4] = np * (4174 / 315 + n2 * (-144838 / 6237));\n  this.cbg[4] = np * (-734 / 315 + n2 * (109598 / 31185));\n  np = np * n2;\n  this.cgb[5] = np * (601676 / 22275);\n  this.cbg[5] = np * (444337 / 155925);\n  np = Math.pow(n2, 2);\n  this.Qn = this.k0 / (1 + n2) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));\n  this.utg[0] = n2 * (-0.5 + n2 * (2 / 3 + n2 * (-37 / 96 + n2 * (1 / 360 + n2 * (81 / 512 + n2 * (-96199 / 604800))))));\n  this.gtu[0] = n2 * (0.5 + n2 * (-2 / 3 + n2 * (5 / 16 + n2 * (41 / 180 + n2 * (-127 / 288 + n2 * (7891 / 37800))))));\n  this.utg[1] = np * (-1 / 48 + n2 * (-1 / 15 + n2 * (437 / 1440 + n2 * (-46 / 105 + n2 * (1118711 / 3870720)))));\n  this.gtu[1] = np * (13 / 48 + n2 * (-3 / 5 + n2 * (557 / 1440 + n2 * (281 / 630 + n2 * (-1983433 / 1935360)))));\n  np = np * n2;\n  this.utg[2] = np * (-17 / 480 + n2 * (37 / 840 + n2 * (209 / 4480 + n2 * (-5569 / 90720))));\n  this.gtu[2] = np * (61 / 240 + n2 * (-103 / 140 + n2 * (15061 / 26880 + n2 * (167603 / 181440))));\n  np = np * n2;\n  this.utg[3] = np * (-4397 / 161280 + n2 * (11 / 504 + n2 * (830251 / 7257600)));\n  this.gtu[3] = np * (49561 / 161280 + n2 * (-179 / 168 + n2 * (6601661 / 7257600)));\n  np = np * n2;\n  this.utg[4] = np * (-4583 / 161280 + n2 * (108847 / 3991680));\n  this.gtu[4] = np * (34729 / 80640 + n2 * (-3418889 / 1995840));\n  np = np * n2;\n  this.utg[5] = np * (-20648693 / 638668800);\n  this.gtu[5] = np * (212378941 / 319334400);\n  var Z2 = gatg(this.cbg, this.lat0);\n  this.Zb = -this.Qn * (Z2 + clens(this.gtu, 2 * Z2));\n}\nfunction forward$q(p5) {\n  var Ce = adjust_lon(p5.x - this.long0);\n  var Cn = p5.y;\n  Cn = gatg(this.cbg, Cn);\n  var sin_Cn = Math.sin(Cn);\n  var cos_Cn = Math.cos(Cn);\n  var sin_Ce = Math.sin(Ce);\n  var cos_Ce = Math.cos(Ce);\n  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);\n  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));\n  Ce = asinhy(Math.tan(Ce));\n  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);\n  Cn = Cn + tmp[0];\n  Ce = Ce + tmp[1];\n  var x2;\n  var y2;\n  if (Math.abs(Ce) <= 2.623395162778) {\n    x2 = this.a * (this.Qn * Ce) + this.x0;\n    y2 = this.a * (this.Qn * Cn + this.Zb) + this.y0;\n  } else {\n    x2 = Infinity;\n    y2 = Infinity;\n  }\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$q(p5) {\n  var Ce = (p5.x - this.x0) * (1 / this.a);\n  var Cn = (p5.y - this.y0) * (1 / this.a);\n  Cn = (Cn - this.Zb) / this.Qn;\n  Ce = Ce / this.Qn;\n  var lon;\n  var lat;\n  if (Math.abs(Ce) <= 2.623395162778) {\n    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);\n    Cn = Cn + tmp[0];\n    Ce = Ce + tmp[1];\n    Ce = Math.atan(sinh(Ce));\n    var sin_Cn = Math.sin(Cn);\n    var cos_Cn = Math.cos(Cn);\n    var sin_Ce = Math.sin(Ce);\n    var cos_Ce = Math.cos(Ce);\n    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));\n    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);\n    lon = adjust_lon(Ce + this.long0);\n    lat = gatg(this.cgb, Cn);\n  } else {\n    lon = Infinity;\n    lat = Infinity;\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$r = [\"Extended_Transverse_Mercator\", \"Extended Transverse Mercator\", \"etmerc\", \"Transverse_Mercator\", \"Transverse Mercator\", \"tmerc\"];\nvar etmerc = {\n  init: init$r,\n  forward: forward$q,\n  inverse: inverse$q,\n  names: names$r\n};\nfunction adjust_zone(zone, lon) {\n  if (zone === void 0) {\n    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;\n    if (zone < 0) {\n      return 0;\n    } else if (zone > 60) {\n      return 60;\n    }\n  }\n  return zone;\n}\nvar dependsOn = \"etmerc\";\nfunction init$q() {\n  var zone = adjust_zone(this.zone, this.long0);\n  if (zone === void 0) {\n    throw new Error(\"unknown utm zone\");\n  }\n  this.lat0 = 0;\n  this.long0 = (6 * Math.abs(zone) - 183) * D2R$1;\n  this.x0 = 5e5;\n  this.y0 = this.utmSouth ? 1e7 : 0;\n  this.k0 = 0.9996;\n  etmerc.init.apply(this);\n  this.forward = etmerc.forward;\n  this.inverse = etmerc.inverse;\n}\nvar names$q = [\"Universal Transverse Mercator System\", \"utm\"];\nvar utm = {\n  init: init$q,\n  names: names$q,\n  dependsOn\n};\nfunction srat(esinp, exp) {\n  return Math.pow((1 - esinp) / (1 + esinp), exp);\n}\nvar MAX_ITER$2 = 20;\nfunction init$p() {\n  var sphi = Math.sin(this.lat0);\n  var cphi = Math.cos(this.lat0);\n  cphi *= cphi;\n  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);\n  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));\n  this.phic0 = Math.asin(sphi / this.C);\n  this.ratexp = 0.5 * this.C * this.e;\n  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));\n}\nfunction forward$p(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  p5.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;\n  p5.x = this.C * lon;\n  return p5;\n}\nfunction inverse$p(p5) {\n  var DEL_TOL = 1e-14;\n  var lon = p5.x / this.C;\n  var lat = p5.y;\n  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);\n  for (var i2 = MAX_ITER$2; i2 > 0; --i2) {\n    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p5.y), -0.5 * this.e)) - HALF_PI;\n    if (Math.abs(lat - p5.y) < DEL_TOL) {\n      break;\n    }\n    p5.y = lat;\n  }\n  if (!i2) {\n    return null;\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$p = [\"gauss\"];\nvar gauss = {\n  init: init$p,\n  forward: forward$p,\n  inverse: inverse$p,\n  names: names$p\n};\nfunction init$o() {\n  gauss.init.apply(this);\n  if (!this.rc) {\n    return;\n  }\n  this.sinc0 = Math.sin(this.phic0);\n  this.cosc0 = Math.cos(this.phic0);\n  this.R2 = 2 * this.rc;\n  if (!this.title) {\n    this.title = \"Oblique Stereographic Alternative\";\n  }\n}\nfunction forward$o(p5) {\n  var sinc, cosc, cosl, k2;\n  p5.x = adjust_lon(p5.x - this.long0);\n  gauss.forward.apply(this, [p5]);\n  sinc = Math.sin(p5.y);\n  cosc = Math.cos(p5.y);\n  cosl = Math.cos(p5.x);\n  k2 = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);\n  p5.x = k2 * cosc * Math.sin(p5.x);\n  p5.y = k2 * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);\n  p5.x = this.a * p5.x + this.x0;\n  p5.y = this.a * p5.y + this.y0;\n  return p5;\n}\nfunction inverse$o(p5) {\n  var sinc, cosc, lon, lat, rho;\n  p5.x = (p5.x - this.x0) / this.a;\n  p5.y = (p5.y - this.y0) / this.a;\n  p5.x /= this.k0;\n  p5.y /= this.k0;\n  if (rho = Math.sqrt(p5.x * p5.x + p5.y * p5.y)) {\n    var c2 = 2 * Math.atan2(rho, this.R2);\n    sinc = Math.sin(c2);\n    cosc = Math.cos(c2);\n    lat = Math.asin(cosc * this.sinc0 + p5.y * sinc * this.cosc0 / rho);\n    lon = Math.atan2(p5.x * sinc, rho * this.cosc0 * cosc - p5.y * this.sinc0 * sinc);\n  } else {\n    lat = this.phic0;\n    lon = 0;\n  }\n  p5.x = lon;\n  p5.y = lat;\n  gauss.inverse.apply(this, [p5]);\n  p5.x = adjust_lon(p5.x + this.long0);\n  return p5;\n}\nvar names$o = [\"Stereographic_North_Pole\", \"Oblique_Stereographic\", \"Polar_Stereographic\", \"sterea\", \"Oblique Stereographic Alternative\", \"Double_Stereographic\"];\nvar sterea = {\n  init: init$o,\n  forward: forward$o,\n  inverse: inverse$o,\n  names: names$o\n};\nfunction ssfn_(phit, sinphi, eccen) {\n  sinphi *= eccen;\n  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);\n}\nfunction init$n() {\n  this.coslat0 = Math.cos(this.lat0);\n  this.sinlat0 = Math.sin(this.lat0);\n  if (this.sphere) {\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));\n    }\n  } else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (this.lat0 > 0) {\n        this.con = 1;\n      } else {\n        this.con = -1;\n      }\n    }\n    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));\n    }\n    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);\n    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;\n    this.cosX0 = Math.cos(this.X0);\n    this.sinX0 = Math.sin(this.X0);\n  }\n}\nfunction forward$n(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var sinlat = Math.sin(lat);\n  var coslat = Math.cos(lat);\n  var A2, X2, sinX, cosX, ts, rh;\n  var dlon = adjust_lon(lon - this.long0);\n  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {\n    p5.x = NaN;\n    p5.y = NaN;\n    return p5;\n  }\n  if (this.sphere) {\n    A2 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));\n    p5.x = this.a * A2 * coslat * Math.sin(dlon) + this.x0;\n    p5.y = this.a * A2 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;\n    return p5;\n  } else {\n    X2 = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;\n    cosX = Math.cos(X2);\n    sinX = Math.sin(X2);\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);\n      rh = 2 * this.a * this.k0 * ts / this.cons;\n      p5.x = this.x0 + rh * Math.sin(lon - this.long0);\n      p5.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);\n      return p5;\n    } else if (Math.abs(this.sinlat0) < EPSLN) {\n      A2 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));\n      p5.y = A2 * sinX;\n    } else {\n      A2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));\n      p5.y = A2 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;\n    }\n    p5.x = A2 * cosX * Math.sin(dlon) + this.x0;\n  }\n  return p5;\n}\nfunction inverse$n(p5) {\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  var lon, lat, ts, ce2, Chi;\n  var rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n  if (this.sphere) {\n    var c2 = 2 * Math.atan(rh / (2 * this.a * this.k0));\n    lon = this.long0;\n    lat = this.lat0;\n    if (rh <= EPSLN) {\n      p5.x = lon;\n      p5.y = lat;\n      return p5;\n    }\n    lat = Math.asin(Math.cos(c2) * this.sinlat0 + p5.y * Math.sin(c2) * this.coslat0 / rh);\n    if (Math.abs(this.coslat0) < EPSLN) {\n      if (this.lat0 > 0) {\n        lon = adjust_lon(this.long0 + Math.atan2(p5.x, -1 * p5.y));\n      } else {\n        lon = adjust_lon(this.long0 + Math.atan2(p5.x, p5.y));\n      }\n    } else {\n      lon = adjust_lon(this.long0 + Math.atan2(p5.x * Math.sin(c2), rh * this.coslat0 * Math.cos(c2) - p5.y * this.sinlat0 * Math.sin(c2)));\n    }\n    p5.x = lon;\n    p5.y = lat;\n    return p5;\n  } else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (rh <= EPSLN) {\n        lat = this.lat0;\n        lon = this.long0;\n        p5.x = lon;\n        p5.y = lat;\n        return p5;\n      }\n      p5.x *= this.con;\n      p5.y *= this.con;\n      ts = rh * this.cons / (2 * this.a * this.k0);\n      lat = this.con * phi2z(this.e, ts);\n      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p5.x, -1 * p5.y));\n    } else {\n      ce2 = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));\n      lon = this.long0;\n      if (rh <= EPSLN) {\n        Chi = this.X0;\n      } else {\n        Chi = Math.asin(Math.cos(ce2) * this.sinX0 + p5.y * Math.sin(ce2) * this.cosX0 / rh);\n        lon = adjust_lon(this.long0 + Math.atan2(p5.x * Math.sin(ce2), rh * this.cosX0 * Math.cos(ce2) - p5.y * this.sinX0 * Math.sin(ce2)));\n      }\n      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));\n    }\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$n = [\"stere\", \"Stereographic_South_Pole\", \"Polar Stereographic (variant B)\"];\nvar stere = {\n  init: init$n,\n  forward: forward$n,\n  inverse: inverse$n,\n  names: names$n,\n  ssfn_\n};\nfunction init$m() {\n  var phy0 = this.lat0;\n  this.lambda0 = this.long0;\n  var sinPhy0 = Math.sin(phy0);\n  var semiMajorAxis = this.a;\n  var invF = this.rf;\n  var flattening = 1 / invF;\n  var e2 = 2 * flattening - Math.pow(flattening, 2);\n  var e3 = this.e = Math.sqrt(e2);\n  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));\n  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));\n  this.b0 = Math.asin(sinPhy0 / this.alpha);\n  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));\n  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));\n  var k3 = Math.log((1 + e3 * sinPhy0) / (1 - e3 * sinPhy0));\n  this.K = k1 - this.alpha * k2 + this.alpha * e3 / 2 * k3;\n}\nfunction forward$m(p5) {\n  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p5.y / 2));\n  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p5.y)) / (1 - this.e * Math.sin(p5.y)));\n  var S2 = -this.alpha * (Sa1 + Sa2) + this.K;\n  var b2 = 2 * (Math.atan(Math.exp(S2)) - Math.PI / 4);\n  var I2 = this.alpha * (p5.x - this.lambda0);\n  var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b2) + Math.cos(this.b0) * Math.cos(I2)));\n  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b2) - Math.sin(this.b0) * Math.cos(b2) * Math.cos(I2));\n  p5.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;\n  p5.x = this.R * rotI + this.x0;\n  return p5;\n}\nfunction inverse$m(p5) {\n  var Y2 = p5.x - this.x0;\n  var X2 = p5.y - this.y0;\n  var rotI = Y2 / this.R;\n  var rotB = 2 * (Math.atan(Math.exp(X2 / this.R)) - Math.PI / 4);\n  var b2 = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));\n  var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));\n  var lambda = this.lambda0 + I2 / this.alpha;\n  var S2 = 0;\n  var phy = b2;\n  var prevPhy = -1e3;\n  var iteration = 0;\n  while (Math.abs(phy - prevPhy) > 1e-7) {\n    if (++iteration > 20) {\n      return;\n    }\n    S2 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b2 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));\n    prevPhy = phy;\n    phy = 2 * Math.atan(Math.exp(S2)) - Math.PI / 2;\n  }\n  p5.x = lambda;\n  p5.y = phy;\n  return p5;\n}\nvar names$m = [\"somerc\"];\nvar somerc = {\n  init: init$m,\n  forward: forward$m,\n  inverse: inverse$m,\n  names: names$m\n};\nvar TOL = 1e-7;\nfunction isTypeA(P2) {\n  var typeAProjections = [\"Hotine_Oblique_Mercator\", \"Hotine_Oblique_Mercator_Azimuth_Natural_Origin\"];\n  var projectionName = typeof P2.PROJECTION === \"object\" ? Object.keys(P2.PROJECTION)[0] : P2.PROJECTION;\n  return \"no_uoff\" in P2 || \"no_off\" in P2 || typeAProjections.indexOf(projectionName) !== -1;\n}\nfunction init$l() {\n  var con, com, cosph0, D2, F2, H4, L2, sinph0, p5, J2, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;\n  this.no_off = isTypeA(this);\n  this.no_rot = \"no_rot\" in this;\n  var alp = false;\n  if (\"alpha\" in this) {\n    alp = true;\n  }\n  var gam = false;\n  if (\"rectified_grid_angle\" in this) {\n    gam = true;\n  }\n  if (alp) {\n    alpha_c = this.alpha;\n  }\n  if (gam) {\n    gamma = this.rectified_grid_angle * D2R$1;\n  }\n  if (alp || gam) {\n    lamc = this.longc;\n  } else {\n    lam1 = this.long1;\n    phi1 = this.lat1;\n    lam2 = this.long2;\n    phi2 = this.lat2;\n    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {\n      throw new Error();\n    }\n  }\n  var one_es = 1 - this.es;\n  com = Math.sqrt(one_es);\n  if (Math.abs(this.lat0) > EPSLN) {\n    sinph0 = Math.sin(this.lat0);\n    cosph0 = Math.cos(this.lat0);\n    con = 1 - this.es * sinph0 * sinph0;\n    this.B = cosph0 * cosph0;\n    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);\n    this.A = this.B * this.k0 * com / con;\n    D2 = this.B * com / (cosph0 * Math.sqrt(con));\n    F2 = D2 * D2 - 1;\n    if (F2 <= 0) {\n      F2 = 0;\n    } else {\n      F2 = Math.sqrt(F2);\n      if (this.lat0 < 0) {\n        F2 = -F2;\n      }\n    }\n    this.E = F2 += D2;\n    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);\n  } else {\n    this.B = 1 / com;\n    this.A = this.k0;\n    this.E = D2 = F2 = 1;\n  }\n  if (alp || gam) {\n    if (alp) {\n      gamma0 = Math.asin(Math.sin(alpha_c) / D2);\n      if (!gam) {\n        gamma = alpha_c;\n      }\n    } else {\n      gamma0 = gamma;\n      alpha_c = Math.asin(D2 * Math.sin(gamma0));\n    }\n    this.lam0 = lamc - Math.asin(0.5 * (F2 - 1 / F2) * Math.tan(gamma0)) / this.B;\n  } else {\n    H4 = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);\n    L2 = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);\n    F2 = this.E / H4;\n    p5 = (L2 - H4) / (L2 + H4);\n    J2 = this.E * this.E;\n    J2 = (J2 - L2 * H4) / (J2 + L2 * H4);\n    con = lam1 - lam2;\n    if (con < -Math.pi) {\n      lam2 -= TWO_PI;\n    } else if (con > Math.pi) {\n      lam2 += TWO_PI;\n    }\n    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J2 * Math.tan(0.5 * this.B * (lam1 - lam2)) / p5) / this.B);\n    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F2 - 1 / F2));\n    gamma = alpha_c = Math.asin(D2 * Math.sin(gamma0));\n  }\n  this.singam = Math.sin(gamma0);\n  this.cosgam = Math.cos(gamma0);\n  this.sinrot = Math.sin(gamma);\n  this.cosrot = Math.cos(gamma);\n  this.rB = 1 / this.B;\n  this.ArB = this.A * this.rB;\n  this.BrA = 1 / this.ArB;\n  this.A * this.B;\n  if (this.no_off) {\n    this.u_0 = 0;\n  } else {\n    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D2 * D2 - 1) / Math.cos(alpha_c)));\n    if (this.lat0 < 0) {\n      this.u_0 = -this.u_0;\n    }\n  }\n  F2 = 0.5 * gamma0;\n  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F2));\n  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F2));\n}\nfunction forward$l(p5) {\n  var coords = {};\n  var S2, T2, U2, V2, W2, temp, u2, v2;\n  p5.x = p5.x - this.lam0;\n  if (Math.abs(Math.abs(p5.y) - HALF_PI) > EPSLN) {\n    W2 = this.E / Math.pow(tsfnz(this.e, p5.y, Math.sin(p5.y)), this.B);\n    temp = 1 / W2;\n    S2 = 0.5 * (W2 - temp);\n    T2 = 0.5 * (W2 + temp);\n    V2 = Math.sin(this.B * p5.x);\n    U2 = (S2 * this.singam - V2 * this.cosgam) / T2;\n    if (Math.abs(Math.abs(U2) - 1) < EPSLN) {\n      throw new Error();\n    }\n    v2 = 0.5 * this.ArB * Math.log((1 - U2) / (1 + U2));\n    temp = Math.cos(this.B * p5.x);\n    if (Math.abs(temp) < TOL) {\n      u2 = this.A * p5.x;\n    } else {\n      u2 = this.ArB * Math.atan2(S2 * this.cosgam + V2 * this.singam, temp);\n    }\n  } else {\n    v2 = p5.y > 0 ? this.v_pole_n : this.v_pole_s;\n    u2 = this.ArB * p5.y;\n  }\n  if (this.no_rot) {\n    coords.x = u2;\n    coords.y = v2;\n  } else {\n    u2 -= this.u_0;\n    coords.x = v2 * this.cosrot + u2 * this.sinrot;\n    coords.y = u2 * this.cosrot - v2 * this.sinrot;\n  }\n  coords.x = this.a * coords.x + this.x0;\n  coords.y = this.a * coords.y + this.y0;\n  return coords;\n}\nfunction inverse$l(p5) {\n  var u2, v2, Qp, Sp, Tp, Vp, Up;\n  var coords = {};\n  p5.x = (p5.x - this.x0) * (1 / this.a);\n  p5.y = (p5.y - this.y0) * (1 / this.a);\n  if (this.no_rot) {\n    v2 = p5.y;\n    u2 = p5.x;\n  } else {\n    v2 = p5.x * this.cosrot - p5.y * this.sinrot;\n    u2 = p5.y * this.cosrot + p5.x * this.sinrot + this.u_0;\n  }\n  Qp = Math.exp(-this.BrA * v2);\n  Sp = 0.5 * (Qp - 1 / Qp);\n  Tp = 0.5 * (Qp + 1 / Qp);\n  Vp = Math.sin(this.BrA * u2);\n  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;\n  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {\n    coords.x = 0;\n    coords.y = Up < 0 ? -HALF_PI : HALF_PI;\n  } else {\n    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));\n    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));\n    if (coords.y === Infinity) {\n      throw new Error();\n    }\n    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u2));\n  }\n  coords.x += this.lam0;\n  return coords;\n}\nvar names$l = [\"Hotine_Oblique_Mercator\", \"Hotine Oblique Mercator\", \"Hotine_Oblique_Mercator_Azimuth_Natural_Origin\", \"Hotine_Oblique_Mercator_Two_Point_Natural_Origin\", \"Hotine_Oblique_Mercator_Azimuth_Center\", \"Oblique_Mercator\", \"omerc\"];\nvar omerc = {\n  init: init$l,\n  forward: forward$l,\n  inverse: inverse$l,\n  names: names$l\n};\nfunction init$k() {\n  if (!this.lat2) {\n    this.lat2 = this.lat1;\n  }\n  if (!this.k0) {\n    this.k0 = 1;\n  }\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  var temp = this.b / this.a;\n  this.e = Math.sqrt(1 - temp * temp);\n  var sin1 = Math.sin(this.lat1);\n  var cos1 = Math.cos(this.lat1);\n  var ms1 = msfnz(this.e, sin1, cos1);\n  var ts1 = tsfnz(this.e, this.lat1, sin1);\n  var sin2 = Math.sin(this.lat2);\n  var cos2 = Math.cos(this.lat2);\n  var ms2 = msfnz(this.e, sin2, cos2);\n  var ts2 = tsfnz(this.e, this.lat2, sin2);\n  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n  } else {\n    this.ns = sin1;\n  }\n  if (isNaN(this.ns)) {\n    this.ns = sin1;\n  }\n  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n  if (!this.title) {\n    this.title = \"Lambert Conformal Conic\";\n  }\n}\nfunction forward$k(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n    lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n  }\n  var con = Math.abs(Math.abs(lat) - HALF_PI);\n  var ts, rh1;\n  if (con > EPSLN) {\n    ts = tsfnz(this.e, lat, Math.sin(lat));\n    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n  } else {\n    con = lat * this.ns;\n    if (con <= 0) {\n      return null;\n    }\n    rh1 = 0;\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  p5.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n  p5.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n  return p5;\n}\nfunction inverse$k(p5) {\n  var rh1, con, ts;\n  var lat, lon;\n  var x2 = (p5.x - this.x0) / this.k0;\n  var y2 = this.rh - (p5.y - this.y0) / this.k0;\n  if (this.ns > 0) {\n    rh1 = Math.sqrt(x2 * x2 + y2 * y2);\n    con = 1;\n  } else {\n    rh1 = -Math.sqrt(x2 * x2 + y2 * y2);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * x2, con * y2);\n  }\n  if (rh1 !== 0 || this.ns > 0) {\n    con = 1 / this.ns;\n    ts = Math.pow(rh1 / (this.a * this.f0), con);\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  } else {\n    lat = -HALF_PI;\n  }\n  lon = adjust_lon(theta / this.ns + this.long0);\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$k = [\n  \"Lambert Tangential Conformal Conic Projection\",\n  \"Lambert_Conformal_Conic\",\n  \"Lambert_Conformal_Conic_1SP\",\n  \"Lambert_Conformal_Conic_2SP\",\n  \"lcc\"\n];\nvar lcc = {\n  init: init$k,\n  forward: forward$k,\n  inverse: inverse$k,\n  names: names$k\n};\nfunction init$j() {\n  this.a = 6377397155e-3;\n  this.es = 0.006674372230614;\n  this.e = Math.sqrt(this.es);\n  if (!this.lat0) {\n    this.lat0 = 0.863937979737193;\n  }\n  if (!this.long0) {\n    this.long0 = 0.7417649320975901 - 0.308341501185665;\n  }\n  if (!this.k0) {\n    this.k0 = 0.9999;\n  }\n  this.s45 = 0.785398163397448;\n  this.s90 = 2 * this.s45;\n  this.fi0 = this.lat0;\n  this.e2 = this.es;\n  this.e = Math.sqrt(this.e2);\n  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));\n  this.uq = 1.04216856380474;\n  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);\n  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);\n  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;\n  this.k1 = this.k0;\n  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));\n  this.s0 = 1.37008346281555;\n  this.n = Math.sin(this.s0);\n  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);\n  this.ad = this.s90 - this.uq;\n}\nfunction forward$j(p5) {\n  var gfi, u2, deltav, s2, d2, eps, ro;\n  var lon = p5.x;\n  var lat = p5.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);\n  u2 = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);\n  deltav = -delta_lon * this.alfa;\n  s2 = Math.asin(Math.cos(this.ad) * Math.sin(u2) + Math.sin(this.ad) * Math.cos(u2) * Math.cos(deltav));\n  d2 = Math.asin(Math.cos(u2) * Math.sin(deltav) / Math.cos(s2));\n  eps = this.n * d2;\n  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s2 / 2 + this.s45), this.n);\n  p5.y = ro * Math.cos(eps) / 1;\n  p5.x = ro * Math.sin(eps) / 1;\n  if (!this.czech) {\n    p5.y *= -1;\n    p5.x *= -1;\n  }\n  return p5;\n}\nfunction inverse$j(p5) {\n  var u2, deltav, s2, d2, eps, ro, fi1;\n  var ok;\n  var tmp = p5.x;\n  p5.x = p5.y;\n  p5.y = tmp;\n  if (!this.czech) {\n    p5.y *= -1;\n    p5.x *= -1;\n  }\n  ro = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n  eps = Math.atan2(p5.y, p5.x);\n  d2 = eps / Math.sin(this.s0);\n  s2 = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);\n  u2 = Math.asin(Math.cos(this.ad) * Math.sin(s2) - Math.sin(this.ad) * Math.cos(s2) * Math.cos(d2));\n  deltav = Math.asin(Math.cos(s2) * Math.sin(d2) / Math.cos(u2));\n  p5.x = this.long0 - deltav / this.alfa;\n  fi1 = u2;\n  ok = 0;\n  var iter = 0;\n  do {\n    p5.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u2 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);\n    if (Math.abs(fi1 - p5.y) < 1e-10) {\n      ok = 1;\n    }\n    fi1 = p5.y;\n    iter += 1;\n  } while (ok === 0 && iter < 15);\n  if (iter >= 15) {\n    return null;\n  }\n  return p5;\n}\nvar names$j = [\"Krovak\", \"krovak\"];\nvar krovak = {\n  init: init$j,\n  forward: forward$j,\n  inverse: inverse$j,\n  names: names$j\n};\nfunction mlfn(e0, e1, e2, e3, phi) {\n  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);\n}\nfunction e0fn(x2) {\n  return 1 - 0.25 * x2 * (1 + x2 / 16 * (3 + 1.25 * x2));\n}\nfunction e1fn(x2) {\n  return 0.375 * x2 * (1 + 0.25 * x2 * (1 + 0.46875 * x2));\n}\nfunction e2fn(x2) {\n  return 0.05859375 * x2 * x2 * (1 + 0.75 * x2);\n}\nfunction e3fn(x2) {\n  return x2 * x2 * x2 * (35 / 3072);\n}\nfunction gN(a2, e2, sinphi) {\n  var temp = e2 * sinphi;\n  return a2 / Math.sqrt(1 - temp * temp);\n}\nfunction adjust_lat(x2) {\n  return Math.abs(x2) < HALF_PI ? x2 : x2 - sign(x2) * Math.PI;\n}\nfunction imlfn(ml, e0, e1, e2, e3) {\n  var phi;\n  var dphi;\n  phi = ml / e0;\n  for (var i2 = 0; i2 < 15; i2++) {\n    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));\n    phi += dphi;\n    if (Math.abs(dphi) <= 1e-10) {\n      return phi;\n    }\n  }\n  return NaN;\n}\nfunction init$i() {\n  if (!this.sphere) {\n    this.e0 = e0fn(this.es);\n    this.e1 = e1fn(this.es);\n    this.e2 = e2fn(this.es);\n    this.e3 = e3fn(this.es);\n    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  }\n}\nfunction forward$i(p5) {\n  var x2, y2;\n  var lam = p5.x;\n  var phi = p5.y;\n  lam = adjust_lon(lam - this.long0);\n  if (this.sphere) {\n    x2 = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));\n    y2 = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);\n  } else {\n    var sinphi = Math.sin(phi);\n    var cosphi = Math.cos(phi);\n    var nl = gN(this.a, this.e, sinphi);\n    var tl = Math.tan(phi) * Math.tan(phi);\n    var al = lam * Math.cos(phi);\n    var asq = al * al;\n    var cl = this.es * cosphi * cosphi / (1 - this.es);\n    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n    x2 = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));\n    y2 = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);\n  }\n  p5.x = x2 + this.x0;\n  p5.y = y2 + this.y0;\n  return p5;\n}\nfunction inverse$i(p5) {\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  var x2 = p5.x / this.a;\n  var y2 = p5.y / this.a;\n  var phi, lam;\n  if (this.sphere) {\n    var dd = y2 + this.lat0;\n    phi = Math.asin(Math.sin(dd) * Math.cos(x2));\n    lam = Math.atan2(Math.tan(x2), Math.cos(dd));\n  } else {\n    var ml1 = this.ml0 / this.a + y2;\n    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);\n    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {\n      p5.x = this.long0;\n      p5.y = HALF_PI;\n      if (y2 < 0) {\n        p5.y *= -1;\n      }\n      return p5;\n    }\n    var nl1 = gN(this.a, this.e, Math.sin(phi1));\n    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);\n    var tl1 = Math.pow(Math.tan(phi1), 2);\n    var dl = x2 * this.a / nl1;\n    var dsq = dl * dl;\n    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);\n    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);\n  }\n  p5.x = adjust_lon(lam + this.long0);\n  p5.y = adjust_lat(phi);\n  return p5;\n}\nvar names$i = [\"Cassini\", \"Cassini_Soldner\", \"cass\"];\nvar cass = {\n  init: init$i,\n  forward: forward$i,\n  inverse: inverse$i,\n  names: names$i\n};\nfunction qsfnz(eccent, sinphi) {\n  var con;\n  if (eccent > 1e-7) {\n    con = eccent * sinphi;\n    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n  } else {\n    return 2 * sinphi;\n  }\n}\nvar S_POLE = 1;\nvar N_POLE = 2;\nvar EQUIT = 3;\nvar OBLIQ = 4;\nfunction init$h() {\n  var t3 = Math.abs(this.lat0);\n  if (Math.abs(t3 - HALF_PI) < EPSLN) {\n    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n  } else if (Math.abs(t3) < EPSLN) {\n    this.mode = this.EQUIT;\n  } else {\n    this.mode = this.OBLIQ;\n  }\n  if (this.es > 0) {\n    var sinphi;\n    this.qp = qsfnz(this.e, 1);\n    this.mmf = 0.5 / (1 - this.es);\n    this.apa = authset(this.es);\n    switch (this.mode) {\n      case this.N_POLE:\n        this.dd = 1;\n        break;\n      case this.S_POLE:\n        this.dd = 1;\n        break;\n      case this.EQUIT:\n        this.rq = Math.sqrt(0.5 * this.qp);\n        this.dd = 1 / this.rq;\n        this.xmf = 1;\n        this.ymf = 0.5 * this.qp;\n        break;\n      case this.OBLIQ:\n        this.rq = Math.sqrt(0.5 * this.qp);\n        sinphi = Math.sin(this.lat0);\n        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n        this.ymf = (this.xmf = this.rq) / this.dd;\n        this.xmf *= this.dd;\n        break;\n    }\n  } else {\n    if (this.mode === this.OBLIQ) {\n      this.sinph0 = Math.sin(this.lat0);\n      this.cosph0 = Math.cos(this.lat0);\n    }\n  }\n}\nfunction forward$h(p5) {\n  var x2, y2, coslam, sinlam, sinphi, q2, sinb, cosb, b2, cosphi;\n  var lam = p5.x;\n  var phi = p5.y;\n  lam = adjust_lon(lam - this.long0);\n  if (this.sphere) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    coslam = Math.cos(lam);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      y2 = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      if (y2 <= EPSLN) {\n        return null;\n      }\n      y2 = Math.sqrt(2 / y2);\n      x2 = y2 * cosphi * Math.sin(lam);\n      y2 *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        coslam = -coslam;\n      }\n      if (Math.abs(phi + this.lat0) < EPSLN) {\n        return null;\n      }\n      y2 = FORTPI - phi * 0.5;\n      y2 = 2 * (this.mode === this.S_POLE ? Math.cos(y2) : Math.sin(y2));\n      x2 = y2 * Math.sin(lam);\n      y2 *= coslam;\n    }\n  } else {\n    sinb = 0;\n    cosb = 0;\n    b2 = 0;\n    coslam = Math.cos(lam);\n    sinlam = Math.sin(lam);\n    sinphi = Math.sin(phi);\n    q2 = qsfnz(this.e, sinphi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinb = q2 / this.qp;\n      cosb = Math.sqrt(1 - sinb * sinb);\n    }\n    switch (this.mode) {\n      case this.OBLIQ:\n        b2 = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n        break;\n      case this.EQUIT:\n        b2 = 1 + cosb * coslam;\n        break;\n      case this.N_POLE:\n        b2 = HALF_PI + phi;\n        q2 = this.qp - q2;\n        break;\n      case this.S_POLE:\n        b2 = phi - HALF_PI;\n        q2 = this.qp + q2;\n        break;\n    }\n    if (Math.abs(b2) < EPSLN) {\n      return null;\n    }\n    switch (this.mode) {\n      case this.OBLIQ:\n      case this.EQUIT:\n        b2 = Math.sqrt(2 / b2);\n        if (this.mode === this.OBLIQ) {\n          y2 = this.ymf * b2 * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n        } else {\n          y2 = (b2 = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n        }\n        x2 = this.xmf * b2 * cosb * sinlam;\n        break;\n      case this.N_POLE:\n      case this.S_POLE:\n        if (q2 >= 0) {\n          x2 = (b2 = Math.sqrt(q2)) * sinlam;\n          y2 = coslam * (this.mode === this.S_POLE ? b2 : -b2);\n        } else {\n          x2 = y2 = 0;\n        }\n        break;\n    }\n  }\n  p5.x = this.a * x2 + this.x0;\n  p5.y = this.a * y2 + this.y0;\n  return p5;\n}\nfunction inverse$h(p5) {\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  var x2 = p5.x / this.a;\n  var y2 = p5.y / this.a;\n  var lam, phi, cCe, sCe, q2, rho, ab;\n  if (this.sphere) {\n    var cosz = 0, rh, sinz = 0;\n    rh = Math.sqrt(x2 * x2 + y2 * y2);\n    phi = rh * 0.5;\n    if (phi > 1) {\n      return null;\n    }\n    phi = 2 * Math.asin(phi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinz = Math.sin(phi);\n      cosz = Math.cos(phi);\n    }\n    switch (this.mode) {\n      case this.EQUIT:\n        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y2 * sinz / rh);\n        x2 *= sinz;\n        y2 = cosz * rh;\n        break;\n      case this.OBLIQ:\n        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y2 * sinz * this.cosph0 / rh);\n        x2 *= sinz * this.cosph0;\n        y2 = (cosz - Math.sin(phi) * this.sinph0) * rh;\n        break;\n      case this.N_POLE:\n        y2 = -y2;\n        phi = HALF_PI - phi;\n        break;\n      case this.S_POLE:\n        phi -= HALF_PI;\n        break;\n    }\n    lam = y2 === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x2, y2);\n  } else {\n    ab = 0;\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      x2 /= this.dd;\n      y2 *= this.dd;\n      rho = Math.sqrt(x2 * x2 + y2 * y2);\n      if (rho < EPSLN) {\n        p5.x = this.long0;\n        p5.y = this.lat0;\n        return p5;\n      }\n      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n      cCe = Math.cos(sCe);\n      x2 *= sCe = Math.sin(sCe);\n      if (this.mode === this.OBLIQ) {\n        ab = cCe * this.sinb1 + y2 * sCe * this.cosb1 / rho;\n        q2 = this.qp * ab;\n        y2 = rho * this.cosb1 * cCe - y2 * this.sinb1 * sCe;\n      } else {\n        ab = y2 * sCe / rho;\n        q2 = this.qp * ab;\n        y2 = rho * cCe;\n      }\n    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        y2 = -y2;\n      }\n      q2 = x2 * x2 + y2 * y2;\n      if (!q2) {\n        p5.x = this.long0;\n        p5.y = this.lat0;\n        return p5;\n      }\n      ab = 1 - q2 / this.qp;\n      if (this.mode === this.S_POLE) {\n        ab = -ab;\n      }\n    }\n    lam = Math.atan2(x2, y2);\n    phi = authlat(Math.asin(ab), this.apa);\n  }\n  p5.x = adjust_lon(this.long0 + lam);\n  p5.y = phi;\n  return p5;\n}\nvar P00 = 0.3333333333333333;\nvar P01 = 0.17222222222222222;\nvar P02 = 0.10257936507936508;\nvar P10 = 0.06388888888888888;\nvar P11 = 0.0664021164021164;\nvar P20 = 0.016415012942191543;\nfunction authset(es) {\n  var t3;\n  var APA = [];\n  APA[0] = es * P00;\n  t3 = es * es;\n  APA[0] += t3 * P01;\n  APA[1] = t3 * P10;\n  t3 *= es;\n  APA[0] += t3 * P02;\n  APA[1] += t3 * P11;\n  APA[2] = t3 * P20;\n  return APA;\n}\nfunction authlat(beta, APA) {\n  var t3 = beta + beta;\n  return beta + APA[0] * Math.sin(t3) + APA[1] * Math.sin(t3 + t3) + APA[2] * Math.sin(t3 + t3 + t3);\n}\nvar names$h = [\"Lambert Azimuthal Equal Area\", \"Lambert_Azimuthal_Equal_Area\", \"laea\"];\nvar laea = {\n  init: init$h,\n  forward: forward$h,\n  inverse: inverse$h,\n  names: names$h,\n  S_POLE,\n  N_POLE,\n  EQUIT,\n  OBLIQ\n};\nfunction asinz(x2) {\n  if (Math.abs(x2) > 1) {\n    x2 = x2 > 1 ? 1 : -1;\n  }\n  return Math.asin(x2);\n}\nfunction init$g() {\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e3 = Math.sqrt(this.es);\n  this.sin_po = Math.sin(this.lat1);\n  this.cos_po = Math.cos(this.lat1);\n  this.t1 = this.sin_po;\n  this.con = this.sin_po;\n  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);\n  this.sin_po = Math.sin(this.lat2);\n  this.cos_po = Math.cos(this.lat2);\n  this.t2 = this.sin_po;\n  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);\n  this.sin_po = Math.sin(this.lat0);\n  this.cos_po = Math.cos(this.lat0);\n  this.t3 = this.sin_po;\n  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);\n  } else {\n    this.ns0 = this.con;\n  }\n  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;\n  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;\n}\nfunction forward$g(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  this.sin_phi = Math.sin(lat);\n  this.cos_phi = Math.cos(lat);\n  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);\n  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;\n  var theta = this.ns0 * adjust_lon(lon - this.long0);\n  var x2 = rh1 * Math.sin(theta) + this.x0;\n  var y2 = this.rh - rh1 * Math.cos(theta) + this.y0;\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$g(p5) {\n  var rh1, qs, con, theta, lon, lat;\n  p5.x -= this.x0;\n  p5.y = this.rh - p5.y + this.y0;\n  if (this.ns0 >= 0) {\n    rh1 = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n    con = 1;\n  } else {\n    rh1 = -Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n    con = -1;\n  }\n  theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p5.x, con * p5.y);\n  }\n  con = rh1 * this.ns0 / this.a;\n  if (this.sphere) {\n    lat = Math.asin((this.c - con * con) / (2 * this.ns0));\n  } else {\n    qs = (this.c - con * con) / this.ns0;\n    lat = this.phi1z(this.e3, qs);\n  }\n  lon = adjust_lon(theta / this.ns0 + this.long0);\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nfunction phi1z(eccent, qs) {\n  var sinphi, cosphi, con, com, dphi;\n  var phi = asinz(0.5 * qs);\n  if (eccent < EPSLN) {\n    return phi;\n  }\n  var eccnts = eccent * eccent;\n  for (var i2 = 1; i2 <= 25; i2++) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    con = eccent * sinphi;\n    com = 1 - con * con;\n    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi = phi + dphi;\n    if (Math.abs(dphi) <= 1e-7) {\n      return phi;\n    }\n  }\n  return null;\n}\nvar names$g = [\"Albers_Conic_Equal_Area\", \"Albers\", \"aea\"];\nvar aea = {\n  init: init$g,\n  forward: forward$g,\n  inverse: inverse$g,\n  names: names$g,\n  phi1z\n};\nfunction init$f() {\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n  this.infinity_dist = 1e3 * this.a;\n  this.rc = 1;\n}\nfunction forward$f(p5) {\n  var sinphi, cosphi;\n  var dlon;\n  var coslon;\n  var ksp;\n  var g2;\n  var x2, y2;\n  var lon = p5.x;\n  var lat = p5.y;\n  dlon = adjust_lon(lon - this.long0);\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n  coslon = Math.cos(dlon);\n  g2 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if (g2 > 0 || Math.abs(g2) <= EPSLN) {\n    x2 = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g2;\n    y2 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g2;\n  } else {\n    x2 = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n    y2 = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n  }\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$f(p5) {\n  var rh;\n  var sinc, cosc;\n  var c2;\n  var lon, lat;\n  p5.x = (p5.x - this.x0) / this.a;\n  p5.y = (p5.y - this.y0) / this.a;\n  p5.x /= this.k0;\n  p5.y /= this.k0;\n  if (rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y)) {\n    c2 = Math.atan2(rh, this.rc);\n    sinc = Math.sin(c2);\n    cosc = Math.cos(c2);\n    lat = asinz(cosc * this.sin_p14 + p5.y * sinc * this.cos_p14 / rh);\n    lon = Math.atan2(p5.x * sinc, rh * this.cos_p14 * cosc - p5.y * this.sin_p14 * sinc);\n    lon = adjust_lon(this.long0 + lon);\n  } else {\n    lat = this.phic0;\n    lon = 0;\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$f = [\"gnom\"];\nvar gnom = {\n  init: init$f,\n  forward: forward$f,\n  inverse: inverse$f,\n  names: names$f\n};\nfunction iqsfnz(eccent, q2) {\n  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));\n  if (Math.abs(Math.abs(q2) - temp) < 1e-6) {\n    if (q2 < 0) {\n      return -1 * HALF_PI;\n    } else {\n      return HALF_PI;\n    }\n  }\n  var phi = Math.asin(0.5 * q2);\n  var dphi;\n  var sin_phi;\n  var cos_phi;\n  var con;\n  for (var i2 = 0; i2 < 30; i2++) {\n    sin_phi = Math.sin(phi);\n    cos_phi = Math.cos(phi);\n    con = eccent * sin_phi;\n    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q2 / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi += dphi;\n    if (Math.abs(dphi) <= 1e-10) {\n      return phi;\n    }\n  }\n  return NaN;\n}\nfunction init$e() {\n  if (!this.sphere) {\n    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n  }\n}\nfunction forward$e(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var x2, y2;\n  var dlon = adjust_lon(lon - this.long0);\n  if (this.sphere) {\n    x2 = this.x0 + this.a * dlon * Math.cos(this.lat_ts);\n    y2 = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);\n  } else {\n    var qs = qsfnz(this.e, Math.sin(lat));\n    x2 = this.x0 + this.a * this.k0 * dlon;\n    y2 = this.y0 + this.a * qs * 0.5 / this.k0;\n  }\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$e(p5) {\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  var lon, lat;\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + p5.x / this.a / Math.cos(this.lat_ts));\n    lat = Math.asin(p5.y / this.a * Math.cos(this.lat_ts));\n  } else {\n    lat = iqsfnz(this.e, 2 * p5.y * this.k0 / this.a);\n    lon = adjust_lon(this.long0 + p5.x / (this.a * this.k0));\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$e = [\"cea\"];\nvar cea = {\n  init: init$e,\n  forward: forward$e,\n  inverse: inverse$e,\n  names: names$e\n};\nfunction init$d() {\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Equidistant Cylindrical (Plate Carre)\";\n  this.rc = Math.cos(this.lat_ts);\n}\nfunction forward$d(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var dlon = adjust_lon(lon - this.long0);\n  var dlat = adjust_lat(lat - this.lat0);\n  p5.x = this.x0 + this.a * dlon * this.rc;\n  p5.y = this.y0 + this.a * dlat;\n  return p5;\n}\nfunction inverse$d(p5) {\n  var x2 = p5.x;\n  var y2 = p5.y;\n  p5.x = adjust_lon(this.long0 + (x2 - this.x0) / (this.a * this.rc));\n  p5.y = adjust_lat(this.lat0 + (y2 - this.y0) / this.a);\n  return p5;\n}\nvar names$d = [\"Equirectangular\", \"Equidistant_Cylindrical\", \"eqc\"];\nvar eqc = {\n  init: init$d,\n  forward: forward$d,\n  inverse: inverse$d,\n  names: names$d\n};\nvar MAX_ITER$1 = 20;\nfunction init$c() {\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n}\nfunction forward$c(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var x2, y2, el;\n  var dlon = adjust_lon(lon - this.long0);\n  el = dlon * Math.sin(lat);\n  if (this.sphere) {\n    if (Math.abs(lat) <= EPSLN) {\n      x2 = this.a * dlon;\n      y2 = -1 * this.a * this.lat0;\n    } else {\n      x2 = this.a * Math.sin(el) / Math.tan(lat);\n      y2 = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));\n    }\n  } else {\n    if (Math.abs(lat) <= EPSLN) {\n      x2 = this.a * dlon;\n      y2 = -1 * this.ml0;\n    } else {\n      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);\n      x2 = nl * Math.sin(el);\n      y2 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));\n    }\n  }\n  p5.x = x2 + this.x0;\n  p5.y = y2 + this.y0;\n  return p5;\n}\nfunction inverse$c(p5) {\n  var lon, lat, x2, y2, i2;\n  var al, bl;\n  var phi, dphi;\n  x2 = p5.x - this.x0;\n  y2 = p5.y - this.y0;\n  if (this.sphere) {\n    if (Math.abs(y2 + this.a * this.lat0) <= EPSLN) {\n      lon = adjust_lon(x2 / this.a + this.long0);\n      lat = 0;\n    } else {\n      al = this.lat0 + y2 / this.a;\n      bl = x2 * x2 / this.a / this.a + al * al;\n      phi = al;\n      var tanphi;\n      for (i2 = MAX_ITER$1; i2; --i2) {\n        tanphi = Math.tan(phi);\n        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);\n        phi += dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n      lon = adjust_lon(this.long0 + Math.asin(x2 * Math.tan(phi) / this.a) / Math.sin(lat));\n    }\n  } else {\n    if (Math.abs(y2 + this.ml0) <= EPSLN) {\n      lat = 0;\n      lon = adjust_lon(this.long0 + x2 / this.a);\n    } else {\n      al = (this.ml0 + y2) / this.a;\n      bl = x2 * x2 / this.a / this.a + al * al;\n      phi = al;\n      var cl, mln, mlnp, ma;\n      var con;\n      for (i2 = MAX_ITER$1; i2; --i2) {\n        con = this.e * Math.sin(phi);\n        cl = Math.sqrt(1 - con * con) * Math.tan(phi);\n        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);\n        ma = mln / this.a;\n        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);\n        phi -= dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);\n      lon = adjust_lon(this.long0 + Math.asin(x2 * cl / this.a) / Math.sin(lat));\n    }\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$c = [\"Polyconic\", \"poly\"];\nvar poly = {\n  init: init$c,\n  forward: forward$c,\n  inverse: inverse$c,\n  names: names$c\n};\nfunction init$b() {\n  this.A = [];\n  this.A[1] = 0.6399175073;\n  this.A[2] = -0.1358797613;\n  this.A[3] = 0.063294409;\n  this.A[4] = -0.02526853;\n  this.A[5] = 0.0117879;\n  this.A[6] = -55161e-7;\n  this.A[7] = 26906e-7;\n  this.A[8] = -1333e-6;\n  this.A[9] = 67e-5;\n  this.A[10] = -34e-5;\n  this.B_re = [];\n  this.B_im = [];\n  this.B_re[1] = 0.7557853228;\n  this.B_im[1] = 0;\n  this.B_re[2] = 0.249204646;\n  this.B_im[2] = 3371507e-9;\n  this.B_re[3] = -1541739e-9;\n  this.B_im[3] = 0.04105856;\n  this.B_re[4] = -0.10162907;\n  this.B_im[4] = 0.01727609;\n  this.B_re[5] = -0.26623489;\n  this.B_im[5] = -0.36249218;\n  this.B_re[6] = -0.6870983;\n  this.B_im[6] = -1.1651967;\n  this.C_re = [];\n  this.C_im = [];\n  this.C_re[1] = 1.3231270439;\n  this.C_im[1] = 0;\n  this.C_re[2] = -0.577245789;\n  this.C_im[2] = -7809598e-9;\n  this.C_re[3] = 0.508307513;\n  this.C_im[3] = -0.112208952;\n  this.C_re[4] = -0.15094762;\n  this.C_im[4] = 0.18200602;\n  this.C_re[5] = 1.01418179;\n  this.C_im[5] = 1.64497696;\n  this.C_re[6] = 1.9660549;\n  this.C_im[6] = 2.5127645;\n  this.D = [];\n  this.D[1] = 1.5627014243;\n  this.D[2] = 0.5185406398;\n  this.D[3] = -0.03333098;\n  this.D[4] = -0.1052906;\n  this.D[5] = -0.0368594;\n  this.D[6] = 7317e-6;\n  this.D[7] = 0.0122;\n  this.D[8] = 394e-5;\n  this.D[9] = -13e-4;\n}\nfunction forward$b(p5) {\n  var n2;\n  var lon = p5.x;\n  var lat = p5.y;\n  var delta_lat = lat - this.lat0;\n  var delta_lon = lon - this.long0;\n  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;\n  var d_lambda = delta_lon;\n  var d_phi_n = 1;\n  var d_psi = 0;\n  for (n2 = 1; n2 <= 10; n2++) {\n    d_phi_n = d_phi_n * d_phi;\n    d_psi = d_psi + this.A[n2] * d_phi_n;\n  }\n  var th_re = d_psi;\n  var th_im = d_lambda;\n  var th_n_re = 1;\n  var th_n_im = 0;\n  var th_n_re1;\n  var th_n_im1;\n  var z_re = 0;\n  var z_im = 0;\n  for (n2 = 1; n2 <= 6; n2++) {\n    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n    th_n_re = th_n_re1;\n    th_n_im = th_n_im1;\n    z_re = z_re + this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im;\n    z_im = z_im + this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im;\n  }\n  p5.x = z_im * this.a + this.x0;\n  p5.y = z_re * this.a + this.y0;\n  return p5;\n}\nfunction inverse$b(p5) {\n  var n2;\n  var x2 = p5.x;\n  var y2 = p5.y;\n  var delta_x = x2 - this.x0;\n  var delta_y = y2 - this.y0;\n  var z_re = delta_y / this.a;\n  var z_im = delta_x / this.a;\n  var z_n_re = 1;\n  var z_n_im = 0;\n  var z_n_re1;\n  var z_n_im1;\n  var th_re = 0;\n  var th_im = 0;\n  for (n2 = 1; n2 <= 6; n2++) {\n    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n    z_n_re = z_n_re1;\n    z_n_im = z_n_im1;\n    th_re = th_re + this.C_re[n2] * z_n_re - this.C_im[n2] * z_n_im;\n    th_im = th_im + this.C_im[n2] * z_n_re + this.C_re[n2] * z_n_im;\n  }\n  for (var i2 = 0; i2 < this.iterations; i2++) {\n    var th_n_re = th_re;\n    var th_n_im = th_im;\n    var th_n_re1;\n    var th_n_im1;\n    var num_re = z_re;\n    var num_im = z_im;\n    for (n2 = 2; n2 <= 6; n2++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      num_re = num_re + (n2 - 1) * (this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im);\n      num_im = num_im + (n2 - 1) * (this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im);\n    }\n    th_n_re = 1;\n    th_n_im = 0;\n    var den_re = this.B_re[1];\n    var den_im = this.B_im[1];\n    for (n2 = 2; n2 <= 6; n2++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      den_re = den_re + n2 * (this.B_re[n2] * th_n_re - this.B_im[n2] * th_n_im);\n      den_im = den_im + n2 * (this.B_im[n2] * th_n_re + this.B_re[n2] * th_n_im);\n    }\n    var den2 = den_re * den_re + den_im * den_im;\n    th_re = (num_re * den_re + num_im * den_im) / den2;\n    th_im = (num_im * den_re - num_re * den_im) / den2;\n  }\n  var d_psi = th_re;\n  var d_lambda = th_im;\n  var d_psi_n = 1;\n  var d_phi = 0;\n  for (n2 = 1; n2 <= 9; n2++) {\n    d_psi_n = d_psi_n * d_psi;\n    d_phi = d_phi + this.D[n2] * d_psi_n;\n  }\n  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;\n  var lon = this.long0 + d_lambda;\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$b = [\"New_Zealand_Map_Grid\", \"nzmg\"];\nvar nzmg = {\n  init: init$b,\n  forward: forward$b,\n  inverse: inverse$b,\n  names: names$b\n};\nfunction init$a() {\n}\nfunction forward$a(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var dlon = adjust_lon(lon - this.long0);\n  var x2 = this.x0 + this.a * dlon;\n  var y2 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$a(p5) {\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  var lon = adjust_lon(this.long0 + p5.x / this.a);\n  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p5.y / this.a)) - Math.PI / 4);\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$a = [\"Miller_Cylindrical\", \"mill\"];\nvar mill = {\n  init: init$a,\n  forward: forward$a,\n  inverse: inverse$a,\n  names: names$a\n};\nvar MAX_ITER = 20;\nfunction init$9() {\n  if (!this.sphere) {\n    this.en = pj_enfn(this.es);\n  } else {\n    this.n = 1;\n    this.m = 0;\n    this.es = 0;\n    this.C_y = Math.sqrt((this.m + 1) / this.n);\n    this.C_x = this.C_y / (this.m + 1);\n  }\n}\nfunction forward$9(p5) {\n  var x2, y2;\n  var lon = p5.x;\n  var lat = p5.y;\n  lon = adjust_lon(lon - this.long0);\n  if (this.sphere) {\n    if (!this.m) {\n      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n    } else {\n      var k2 = this.n * Math.sin(lat);\n      for (var i2 = MAX_ITER; i2; --i2) {\n        var V2 = (this.m * lat + Math.sin(lat) - k2) / (this.m + Math.cos(lat));\n        lat -= V2;\n        if (Math.abs(V2) < EPSLN) {\n          break;\n        }\n      }\n    }\n    x2 = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n    y2 = this.a * this.C_y * lat;\n  } else {\n    var s2 = Math.sin(lat);\n    var c2 = Math.cos(lat);\n    y2 = this.a * pj_mlfn(lat, s2, c2, this.en);\n    x2 = this.a * lon * c2 / Math.sqrt(1 - this.es * s2 * s2);\n  }\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$9(p5) {\n  var lat, temp, lon, s2;\n  p5.x -= this.x0;\n  lon = p5.x / this.a;\n  p5.y -= this.y0;\n  lat = p5.y / this.a;\n  if (this.sphere) {\n    lat /= this.C_y;\n    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n    if (this.m) {\n      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n    } else if (this.n !== 1) {\n      lat = asinz(Math.sin(lat) / this.n);\n    }\n    lon = adjust_lon(lon + this.long0);\n    lat = adjust_lat(lat);\n  } else {\n    lat = pj_inv_mlfn(p5.y / this.a, this.es, this.en);\n    s2 = Math.abs(lat);\n    if (s2 < HALF_PI) {\n      s2 = Math.sin(lat);\n      temp = this.long0 + p5.x * Math.sqrt(1 - this.es * s2 * s2) / (this.a * Math.cos(lat));\n      lon = adjust_lon(temp);\n    } else if (s2 - EPSLN < HALF_PI) {\n      lon = this.long0;\n    }\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$9 = [\"Sinusoidal\", \"sinu\"];\nvar sinu = {\n  init: init$9,\n  forward: forward$9,\n  inverse: inverse$9,\n  names: names$9\n};\nfunction init$8() {\n}\nfunction forward$8(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x2 = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y2 = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$8(p5) {\n  var theta;\n  var arg;\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  arg = p5.y / (1.4142135623731 * this.a);\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + p5.x / (0.900316316158 * this.a * Math.cos(theta)));\n  if (lon < -Math.PI) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$8 = [\"Mollweide\", \"moll\"];\nvar moll = {\n  init: init$8,\n  forward: forward$8,\n  inverse: inverse$8,\n  names: names$8\n};\nfunction init$7() {\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.lat2 = this.lat2 || this.lat1;\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n  this.sinphi = Math.sin(this.lat1);\n  this.cosphi = Math.cos(this.lat1);\n  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);\n  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);\n  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {\n    this.ns = this.sinphi;\n  } else {\n    this.sinphi = Math.sin(this.lat2);\n    this.cosphi = Math.cos(this.lat2);\n    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);\n    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);\n    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);\n  }\n  this.g = this.ml1 + this.ms1 / this.ns;\n  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  this.rh = this.a * (this.g - this.ml0);\n}\nfunction forward$7(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var rh1;\n  if (this.sphere) {\n    rh1 = this.a * (this.g - lat);\n  } else {\n    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n    rh1 = this.a * (this.g - ml);\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  var x2 = this.x0 + rh1 * Math.sin(theta);\n  var y2 = this.y0 + this.rh - rh1 * Math.cos(theta);\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$7(p5) {\n  p5.x -= this.x0;\n  p5.y = this.rh - p5.y + this.y0;\n  var con, rh1, lat, lon;\n  if (this.ns >= 0) {\n    rh1 = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n    con = 1;\n  } else {\n    rh1 = -Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p5.x, con * p5.y);\n  }\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    lat = adjust_lat(this.g - rh1 / this.a);\n    p5.x = lon;\n    p5.y = lat;\n    return p5;\n  } else {\n    var ml = this.g - rh1 / this.a;\n    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    p5.x = lon;\n    p5.y = lat;\n    return p5;\n  }\n}\nvar names$7 = [\"Equidistant_Conic\", \"eqdc\"];\nvar eqdc = {\n  init: init$7,\n  forward: forward$7,\n  inverse: inverse$7,\n  names: names$7\n};\nfunction init$6() {\n  this.R = this.a;\n}\nfunction forward$6(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var dlon = adjust_lon(lon - this.long0);\n  var x2, y2;\n  if (Math.abs(lat) <= EPSLN) {\n    x2 = this.x0 + this.R * dlon;\n    y2 = this.y0;\n  }\n  var theta = asinz(2 * Math.abs(lat / Math.PI));\n  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    x2 = this.x0;\n    if (lat >= 0) {\n      y2 = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);\n    } else {\n      y2 = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);\n    }\n  }\n  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);\n  var asq = al * al;\n  var sinth = Math.sin(theta);\n  var costh = Math.cos(theta);\n  var g2 = costh / (sinth + costh - 1);\n  var gsq = g2 * g2;\n  var m2 = g2 * (2 / sinth - 1);\n  var msq = m2 * m2;\n  var con = Math.PI * this.R * (al * (g2 - msq) + Math.sqrt(asq * (g2 - msq) * (g2 - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);\n  if (dlon < 0) {\n    con = -con;\n  }\n  x2 = this.x0 + con;\n  var q2 = asq + g2;\n  con = Math.PI * this.R * (m2 * q2 - al * Math.sqrt((msq + asq) * (asq + 1) - q2 * q2)) / (msq + asq);\n  if (lat >= 0) {\n    y2 = this.y0 + con;\n  } else {\n    y2 = this.y0 - con;\n  }\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$6(p5) {\n  var lon, lat;\n  var xx, yy, xys, c1, c2, c3;\n  var a1;\n  var m1;\n  var con;\n  var th1;\n  var d2;\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  con = Math.PI * this.R;\n  xx = p5.x / con;\n  yy = p5.y / con;\n  xys = xx * xx + yy * yy;\n  c1 = -Math.abs(yy) * (1 + xys);\n  c2 = c1 - 2 * yy * yy + xx * xx;\n  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;\n  d2 = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;\n  a1 = (c1 - c2 * c2 / 3 / c3) / c3;\n  m1 = 2 * Math.sqrt(-a1 / 3);\n  con = 3 * d2 / a1 / m1;\n  if (Math.abs(con) > 1) {\n    if (con >= 0) {\n      con = 1;\n    } else {\n      con = -1;\n    }\n  }\n  th1 = Math.acos(con) / 3;\n  if (p5.y >= 0) {\n    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  } else {\n    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n  if (Math.abs(xx) < EPSLN) {\n    lon = this.long0;\n  } else {\n    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);\n  }\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$6 = [\"Van_der_Grinten_I\", \"VanDerGrinten\", \"vandg\"];\nvar vandg = {\n  init: init$6,\n  forward: forward$6,\n  inverse: inverse$6,\n  names: names$6\n};\nfunction init$5() {\n  this.sin_p12 = Math.sin(this.lat0);\n  this.cos_p12 = Math.cos(this.lat0);\n}\nfunction forward$5(p5) {\n  var lon = p5.x;\n  var lat = p5.y;\n  var sinphi = Math.sin(p5.y);\n  var cosphi = Math.cos(p5.y);\n  var dlon = adjust_lon(lon - this.long0);\n  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G2, H4, GH, Hs, c2, kp, cos_c, s2, s22, s3, s4, s5;\n  if (this.sphere) {\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      p5.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);\n      p5.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);\n      return p5;\n    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      p5.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);\n      p5.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);\n      return p5;\n    } else {\n      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);\n      c2 = Math.acos(cos_c);\n      kp = c2 ? c2 / Math.sin(c2) : 1;\n      p5.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);\n      p5.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));\n      return p5;\n    }\n  } else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p5.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);\n      p5.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);\n      return p5;\n    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p5.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);\n      p5.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);\n      return p5;\n    } else {\n      tanphi = sinphi / cosphi;\n      Nl1 = gN(this.a, this.e, this.sin_p12);\n      Nl = gN(this.a, this.e, sinphi);\n      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));\n      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));\n      if (Az === 0) {\n        s2 = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {\n        s2 = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      } else {\n        s2 = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));\n      }\n      G2 = this.e * this.sin_p12 / Math.sqrt(1 - this.es);\n      H4 = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);\n      GH = G2 * H4;\n      Hs = H4 * H4;\n      s22 = s2 * s2;\n      s3 = s22 * s2;\n      s4 = s3 * s2;\n      s5 = s4 * s2;\n      c2 = Nl1 * s2 * (1 - s22 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G2 * G2 * (1 - 7 * Hs)) - s5 / 48 * GH);\n      p5.x = this.x0 + c2 * Math.sin(Az);\n      p5.y = this.y0 + c2 * Math.cos(Az);\n      return p5;\n    }\n  }\n}\nfunction inverse$5(p5) {\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  var rh, z2, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M2, N1, psi, Az, cosAz, tmp, A2, B3, D2, Ee, F2, sinpsi;\n  if (this.sphere) {\n    rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n    if (rh > 2 * HALF_PI * this.a) {\n      return;\n    }\n    z2 = rh / this.a;\n    sinz = Math.sin(z2);\n    cosz = Math.cos(z2);\n    lon = this.long0;\n    if (Math.abs(rh) <= EPSLN) {\n      lat = this.lat0;\n    } else {\n      lat = asinz(cosz * this.sin_p12 + p5.y * sinz * this.cos_p12 / rh);\n      con = Math.abs(this.lat0) - HALF_PI;\n      if (Math.abs(con) <= EPSLN) {\n        if (this.lat0 >= 0) {\n          lon = adjust_lon(this.long0 + Math.atan2(p5.x, -p5.y));\n        } else {\n          lon = adjust_lon(this.long0 - Math.atan2(-p5.x, p5.y));\n        }\n      } else {\n        lon = adjust_lon(this.long0 + Math.atan2(p5.x * sinz, rh * this.cos_p12 * cosz - p5.y * this.sin_p12 * sinz));\n      }\n    }\n    p5.x = lon;\n    p5.y = lat;\n    return p5;\n  } else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n      M2 = Mlp - rh;\n      lat = imlfn(M2 / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p5.x, -1 * p5.y));\n      p5.x = lon;\n      p5.y = lat;\n      return p5;\n    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n      M2 = rh - Mlp;\n      lat = imlfn(M2 / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p5.x, p5.y));\n      p5.x = lon;\n      p5.y = lat;\n      return p5;\n    } else {\n      rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n      Az = Math.atan2(p5.x, p5.y);\n      N1 = gN(this.a, this.e, this.sin_p12);\n      cosAz = Math.cos(Az);\n      tmp = this.e * this.cos_p12 * cosAz;\n      A2 = -tmp * tmp / (1 - this.es);\n      B3 = 3 * this.es * (1 - A2) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);\n      D2 = rh / N1;\n      Ee = D2 - A2 * (1 + A2) * Math.pow(D2, 3) / 6 - B3 * (1 + 3 * A2) * Math.pow(D2, 4) / 24;\n      F2 = 1 - A2 * Ee * Ee / 2 - D2 * Ee * Ee * Ee / 6;\n      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);\n      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));\n      sinpsi = Math.sin(psi);\n      lat = Math.atan2((sinpsi - this.es * F2 * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));\n      p5.x = lon;\n      p5.y = lat;\n      return p5;\n    }\n  }\n}\nvar names$5 = [\"Azimuthal_Equidistant\", \"aeqd\"];\nvar aeqd = {\n  init: init$5,\n  forward: forward$5,\n  inverse: inverse$5,\n  names: names$5\n};\nfunction init$4() {\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n}\nfunction forward$4(p5) {\n  var sinphi, cosphi;\n  var dlon;\n  var coslon;\n  var ksp;\n  var g2, x2, y2;\n  var lon = p5.x;\n  var lat = p5.y;\n  dlon = adjust_lon(lon - this.long0);\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n  coslon = Math.cos(dlon);\n  g2 = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if (g2 > 0 || Math.abs(g2) <= EPSLN) {\n    x2 = this.a * ksp * cosphi * Math.sin(dlon);\n    y2 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n  }\n  p5.x = x2;\n  p5.y = y2;\n  return p5;\n}\nfunction inverse$4(p5) {\n  var rh;\n  var z2;\n  var sinz, cosz;\n  var con;\n  var lon, lat;\n  p5.x -= this.x0;\n  p5.y -= this.y0;\n  rh = Math.sqrt(p5.x * p5.x + p5.y * p5.y);\n  z2 = asinz(rh / this.a);\n  sinz = Math.sin(z2);\n  cosz = Math.cos(z2);\n  lon = this.long0;\n  if (Math.abs(rh) <= EPSLN) {\n    lat = this.lat0;\n    p5.x = lon;\n    p5.y = lat;\n    return p5;\n  }\n  lat = asinz(cosz * this.sin_p14 + p5.y * sinz * this.cos_p14 / rh);\n  con = Math.abs(this.lat0) - HALF_PI;\n  if (Math.abs(con) <= EPSLN) {\n    if (this.lat0 >= 0) {\n      lon = adjust_lon(this.long0 + Math.atan2(p5.x, -p5.y));\n    } else {\n      lon = adjust_lon(this.long0 - Math.atan2(-p5.x, p5.y));\n    }\n    p5.x = lon;\n    p5.y = lat;\n    return p5;\n  }\n  lon = adjust_lon(this.long0 + Math.atan2(p5.x * sinz, rh * this.cos_p14 * cosz - p5.y * this.sin_p14 * sinz));\n  p5.x = lon;\n  p5.y = lat;\n  return p5;\n}\nvar names$4 = [\"ortho\"];\nvar ortho = {\n  init: init$4,\n  forward: forward$4,\n  inverse: inverse$4,\n  names: names$4\n};\nvar FACE_ENUM = {\n  FRONT: 1,\n  RIGHT: 2,\n  BACK: 3,\n  LEFT: 4,\n  TOP: 5,\n  BOTTOM: 6\n};\nvar AREA_ENUM = {\n  AREA_0: 1,\n  AREA_1: 2,\n  AREA_2: 3,\n  AREA_3: 4\n};\nfunction init$3() {\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n  if (this.lat0 >= HALF_PI - FORTPI / 2) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\nfunction forward$3(p5) {\n  var xy = { x: 0, y: 0 };\n  var lat, lon;\n  var theta, phi;\n  var t3, mu;\n  var area = { value: 0 };\n  p5.x -= this.long0;\n  if (this.es !== 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p5.y));\n  } else {\n    lat = p5.y;\n  }\n  lon = p5.x;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = lon > 0 ? lon - SPI : lon + SPI;\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon > 0 ? -lon + SPI : -lon - SPI;\n    }\n  } else {\n    var q2, r2, s2;\n    var sinlat, coslat;\n    var sinlon, coslon;\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q2 = coslat * coslon;\n    r2 = coslat * sinlon;\n    s2 = sinlat;\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q2);\n      theta = qsc_fwd_equat_face_theta(phi, s2, r2, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r2);\n      theta = qsc_fwd_equat_face_theta(phi, s2, -q2, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q2);\n      theta = qsc_fwd_equat_face_theta(phi, s2, -r2, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r2);\n      theta = qsc_fwd_equat_face_theta(phi, s2, q2, area);\n    } else {\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t3 = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n  xy.x = t3 * Math.cos(mu);\n  xy.y = t3 * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n  p5.x = xy.x;\n  p5.y = xy.y;\n  return p5;\n}\nfunction inverse$3(p5) {\n  var lp = { lam: 0, phi: 0 };\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t3;\n  var area = { value: 0 };\n  p5.x = (p5.x - this.x0) / this.a;\n  p5.y = (p5.y - this.y0) / this.a;\n  nu = Math.atan(Math.sqrt(p5.x * p5.x + p5.y * p5.y));\n  mu = Math.atan2(p5.y, p5.x);\n  if (p5.x >= 0 && p5.x >= Math.abs(p5.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p5.y >= 0 && p5.y >= Math.abs(p5.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p5.x < 0 && -p5.x >= Math.abs(p5.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = mu < 0 ? mu + SPI : mu - SPI;\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n  t3 = SPI / 12 * Math.tan(mu);\n  tantheta = Math.sin(t3) / (Math.cos(t3) - 1 / Math.sqrt(2));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > 1) {\n    cosphi = 1;\n  }\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = theta < 0 ? theta + SPI : theta - SPI;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else {\n      lp.lam = theta;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else {\n      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;\n    }\n  } else {\n    var q2, r2, s2;\n    q2 = cosphi;\n    t3 = q2 * q2;\n    if (t3 >= 1) {\n      s2 = 0;\n    } else {\n      s2 = Math.sqrt(1 - t3) * Math.sin(theta);\n    }\n    t3 += s2 * s2;\n    if (t3 >= 1) {\n      r2 = 0;\n    } else {\n      r2 = Math.sqrt(1 - t3);\n    }\n    if (area.value === AREA_ENUM.AREA_1) {\n      t3 = r2;\n      r2 = -s2;\n      s2 = t3;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r2 = -r2;\n      s2 = -s2;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t3 = r2;\n      r2 = s2;\n      s2 = -t3;\n    }\n    if (this.face === FACE_ENUM.RIGHT) {\n      t3 = q2;\n      q2 = -r2;\n      r2 = t3;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q2 = -q2;\n      r2 = -r2;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t3 = q2;\n      q2 = r2;\n      r2 = -t3;\n    }\n    lp.phi = Math.acos(-s2) - HALF_PI;\n    lp.lam = Math.atan2(r2, q2);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = lp.phi < 0 ? 1 : 0;\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n  lp.lam += this.long0;\n  p5.x = lp.lam;\n  p5.y = lp.phi;\n  return p5;\n}\nfunction qsc_fwd_equat_face_theta(phi, y2, x2, area) {\n  var theta;\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0;\n  } else {\n    theta = Math.atan2(y2, x2);\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = theta >= 0 ? theta - SPI : theta + SPI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n  return theta;\n}\nfunction qsc_shift_lon_origin(lon, offset2) {\n  var slon = lon + offset2;\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n  return slon;\n}\nvar names$3 = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nvar qsc = {\n  init: init$3,\n  forward: forward$3,\n  inverse: inverse$3,\n  names: names$3\n};\nvar COEFS_X = [\n  [1, 22199e-21, -715515e-10, 31103e-10],\n  [0.9986, -482243e-9, -24897e-9, -13309e-10],\n  [0.9954, -83103e-8, -448605e-10, -986701e-12],\n  [0.99, -135364e-8, -59661e-9, 36777e-10],\n  [0.9822, -167442e-8, -449547e-11, -572411e-11],\n  [0.973, -214868e-8, -903571e-10, 18736e-12],\n  [0.96, -305085e-8, -900761e-10, 164917e-11],\n  [0.9427, -382792e-8, -653386e-10, -26154e-10],\n  [0.9216, -467746e-8, -10457e-8, 481243e-11],\n  [0.8962, -536223e-8, -323831e-10, -543432e-11],\n  [0.8679, -609363e-8, -113898e-9, 332484e-11],\n  [0.835, -698325e-8, -640253e-10, 934959e-12],\n  [0.7986, -755338e-8, -500009e-10, 935324e-12],\n  [0.7597, -798324e-8, -35971e-9, -227626e-11],\n  [0.7186, -851367e-8, -701149e-10, -86303e-10],\n  [0.6732, -986209e-8, -199569e-9, 191974e-10],\n  [0.6213, -0.010418, 883923e-10, 624051e-11],\n  [0.5722, -906601e-8, 182e-6, 624051e-11],\n  [0.5322, -677797e-8, 275608e-9, 624051e-11]\n];\nvar COEFS_Y = [\n  [-520417e-23, 0.0124, 121431e-23, -845284e-16],\n  [0.062, 0.0124, -126793e-14, 422642e-15],\n  [0.124, 0.0124, 507171e-14, -160604e-14],\n  [0.186, 0.0123999, -190189e-13, 600152e-14],\n  [0.248, 0.0124002, 710039e-13, -224e-10],\n  [0.31, 0.0123992, -264997e-12, 835986e-13],\n  [0.372, 0.0124029, 988983e-12, -311994e-12],\n  [0.434, 0.0123893, -369093e-11, -435621e-12],\n  [0.4958, 0.0123198, -102252e-10, -345523e-12],\n  [0.5571, 0.0121916, -154081e-10, -582288e-12],\n  [0.6176, 0.0119938, -241424e-10, -525327e-12],\n  [0.6769, 0.011713, -320223e-10, -516405e-12],\n  [0.7346, 0.0113541, -397684e-10, -609052e-12],\n  [0.7903, 0.0109107, -489042e-10, -104739e-11],\n  [0.8435, 0.0103431, -64615e-9, -140374e-14],\n  [0.8936, 969686e-8, -64636e-9, -8547e-9],\n  [0.9394, 840947e-8, -192841e-9, -42106e-10],\n  [0.9761, 616527e-8, -256e-6, -42106e-10],\n  [1, 328947e-8, -319159e-9, -42106e-10]\n];\nvar FXC = 0.8487;\nvar FYC = 1.3523;\nvar C1 = R2D / 5;\nvar RC1 = 1 / C1;\nvar NODES = 18;\nvar poly3_val = function(coefs, x2) {\n  return coefs[0] + x2 * (coefs[1] + x2 * (coefs[2] + x2 * coefs[3]));\n};\nvar poly3_der = function(coefs, x2) {\n  return coefs[1] + x2 * (2 * coefs[2] + x2 * 3 * coefs[3]);\n};\nfunction newton_rapshon(f_df, start2, max_err, iters) {\n  var x2 = start2;\n  for (; iters; --iters) {\n    var upd = f_df(x2);\n    x2 -= upd;\n    if (Math.abs(upd) < max_err) {\n      break;\n    }\n  }\n  return x2;\n}\nfunction init$2() {\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.long0 = this.long0 || 0;\n  this.es = 0;\n  this.title = this.title || \"Robinson\";\n}\nfunction forward$2(ll) {\n  var lon = adjust_lon(ll.x - this.long0);\n  var dphi = Math.abs(ll.y);\n  var i2 = Math.floor(dphi * C1);\n  if (i2 < 0) {\n    i2 = 0;\n  } else if (i2 >= NODES) {\n    i2 = NODES - 1;\n  }\n  dphi = R2D * (dphi - RC1 * i2);\n  var xy = {\n    x: poly3_val(COEFS_X[i2], dphi) * lon,\n    y: poly3_val(COEFS_Y[i2], dphi)\n  };\n  if (ll.y < 0) {\n    xy.y = -xy.y;\n  }\n  xy.x = xy.x * this.a * FXC + this.x0;\n  xy.y = xy.y * this.a * FYC + this.y0;\n  return xy;\n}\nfunction inverse$2(xy) {\n  var ll = {\n    x: (xy.x - this.x0) / (this.a * FXC),\n    y: Math.abs(xy.y - this.y0) / (this.a * FYC)\n  };\n  if (ll.y >= 1) {\n    ll.x /= COEFS_X[NODES][0];\n    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;\n  } else {\n    var i2 = Math.floor(ll.y * NODES);\n    if (i2 < 0) {\n      i2 = 0;\n    } else if (i2 >= NODES) {\n      i2 = NODES - 1;\n    }\n    for (; ; ) {\n      if (COEFS_Y[i2][0] > ll.y) {\n        --i2;\n      } else if (COEFS_Y[i2 + 1][0] <= ll.y) {\n        ++i2;\n      } else {\n        break;\n      }\n    }\n    var coefs = COEFS_Y[i2];\n    var t3 = 5 * (ll.y - coefs[0]) / (COEFS_Y[i2 + 1][0] - coefs[0]);\n    t3 = newton_rapshon(function(x2) {\n      return (poly3_val(coefs, x2) - ll.y) / poly3_der(coefs, x2);\n    }, t3, EPSLN, 100);\n    ll.x /= poly3_val(COEFS_X[i2], t3);\n    ll.y = (5 * i2 + t3) * D2R$1;\n    if (xy.y < 0) {\n      ll.y = -ll.y;\n    }\n  }\n  ll.x = adjust_lon(ll.x + this.long0);\n  return ll;\n}\nvar names$2 = [\"Robinson\", \"robin\"];\nvar robin = {\n  init: init$2,\n  forward: forward$2,\n  inverse: inverse$2,\n  names: names$2\n};\nfunction init$1() {\n  this.name = \"geocent\";\n}\nfunction forward$1(p5) {\n  var point = geodeticToGeocentric(p5, this.es, this.a);\n  return point;\n}\nfunction inverse$1(p5) {\n  var point = geocentricToGeodetic(p5, this.es, this.a, this.b);\n  return point;\n}\nvar names$1 = [\"Geocentric\", \"geocentric\", \"geocent\", \"Geocent\"];\nvar geocent = {\n  init: init$1,\n  forward: forward$1,\n  inverse: inverse$1,\n  names: names$1\n};\nvar mode = {\n  N_POLE: 0,\n  S_POLE: 1,\n  EQUIT: 2,\n  OBLIQ: 3\n};\nvar params = {\n  h: { def: 1e5, num: true },\n  azi: { def: 0, num: true, degrees: true },\n  tilt: { def: 0, num: true, degrees: true },\n  long0: { def: 0, num: true },\n  lat0: { def: 0, num: true }\n};\nfunction init() {\n  Object.keys(params).forEach(function(p5) {\n    if (typeof this[p5] === \"undefined\") {\n      this[p5] = params[p5].def;\n    } else if (params[p5].num && isNaN(this[p5])) {\n      throw new Error(\"Invalid parameter value, must be numeric \" + p5 + \" = \" + this[p5]);\n    } else if (params[p5].num) {\n      this[p5] = parseFloat(this[p5]);\n    }\n    if (params[p5].degrees) {\n      this[p5] = this[p5] * D2R$1;\n    }\n  }.bind(this));\n  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {\n    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;\n  } else if (Math.abs(this.lat0) < EPSLN) {\n    this.mode = mode.EQUIT;\n  } else {\n    this.mode = mode.OBLIQ;\n    this.sinph0 = Math.sin(this.lat0);\n    this.cosph0 = Math.cos(this.lat0);\n  }\n  this.pn1 = this.h / this.a;\n  if (this.pn1 <= 0 || this.pn1 > 1e10) {\n    throw new Error(\"Invalid height\");\n  }\n  this.p = 1 + this.pn1;\n  this.rp = 1 / this.p;\n  this.h1 = 1 / this.pn1;\n  this.pfact = (this.p + 1) * this.h1;\n  this.es = 0;\n  var omega = this.tilt;\n  var gamma = this.azi;\n  this.cg = Math.cos(gamma);\n  this.sg = Math.sin(gamma);\n  this.cw = Math.cos(omega);\n  this.sw = Math.sin(omega);\n}\nfunction forward(p5) {\n  p5.x -= this.long0;\n  var sinphi = Math.sin(p5.y);\n  var cosphi = Math.cos(p5.y);\n  var coslam = Math.cos(p5.x);\n  var x2, y2;\n  switch (this.mode) {\n    case mode.OBLIQ:\n      y2 = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      break;\n    case mode.EQUIT:\n      y2 = cosphi * coslam;\n      break;\n    case mode.S_POLE:\n      y2 = -sinphi;\n      break;\n    case mode.N_POLE:\n      y2 = sinphi;\n      break;\n  }\n  y2 = this.pn1 / (this.p - y2);\n  x2 = y2 * cosphi * Math.sin(p5.x);\n  switch (this.mode) {\n    case mode.OBLIQ:\n      y2 *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n      break;\n    case mode.EQUIT:\n      y2 *= sinphi;\n      break;\n    case mode.N_POLE:\n      y2 *= -(cosphi * coslam);\n      break;\n    case mode.S_POLE:\n      y2 *= cosphi * coslam;\n      break;\n  }\n  var yt2, ba;\n  yt2 = y2 * this.cg + x2 * this.sg;\n  ba = 1 / (yt2 * this.sw * this.h1 + this.cw);\n  x2 = (x2 * this.cg - y2 * this.sg) * this.cw * ba;\n  y2 = yt2 * ba;\n  p5.x = x2 * this.a;\n  p5.y = y2 * this.a;\n  return p5;\n}\nfunction inverse(p5) {\n  p5.x /= this.a;\n  p5.y /= this.a;\n  var r2 = { x: p5.x, y: p5.y };\n  var bm, bq, yt2;\n  yt2 = 1 / (this.pn1 - p5.y * this.sw);\n  bm = this.pn1 * p5.x * yt2;\n  bq = this.pn1 * p5.y * this.cw * yt2;\n  p5.x = bm * this.cg + bq * this.sg;\n  p5.y = bq * this.cg - bm * this.sg;\n  var rh = hypot(p5.x, p5.y);\n  if (Math.abs(rh) < EPSLN) {\n    r2.x = 0;\n    r2.y = p5.y;\n  } else {\n    var cosz, sinz;\n    sinz = 1 - rh * rh * this.pfact;\n    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);\n    cosz = Math.sqrt(1 - sinz * sinz);\n    switch (this.mode) {\n      case mode.OBLIQ:\n        r2.y = Math.asin(cosz * this.sinph0 + p5.y * sinz * this.cosph0 / rh);\n        p5.y = (cosz - this.sinph0 * Math.sin(r2.y)) * rh;\n        p5.x *= sinz * this.cosph0;\n        break;\n      case mode.EQUIT:\n        r2.y = Math.asin(p5.y * sinz / rh);\n        p5.y = cosz * rh;\n        p5.x *= sinz;\n        break;\n      case mode.N_POLE:\n        r2.y = Math.asin(cosz);\n        p5.y = -p5.y;\n        break;\n      case mode.S_POLE:\n        r2.y = -Math.asin(cosz);\n        break;\n    }\n    r2.x = Math.atan2(p5.x, p5.y);\n  }\n  p5.x = r2.x + this.long0;\n  p5.y = r2.y;\n  return p5;\n}\nvar names = [\"Tilted_Perspective\", \"tpers\"];\nvar tpers = {\n  init,\n  forward,\n  inverse,\n  names\n};\nfunction includedProjections(proj42) {\n  proj42.Proj.projections.add(tmerc);\n  proj42.Proj.projections.add(etmerc);\n  proj42.Proj.projections.add(utm);\n  proj42.Proj.projections.add(sterea);\n  proj42.Proj.projections.add(stere);\n  proj42.Proj.projections.add(somerc);\n  proj42.Proj.projections.add(omerc);\n  proj42.Proj.projections.add(lcc);\n  proj42.Proj.projections.add(krovak);\n  proj42.Proj.projections.add(cass);\n  proj42.Proj.projections.add(laea);\n  proj42.Proj.projections.add(aea);\n  proj42.Proj.projections.add(gnom);\n  proj42.Proj.projections.add(cea);\n  proj42.Proj.projections.add(eqc);\n  proj42.Proj.projections.add(poly);\n  proj42.Proj.projections.add(nzmg);\n  proj42.Proj.projections.add(mill);\n  proj42.Proj.projections.add(sinu);\n  proj42.Proj.projections.add(moll);\n  proj42.Proj.projections.add(eqdc);\n  proj42.Proj.projections.add(vandg);\n  proj42.Proj.projections.add(aeqd);\n  proj42.Proj.projections.add(ortho);\n  proj42.Proj.projections.add(qsc);\n  proj42.Proj.projections.add(robin);\n  proj42.Proj.projections.add(geocent);\n  proj42.Proj.projections.add(tpers);\n}\nproj4.defaultDatum = \"WGS84\";\nproj4.Proj = Projection$1;\nproj4.WGS84 = new proj4.Proj(\"WGS84\");\nproj4.Point = Point$2;\nproj4.toPoint = common;\nproj4.defs = defs;\nproj4.nadgrid = nadgrid;\nproj4.transform = transform$2;\nproj4.mgrs = mgrs;\nproj4.version = \"__VERSION__\";\nincludedProjections(proj4);\nfunction register(proj42) {\n  var projCodes = Object.keys(proj42.defs);\n  var len = projCodes.length;\n  var i2, j2;\n  for (i2 = 0; i2 < len; ++i2) {\n    var code = projCodes[i2];\n    if (!get$3(code)) {\n      var def = proj42.defs(code);\n      var units2 = def.units;\n      if (!units2 && def.projName === \"longlat\") {\n        units2 = Units$2.DEGREES;\n      }\n      addProjection(new Projection$3({\n        code,\n        axisOrientation: def.axis,\n        metersPerUnit: def.to_meter,\n        units: units2\n      }));\n    }\n  }\n  for (i2 = 0; i2 < len; ++i2) {\n    var code1 = projCodes[i2];\n    var proj1 = get$3(code1);\n    for (j2 = 0; j2 < len; ++j2) {\n      var code2 = projCodes[j2];\n      var proj2 = get$3(code2);\n      if (!get$4(code1, code2)) {\n        if (proj42.defs[code1] === proj42.defs[code2]) {\n          addEquivalentProjections([proj1, proj2]);\n        } else {\n          var transform2 = proj42(code1, code2);\n          addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform2.forward), createSafeCoordinateTransform(proj2, proj1, transform2.inverse));\n        }\n      }\n    }\n  }\n}\nconst _sfc_main$10 = {\n  name: \"ol-projection-register\",\n  setup(props) {\n    const {\n      projectionName,\n      projectionDef,\n      projectionExtent\n    } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(props);\n    proj4.defs(projectionName.value, projectionDef.value);\n    register(proj4);\n    const projection = new Projection$3({\n      code: projectionName.value,\n      extent: projectionExtent.value\n    });\n    return {\n      projection\n    };\n  },\n  props: {\n    projectionName: {\n      type: String\n    },\n    projectionDef: {\n      type: String\n    },\n    projectionExtent: {\n      type: Array\n    }\n  }\n};\nfunction _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar Projection = /* @__PURE__ */ _export_sfc(_sfc_main$10, [[\"render\", _sfc_render$10]]);\nfunction install$8(app) {\n  if (install$8.installed) {\n    return;\n  }\n  install$8.installed = true;\n  app.component(Map$2.name, Map$2);\n  app.component(View.name, View);\n  app.component(Feature.name, Feature);\n  app.component(Overlay.name, Overlay);\n  app.component(GeoLocation.name, GeoLocation);\n  app.component(Projection.name, Projection);\n}\nvar Map$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": install$8,\n  install: install$8,\n  Map: Map$2,\n  View,\n  Feature,\n  Overlay,\n  GeoLocation,\n  Projection\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar TileProperty = {\n  PRELOAD: \"preload\",\n  USE_INTERIM_TILES_ON_ERROR: \"useInterimTilesOnError\"\n};\nvar __extends$_ = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar BaseTileLayer = function(_super) {\n  __extends$_(BaseTileLayer2, _super);\n  function BaseTileLayer2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({}, options);\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    _this = _super.call(this, baseOptions) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.setPreload(options.preload !== void 0 ? options.preload : 0);\n    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);\n    return _this;\n  }\n  BaseTileLayer2.prototype.getPreload = function() {\n    return this.get(TileProperty.PRELOAD);\n  };\n  BaseTileLayer2.prototype.setPreload = function(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  };\n  BaseTileLayer2.prototype.getUseInterimTilesOnError = function() {\n    return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);\n  };\n  BaseTileLayer2.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  };\n  BaseTileLayer2.prototype.getData = function(pixel) {\n    return _super.prototype.getData.call(this, pixel);\n  };\n  return BaseTileLayer2;\n}(ol_layer_Base);\nvar BaseTileLayer$1 = BaseTileLayer;\nvar __extends$Z = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Tile = function(_super) {\n  __extends$Z(Tile2, _super);\n  function Tile2(tileCoord, state, opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.tileCoord = tileCoord;\n    _this.state = state;\n    _this.interimTile = null;\n    _this.key = \"\";\n    _this.transition_ = options.transition === void 0 ? 250 : options.transition;\n    _this.transitionStarts_ = {};\n    _this.interpolate = !!options.interpolate;\n    return _this;\n  }\n  Tile2.prototype.changed = function() {\n    this.dispatchEvent(EventType.CHANGE);\n  };\n  Tile2.prototype.release = function() {\n  };\n  Tile2.prototype.getKey = function() {\n    return this.key + \"/\" + this.tileCoord;\n  };\n  Tile2.prototype.getInterimTile = function() {\n    if (!this.interimTile) {\n      return this;\n    }\n    var tile2 = this.interimTile;\n    do {\n      if (tile2.getState() == TileState.LOADED) {\n        this.transition_ = 0;\n        return tile2;\n      }\n      tile2 = tile2.interimTile;\n    } while (tile2);\n    return this;\n  };\n  Tile2.prototype.refreshInterimChain = function() {\n    if (!this.interimTile) {\n      return;\n    }\n    var tile2 = this.interimTile;\n    var prev = this;\n    do {\n      if (tile2.getState() == TileState.LOADED) {\n        tile2.interimTile = null;\n        break;\n      } else if (tile2.getState() == TileState.LOADING) {\n        prev = tile2;\n      } else if (tile2.getState() == TileState.IDLE) {\n        prev.interimTile = tile2.interimTile;\n      } else {\n        prev = tile2;\n      }\n      tile2 = prev.interimTile;\n    } while (tile2);\n  };\n  Tile2.prototype.getTileCoord = function() {\n    return this.tileCoord;\n  };\n  Tile2.prototype.getState = function() {\n    return this.state;\n  };\n  Tile2.prototype.setState = function(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error(\"Tile load sequence violation\");\n    }\n    this.state = state;\n    this.changed();\n  };\n  Tile2.prototype.load = function() {\n    abstract();\n  };\n  Tile2.prototype.getAlpha = function(id, time2) {\n    if (!this.transition_) {\n      return 1;\n    }\n    var start2 = this.transitionStarts_[id];\n    if (!start2) {\n      start2 = time2;\n      this.transitionStarts_[id] = start2;\n    } else if (start2 === -1) {\n      return 1;\n    }\n    var delta = time2 - start2 + 1e3 / 60;\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  };\n  Tile2.prototype.inTransition = function(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  };\n  Tile2.prototype.endTransition = function(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  };\n  return Tile2;\n}(EventTarget);\nvar Tile$1 = Tile;\nvar __extends$Y = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ImageTile = function(_super) {\n  __extends$Y(ImageTile2, _super);\n  function ImageTile2(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {\n    var _this = _super.call(this, tileCoord, state, opt_options) || this;\n    _this.crossOrigin_ = crossOrigin;\n    _this.src_ = src;\n    _this.key = src;\n    _this.image_ = new Image();\n    if (crossOrigin !== null) {\n      _this.image_.crossOrigin = crossOrigin;\n    }\n    _this.unlisten_ = null;\n    _this.tileLoadFunction_ = tileLoadFunction;\n    return _this;\n  }\n  ImageTile2.prototype.getImage = function() {\n    return this.image_;\n  };\n  ImageTile2.prototype.setImage = function(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  };\n  ImageTile2.prototype.handleImageError_ = function() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  };\n  ImageTile2.prototype.handleImageLoad_ = function() {\n    var image2 = this.image_;\n    if (image2.naturalWidth && image2.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  };\n  ImageTile2.prototype.load = function() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));\n    }\n  };\n  ImageTile2.prototype.unlistenImage_ = function() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  };\n  return ImageTile2;\n}(Tile$1);\nfunction getBlankImage() {\n  var ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = \"rgba(0,0,0,0)\";\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\nvar ImageTile$1 = ImageTile;\nvar ERROR_THRESHOLD = 0.5;\nvar ENABLE_RASTER_REPROJECTION = true;\nvar MAX_SUBDIVISION = 10;\nvar MAX_TRIANGLE_WIDTH = 0.25;\nvar Triangulation = function() {\n  function Triangulation2(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {\n    this.sourceProj_ = sourceProj;\n    this.targetProj_ = targetProj;\n    var transformInvCache = {};\n    var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n    this.transformInv_ = function(c2) {\n      var key = c2[0] + \"/\" + c2[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c2);\n      }\n      return transformInvCache[key];\n    };\n    this.maxSourceExtent_ = maxSourceExtent;\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n    this.triangles_ = [];\n    this.wrapsXInSource_ = false;\n    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;\n    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;\n    var destinationTopLeft = getTopLeft(targetExtent);\n    var destinationTopRight = getTopRight(targetExtent);\n    var destinationBottomRight = getBottomRight(targetExtent);\n    var destinationBottomLeft = getBottomLeft(targetExtent);\n    var sourceTopLeft = this.transformInv_(destinationTopLeft);\n    var sourceTopRight = this.transformInv_(destinationTopRight);\n    var sourceBottomRight = this.transformInv_(destinationBottomRight);\n    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n    var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(log2(getArea(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);\n    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n    if (this.wrapsXInSource_) {\n      var leftBound_1 = Infinity;\n      this.triangles_.forEach(function(triangle, i2, arr) {\n        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n      });\n      this.triangles_.forEach(function(triangle) {\n        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {\n          var newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]]\n          ];\n          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      }.bind(this));\n    }\n    transformInvCache = {};\n  }\n  Triangulation2.prototype.addTriangle_ = function(a2, b2, c2, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a2, b2, c2]\n    });\n  };\n  Triangulation2.prototype.addQuad_ = function(a2, b2, c2, d2, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n    var sourceWorldWidth = this.sourceWorldWidth_;\n    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n    var needsSubdivision = false;\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        var targetQuadExtent = boundingExtent([a2, b2, c2, d2]);\n        var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {\n        if (!intersects$1(sourceQuadExtent, this.maxSourceExtent_)) {\n          return;\n        }\n      }\n    }\n    var isNotFinite = 0;\n    if (!needsSubdivision) {\n      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {\n            return;\n          }\n        }\n      }\n    }\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        var center = [(a2[0] + c2[0]) / 2, (a2[1] + c2[1]) / 2];\n        var centerSrc = this.transformInv_(center);\n        var dx = void 0;\n        if (wrapsX) {\n          var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        var centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a2[0] - c2[0]) <= Math.abs(a2[1] - c2[1])) {\n          var bc = [(b2[0] + c2[0]) / 2, (b2[1] + c2[1]) / 2];\n          var bcSrc = this.transformInv_(bc);\n          var da = [(d2[0] + a2[0]) / 2, (d2[1] + a2[1]) / 2];\n          var daSrc = this.transformInv_(da);\n          this.addQuad_(a2, b2, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n          this.addQuad_(da, bc, c2, d2, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n        } else {\n          var ab = [(a2[0] + b2[0]) / 2, (a2[1] + b2[1]) / 2];\n          var abSrc = this.transformInv_(ab);\n          var cd = [(c2[0] + d2[0]) / 2, (c2[1] + d2[1]) / 2];\n          var cdSrc = this.transformInv_(cd);\n          this.addQuad_(a2, ab, cd, d2, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n          this.addQuad_(ab, b2, c2, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n        }\n        return;\n      }\n    }\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n    if ((isNotFinite & 11) == 0) {\n      this.addTriangle_(a2, c2, d2, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 14) == 0) {\n      this.addTriangle_(a2, c2, b2, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      if ((isNotFinite & 13) == 0) {\n        this.addTriangle_(b2, d2, a2, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 7) == 0) {\n        this.addTriangle_(b2, d2, c2, bSrc, dSrc, cSrc);\n      }\n    }\n  };\n  Triangulation2.prototype.calculateSourceExtent = function() {\n    var extent2 = createEmpty();\n    this.triangles_.forEach(function(triangle, i2, arr) {\n      var src = triangle.source;\n      extendCoordinate(extent2, src[0]);\n      extendCoordinate(extent2, src[1]);\n      extendCoordinate(extent2, src[2]);\n    });\n    return extent2;\n  };\n  Triangulation2.prototype.getTriangles = function() {\n    return this.triangles_;\n  };\n  return Triangulation2;\n}();\nvar Triangulation$1 = Triangulation;\nvar IMAGE_SMOOTHING_DISABLED = {\n  imageSmoothingEnabled: false,\n  msImageSmoothingEnabled: false\n};\nvar IMAGE_SMOOTHING_ENABLED = {\n  imageSmoothingEnabled: true,\n  msImageSmoothingEnabled: true\n};\nvar brokenDiagonalRendering_;\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\nfunction verifyBrokenDiagonalRendering(data2, offset2) {\n  return Math.abs(data2[offset2 * 4] - 210) > 2 || Math.abs(data2[offset2 * 4 + 3] - 0.75 * 255) > 2;\n}\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === void 0) {\n    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n    ctx.globalCompositeOperation = \"lighter\";\n    ctx.fillStyle = \"rgba(210, 0, 0, 0.75)\";\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    var data2 = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data2, 0) || verifyBrokenDiagonalRendering(data2, 4) || verifyBrokenDiagonalRendering(data2, 8);\n  }\n  return brokenDiagonalRendering_;\n}\nfunction calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n  var sourceCenter = transform$3(targetCenter, targetProj, sourceProj);\n  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== void 0) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== void 0) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n  var sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n  return sourceResolution;\n}\nfunction calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {\n  var targetCenter = getCenter(targetExtent);\n  var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function(corner) {\n      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n  return sourceResolution;\n}\nfunction render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_interpolate) {\n  var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n  if (!opt_interpolate) {\n    assign(context, IMAGE_SMOOTHING_DISABLED);\n  }\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n  context.scale(pixelRatio, pixelRatio);\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n  context.globalCompositeOperation = \"lighter\";\n  var sourceDataExtent = createEmpty();\n  sources.forEach(function(src, i2, arr) {\n    extend$2(sourceDataExtent, src.extent);\n  });\n  var canvasWidthInUnits = getWidth(sourceDataExtent);\n  var canvasHeightInUnits = getHeight(sourceDataExtent);\n  var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n  if (!opt_interpolate) {\n    assign(stitchContext, IMAGE_SMOOTHING_DISABLED);\n  }\n  var stitchScale = pixelRatio / sourceResolution;\n  sources.forEach(function(src, i2, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = getWidth(src.extent);\n    var srcHeight = getHeight(src.extent);\n    if (src.image.width > 0 && src.image.height > 0) {\n      stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n    }\n  });\n  var targetTopLeft = getTopLeft(targetExtent);\n  triangulation.getTriangles().forEach(function(triangle, i2, arr) {\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0], y0 = source[0][1];\n    var x1 = source[1][0], y1 = source[1][1];\n    var x2 = source[2][0], y2 = source[2][1];\n    var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);\n    var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);\n    var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n    var augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0]\n    ];\n    var affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n    context.save();\n    context.beginPath();\n    if (isBrokenDiagonalRendering() || !opt_interpolate) {\n      context.moveTo(u1, v1);\n      var steps = 4;\n      var ud = u0 - u1;\n      var vd = v0 - v1;\n      for (var step = 0; step < steps; step++) {\n        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));\n        if (step != steps - 1) {\n          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));\n        }\n      }\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n    context.clip();\n    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n  if (opt_renderEdges) {\n    context.save();\n    context.globalCompositeOperation = \"source-over\";\n    context.strokeStyle = \"black\";\n    context.lineWidth = 1;\n    triangulation.getTriangles().forEach(function(triangle, i2, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n    context.restore();\n  }\n  return context.canvas;\n}\nvar __extends$X = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ReprojTile = function(_super) {\n  __extends$X(ReprojTile2, _super);\n  function ReprojTile2(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {\n    var _this = _super.call(this, tileCoord, TileState.IDLE, { interpolate: !!opt_interpolate }) || this;\n    _this.renderEdges_ = opt_renderEdges !== void 0 ? opt_renderEdges : false;\n    _this.pixelRatio_ = pixelRatio;\n    _this.gutter_ = gutter;\n    _this.canvas_ = null;\n    _this.sourceTileGrid_ = sourceTileGrid;\n    _this.targetTileGrid_ = targetTileGrid;\n    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    _this.sourceTiles_ = [];\n    _this.sourcesListenerKeys_ = null;\n    _this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n    var maxTargetExtent = _this.targetTileGrid_.getExtent();\n    var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n    var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    var errorThresholdInPixels = opt_errorThreshold !== void 0 ? opt_errorThreshold : ERROR_THRESHOLD;\n    _this.triangulation_ = new Triangulation$1(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    if (_this.triangulation_.getTriangles().length === 0) {\n      _this.state = TileState.EMPTY;\n      return _this;\n    }\n    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = _this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      _this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile2 = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile2) {\n            _this.sourceTiles_.push(tile2);\n          }\n        }\n      }\n      if (_this.sourceTiles_.length === 0) {\n        _this.state = TileState.EMPTY;\n      }\n    }\n    return _this;\n  }\n  ReprojTile2.prototype.getImage = function() {\n    return this.canvas_;\n  };\n  ReprojTile2.prototype.reproject_ = function() {\n    var sources = [];\n    this.sourceTiles_.forEach(function(tile2, i2, arr) {\n      if (tile2 && tile2.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile2.tileCoord),\n          image: tile2.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z2 = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z2);\n      var width = typeof size === \"number\" ? size : size[0];\n      var height = typeof size === \"number\" ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z2);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  };\n  ReprojTile2.prototype.load = function() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad_1 = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function(tile2, i2, arr) {\n        var state = tile2.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad_1++;\n          var sourceListenKey_1 = listen(tile2, EventType.CHANGE, function(e2) {\n            var state2 = tile2.getState();\n            if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey_1);\n              leftToLoad_1--;\n              if (leftToLoad_1 === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey_1);\n        }\n      }.bind(this));\n      if (leftToLoad_1 === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function(tile2, i2, arr) {\n          var state = tile2.getState();\n          if (state == TileState.IDLE) {\n            tile2.load();\n          }\n        });\n      }\n    }\n  };\n  ReprojTile2.prototype.unlistenSources_ = function() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n  return ReprojTile2;\n}(Tile$1);\nvar ReprojTile$1 = ReprojTile;\nvar TileRange = function() {\n  function TileRange2(minX, maxX, minY, maxY) {\n    this.minX = minX;\n    this.maxX = maxX;\n    this.minY = minY;\n    this.maxY = maxY;\n  }\n  TileRange2.prototype.contains = function(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  };\n  TileRange2.prototype.containsTileRange = function(tileRange) {\n    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;\n  };\n  TileRange2.prototype.containsXY = function(x2, y2) {\n    return this.minX <= x2 && x2 <= this.maxX && this.minY <= y2 && y2 <= this.maxY;\n  };\n  TileRange2.prototype.equals = function(tileRange) {\n    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;\n  };\n  TileRange2.prototype.extend = function(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  };\n  TileRange2.prototype.getHeight = function() {\n    return this.maxY - this.minY + 1;\n  };\n  TileRange2.prototype.getSize = function() {\n    return [this.getWidth(), this.getHeight()];\n  };\n  TileRange2.prototype.getWidth = function() {\n    return this.maxX - this.minX + 1;\n  };\n  TileRange2.prototype.intersects = function(tileRange) {\n    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;\n  };\n  return TileRange2;\n}();\nfunction createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== void 0) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  } else {\n    return new TileRange(minX, maxX, minY, maxY);\n  }\n}\nvar TileRange$1 = TileRange;\nvar __extends$W = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CanvasTileLayerRenderer = function(_super) {\n  __extends$W(CanvasTileLayerRenderer2, _super);\n  function CanvasTileLayerRenderer2(tileLayer) {\n    var _this = _super.call(this, tileLayer) || this;\n    _this.extentChanged = true;\n    _this.renderedExtent_ = null;\n    _this.renderedPixelRatio;\n    _this.renderedProjection = null;\n    _this.renderedRevision;\n    _this.renderedTiles = [];\n    _this.newTiles_ = false;\n    _this.tmpExtent = createEmpty();\n    _this.tmpTileRange_ = new TileRange$1(0, 0, 0, 0);\n    return _this;\n  }\n  CanvasTileLayerRenderer2.prototype.isDrawableTile = function(tile2) {\n    var tileLayer = this.getLayer();\n    var tileState = tile2.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  CanvasTileLayerRenderer2.prototype.getTile = function(z2, x2, y2, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var tile2 = tileSource.getTile(z2, x2, y2, pixelRatio, projection);\n    if (tile2.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        tile2.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile2)) {\n      tile2 = tile2.getInterimTile();\n    }\n    return tile2;\n  };\n  CanvasTileLayerRenderer2.prototype.getData = function(pixel) {\n    var frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    var layer = this.getLayer();\n    var coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());\n    var layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n    var pixelRatio = frameState.pixelRatio;\n    var projection = frameState.viewState.projection;\n    var viewState = frameState.viewState;\n    var source = layer.getRenderSource();\n    var tileGrid = source.getTileGridForProjection(viewState.projection);\n    var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n    for (var z2 = tileGrid.getZForResolution(viewState.resolution); z2 >= tileGrid.getMinZoom(); --z2) {\n      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);\n      var tile2 = source.getTile(z2, tileCoord[1], tileCoord[2], pixelRatio, projection);\n      if (!(tile2 instanceof ImageTile$1 || tile2 instanceof ReprojTile$1)) {\n        return null;\n      }\n      if (tile2.getState() !== TileState.LOADED) {\n        continue;\n      }\n      var tileOrigin = tileGrid.getOrigin(z2);\n      var tileSize = toSize(tileGrid.getTileSize(z2));\n      var tileResolution = tileGrid.getResolution(z2);\n      var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      return this.getImageData(tile2.getImage(), col, row);\n    }\n    return null;\n  };\n  CanvasTileLayerRenderer2.prototype.loadedTileCallback = function(tiles, zoom, tile2) {\n    if (this.isDrawableTile(tile2)) {\n      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile2);\n    }\n    return false;\n  };\n  CanvasTileLayerRenderer2.prototype.prepareFrame = function(frameState) {\n    return !!this.getLayer().getSource();\n  };\n  CanvasTileLayerRenderer2.prototype.renderFrame = function(frameState, target) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var rotation = viewState.rotation;\n    var pixelRatio = frameState.pixelRatio;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z2 = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    var tileResolution = tileGrid.getResolution(z2);\n    var extent2 = frameState.extent;\n    var layerExtent = layerState.extent && fromUserExtent(layerState.extent);\n    if (layerExtent) {\n      extent2 = getIntersection(extent2, fromUserExtent(layerState.extent));\n    }\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    var width = Math.round(frameState.size[0] * tilePixelRatio);\n    var height = Math.round(frameState.size[1] * tilePixelRatio);\n    if (rotation) {\n      var size = Math.round(Math.sqrt(width * width + height * height));\n      width = size;\n      height = size;\n    }\n    var dx = tileResolution * width / 2 / tilePixelRatio;\n    var dy = tileResolution * height / 2 / tilePixelRatio;\n    var canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy\n    ];\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2);\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z2] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var tmpExtent2 = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    for (var x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {\n      for (var y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {\n        var tile2 = this.getTile(z2, x2, y2, frameState);\n        if (this.isDrawableTile(tile2)) {\n          var uid2 = getUid(this);\n          if (tile2.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z2][tile2.tileCoord.toString()] = tile2;\n            var inTransition = tile2.inTransition(uid2);\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile2) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile2.getAlpha(uid2, frameState.time) === 1) {\n            continue;\n          }\n        }\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile2.tileCoord, tmpTileRange, tmpExtent2);\n        var covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z2 + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile2.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent2);\n        }\n      }\n    }\n    var canvasScale = tileResolution / viewResolution;\n    compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);\n    var canvasTransform = toString$d(this.pixelTransform);\n    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));\n    var context = this.context;\n    var canvas = context.canvas;\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n    if (!tileSource.getInterpolate()) {\n      assign(context, IMAGE_SMOOTHING_DISABLED);\n    }\n    this.preRender(context, frameState);\n    this.renderedTiles.length = 0;\n    var zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var clips, clipZs, currentClip;\n    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (var i2 = zs.length - 1; i2 >= 0; --i2) {\n      var currentZ = zs[i2];\n      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      var currentResolution = tileGrid.getResolution(currentZ);\n      var currentScale = currentResolution / tileResolution;\n      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;\n      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;\n      var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      var origin_1 = apply$5(this.tempTransform, [\n        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,\n        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution\n      ]);\n      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      var tilesToDraw = tilesToDrawByZ[currentZ];\n      for (var tileCoordKey in tilesToDraw) {\n        var tile2 = tilesToDraw[tileCoordKey];\n        var tileCoord = tile2.tileCoord;\n        var xIndex = originTileCoord[1] - tileCoord[1];\n        var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);\n        var yIndex = originTileCoord[2] - tileCoord[2];\n        var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);\n        var x2 = Math.round(origin_1[0] - xIndex * dx_1);\n        var y2 = Math.round(origin_1[1] - yIndex * dy_1);\n        var w2 = nextX - x2;\n        var h2 = nextY - y2;\n        var transition = z2 === currentZ;\n        var inTransition = transition && tile2.getAlpha(getUid(this), frameState.time) !== 1;\n        var contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            currentClip = [x2, y2, x2 + w2, y2, x2 + w2, y2 + h2, x2, y2 + h2];\n            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {\n              if (z2 !== currentZ && currentZ < clipZs[i_1]) {\n                var clip = clips[i_1];\n                if (intersects$1([x2, y2, x2 + w2, y2 + h2], [clip[0], clip[3], clip[4], clip[7]])) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x2, y2, w2, h2);\n          }\n        }\n        this.drawTileImage(tile2, frameState, x2, y2, w2, h2, tileGutter, transition);\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile2);\n        } else {\n          this.renderedTiles.push(tile2);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile2);\n      }\n    }\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals$1(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent2, z2, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.postRender(context, frameState);\n    if (layerState.extent) {\n      context.restore();\n    }\n    assign(context, IMAGE_SMOOTHING_ENABLED);\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n    var opacity2 = cssOpacity(layerState.opacity);\n    var container = this.container;\n    if (opacity2 !== container.style.opacity) {\n      container.style.opacity = opacity2;\n    }\n    return this.container;\n  };\n  CanvasTileLayerRenderer2.prototype.drawTileImage = function(tile2, frameState, x2, y2, w2, h2, gutter, transition) {\n    var image2 = this.getTileImage(tile2);\n    if (!image2) {\n      return;\n    }\n    var uid2 = getUid(this);\n    var alpha = transition ? tile2.getAlpha(uid2, frameState.time) : 1;\n    var alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image2, gutter, gutter, image2.width - 2 * gutter, image2.height - 2 * gutter, x2, y2, w2, h2);\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile2.endTransition(uid2);\n    }\n  };\n  CanvasTileLayerRenderer2.prototype.getImage = function() {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  CanvasTileLayerRenderer2.prototype.getTileImage = function(tile2) {\n    return tile2.getImage();\n  };\n  CanvasTileLayerRenderer2.prototype.scheduleExpireCache = function(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      var postRenderFunction = function(tileSource2, map, frameState2) {\n        var tileSourceKey = getUid(tileSource2);\n        if (tileSourceKey in frameState2.usedTiles) {\n          tileSource2.expireCache(frameState2.viewState.projection, frameState2.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n  };\n  CanvasTileLayerRenderer2.prototype.updateUsedTiles = function(usedTiles, tileSource, tile2) {\n    var tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile2.getKey()] = true;\n  };\n  CanvasTileLayerRenderer2.prototype.manageTilePyramid = function(frameState, tileSource, tileGrid, pixelRatio, projection, extent2, currentZ, preload, opt_tileCallback) {\n    var tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tileCount = 0;\n    var tile2, tileRange, tileResolution, x2, y2, z2;\n    for (z2 = minZoom; z2 <= currentZ; ++z2) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2, tileRange);\n      tileResolution = tileGrid.getResolution(z2);\n      for (x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {\n        for (y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {\n          if (currentZ - z2 <= preload) {\n            ++tileCount;\n            tile2 = tileSource.getTile(z2, x2, y2, pixelRatio, projection);\n            if (tile2.getState() == TileState.IDLE) {\n              wantedTiles[tile2.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile2.getKey())) {\n                tileQueue.enqueue([\n                  tile2,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile2.tileCoord),\n                  tileResolution\n                ]);\n              }\n            }\n            if (opt_tileCallback !== void 0) {\n              opt_tileCallback(tile2);\n            }\n          } else {\n            tileSource.useTile(z2, x2, y2, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  };\n  return CanvasTileLayerRenderer2;\n}(CanvasLayerRenderer$1);\nvar CanvasTileLayerRenderer$1 = CanvasTileLayerRenderer;\nvar __extends$V = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TileLayer$2 = function(_super) {\n  __extends$V(TileLayer2, _super);\n  function TileLayer2(opt_options) {\n    return _super.call(this, opt_options) || this;\n  }\n  TileLayer2.prototype.createRenderer = function() {\n    return new CanvasTileLayerRenderer$1(this);\n  };\n  return TileLayer2;\n}(BaseTileLayer$1);\nvar ol_layer_Tile = TileLayer$2;\nconst _sfc_main$$ = {\n  props: {\n    className: {\n      type: String,\n      default: \"ol-layer\"\n    },\n    opacity: {\n      type: Number,\n      default: 1\n    },\n    visible: {\n      type: Boolean,\n      default: true\n    },\n    extent: {\n      type: Array\n    },\n    zIndex: {\n      type: Number\n    },\n    minResolution: {\n      type: Number\n    },\n    maxResolution: {\n      type: Number\n    },\n    minZoom: {\n      type: Number\n    },\n    maxZoom: {\n      type: Number\n    },\n    title: {\n      type: String\n    },\n    name: {\n      type: String\n    },\n    preview: {\n      type: String\n    },\n    baseLayer: {\n      type: Boolean\n    },\n    properties: {\n      type: Object,\n      default: () => {\n      }\n    }\n  }\n};\nfunction _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\");\n}\nvar BaseLayer = /* @__PURE__ */ _export_sfc(_sfc_main$$, [[\"render\", _sfc_render$$]]);\nconst _sfc_main$_ = {\n  extends: BaseLayer,\n  name: \"ol-tile-layer\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const overViewMap = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"overviewMap\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const tileLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new ol_layer_Tile(properties));\n    const applyTileLayer = () => {\n      if (overViewMap != null) {\n        overViewMap.value.getOverviewMap().addLayer(tileLayer.value);\n        overViewMap.value.changed();\n      } else {\n        map.addLayer(tileLayer.value);\n      }\n    };\n    const removeTileLayer = () => {\n      if (overViewMap != null) {\n        overViewMap.value.getOverviewMap().removeLayer(tileLayer.value);\n        overViewMap.value.changed();\n      } else {\n        map.removeLayer(tileLayer.value);\n      }\n    };\n    if (overViewMap != null) {\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(overViewMap, () => {\n        removeTileLayer();\n        applyTileLayer();\n      });\n    }\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      applyTileLayer();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      removeTileLayer();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"tileLayer\", tileLayer);\n    return {\n      tileLayer\n    };\n  },\n  props: {\n    preload: {\n      type: Number,\n      default: 1\n    }\n  }\n};\nfunction _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar TileLayer$1 = /* @__PURE__ */ _export_sfc(_sfc_main$_, [[\"render\", _sfc_render$_]]);\nvar LRUCache = function() {\n  function LRUCache2(opt_highWaterMark) {\n    this.highWaterMark = opt_highWaterMark !== void 0 ? opt_highWaterMark : 2048;\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n  LRUCache2.prototype.canExpireCache = function() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  };\n  LRUCache2.prototype.expireCache = function(keep) {\n    while (this.canExpireCache()) {\n      this.pop();\n    }\n  };\n  LRUCache2.prototype.clear = function() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  };\n  LRUCache2.prototype.containsKey = function(key) {\n    return this.entries_.hasOwnProperty(key);\n  };\n  LRUCache2.prototype.forEach = function(f2) {\n    var entry = this.oldest_;\n    while (entry) {\n      f2(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  };\n  LRUCache2.prototype.get = function(key, opt_options) {\n    var entry = this.entries_[key];\n    assert(entry !== void 0, 15);\n    if (entry === this.newest_) {\n      return entry.value_;\n    } else if (entry === this.oldest_) {\n      this.oldest_ = this.oldest_.newer;\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  };\n  LRUCache2.prototype.remove = function(key) {\n    var entry = this.entries_[key];\n    assert(entry !== void 0, 15);\n    if (entry === this.newest_) {\n      this.newest_ = entry.older;\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = entry.newer;\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  };\n  LRUCache2.prototype.getCount = function() {\n    return this.count_;\n  };\n  LRUCache2.prototype.getKeys = function() {\n    var keys3 = new Array(this.count_);\n    var i2 = 0;\n    var entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys3[i2++] = entry.key_;\n    }\n    return keys3;\n  };\n  LRUCache2.prototype.getValues = function() {\n    var values2 = new Array(this.count_);\n    var i2 = 0;\n    var entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values2[i2++] = entry.value_;\n    }\n    return values2;\n  };\n  LRUCache2.prototype.peekLast = function() {\n    return this.oldest_.value_;\n  };\n  LRUCache2.prototype.peekLastKey = function() {\n    return this.oldest_.key_;\n  };\n  LRUCache2.prototype.peekFirstKey = function() {\n    return this.newest_.key_;\n  };\n  LRUCache2.prototype.pop = function() {\n    var entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = entry.newer;\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  };\n  LRUCache2.prototype.replace = function(key, value) {\n    this.get(key);\n    this.entries_[key].value_ = value;\n  };\n  LRUCache2.prototype.set = function(key, value) {\n    assert(!(key in this.entries_), 16);\n    var entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  };\n  LRUCache2.prototype.setSize = function(size) {\n    this.highWaterMark = size;\n  };\n  return LRUCache2;\n}();\nvar LRUCache$1 = LRUCache;\nvar __extends$U = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DataTile = function(_super) {\n  __extends$U(DataTile2, _super);\n  function DataTile2(options) {\n    var _this = this;\n    var state = TileState.IDLE;\n    _this = _super.call(this, options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate\n    }) || this;\n    _this.loader_ = options.loader;\n    _this.data_ = null;\n    _this.error_ = null;\n    return _this;\n  }\n  DataTile2.prototype.getData = function() {\n    return this.data_;\n  };\n  DataTile2.prototype.getError = function() {\n    return this.error_;\n  };\n  DataTile2.prototype.load = function() {\n    this.state = TileState.LOADING;\n    this.changed();\n    var self2 = this;\n    this.loader_().then(function(data2) {\n      self2.data_ = data2;\n      self2.state = TileState.LOADED;\n      self2.changed();\n    }).catch(function(error) {\n      self2.error_ = error;\n      self2.state = TileState.ERROR;\n      self2.changed();\n    });\n  };\n  return DataTile2;\n}(Tile$1);\nvar DataTile$1 = DataTile;\nvar ARRAY_BUFFER = 34962;\nvar ELEMENT_ARRAY_BUFFER = 34963;\nvar STREAM_DRAW = 35040;\nvar STATIC_DRAW = 35044;\nvar DYNAMIC_DRAW = 35048;\nvar UNSIGNED_BYTE = 5121;\nvar UNSIGNED_SHORT = 5123;\nvar UNSIGNED_INT = 5125;\nvar FLOAT = 5126;\nvar CONTEXT_IDS = [\"experimental-webgl\", \"webgl\", \"webkit-3d\", \"moz-webgl\"];\nfunction getContext(canvas, opt_attributes) {\n  var attributes = assign({\n    preserveDrawingBuffer: true,\n    antialias: SAFARI_BUG_237906 ? false : true\n  }, opt_attributes);\n  var ii = CONTEXT_IDS.length;\n  for (var i2 = 0; i2 < ii; ++i2) {\n    try {\n      var context = canvas.getContext(CONTEXT_IDS[i2], attributes);\n      if (context) {\n        return context;\n      }\n    } catch (e2) {\n    }\n  }\n  return null;\n}\nvar BufferUsage = {\n  STATIC_DRAW,\n  STREAM_DRAW,\n  DYNAMIC_DRAW\n};\nvar WebGLArrayBuffer = function() {\n  function WebGLArrayBuffer2(type, opt_usage) {\n    this.array = null;\n    this.type = type;\n    assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);\n    this.usage = opt_usage !== void 0 ? opt_usage : BufferUsage.STATIC_DRAW;\n  }\n  WebGLArrayBuffer2.prototype.ofSize = function(size) {\n    this.array = new (getArrayClassForType(this.type))(size);\n  };\n  WebGLArrayBuffer2.prototype.fromArray = function(array) {\n    var arrayClass = getArrayClassForType(this.type);\n    this.array = arrayClass.from ? arrayClass.from(array) : new arrayClass(array);\n  };\n  WebGLArrayBuffer2.prototype.fromArrayBuffer = function(buffer2) {\n    this.array = new (getArrayClassForType(this.type))(buffer2);\n  };\n  WebGLArrayBuffer2.prototype.getType = function() {\n    return this.type;\n  };\n  WebGLArrayBuffer2.prototype.getArray = function() {\n    return this.array;\n  };\n  WebGLArrayBuffer2.prototype.getUsage = function() {\n    return this.usage;\n  };\n  WebGLArrayBuffer2.prototype.getSize = function() {\n    return this.array ? this.array.length : 0;\n  };\n  return WebGLArrayBuffer2;\n}();\nfunction getArrayClassForType(type) {\n  switch (type) {\n    case ARRAY_BUFFER:\n      return Float32Array;\n    case ELEMENT_ARRAY_BUFFER:\n      return Uint32Array;\n    default:\n      return Float32Array;\n  }\n}\nvar WebGLArrayBuffer$1 = WebGLArrayBuffer;\nvar __extends$T = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nfunction bindAndConfigure(gl, texture, interpolate) {\n  var resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);\n}\nfunction uploadImageTexture(gl, texture, image2, interpolate) {\n  bindAndConfigure(gl, texture, interpolate);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);\n}\nfunction uploadDataTexture(helper, texture, data2, size, bandCount, interpolate) {\n  var gl = helper.getGL();\n  var textureType;\n  var canInterpolate;\n  if (data2 instanceof Float32Array) {\n    textureType = gl.FLOAT;\n    helper.getExtension(\"OES_texture_float\");\n    var extension = helper.getExtension(\"OES_texture_float_linear\");\n    canInterpolate = extension !== null;\n  } else {\n    textureType = gl.UNSIGNED_BYTE;\n    canInterpolate = true;\n  }\n  bindAndConfigure(gl, texture, interpolate && canInterpolate);\n  var bytesPerRow = data2.byteLength / size[1];\n  var unpackAlignment = 1;\n  if (bytesPerRow % 8 === 0) {\n    unpackAlignment = 8;\n  } else if (bytesPerRow % 4 === 0) {\n    unpackAlignment = 4;\n  } else if (bytesPerRow % 2 === 0) {\n    unpackAlignment = 2;\n  }\n  var format2;\n  switch (bandCount) {\n    case 1: {\n      format2 = gl.LUMINANCE;\n      break;\n    }\n    case 2: {\n      format2 = gl.LUMINANCE_ALPHA;\n      break;\n    }\n    case 3: {\n      format2 = gl.RGB;\n      break;\n    }\n    case 4: {\n      format2 = gl.RGBA;\n      break;\n    }\n    default: {\n      throw new Error(\"Unsupported number of bands: \".concat(bandCount));\n    }\n  }\n  var oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.texImage2D(gl.TEXTURE_2D, 0, format2, size[0], size[1], 0, format2, textureType, data2);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);\n}\nvar pixelContext = null;\nfunction createPixelContext() {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = 1;\n  pixelContext = canvas.getContext(\"2d\");\n}\nvar TileTexture = function(_super) {\n  __extends$T(TileTexture2, _super);\n  function TileTexture2(options) {\n    var _this = _super.call(this) || this;\n    _this.tile;\n    _this.textures = [];\n    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);\n    _this.size = toSize(options.grid.getTileSize(options.tile.tileCoord[0]));\n    _this.tilePixelRatio_ = options.tilePixelRatio || 1;\n    _this.gutter_ = options.gutter || 0;\n    _this.bandCount = NaN;\n    _this.helper_ = options.helper;\n    var coords = new WebGLArrayBuffer$1(ARRAY_BUFFER, STATIC_DRAW);\n    coords.fromArray([\n      0,\n      1,\n      1,\n      1,\n      1,\n      0,\n      0,\n      0\n    ]);\n    _this.helper_.flushBufferData(coords);\n    _this.coords = coords;\n    _this.setTile(options.tile);\n    return _this;\n  }\n  TileTexture2.prototype.setTile = function(tile2) {\n    if (tile2 !== this.tile) {\n      if (this.tile) {\n        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n      }\n      this.tile = tile2;\n      this.textures.length = 0;\n      this.loaded = tile2.getState() === TileState.LOADED;\n      if (this.loaded) {\n        this.uploadTile_();\n      } else {\n        if (tile2 instanceof ImageTile$1) {\n          var image2 = tile2.getImage();\n          if (image2 instanceof Image && !image2.crossOrigin) {\n            image2.crossOrigin = \"anonymous\";\n          }\n        }\n        tile2.addEventListener(EventType.CHANGE, this.handleTileChange_);\n      }\n    }\n  };\n  TileTexture2.prototype.uploadTile_ = function() {\n    var helper = this.helper_;\n    var gl = helper.getGL();\n    var tile2 = this.tile;\n    if (tile2 instanceof ImageTile$1 || tile2 instanceof ReprojTile$1) {\n      var image2 = tile2.getImage();\n      if (this.gutter_ !== 0) {\n        var gutter = this.tilePixelRatio_ * this.gutter_;\n        var width = Math.round(image2.width - 2 * gutter);\n        var height = Math.round(image2.height - 2 * gutter);\n        var context = createCanvasContext2D(width, height);\n        if (!tile2.interpolate) {\n          assign(context, IMAGE_SMOOTHING_DISABLED);\n        }\n        context.drawImage(image2, gutter, gutter, width, height, 0, 0, width, height);\n        image2 = context.canvas;\n      }\n      var texture = gl.createTexture();\n      this.textures.push(texture);\n      this.bandCount = 4;\n      uploadImageTexture(gl, texture, image2, tile2.interpolate);\n      return;\n    }\n    var pixelSize = [\n      this.size[0] * this.tilePixelRatio_,\n      this.size[1] * this.tilePixelRatio_\n    ];\n    var data2 = tile2.getData();\n    var isFloat = data2 instanceof Float32Array;\n    var pixelCount = pixelSize[0] * pixelSize[1];\n    var DataType = isFloat ? Float32Array : Uint8Array;\n    var bytesPerElement = DataType.BYTES_PER_ELEMENT;\n    var bytesPerRow = data2.byteLength / pixelSize[1];\n    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n    var textureCount = Math.ceil(this.bandCount / 4);\n    if (textureCount === 1) {\n      var texture = gl.createTexture();\n      this.textures.push(texture);\n      uploadDataTexture(helper, texture, data2, pixelSize, this.bandCount, tile2.interpolate);\n      return;\n    }\n    var textureDataArrays = new Array(textureCount);\n    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      var texture = gl.createTexture();\n      this.textures.push(texture);\n      var bandCount = textureIndex < textureCount - 1 ? 4 : this.bandCount % 4;\n      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);\n    }\n    var dataIndex = 0;\n    var rowOffset = 0;\n    var colCount = pixelSize[0] * this.bandCount;\n    for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n      for (var colIndex = 0; colIndex < colCount; ++colIndex) {\n        var dataValue = data2[rowOffset + colIndex];\n        var pixelIndex = Math.floor(dataIndex / this.bandCount);\n        var bandIndex = colIndex % this.bandCount;\n        var textureIndex = Math.floor(bandIndex / 4);\n        var textureData = textureDataArrays[textureIndex];\n        var bandCount = textureData.length / pixelCount;\n        var textureBandIndex = bandIndex % 4;\n        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;\n        ++dataIndex;\n      }\n      rowOffset += bytesPerRow / bytesPerElement;\n    }\n    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      var texture = this.textures[textureIndex];\n      var textureData = textureDataArrays[textureIndex];\n      var bandCount = textureData.length / pixelCount;\n      uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile2.interpolate);\n    }\n  };\n  TileTexture2.prototype.handleTileChange_ = function() {\n    if (this.tile.getState() === TileState.LOADED) {\n      this.loaded = true;\n      this.uploadTile_();\n      this.dispatchEvent(EventType.CHANGE);\n    }\n  };\n  TileTexture2.prototype.disposeInternal = function() {\n    var gl = this.helper_.getGL();\n    this.helper_.deleteBuffer(this.coords);\n    for (var i2 = 0; i2 < this.textures.length; ++i2) {\n      gl.deleteTexture(this.textures[i2]);\n    }\n    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n  };\n  TileTexture2.prototype.getPixelData = function(col, row) {\n    if (!this.loaded) {\n      return null;\n    }\n    col = Math.floor(this.tilePixelRatio_ * col);\n    row = Math.floor(this.tilePixelRatio_ * row);\n    if (this.tile instanceof DataTile$1) {\n      var data_1 = this.tile.getData();\n      var pixelsPerRow = Math.floor(this.tilePixelRatio_ * this.size[0]);\n      if (data_1 instanceof DataView) {\n        var bytesPerPixel = data_1.byteLength / (this.size[0] * this.size[1]);\n        var offset_1 = row * pixelsPerRow * bytesPerPixel + col * bytesPerPixel;\n        var buffer2 = data_1.buffer.slice(offset_1, offset_1 + bytesPerPixel);\n        return new DataView(buffer2);\n      }\n      var offset2 = row * pixelsPerRow * this.bandCount + col * this.bandCount;\n      return data_1.slice(offset2, offset2 + this.bandCount);\n    }\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n    var data2;\n    var image2 = this.tile.getImage();\n    try {\n      pixelContext.drawImage(image2, col, row, 1, 1, 0, 0, 1, 1);\n      data2 = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      return null;\n    }\n    return data2;\n  };\n  return TileTexture2;\n}(EventTarget);\nvar TileTexture$1 = TileTexture;\nvar ContextEventType = {\n  LOST: \"webglcontextlost\",\n  RESTORED: \"webglcontextrestored\"\n};\nvar DEFAULT_VERTEX_SHADER = \"\\n  precision mediump float;\\n  \\n  attribute vec2 a_position;\\n  varying vec2 v_texCoord;\\n  varying vec2 v_screenCoord;\\n  \\n  uniform vec2 u_screenSize;\\n   \\n  void main() {\\n    v_texCoord = a_position * 0.5 + 0.5;\\n    v_screenCoord = v_texCoord * u_screenSize;\\n    gl_Position = vec4(a_position, 0.0, 1.0);\\n  }\\n\";\nvar DEFAULT_FRAGMENT_SHADER = \"\\n  precision mediump float;\\n   \\n  uniform sampler2D u_image;\\n  uniform float u_opacity;\\n   \\n  varying vec2 v_texCoord;\\n   \\n  void main() {\\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\\n  }\\n\";\nvar WebGLPostProcessingPass = function() {\n  function WebGLPostProcessingPass2(options) {\n    this.gl_ = options.webGlContext;\n    var gl = this.gl_;\n    this.scaleRatio_ = options.scaleRatio || 1;\n    this.renderTargetTexture_ = gl.createTexture();\n    this.renderTargetTextureSize_ = null;\n    this.frameBuffer_ = gl.createFramebuffer();\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);\n    gl.compileShader(vertexShader);\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);\n    gl.compileShader(fragmentShader);\n    this.renderTargetProgram_ = gl.createProgram();\n    gl.attachShader(this.renderTargetProgram_, vertexShader);\n    gl.attachShader(this.renderTargetProgram_, fragmentShader);\n    gl.linkProgram(this.renderTargetProgram_);\n    this.renderTargetVerticesBuffer_ = gl.createBuffer();\n    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);\n    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, \"a_position\");\n    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, \"u_screenSize\");\n    this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, \"u_opacity\");\n    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, \"u_image\");\n    this.uniforms_ = [];\n    options.uniforms && Object.keys(options.uniforms).forEach(function(name) {\n      this.uniforms_.push({\n        value: options.uniforms[name],\n        location: gl.getUniformLocation(this.renderTargetProgram_, name)\n      });\n    }.bind(this));\n  }\n  WebGLPostProcessingPass2.prototype.getGL = function() {\n    return this.gl_;\n  };\n  WebGLPostProcessingPass2.prototype.init = function(frameState) {\n    var gl = this.getGL();\n    var textureSize = [\n      gl.drawingBufferWidth * this.scaleRatio_,\n      gl.drawingBufferHeight * this.scaleRatio_\n    ];\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n    gl.viewport(0, 0, textureSize[0], textureSize[1]);\n    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {\n      this.renderTargetTextureSize_ = textureSize;\n      var level = 0;\n      var internalFormat = gl.RGBA;\n      var border = 0;\n      var format2 = gl.RGBA;\n      var type = gl.UNSIGNED_BYTE;\n      var data2 = null;\n      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format2, type, data2);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);\n    }\n  };\n  WebGLPostProcessingPass2.prototype.apply = function(frameState, nextPass, preCompose, postCompose) {\n    var gl = this.getGL();\n    var size = frameState.size;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n    if (!nextPass) {\n      var canvasId = getUid(gl.canvas);\n      if (!frameState.renderTargets[canvasId]) {\n        var attributes = gl.getContextAttributes();\n        if (attributes && attributes.preserveDrawingBuffer) {\n          gl.clearColor(0, 0, 0, 0);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        frameState.renderTargets[canvasId] = true;\n      }\n    }\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.useProgram(this.renderTargetProgram_);\n    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);\n    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n    gl.uniform1i(this.renderTargetTextureLocation_, 0);\n    var opacity2 = frameState.layerStatesArray[frameState.layerIndex].opacity;\n    gl.uniform1f(this.renderTargetOpacityLocation_, opacity2);\n    this.applyUniforms(frameState);\n    if (preCompose) {\n      preCompose(gl, frameState);\n    }\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    if (postCompose) {\n      postCompose(gl, frameState);\n    }\n  };\n  WebGLPostProcessingPass2.prototype.getFrameBuffer = function() {\n    return this.frameBuffer_;\n  };\n  WebGLPostProcessingPass2.prototype.applyUniforms = function(frameState) {\n    var gl = this.getGL();\n    var value;\n    var textureSlot = 1;\n    this.uniforms_.forEach(function(uniform) {\n      value = typeof uniform.value === \"function\" ? uniform.value(frameState) : uniform.value;\n      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n        if (!uniform.texture) {\n          uniform.texture = gl.createTexture();\n        }\n        gl.activeTexture(gl[\"TEXTURE\".concat(textureSlot)]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        if (value instanceof ImageData) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));\n        } else {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n        }\n        gl.uniform1i(uniform.location, textureSlot++);\n      } else if (Array.isArray(value)) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(uniform.location, value[0], value[1]);\n            return;\n          case 3:\n            gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n            return;\n          case 4:\n            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);\n            return;\n          default:\n            return;\n        }\n      } else if (typeof value === \"number\") {\n        gl.uniform1f(uniform.location, value);\n      }\n    });\n  };\n  return WebGLPostProcessingPass2;\n}();\nvar WebGLPostProcessingPass$1 = WebGLPostProcessingPass;\nfunction create$5() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction fromTransform(mat4, transform2) {\n  mat4[0] = transform2[0];\n  mat4[1] = transform2[1];\n  mat4[4] = transform2[2];\n  mat4[5] = transform2[3];\n  mat4[12] = transform2[4];\n  mat4[13] = transform2[5];\n  return mat4;\n}\nvar __extends$S = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DefaultUniform = {\n  PROJECTION_MATRIX: \"u_projectionMatrix\",\n  OFFSET_SCALE_MATRIX: \"u_offsetScaleMatrix\",\n  OFFSET_ROTATION_MATRIX: \"u_offsetRotateMatrix\",\n  TIME: \"u_time\",\n  ZOOM: \"u_zoom\",\n  RESOLUTION: \"u_resolution\"\n};\nvar AttributeType = {\n  UNSIGNED_BYTE,\n  UNSIGNED_SHORT,\n  UNSIGNED_INT,\n  FLOAT\n};\nvar canvasCache = {};\nfunction getSharedCanvasCacheKey(key) {\n  return \"shared/\" + key;\n}\nvar uniqueCanvasCacheKeyCount = 0;\nfunction getUniqueCanvasCacheKey() {\n  var key = \"unique/\" + uniqueCanvasCacheKeyCount;\n  uniqueCanvasCacheKeyCount += 1;\n  return key;\n}\nfunction getCanvas(key) {\n  var cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.style.position = \"absolute\";\n    canvas.style.left = \"0\";\n    cacheItem = { users: 0, canvas };\n    canvasCache[key] = cacheItem;\n  }\n  cacheItem.users += 1;\n  return cacheItem.canvas;\n}\nfunction releaseCanvas(key) {\n  var cacheItem = canvasCache[key];\n  if (!cacheItem) {\n    return;\n  }\n  cacheItem.users -= 1;\n  if (cacheItem.users > 0) {\n    return;\n  }\n  var canvas = cacheItem.canvas;\n  var gl = getContext(canvas);\n  var extension = gl.getExtension(\"WEBGL_lose_context\");\n  if (extension) {\n    extension.loseContext();\n  }\n  delete canvasCache[key];\n}\nvar WebGLHelper = function(_super) {\n  __extends$S(WebGLHelper2, _super);\n  function WebGLHelper2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options || {};\n    _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);\n    _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);\n    _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();\n    _this.canvas_ = getCanvas(_this.canvasCacheKey_);\n    _this.gl_ = getContext(_this.canvas_);\n    _this.bufferCache_ = {};\n    _this.extensionCache_ = {};\n    _this.currentProgram_ = null;\n    _this.canvas_.addEventListener(ContextEventType.LOST, _this.boundHandleWebGLContextLost_);\n    _this.canvas_.addEventListener(ContextEventType.RESTORED, _this.boundHandleWebGLContextRestored_);\n    _this.offsetRotateMatrix_ = create$6();\n    _this.offsetScaleMatrix_ = create$6();\n    _this.tmpMat4_ = create$5();\n    _this.uniformLocations_ = {};\n    _this.attribLocations_ = {};\n    _this.uniforms_ = [];\n    if (options.uniforms) {\n      _this.setUniforms(options.uniforms);\n    }\n    var gl = _this.getGL();\n    _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function(options2) {\n      return new WebGLPostProcessingPass$1({\n        webGlContext: gl,\n        scaleRatio: options2.scaleRatio,\n        vertexShader: options2.vertexShader,\n        fragmentShader: options2.fragmentShader,\n        uniforms: options2.uniforms\n      });\n    }) : [new WebGLPostProcessingPass$1({ webGlContext: gl })];\n    _this.shaderCompileErrors_ = null;\n    _this.startTime_ = Date.now();\n    return _this;\n  }\n  WebGLHelper2.prototype.setUniforms = function(uniforms) {\n    this.uniforms_ = [];\n    for (var name_1 in uniforms) {\n      this.uniforms_.push({\n        name: name_1,\n        value: uniforms[name_1]\n      });\n    }\n    this.uniformLocations_ = {};\n  };\n  WebGLHelper2.prototype.canvasCacheKeyMatches = function(canvasCacheKey) {\n    return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);\n  };\n  WebGLHelper2.prototype.getExtension = function(name) {\n    if (name in this.extensionCache_) {\n      return this.extensionCache_[name];\n    }\n    var extension = this.gl_.getExtension(name);\n    this.extensionCache_[name] = extension;\n    return extension;\n  };\n  WebGLHelper2.prototype.bindBuffer = function(buffer2) {\n    var gl = this.getGL();\n    var bufferKey = getUid(buffer2);\n    var bufferCache = this.bufferCache_[bufferKey];\n    if (!bufferCache) {\n      var webGlBuffer = gl.createBuffer();\n      bufferCache = {\n        buffer: buffer2,\n        webGlBuffer\n      };\n      this.bufferCache_[bufferKey] = bufferCache;\n    }\n    gl.bindBuffer(buffer2.getType(), bufferCache.webGlBuffer);\n  };\n  WebGLHelper2.prototype.flushBufferData = function(buffer2) {\n    var gl = this.getGL();\n    this.bindBuffer(buffer2);\n    gl.bufferData(buffer2.getType(), buffer2.getArray(), buffer2.getUsage());\n  };\n  WebGLHelper2.prototype.deleteBuffer = function(buf) {\n    var gl = this.getGL();\n    var bufferKey = getUid(buf);\n    var bufferCacheEntry = this.bufferCache_[bufferKey];\n    if (bufferCacheEntry && !gl.isContextLost()) {\n      gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n    }\n    delete this.bufferCache_[bufferKey];\n  };\n  WebGLHelper2.prototype.disposeInternal = function() {\n    this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);\n    this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);\n    releaseCanvas(this.canvasCacheKey_);\n    delete this.gl_;\n    delete this.canvas_;\n  };\n  WebGLHelper2.prototype.prepareDraw = function(frameState, opt_disableAlphaBlend) {\n    var gl = this.getGL();\n    var canvas = this.getCanvas();\n    var size = frameState.size;\n    var pixelRatio = frameState.pixelRatio;\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + \"px\";\n    canvas.style.height = size[1] + \"px\";\n    gl.useProgram(this.currentProgram_);\n    for (var i2 = this.postProcessPasses_.length - 1; i2 >= 0; i2--) {\n      this.postProcessPasses_[i2].init(frameState);\n    }\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n    gl.useProgram(this.currentProgram_);\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  };\n  WebGLHelper2.prototype.prepareDrawToRenderTarget = function(frameState, renderTarget, opt_disableAlphaBlend) {\n    var gl = this.getGL();\n    var size = renderTarget.getSize();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n    gl.useProgram(this.currentProgram_);\n    this.applyFrameState(frameState);\n    this.applyUniforms(frameState);\n  };\n  WebGLHelper2.prototype.drawElements = function(start2, end) {\n    var gl = this.getGL();\n    this.getExtension(\"OES_element_index_uint\");\n    var elementType = gl.UNSIGNED_INT;\n    var elementSize = 4;\n    var numItems = end - start2;\n    var offsetInBytes = start2 * elementSize;\n    gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n  };\n  WebGLHelper2.prototype.finalizeDraw = function(frameState, preCompose, postCompose) {\n    for (var i2 = 0, ii = this.postProcessPasses_.length; i2 < ii; i2++) {\n      if (i2 === ii - 1) {\n        this.postProcessPasses_[i2].apply(frameState, null, preCompose, postCompose);\n      } else {\n        this.postProcessPasses_[i2].apply(frameState, this.postProcessPasses_[i2 + 1]);\n      }\n    }\n  };\n  WebGLHelper2.prototype.getCanvas = function() {\n    return this.canvas_;\n  };\n  WebGLHelper2.prototype.getGL = function() {\n    return this.gl_;\n  };\n  WebGLHelper2.prototype.applyFrameState = function(frameState) {\n    var size = frameState.size;\n    var rotation = frameState.viewState.rotation;\n    var offsetScaleMatrix = reset(this.offsetScaleMatrix_);\n    scale$3(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n    var offsetRotateMatrix = reset(this.offsetRotateMatrix_);\n    if (rotation !== 0) {\n      rotate$2(offsetRotateMatrix, -rotation);\n    }\n    this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));\n    this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));\n    this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 1e-3);\n    this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n    this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);\n  };\n  WebGLHelper2.prototype.applyUniforms = function(frameState) {\n    var gl = this.getGL();\n    var value;\n    var textureSlot = 0;\n    this.uniforms_.forEach(function(uniform) {\n      value = typeof uniform.value === \"function\" ? uniform.value(frameState) : uniform.value;\n      if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {\n        if (!uniform.texture) {\n          uniform.prevValue = void 0;\n          uniform.texture = gl.createTexture();\n        }\n        gl.activeTexture(gl[\"TEXTURE\".concat(textureSlot)]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        var imageReady2 = !(value instanceof HTMLImageElement) || value.complete;\n        if (imageReady2 && uniform.prevValue !== value) {\n          uniform.prevValue = value;\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n        }\n        gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);\n      } else if (Array.isArray(value) && value.length === 6) {\n        this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));\n      } else if (Array.isArray(value) && value.length <= 4) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);\n            return;\n          case 3:\n            gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);\n            return;\n          case 4:\n            gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);\n            return;\n          default:\n            return;\n        }\n      } else if (typeof value === \"number\") {\n        gl.uniform1f(this.getUniformLocation(uniform.name), value);\n      }\n    }.bind(this));\n  };\n  WebGLHelper2.prototype.useProgram = function(program) {\n    if (program == this.currentProgram_) {\n      return false;\n    } else {\n      var gl = this.getGL();\n      gl.useProgram(program);\n      this.currentProgram_ = program;\n      this.uniformLocations_ = {};\n      this.attribLocations_ = {};\n      return true;\n    }\n  };\n  WebGLHelper2.prototype.compileShader = function(source, type) {\n    var gl = this.getGL();\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    return shader;\n  };\n  WebGLHelper2.prototype.getProgram = function(fragmentShaderSource, vertexShaderSource) {\n    var gl = this.getGL();\n    var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\n    var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n    var program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      var message = \"Fragment shader compliation failed: \".concat(gl.getShaderInfoLog(fragmentShader));\n      throw new Error(message);\n    }\n    gl.deleteShader(fragmentShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      var message = \"Vertex shader compilation failed: \".concat(gl.getShaderInfoLog(vertexShader));\n      throw new Error(message);\n    }\n    gl.deleteShader(vertexShader);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      var message = \"GL program linking failed: \".concat(gl.getShaderInfoLog(vertexShader));\n      throw new Error(message);\n    }\n    return program;\n  };\n  WebGLHelper2.prototype.getUniformLocation = function(name) {\n    if (this.uniformLocations_[name] === void 0) {\n      this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);\n    }\n    return this.uniformLocations_[name];\n  };\n  WebGLHelper2.prototype.getAttributeLocation = function(name) {\n    if (this.attribLocations_[name] === void 0) {\n      this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);\n    }\n    return this.attribLocations_[name];\n  };\n  WebGLHelper2.prototype.makeProjectionTransform = function(frameState, transform2) {\n    var size = frameState.size;\n    var rotation = frameState.viewState.rotation;\n    var resolution = frameState.viewState.resolution;\n    var center = frameState.viewState.center;\n    reset(transform2);\n    compose(transform2, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);\n    return transform2;\n  };\n  WebGLHelper2.prototype.setUniformFloatValue = function(uniform, value) {\n    this.getGL().uniform1f(this.getUniformLocation(uniform), value);\n  };\n  WebGLHelper2.prototype.setUniformFloatVec4 = function(uniform, value) {\n    this.getGL().uniform4fv(this.getUniformLocation(uniform), value);\n  };\n  WebGLHelper2.prototype.setUniformMatrixValue = function(uniform, value) {\n    this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\n  };\n  WebGLHelper2.prototype.enableAttributeArray_ = function(attribName, size, type, stride, offset2) {\n    var location2 = this.getAttributeLocation(attribName);\n    if (location2 < 0) {\n      return;\n    }\n    this.getGL().enableVertexAttribArray(location2);\n    this.getGL().vertexAttribPointer(location2, size, type, false, stride, offset2);\n  };\n  WebGLHelper2.prototype.enableAttributes = function(attributes) {\n    var stride = computeAttributesStride(attributes);\n    var offset2 = 0;\n    for (var i2 = 0; i2 < attributes.length; i2++) {\n      var attr = attributes[i2];\n      this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset2);\n      offset2 += attr.size * getByteSizeFromType(attr.type);\n    }\n  };\n  WebGLHelper2.prototype.handleWebGLContextLost = function() {\n    clear$1(this.bufferCache_);\n    this.currentProgram_ = null;\n  };\n  WebGLHelper2.prototype.handleWebGLContextRestored = function() {\n  };\n  WebGLHelper2.prototype.createTexture = function(size, opt_data, opt_texture) {\n    var gl = this.getGL();\n    var texture = opt_texture || gl.createTexture();\n    var level = 0;\n    var internalFormat = gl.RGBA;\n    var border = 0;\n    var format2 = gl.RGBA;\n    var type = gl.UNSIGNED_BYTE;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    if (opt_data) {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format2, type, opt_data);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format2, type, null);\n    }\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    return texture;\n  };\n  return WebGLHelper2;\n}(Disposable$1);\nfunction computeAttributesStride(attributes) {\n  var stride = 0;\n  for (var i2 = 0; i2 < attributes.length; i2++) {\n    var attr = attributes[i2];\n    stride += attr.size * getByteSizeFromType(attr.type);\n  }\n  return stride;\n}\nfunction getByteSizeFromType(type) {\n  switch (type) {\n    case AttributeType.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case AttributeType.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n    case AttributeType.FLOAT:\n    default:\n      return Float32Array.BYTES_PER_ELEMENT;\n  }\n}\nvar __extends$R = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar WebGLWorkerMessageType = {\n  GENERATE_BUFFERS: \"GENERATE_BUFFERS\"\n};\nvar WebGLLayerRenderer = function(_super) {\n  __extends$R(WebGLLayerRenderer2, _super);\n  function WebGLLayerRenderer2(layer, opt_options) {\n    var _this = _super.call(this, layer) || this;\n    var options = opt_options || {};\n    _this.inversePixelTransform_ = create$6();\n    _this.pixelContext_ = null;\n    _this.postProcesses_ = options.postProcesses;\n    _this.uniforms_ = options.uniforms;\n    _this.helper;\n    layer.addChangeListener(LayerProperty.MAP, _this.removeHelper.bind(_this));\n    _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);\n    _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);\n    return _this;\n  }\n  WebGLLayerRenderer2.prototype.dispatchPreComposeEvent = function(context, frameState) {\n    var layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      var event_1 = new RenderEvent$1(RenderEventType.PRECOMPOSE, void 0, frameState, context);\n      layer.dispatchEvent(event_1);\n    }\n  };\n  WebGLLayerRenderer2.prototype.dispatchPostComposeEvent = function(context, frameState) {\n    var layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      var event_2 = new RenderEvent$1(RenderEventType.POSTCOMPOSE, void 0, frameState, context);\n      layer.dispatchEvent(event_2);\n    }\n  };\n  WebGLLayerRenderer2.prototype.reset = function(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  };\n  WebGLLayerRenderer2.prototype.removeHelper = function() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  };\n  WebGLLayerRenderer2.prototype.prepareFrame = function(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      var incrementGroup = true;\n      var groupNumber = -1;\n      var className = void 0;\n      for (var i2 = 0, ii = frameState.layerStatesArray.length; i2 < ii; i2++) {\n        var layer = frameState.layerStatesArray[i2].layer;\n        var renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer2)) {\n          incrementGroup = true;\n          continue;\n        }\n        var layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n      var canvasCacheKey = \"map/\" + frameState.mapId + \"/group/\" + groupNumber;\n      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n        this.removeHelper();\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey\n        });\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n        this.afterHelperCreated();\n      }\n    }\n    return this.prepareFrameInternal(frameState);\n  };\n  WebGLLayerRenderer2.prototype.afterHelperCreated = function() {\n  };\n  WebGLLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {\n    return true;\n  };\n  WebGLLayerRenderer2.prototype.disposeInternal = function() {\n    this.removeHelper();\n    _super.prototype.disposeInternal.call(this);\n  };\n  WebGLLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, context, frameState) {\n    var layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      compose(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n      var event_3 = new RenderEvent$1(type, this.inversePixelTransform_, frameState, context);\n      layer.dispatchEvent(event_3);\n    }\n  };\n  WebGLLayerRenderer2.prototype.preRender = function(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  };\n  WebGLLayerRenderer2.prototype.postRender = function(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  };\n  WebGLLayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {\n    var renderPixel = apply$5([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());\n    var gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n    var layer = this.getLayer();\n    var layerExtent = layer.getExtent();\n    if (layerExtent) {\n      var renderCoordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());\n      if (!containsCoordinate(layerExtent, renderCoordinate)) {\n        return null;\n      }\n    }\n    var attributes = gl.getContextAttributes();\n    if (!attributes || !attributes.preserveDrawingBuffer) {\n      return new Uint8Array();\n    }\n    var x2 = Math.round(renderPixel[0]);\n    var y2 = Math.round(renderPixel[1]);\n    var pixelContext2 = this.pixelContext_;\n    if (!pixelContext2) {\n      var pixelCanvas = document.createElement(\"canvas\");\n      pixelCanvas.width = 1;\n      pixelCanvas.height = 1;\n      pixelContext2 = pixelCanvas.getContext(\"2d\");\n      this.pixelContext_ = pixelContext2;\n    }\n    pixelContext2.clearRect(0, 0, 1, 1);\n    var data2;\n    try {\n      pixelContext2.drawImage(gl.canvas, x2, y2, 1, 1, 0, 0, 1, 1);\n      data2 = pixelContext2.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      return data2;\n    }\n    if (data2[3] === 0) {\n      return null;\n    }\n    return data2;\n  };\n  return WebGLLayerRenderer2;\n}(LayerRenderer$1);\nfunction colorEncodeId(id, opt_array) {\n  var array = opt_array || [];\n  var radix = 256;\n  var divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = Math.floor(id / radix / radix) % radix / divide;\n  array[2] = Math.floor(id / radix) % radix / divide;\n  array[3] = id % radix / divide;\n  return array;\n}\nfunction colorDecodeId(color2) {\n  var id = 0;\n  var radix = 256;\n  var mult = radix - 1;\n  id += Math.round(color2[0] * radix * radix * radix * mult);\n  id += Math.round(color2[1] * radix * radix * mult);\n  id += Math.round(color2[2] * radix * mult);\n  id += Math.round(color2[3] * mult);\n  return id;\n}\nvar WebGLLayerRenderer$1 = WebGLLayerRenderer;\nfunction createOrUpdate(z2, x2, y2, opt_tileCoord) {\n  if (opt_tileCoord !== void 0) {\n    opt_tileCoord[0] = z2;\n    opt_tileCoord[1] = x2;\n    opt_tileCoord[2] = y2;\n    return opt_tileCoord;\n  } else {\n    return [z2, x2, y2];\n  }\n}\nfunction getKeyZXY(z2, x2, y2) {\n  return z2 + \"/\" + x2 + \"/\" + y2;\n}\nfunction getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\nfunction fromKey(key) {\n  return key.split(\"/\").map(Number);\n}\nfunction hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\nfunction withinExtentAndZ(tileCoord, tileGrid) {\n  var z2 = tileCoord[0];\n  var x2 = tileCoord[1];\n  var y2 = tileCoord[2];\n  if (tileGrid.getMinZoom() > z2 || z2 > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  var tileRange = tileGrid.getFullTileRange(z2);\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x2, y2);\n  }\n}\nvar __extends$Q = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Uniforms = {\n  TILE_TEXTURE_ARRAY: \"u_tileTextures\",\n  TILE_TRANSFORM: \"u_tileTransform\",\n  TRANSITION_ALPHA: \"u_transitionAlpha\",\n  DEPTH: \"u_depth\",\n  TEXTURE_PIXEL_WIDTH: \"u_texturePixelWidth\",\n  TEXTURE_PIXEL_HEIGHT: \"u_texturePixelHeight\",\n  TEXTURE_RESOLUTION: \"u_textureResolution\",\n  TEXTURE_ORIGIN_X: \"u_textureOriginX\",\n  TEXTURE_ORIGIN_Y: \"u_textureOriginY\",\n  RENDER_EXTENT: \"u_renderExtent\",\n  RESOLUTION: \"u_resolution\",\n  ZOOM: \"u_zoom\"\n};\nvar Attributes = {\n  TEXTURE_COORD: \"a_textureCoord\"\n};\nvar attributeDescriptions = [\n  {\n    name: Attributes.TEXTURE_COORD,\n    size: 2,\n    type: AttributeType.FLOAT\n  }\n];\nvar empty$1 = {};\nfunction depthForZ(z2) {\n  return 2 * (1 - 1 / (z2 + 1)) - 1;\n}\nfunction addTileTextureToLookup(tileTexturesByZ, tileTexture, z2) {\n  if (!(z2 in tileTexturesByZ)) {\n    tileTexturesByZ[z2] = [];\n  }\n  tileTexturesByZ[z2].push(tileTexture);\n}\nfunction getRenderExtent(frameState, extent2) {\n  var layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent2 = getIntersection(extent2, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  var source = layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    var gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent2 = getIntersection(extent2, gridExtent);\n    }\n  }\n  return extent2;\n}\nfunction getCacheKey(source, tileCoord) {\n  return \"\".concat(source.getKey(), \",\").concat(getKey(tileCoord));\n}\nvar WebGLTileLayerRenderer = function(_super) {\n  __extends$Q(WebGLTileLayerRenderer2, _super);\n  function WebGLTileLayerRenderer2(tileLayer, options) {\n    var _this = _super.call(this, tileLayer, {\n      uniforms: options.uniforms\n    }) || this;\n    _this.renderComplete = false;\n    _this.tileTransform_ = create$6();\n    _this.tempMat4_ = create$5();\n    _this.tempTileRange_ = new TileRange$1(0, 0, 0, 0);\n    _this.tempTileCoord_ = createOrUpdate(0, 0, 0);\n    _this.tempSize_ = [0, 0];\n    _this.program_;\n    _this.vertexShader_ = options.vertexShader;\n    _this.fragmentShader_ = options.fragmentShader;\n    _this.indices_ = new WebGLArrayBuffer$1(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    _this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n    var cacheSize = options.cacheSize !== void 0 ? options.cacheSize : 512;\n    _this.tileTextureCache_ = new LRUCache$1(cacheSize);\n    _this.paletteTextures_ = options.paletteTextures || [];\n    _this.frameState_ = null;\n    return _this;\n  }\n  WebGLTileLayerRenderer2.prototype.reset = function(options) {\n    _super.prototype.reset.call(this, {\n      uniforms: options.uniforms\n    });\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    }\n  };\n  WebGLTileLayerRenderer2.prototype.afterHelperCreated = function() {\n    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    this.helper.flushBufferData(this.indices_);\n  };\n  WebGLTileLayerRenderer2.prototype.isDrawableTile_ = function(tile2) {\n    var tileLayer = this.getLayer();\n    var tileState = tile2.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  WebGLTileLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {\n    var layer = this.getLayer();\n    var source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n    if (isEmpty$1(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === SourceState.READY;\n  };\n  WebGLTileLayerRenderer2.prototype.enqueueTiles = function(frameState, extent2, initialZ, tileTexturesByZ) {\n    var viewState = frameState.viewState;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getRenderSource();\n    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    var tilePixelRatio = tileSource.getTilePixelRatio(frameState.pixelRatio);\n    var gutter = tileSource.getGutterForProjection(viewState.projection);\n    var tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileTextureCache = this.tileTextureCache_;\n    var minZ = Math.max(initialZ - tileLayer.getPreload(), tileGrid.getMinZoom(), tileLayer.getMinZoom());\n    for (var z2 = initialZ; z2 >= minZ; --z2) {\n      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent2, z2, this.tempTileRange_);\n      var tileResolution = tileGrid.getResolution(z2);\n      for (var x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {\n        for (var y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {\n          var tileCoord = createOrUpdate(z2, x2, y2, this.tempTileCoord_);\n          var cacheKey = getCacheKey(tileSource, tileCoord);\n          var tileTexture = void 0;\n          var tile2 = void 0;\n          if (tileTextureCache.containsKey(cacheKey)) {\n            tileTexture = tileTextureCache.get(cacheKey);\n            tile2 = tileTexture.tile;\n          }\n          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {\n            tile2 = tileSource.getTile(z2, x2, y2, frameState.pixelRatio, viewState.projection);\n            if (!tileTexture) {\n              tileTexture = new TileTexture$1({\n                tile: tile2,\n                grid: tileGrid,\n                helper: this.helper,\n                tilePixelRatio,\n                gutter\n              });\n              tileTextureCache.set(cacheKey, tileTexture);\n            } else {\n              if (this.isDrawableTile_(tile2)) {\n                tileTexture.setTile(tile2);\n              } else {\n                var interimTile = tile2.getInterimTile();\n                tileTexture.setTile(interimTile);\n              }\n            }\n          }\n          addTileTextureToLookup(tileTexturesByZ, tileTexture, z2);\n          var tileQueueKey = tile2.getKey();\n          wantedTiles[tileQueueKey] = true;\n          if (tile2.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile2,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution\n              ]);\n            }\n          }\n        }\n      }\n    }\n  };\n  WebGLTileLayerRenderer2.prototype.renderFrame = function(frameState) {\n    this.frameState_ = frameState;\n    this.renderComplete = true;\n    var gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    var viewState = frameState.viewState;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getRenderSource();\n    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    var extent2 = getRenderExtent(frameState, frameState.extent);\n    var z2 = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n    var tileTexturesByZ = {};\n    if (frameState.nextExtent) {\n      var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      var nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);\n    }\n    this.enqueueTiles(frameState, extent2, z2, tileTexturesByZ);\n    var alphaLookup = {};\n    var uid2 = getUid(this);\n    var time2 = frameState.time;\n    var blend = false;\n    var tileTextures = tileTexturesByZ[z2];\n    for (var i2 = 0, ii = tileTextures.length; i2 < ii; ++i2) {\n      var tileTexture = tileTextures[i2];\n      var tile2 = tileTexture.tile;\n      var tileCoord = tile2.tileCoord;\n      if (tileTexture.loaded) {\n        var alpha = tile2.getAlpha(uid2, time2);\n        if (alpha === 1) {\n          tile2.endTransition(uid2);\n          continue;\n        }\n        blend = true;\n        var tileCoordKey = getKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n      var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z2 + 1, tileTexturesByZ);\n      if (coveredByChildren) {\n        continue;\n      }\n      var minZoom = tileGrid.getMinZoom();\n      for (var parentZ = z2 - 1; parentZ >= minZoom; --parentZ) {\n        var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n    this.helper.useProgram(this.program_);\n    this.helper.prepareDraw(frameState, !blend);\n    var zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);\n    var centerX = viewState.center[0];\n    var centerY = viewState.center[1];\n    for (var j2 = 0, jj = zs.length; j2 < jj; ++j2) {\n      var tileZ = zs[j2];\n      var tileResolution = tileGrid.getResolution(tileZ);\n      var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n      var tileOrigin = tileGrid.getOrigin(tileZ);\n      var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n      var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n      var tileScale = viewState.resolution / tileResolution;\n      var depth = depthForZ(tileZ);\n      var tileTextures_1 = tileTexturesByZ[tileZ];\n      for (var i2 = 0, ii = tileTextures_1.length; i2 < ii; ++i2) {\n        var tileTexture = tileTextures_1[i2];\n        if (!tileTexture.loaded) {\n          continue;\n        }\n        var tile2 = tileTexture.tile;\n        var tileCoord = tile2.tileCoord;\n        var tileCoordKey = getKey(tileCoord);\n        var tileCenterI = tileCoord[1];\n        var tileCenterJ = tileCoord[2];\n        compose(this.tileTransform_, 0, 0, 2 / (frameState.size[0] * tileScale / tileSize[0]), -2 / (frameState.size[1] * tileScale / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));\n        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, fromTransform(this.tempMat4_, this.tileTransform_));\n        this.helper.bindBuffer(tileTexture.coords);\n        this.helper.bindBuffer(this.indices_);\n        this.helper.enableAttributes(attributeDescriptions);\n        var textureSlot = 0;\n        while (textureSlot < tileTexture.textures.length) {\n          var textureProperty = \"TEXTURE\" + textureSlot;\n          var uniformName = \"\".concat(Uniforms.TILE_TEXTURE_ARRAY, \"[\").concat(textureSlot, \"]\");\n          gl.activeTexture(gl[textureProperty]);\n          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);\n          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);\n          ++textureSlot;\n        }\n        for (var paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {\n          var paletteTexture = this.paletteTextures_[paletteIndex];\n          gl.activeTexture(gl[\"TEXTURE\" + textureSlot]);\n          var texture = paletteTexture.getTexture(gl);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);\n          ++textureSlot;\n        }\n        var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n        if (alpha < 1) {\n          frameState.animate = true;\n        }\n        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution);\n        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, extent2);\n        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n        this.helper.drawElements(0, this.indices_.getSize());\n      }\n    }\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    var canvas = this.helper.getCanvas();\n    var tileTextureCache = this.tileTextureCache_;\n    while (tileTextureCache.canExpireCache()) {\n      var tileTexture = tileTextureCache.pop();\n      tileTexture.dispose();\n    }\n    var postRenderFunction = function(map, frameState2) {\n      tileSource.expireCache(frameState2.viewState.projection, empty$1);\n    };\n    frameState.postRenderFunctions.push(postRenderFunction);\n    this.postRender(gl, frameState);\n    return canvas;\n  };\n  WebGLTileLayerRenderer2.prototype.getData = function(pixel) {\n    var gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n    var layer = this.getLayer();\n    var coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());\n    var viewState = frameState.viewState;\n    var layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {\n        return null;\n      }\n    }\n    var source = layer.getRenderSource();\n    var tileGrid = source.getTileGridForProjection(viewState.projection);\n    if (!source.getWrapX()) {\n      var gridExtent = tileGrid.getExtent();\n      if (gridExtent) {\n        if (!containsCoordinate(gridExtent, coordinate)) {\n          return null;\n        }\n      }\n    }\n    var tileTextureCache = this.tileTextureCache_;\n    for (var z2 = tileGrid.getZForResolution(viewState.resolution); z2 >= tileGrid.getMinZoom(); --z2) {\n      var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);\n      var cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      var tileTexture = tileTextureCache.get(cacheKey);\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      var tileOrigin = tileGrid.getOrigin(z2);\n      var tileSize = toSize(tileGrid.getTileSize(z2));\n      var tileResolution = tileGrid.getResolution(z2);\n      var col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];\n      var row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  };\n  WebGLTileLayerRenderer2.prototype.findAltTiles_ = function(tileGrid, tileCoord, altZ, tileTexturesByZ) {\n    var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n    if (!tileRange) {\n      return false;\n    }\n    var covered = true;\n    var tileTextureCache = this.tileTextureCache_;\n    var source = this.getLayer().getRenderSource();\n    for (var x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {\n      for (var y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {\n        var cacheKey = getCacheKey(source, [altZ, x2, y2]);\n        var loaded = false;\n        if (tileTextureCache.containsKey(cacheKey)) {\n          var tileTexture = tileTextureCache.get(cacheKey);\n          if (tileTexture.loaded) {\n            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  };\n  WebGLTileLayerRenderer2.prototype.removeHelper = function() {\n    if (this.helper) {\n      var tileTextureCache = this.tileTextureCache_;\n      tileTextureCache.forEach(function(tileTexture) {\n        return tileTexture.dispose();\n      });\n      tileTextureCache.clear();\n    }\n    _super.prototype.removeHelper.call(this);\n  };\n  WebGLTileLayerRenderer2.prototype.disposeInternal = function() {\n    var helper = this.helper;\n    if (helper) {\n      var gl = helper.getGL();\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n      helper.deleteBuffer(this.indices_);\n    }\n    _super.prototype.disposeInternal.call(this);\n    delete this.indices_;\n    delete this.tileTextureCache_;\n    delete this.frameState_;\n  };\n  return WebGLTileLayerRenderer2;\n}(WebGLLayerRenderer$1);\nvar WebGLTileLayerRenderer$1 = WebGLTileLayerRenderer;\nvar PaletteTexture = function() {\n  function PaletteTexture2(name, data2) {\n    this.name = name;\n    this.data = data2;\n    this.texture_ = null;\n  }\n  PaletteTexture2.prototype.getTexture = function(gl) {\n    if (!this.texture_) {\n      var texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);\n      this.texture_ = texture;\n    }\n    return this.texture_;\n  };\n  return PaletteTexture2;\n}();\nvar PaletteTexture$1 = PaletteTexture;\nvar ValueTypes = {\n  NUMBER: 1,\n  STRING: 2,\n  COLOR: 4,\n  BOOLEAN: 8,\n  NUMBER_ARRAY: 16,\n  ANY: 31,\n  NONE: 0\n};\nvar Operators = {};\nfunction getValueType(value) {\n  if (typeof value === \"number\") {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === \"boolean\") {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === \"string\") {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(\"Unhandled value type: \".concat(JSON.stringify(value)));\n  }\n  var valueArr = value;\n  var onlyNumbers = valueArr.every(function(v2) {\n    return typeof v2 === \"number\";\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== \"string\") {\n    throw new Error(\"Expected an expression operator but received: \".concat(JSON.stringify(valueArr)));\n  }\n  var operator = Operators[valueArr[0]];\n  if (operator === void 0) {\n    throw new Error(\"Unrecognized expression operator: \".concat(JSON.stringify(valueArr)));\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\nfunction isTypeUnique(valueType) {\n  return log2(valueType) % 1 === 0;\n}\nfunction numberToGlsl(v2) {\n  var s2 = v2.toString();\n  return s2.indexOf(\".\") === -1 ? s2 + \".0\" : s2;\n}\nfunction arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\"`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.\");\n  }\n  return \"vec\".concat(array.length, \"(\").concat(array.map(numberToGlsl).join(\", \"), \")\");\n}\nfunction colorToGlsl(color2) {\n  var array = asArray(color2).slice();\n  if (array.length < 4) {\n    array.push(1);\n  }\n  return arrayToGlsl(array.map(function(c2, i2) {\n    return i2 < 3 ? c2 / 255 : c2;\n  }));\n}\nfunction getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === void 0) {\n    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n  }\n  return context.stringLiteralsMap[string];\n}\nfunction stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\nfunction expressionToGlsl(context, value, typeHint) {\n  if (Array.isArray(value) && typeof value[0] === \"string\") {\n    var operator = Operators[value[0]];\n    if (operator === void 0) {\n      throw new Error(\"Unrecognized expression operator: \".concat(JSON.stringify(value)));\n    }\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  }\n  var valueType = getValueType(value);\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(value);\n  }\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === void 0 || typeHint == ValueTypes.STRING)) {\n    return stringToGlsl(context, value.toString());\n  }\n  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === void 0 || typeHint == ValueTypes.COLOR)) {\n    return colorToGlsl(value);\n  }\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(value);\n  }\n  throw new Error(\"Unexpected expression \".concat(value, \" (expected type \").concat(typeHint, \")\"));\n}\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(\"A numeric value was expected, got \".concat(JSON.stringify(value), \" instead\"));\n  }\n}\nfunction assertNumbers(values2) {\n  for (var i2 = 0; i2 < values2.length; i2++) {\n    assertNumber(values2[i2]);\n  }\n}\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(\"A string value was expected, got \".concat(JSON.stringify(value), \" instead\"));\n  }\n}\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(\"A boolean value was expected, got \".concat(JSON.stringify(value), \" instead\"));\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\"Exactly \".concat(count, \" arguments were expected, got \").concat(args.length, \" instead\"));\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\"At least \".concat(count, \" arguments were expected, got \").concat(args.length, \" instead\"));\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\"At most \".concat(count, \" arguments were expected, got \").concat(args.length, \" instead\"));\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\"An even amount of arguments was expected, got \".concat(args, \" instead\"));\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\"An odd amount of arguments was expected, got \".concat(args, \" instead\"));\n  }\n}\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(\"Could not infer only one type from the following expression: \".concat(JSON.stringify(args)));\n  }\n}\nOperators[\"get\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n    if (context.attributes.indexOf(value) === -1) {\n      context.attributes.push(value);\n    }\n    var prefix = context.inFragmentShader ? \"v_\" : \"a_\";\n    return prefix + value;\n  }\n};\nfunction uniformNameForVariable(variableName) {\n  return \"u_var_\" + variableName;\n}\nOperators[\"var\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n    if (context.variables.indexOf(value) === -1) {\n      context.variables.push(value);\n    }\n    return uniformNameForVariable(value);\n  }\n};\nvar PALETTE_TEXTURE_ARRAY = \"u_paletteTextures\";\nOperators[\"palette\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    var index2 = expressionToGlsl(context, args[0]);\n    var colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error(\"The second argument of palette must be an array\");\n    }\n    var numColors = colors.length;\n    var palette = new Uint8Array(numColors * 4);\n    for (var i2 = 0; i2 < numColors; i2++) {\n      var candidate = colors[i2];\n      var color2 = void 0;\n      if (typeof candidate === \"string\") {\n        color2 = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error(\"The second argument of palette must be an array of strings or colors\");\n        }\n        var length_1 = candidate.length;\n        if (length_1 === 4) {\n          color2 = candidate;\n        } else {\n          if (length_1 !== 3) {\n            throw new Error(\"Expected palette color to have 3 or 4 values, got \".concat(length_1));\n          }\n          color2 = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      var offset2 = i2 * 4;\n      palette[offset2] = color2[0];\n      palette[offset2 + 1] = color2[1];\n      palette[offset2 + 2] = color2[2];\n      palette[offset2 + 3] = color2[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    var paletteName = \"\".concat(PALETTE_TEXTURE_ARRAY, \"[\").concat(context.paletteTextures.length, \"]\");\n    var paletteTexture = new PaletteTexture$1(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return \"texture2D(\".concat(paletteName, \", vec2((\").concat(index2, \" + 0.5) / \").concat(numColors, \".0, 0.5))\");\n  }\n};\nvar GET_BAND_VALUE_FUNC = \"getBandValue\";\nOperators[\"band\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    var band = args[0];\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      var ifBlocks = \"\";\n      var bandCount = context.bandCount || 1;\n      for (var i2 = 0; i2 < bandCount; i2++) {\n        var colorIndex = Math.floor(i2 / 4);\n        var bandIndex = i2 % 4;\n        if (bandIndex === bandCount - 1 && bandIndex === 1) {\n          bandIndex = 3;\n        }\n        var textureName = \"\".concat(Uniforms.TILE_TEXTURE_ARRAY, \"[\").concat(colorIndex, \"]\");\n        ifBlocks += \"\\n          if (band == \".concat(i2 + 1, \".0) {\\n            return texture2D(\").concat(textureName, \", v_textureCoord + vec2(dx, dy))[\").concat(bandIndex, \"];\\n          }\\n        \");\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = \"\\n        float getBandValue(float band, float xOffset, float yOffset) {\\n          float dx = xOffset / \".concat(Uniforms.TEXTURE_PIXEL_WIDTH, \";\\n          float dy = yOffset / \").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, \";\\n          \").concat(ifBlocks, \"\\n        }\\n      \");\n    }\n    var bandExpression = expressionToGlsl(context, band);\n    var xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    var yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return \"\".concat(GET_BAND_VALUE_FUNC, \"(\").concat(bandExpression, \", \").concat(xOffsetExpression, \", \").concat(yOffsetExpression, \")\");\n  }\n};\nOperators[\"time\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 0);\n    return \"u_time\";\n  }\n};\nOperators[\"zoom\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 0);\n    return \"u_zoom\";\n  }\n};\nOperators[\"resolution\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 0);\n    return \"u_resolution\";\n  }\n};\nOperators[\"*\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" * \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\"/\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" / \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\"+\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" + \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\"-\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" - \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\"clamp\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min2 = expressionToGlsl(context, args[1]);\n    var max2 = expressionToGlsl(context, args[2]);\n    return \"clamp(\".concat(expressionToGlsl(context, args[0]), \", \").concat(min2, \", \").concat(max2, \")\");\n  }\n};\nOperators[\"%\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"mod(\".concat(expressionToGlsl(context, args[0]), \", \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\"^\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"pow(\".concat(expressionToGlsl(context, args[0]), \", \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\"abs\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"abs(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators[\"floor\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"floor(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators[\"round\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"floor(\".concat(expressionToGlsl(context, args[0]), \" + 0.5)\");\n  }\n};\nOperators[\"ceil\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"ceil(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators[\"sin\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"sin(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators[\"cos\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"cos(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators[\"atan\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function(context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2 ? \"atan(\".concat(expressionToGlsl(context, args[0]), \", \").concat(expressionToGlsl(context, args[1]), \")\") : \"atan(\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nOperators[\">\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" > \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\">=\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" >= \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\"<\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" < \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nOperators[\"<=\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\".concat(expressionToGlsl(context, args[0]), \" <= \").concat(expressionToGlsl(context, args[1]), \")\");\n  }\n};\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function(args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function(context, args) {\n      assertArgsCount(args, 2);\n      var type = ValueTypes.ANY;\n      for (var i2 = 0; i2 < args.length; i2++) {\n        type &= getValueType(args[i2]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(\"All arguments should be of compatible type, got \".concat(JSON.stringify(args), \" instead\"));\n      }\n      type &= ~ValueTypes.COLOR;\n      return \"(\".concat(expressionToGlsl(context, args[0], type), \" \").concat(operator, \" \").concat(expressionToGlsl(context, args[1], type), \")\");\n    }\n  };\n}\nOperators[\"==\"] = getEqualOperator(\"==\");\nOperators[\"!=\"] = getEqualOperator(\"!=\");\nOperators[\"!\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return \"(!\".concat(expressionToGlsl(context, args[0]), \")\");\n  }\n};\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function(args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function(context, args) {\n      assertArgsMinCount(args, 2);\n      for (var i2 = 0; i2 < args.length; i2++) {\n        assertBoolean(args[i2]);\n      }\n      var result = \"\";\n      result = args.map(function(arg) {\n        return expressionToGlsl(context, arg);\n      }).join(\" \".concat(operator, \" \"));\n      result = \"(\".concat(result, \")\");\n      return result;\n    }\n  };\n}\nOperators[\"all\"] = getDecisionOperator(\"&&\");\nOperators[\"any\"] = getDecisionOperator(\"||\");\nOperators[\"between\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function(context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min2 = expressionToGlsl(context, args[1]);\n    var max2 = expressionToGlsl(context, args[2]);\n    var value = expressionToGlsl(context, args[0]);\n    return \"(\".concat(value, \" >= \").concat(min2, \" && \").concat(value, \" <= \").concat(max2, \")\");\n  }\n};\nOperators[\"array\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function(context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var parsedArgs = args.map(function(val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return \"vec\".concat(args.length, \"(\").concat(parsedArgs.join(\", \"), \")\");\n  }\n};\nOperators[\"color\"] = {\n  getReturnType: function(args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function(context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var array = args;\n    if (args.length === 3) {\n      array.push(1);\n    }\n    var parsedArgs = args.map(function(val, i2) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i2 < 3 ? \" / 255.0\" : \"\");\n    });\n    return \"vec\".concat(args.length, \"(\").concat(parsedArgs.join(\", \"), \")\");\n  }\n};\nOperators[\"interpolate\"] = {\n  getReturnType: function(args) {\n    var type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (var i2 = 3; i2 < args.length; i2 += 2) {\n      type = type & getValueType(args[i2]);\n    }\n    return type;\n  },\n  toGlsl: function(context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n    var type = args[0];\n    var interpolation;\n    switch (type[0]) {\n      case \"linear\":\n        interpolation = 1;\n        break;\n      case \"exponential\":\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error('Invalid interpolation type for \"interpolate\" operator, received: '.concat(JSON.stringify(type)));\n    }\n    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators[\"interpolate\"].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[1]);\n    var exponent = numberToGlsl(interpolation);\n    var result = \"\";\n    for (var i2 = 2; i2 < args.length - 2; i2 += 2) {\n      var stop1 = expressionToGlsl(context, args[i2]);\n      var output1 = result || expressionToGlsl(context, args[i2 + 1], outputType);\n      var stop2 = expressionToGlsl(context, args[i2 + 2]);\n      var output2 = expressionToGlsl(context, args[i2 + 3], outputType);\n      result = \"mix(\".concat(output1, \", \").concat(output2, \", pow(clamp((\").concat(input, \" - \").concat(stop1, \") / (\").concat(stop2, \" - \").concat(stop1, \"), 0.0, 1.0), \").concat(exponent, \"))\");\n    }\n    return result;\n  }\n};\nOperators[\"match\"] = {\n  getReturnType: function(args) {\n    var type = ValueTypes.ANY;\n    for (var i2 = 2; i2 < args.length; i2 += 2) {\n      type = type & getValueType(args[i2]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function(context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators[\"match\"].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[0]);\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n    for (var i2 = args.length - 3; i2 >= 1; i2 -= 2) {\n      var match2 = expressionToGlsl(context, args[i2]);\n      var output = expressionToGlsl(context, args[i2 + 1], outputType);\n      result = \"(\".concat(input, \" == \").concat(match2, \" ? \").concat(output, \" : \").concat(result || fallback, \")\");\n    }\n    return result;\n  }\n};\nOperators[\"case\"] = {\n  getReturnType: function(args) {\n    var type = ValueTypes.ANY;\n    for (var i2 = 1; i2 < args.length; i2 += 2) {\n      type = type & getValueType(args[i2]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function(context, args, opt_typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    var typeHint = opt_typeHint !== void 0 ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators[\"case\"].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    for (var i2 = 0; i2 < args.length - 1; i2 += 2) {\n      assertBoolean(args[i2]);\n    }\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n    for (var i2 = args.length - 3; i2 >= 0; i2 -= 2) {\n      var condition = expressionToGlsl(context, args[i2]);\n      var output = expressionToGlsl(context, args[i2 + 1], outputType);\n      result = \"(\".concat(condition, \" ? \").concat(output, \" : \").concat(result || fallback, \")\");\n    }\n    return result;\n  }\n};\nvar __extends$P = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nfunction parseStyle(style2, bandCount) {\n  var vertexShader = \"\\n    attribute vec2 \".concat(Attributes.TEXTURE_COORD, \";\\n    uniform mat4 \").concat(Uniforms.TILE_TRANSFORM, \";\\n    uniform float \").concat(Uniforms.TEXTURE_PIXEL_WIDTH, \";\\n    uniform float \").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, \";\\n    uniform float \").concat(Uniforms.TEXTURE_RESOLUTION, \";\\n    uniform float \").concat(Uniforms.TEXTURE_ORIGIN_X, \";\\n    uniform float \").concat(Uniforms.TEXTURE_ORIGIN_Y, \";\\n    uniform float \").concat(Uniforms.DEPTH, \";\\n\\n    varying vec2 v_textureCoord;\\n    varying vec2 v_mapCoord;\\n\\n    void main() {\\n      v_textureCoord = \").concat(Attributes.TEXTURE_COORD, \";\\n      v_mapCoord = vec2(\\n        \").concat(Uniforms.TEXTURE_ORIGIN_X, \" + \").concat(Uniforms.TEXTURE_RESOLUTION, \" * \").concat(Uniforms.TEXTURE_PIXEL_WIDTH, \" * v_textureCoord[0],\\n        \").concat(Uniforms.TEXTURE_ORIGIN_Y, \" - \").concat(Uniforms.TEXTURE_RESOLUTION, \" * \").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, \" * v_textureCoord[1]\\n      );\\n      gl_Position = \").concat(Uniforms.TILE_TRANSFORM, \" * vec4(\").concat(Attributes.TEXTURE_COORD, \", \").concat(Uniforms.DEPTH, \", 1.0);\\n    }\\n  \");\n  var context = {\n    inFragmentShader: true,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {},\n    bandCount\n  };\n  var pipeline = [];\n  if (style2.color !== void 0) {\n    var color2 = expressionToGlsl(context, style2.color, ValueTypes.COLOR);\n    pipeline.push(\"color = \".concat(color2, \";\"));\n  }\n  if (style2.contrast !== void 0) {\n    var contrast = expressionToGlsl(context, style2.contrast, ValueTypes.NUMBER);\n    pipeline.push(\"color.rgb = clamp((\".concat(contrast, \" + 1.0) * color.rgb - (\").concat(contrast, \" / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\"));\n  }\n  if (style2.exposure !== void 0) {\n    var exposure = expressionToGlsl(context, style2.exposure, ValueTypes.NUMBER);\n    pipeline.push(\"color.rgb = clamp((\".concat(exposure, \" + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\"));\n  }\n  if (style2.saturation !== void 0) {\n    var saturation = expressionToGlsl(context, style2.saturation, ValueTypes.NUMBER);\n    pipeline.push(\"\\n      float saturation = \".concat(saturation, \" + 1.0;\\n      float sr = (1.0 - saturation) * 0.2126;\\n      float sg = (1.0 - saturation) * 0.7152;\\n      float sb = (1.0 - saturation) * 0.0722;\\n      mat3 saturationMatrix = mat3(\\n        sr + saturation, sr, sr,\\n        sg, sg + saturation, sg,\\n        sb, sb, sb + saturation\\n      );\\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\\n    \"));\n  }\n  if (style2.gamma !== void 0) {\n    var gamma = expressionToGlsl(context, style2.gamma, ValueTypes.NUMBER);\n    pipeline.push(\"color.rgb = pow(color.rgb, vec3(1.0 / \".concat(gamma, \"));\"));\n  }\n  if (style2.brightness !== void 0) {\n    var brightness = expressionToGlsl(context, style2.brightness, ValueTypes.NUMBER);\n    pipeline.push(\"color.rgb = clamp(color.rgb + \".concat(brightness, \", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\"));\n  }\n  var uniforms = {};\n  var numVariables = context.variables.length;\n  if (numVariables > 1 && !style2.variables) {\n    throw new Error(\"Missing variables in style (expected \".concat(context.variables, \")\"));\n  }\n  var _loop_1 = function(i3) {\n    var variableName = context.variables[i3];\n    if (!(variableName in style2.variables)) {\n      throw new Error(\"Missing '\".concat(variableName, \"' in style variables\"));\n    }\n    var uniformName = uniformNameForVariable(variableName);\n    uniforms[uniformName] = function() {\n      var value = style2.variables[variableName];\n      if (typeof value === \"string\") {\n        value = getStringNumberEquivalent(context, value);\n      }\n      return value !== void 0 ? value : -9999999;\n    };\n  };\n  for (var i2 = 0; i2 < numVariables; ++i2) {\n    _loop_1(i2);\n  }\n  var uniformDeclarations = Object.keys(uniforms).map(function(name) {\n    return \"uniform float \".concat(name, \";\");\n  });\n  var textureCount = Math.ceil(bandCount / 4);\n  uniformDeclarations.push(\"uniform sampler2D \".concat(Uniforms.TILE_TEXTURE_ARRAY, \"[\").concat(textureCount, \"];\"));\n  if (context.paletteTextures) {\n    uniformDeclarations.push(\"uniform sampler2D \".concat(PALETTE_TEXTURE_ARRAY, \"[\").concat(context.paletteTextures.length, \"];\"));\n  }\n  var functionDefintions = Object.keys(context.functions).map(function(name) {\n    return context.functions[name];\n  });\n  var fragmentShader = \"\\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\\n    precision highp float;\\n    #else\\n    precision mediump float;\\n    #endif\\n\\n    varying vec2 v_textureCoord;\\n    varying vec2 v_mapCoord;\\n    uniform vec4 \".concat(Uniforms.RENDER_EXTENT, \";\\n    uniform float \").concat(Uniforms.TRANSITION_ALPHA, \";\\n    uniform float \").concat(Uniforms.TEXTURE_PIXEL_WIDTH, \";\\n    uniform float \").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, \";\\n    uniform float \").concat(Uniforms.RESOLUTION, \";\\n    uniform float \").concat(Uniforms.ZOOM, \";\\n\\n    \").concat(uniformDeclarations.join(\"\\n\"), \"\\n\\n    \").concat(functionDefintions.join(\"\\n\"), \"\\n\\n    void main() {\\n      if (\\n        v_mapCoord[0] < \").concat(Uniforms.RENDER_EXTENT, \"[0] ||\\n        v_mapCoord[1] < \").concat(Uniforms.RENDER_EXTENT, \"[1] ||\\n        v_mapCoord[0] > \").concat(Uniforms.RENDER_EXTENT, \"[2] ||\\n        v_mapCoord[1] > \").concat(Uniforms.RENDER_EXTENT, \"[3]\\n      ) {\\n        discard;\\n      }\\n\\n      vec4 color = texture2D(\").concat(Uniforms.TILE_TEXTURE_ARRAY, \"[0],  v_textureCoord);\\n\\n      \").concat(pipeline.join(\"\\n\"), \"\\n\\n      if (color.a == 0.0) {\\n        discard;\\n      }\\n\\n      gl_FragColor = color;\\n      gl_FragColor.rgb *= gl_FragColor.a;\\n      gl_FragColor *= \").concat(Uniforms.TRANSITION_ALPHA, \";\\n    }\");\n  return {\n    vertexShader,\n    fragmentShader,\n    uniforms,\n    paletteTextures: context.paletteTextures\n  };\n}\nvar WebGLTileLayer$1 = function(_super) {\n  __extends$P(WebGLTileLayer2, _super);\n  function WebGLTileLayer2(opt_options) {\n    var _this = this;\n    var options = opt_options ? assign({}, opt_options) : {};\n    var style2 = options.style || {};\n    delete options.style;\n    var cacheSize = options.cacheSize;\n    delete options.cacheSize;\n    _this = _super.call(this, options) || this;\n    _this.sources_ = options.sources;\n    _this.renderedSource_ = null;\n    _this.renderedResolution_ = NaN;\n    _this.style_ = style2;\n    _this.cacheSize_ = cacheSize;\n    _this.styleVariables_ = _this.style_.variables || {};\n    _this.addChangeListener(LayerProperty.SOURCE, _this.handleSourceUpdate_);\n    return _this;\n  }\n  WebGLTileLayer2.prototype.getSources = function(extent2, resolution) {\n    var source = this.getSource();\n    return this.sources_ ? typeof this.sources_ === \"function\" ? this.sources_(extent2, resolution) : this.sources_ : source ? [source] : [];\n  };\n  WebGLTileLayer2.prototype.getRenderSource = function() {\n    return this.renderedSource_ || this.getSource();\n  };\n  WebGLTileLayer2.prototype.getSourceState = function() {\n    var source = this.getRenderSource();\n    return source ? source.getState() : SourceState.UNDEFINED;\n  };\n  WebGLTileLayer2.prototype.handleSourceUpdate_ = function() {\n    if (this.getSource()) {\n      this.setStyle(this.style_);\n    }\n  };\n  WebGLTileLayer2.prototype.getSourceBandCount_ = function() {\n    var source = this.getSource();\n    return source && \"bandCount\" in source ? source.bandCount : 4;\n  };\n  WebGLTileLayer2.prototype.createRenderer = function() {\n    var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n    return new WebGLTileLayerRenderer$1(this, {\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      cacheSize: this.cacheSize_,\n      paletteTextures: parsedStyle.paletteTextures\n    });\n  };\n  WebGLTileLayer2.prototype.renderSources = function(frameState, sources) {\n    var layerRenderer = this.getRenderer();\n    var canvas;\n    for (var i2 = 0, ii = sources.length; i2 < ii; ++i2) {\n      this.renderedSource_ = sources[i2];\n      if (layerRenderer.prepareFrame(frameState)) {\n        canvas = layerRenderer.renderFrame(frameState);\n      }\n    }\n    return canvas;\n  };\n  WebGLTileLayer2.prototype.render = function(frameState, target) {\n    var _this = this;\n    this.rendered = true;\n    var viewState = frameState.viewState;\n    var sources = this.getSources(frameState.extent, viewState.resolution);\n    var ready = true;\n    var _loop_2 = function(i3, ii2) {\n      var source = sources[i3];\n      var sourceState = source.getState();\n      if (sourceState == SourceState.LOADING) {\n        var onChange_1 = function() {\n          if (source.getState() == SourceState.READY) {\n            source.removeEventListener(\"change\", onChange_1);\n            _this.changed();\n          }\n        };\n        source.addEventListener(\"change\", onChange_1);\n      }\n      ready = ready && sourceState == SourceState.READY;\n    };\n    for (var i2 = 0, ii = sources.length; i2 < ii; ++i2) {\n      _loop_2(i2);\n    }\n    var canvas = this.renderSources(frameState, sources);\n    if (this.getRenderer().renderComplete && ready) {\n      this.renderedResolution_ = viewState.resolution;\n      return canvas;\n    }\n    if (this.renderedResolution_ > 0.5 * viewState.resolution) {\n      var altSources = this.getSources(frameState.extent, this.renderedResolution_).filter(function(source) {\n        return !sources.includes(source);\n      });\n      if (altSources.length > 0) {\n        return this.renderSources(frameState, altSources);\n      }\n    }\n    return canvas;\n  };\n  WebGLTileLayer2.prototype.setStyle = function(style2) {\n    this.styleVariables_ = style2.variables || {};\n    this.style_ = style2;\n    var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n    var renderer = this.getRenderer();\n    renderer.reset({\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      paletteTextures: parsedStyle.paletteTextures\n    });\n    this.changed();\n  };\n  WebGLTileLayer2.prototype.updateStyleVariables = function(variables) {\n    assign(this.styleVariables_, variables);\n    this.changed();\n  };\n  return WebGLTileLayer2;\n}(BaseTileLayer$1);\nWebGLTileLayer$1.prototype.dispose;\nvar TileLayer = WebGLTileLayer$1;\nconst _sfc_main$Z = {\n  extends: BaseLayer,\n  name: \"ol-webgl-tile-layer\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const overViewMap = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"overviewMap\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const tileLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new TileLayer(properties));\n    const applyTileLayer = () => {\n      if (overViewMap != null) {\n        overViewMap.value.getOverviewMap().addLayer(tileLayer.value);\n        overViewMap.value.changed();\n      } else {\n        map.addLayer(tileLayer.value);\n      }\n    };\n    const removeTileLayer = () => {\n      if (overViewMap != null) {\n        overViewMap.value.getOverviewMap().removeLayer(tileLayer.value);\n        overViewMap.value.changed();\n      } else {\n        map.removeLayer(tileLayer.value);\n      }\n    };\n    if (overViewMap != null) {\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(overViewMap, () => {\n        removeTileLayer();\n        applyTileLayer();\n      });\n    }\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      applyTileLayer();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      removeTileLayer();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"tileLayer\", tileLayer);\n    return {\n      tileLayer\n    };\n  },\n  props: {\n    preload: {\n      type: Number,\n      default: 1\n    }\n  }\n};\nfunction _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar WebGLTileLayer = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [[\"render\", _sfc_render$Z]]);\nvar __extends$O = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar BaseImageLayer = function(_super) {\n  __extends$O(BaseImageLayer2, _super);\n  function BaseImageLayer2(opt_options) {\n    var options = opt_options ? opt_options : {};\n    return _super.call(this, options) || this;\n  }\n  return BaseImageLayer2;\n}(ol_layer_Base);\nvar BaseImageLayer$1 = BaseImageLayer;\nvar __extends$N = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar CanvasImageLayerRenderer = function(_super) {\n  __extends$N(CanvasImageLayerRenderer2, _super);\n  function CanvasImageLayerRenderer2(imageLayer) {\n    var _this = _super.call(this, imageLayer) || this;\n    _this.image_ = null;\n    return _this;\n  }\n  CanvasImageLayerRenderer2.prototype.getImage = function() {\n    return !this.image_ ? null : this.image_.getImage();\n  };\n  CanvasImageLayerRenderer2.prototype.prepareFrame = function(frameState) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var viewResolution = viewState.resolution;\n    var imageSource = this.getLayer().getSource();\n    var hints = frameState.viewHints;\n    var renderedExtent = frameState.extent;\n    if (layerState.extent !== void 0) {\n      renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));\n    }\n    if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !isEmpty$1(renderedExtent)) {\n      if (imageSource) {\n        var projection = viewState.projection;\n        if (!ENABLE_RASTER_REPROJECTION) {\n          var sourceProjection = imageSource.getProjection();\n          if (sourceProjection) {\n            projection = sourceProjection;\n          }\n        }\n        var image2 = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n        if (image2) {\n          if (this.loadImage(image2)) {\n            this.image_ = image2;\n          } else if (image2.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n    return !!this.image_;\n  };\n  CanvasImageLayerRenderer2.prototype.getData = function(pixel) {\n    var frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    var layer = this.getLayer();\n    var coordinate = apply$5(frameState.pixelToCoordinateTransform, pixel.slice());\n    var layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n    var imageExtent = this.image_.getExtent();\n    var img = this.image_.getImage();\n    var imageMapWidth = getWidth(imageExtent);\n    var col = Math.floor(img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth));\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n    var imageMapHeight = getHeight(imageExtent);\n    var row = Math.floor(img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight));\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n    return this.getImageData(img, col, row);\n  };\n  CanvasImageLayerRenderer2.prototype.renderFrame = function(frameState, target) {\n    var image2 = this.image_;\n    var imageExtent = image2.getExtent();\n    var imageResolution = image2.getResolution();\n    var imagePixelRatio = image2.getPixelRatio();\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var viewCenter = viewState.center;\n    var viewResolution = viewState.resolution;\n    var size = frameState.size;\n    var scale2 = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var rotation = viewState.rotation;\n    if (rotation) {\n      var size_1 = Math.round(Math.sqrt(width * width + height * height));\n      width = size_1;\n      height = size_1;\n    }\n    compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n    var canvasTransform = toString$d(this.pixelTransform);\n    this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));\n    var context = this.context;\n    var canvas = context.canvas;\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n    var clipped = false;\n    var render2 = true;\n    if (layerState.extent) {\n      var layerExtent = fromUserExtent(layerState.extent, viewState.projection);\n      render2 = intersects$1(layerExtent, frameState.extent);\n      clipped = render2 && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n    var img = image2.getImage();\n    var transform2 = compose(this.tempTransform, width / 2, height / 2, scale2, scale2, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);\n    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;\n    var dw = img.width * transform2[0];\n    var dh = img.height * transform2[3];\n    if (!this.getLayer().getSource().getInterpolate()) {\n      assign(context, IMAGE_SMOOTHING_DISABLED);\n    }\n    this.preRender(context, frameState);\n    if (render2 && dw >= 0.5 && dh >= 0.5) {\n      var dx = transform2[4];\n      var dy = transform2[5];\n      var opacity2 = layerState.opacity;\n      var previousAlpha = void 0;\n      if (opacity2 !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity2;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      if (opacity2 !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n    if (clipped) {\n      context.restore();\n    }\n    assign(context, IMAGE_SMOOTHING_ENABLED);\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n    return this.container;\n  };\n  return CanvasImageLayerRenderer2;\n}(CanvasLayerRenderer$1);\nvar CanvasImageLayerRenderer$1 = CanvasImageLayerRenderer;\nvar __extends$M = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ImageLayer$1 = function(_super) {\n  __extends$M(ImageLayer2, _super);\n  function ImageLayer2(opt_options) {\n    return _super.call(this, opt_options) || this;\n  }\n  ImageLayer2.prototype.createRenderer = function() {\n    return new CanvasImageLayerRenderer$1(this);\n  };\n  ImageLayer2.prototype.getData = function(pixel) {\n    return _super.prototype.getData.call(this, pixel);\n  };\n  return ImageLayer2;\n}(BaseImageLayer$1);\nvar ol_layer_Image = ImageLayer$1;\nconst _sfc_main$Y = {\n  extends: BaseLayer,\n  name: \"ol-image-layer\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const imageLayer = new ol_layer_Image(properties);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      imageLayer.setProperties(properties);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addLayer(imageLayer);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeLayer(imageLayer);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"imageLayer\", imageLayer);\n    return {\n      imageLayer\n    };\n  }\n};\nfunction _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar ImageLayer = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [[\"render\", _sfc_render$Y]]);\nconst _sfc_main$X = {\n  extends: BaseLayer,\n  name: \"ol-vector-layer\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const vectorLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new ol_layer_Vector(properties));\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      vectorLayer.value.setProperties(properties);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addLayer(vectorLayer.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeLayer(vectorLayer.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"vectorLayer\", vectorLayer);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"stylable\", vectorLayer);\n    return {\n      vectorLayer\n    };\n  },\n  props: {\n    renderBuffer: {\n      type: Number,\n      default: 100\n    },\n    updateWhileAnimating: {\n      type: Boolean,\n      default: false\n    },\n    style: {\n      type: Function\n    },\n    updateWhileInteracting: {\n      type: Boolean,\n      default: false\n    }\n  }\n};\nfunction _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar VectorLayer = /* @__PURE__ */ _export_sfc(_sfc_main$X, [[\"render\", _sfc_render$X]]);\nvar __extends$L = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TileCache = function(_super) {\n  __extends$L(TileCache2, _super);\n  function TileCache2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TileCache2.prototype.expireCache = function(usedTiles) {\n    while (this.canExpireCache()) {\n      var tile2 = this.peekLast();\n      if (tile2.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  };\n  TileCache2.prototype.pruneExceptNewestZ = function() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    var key = this.peekFirstKey();\n    var tileCoord = fromKey(key);\n    var z2 = tileCoord[0];\n    this.forEach(function(tile2) {\n      if (tile2.tileCoord[0] !== z2) {\n        this.remove(getKey(tile2.tileCoord));\n        tile2.release();\n      }\n    }.bind(this));\n  };\n  return TileCache2;\n}(LRUCache$1);\nvar TileCache$1 = TileCache;\nvar TileEventType = {\n  TILELOADSTART: \"tileloadstart\",\n  TILELOADEND: \"tileloadend\",\n  TILELOADERROR: \"tileloaderror\"\n};\nvar tmpTileCoord = [0, 0, 0];\nvar DECIMALS$1 = 5;\nvar TileGrid = function() {\n  function TileGrid2(options) {\n    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;\n    this.resolutions_ = options.resolutions;\n    assert(isSorted(this.resolutions_, function(a2, b2) {\n      return b2 - a2;\n    }, true), 17);\n    var zoomFactor;\n    if (!options.origins) {\n      for (var i2 = 0, ii = this.resolutions_.length - 1; i2 < ii; ++i2) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i2] / this.resolutions_[i2 + 1];\n        } else {\n          if (this.resolutions_[i2] / this.resolutions_[i2 + 1] !== zoomFactor) {\n            zoomFactor = void 0;\n            break;\n          }\n        }\n      }\n    }\n    this.zoomFactor_ = zoomFactor;\n    this.maxZoom = this.resolutions_.length - 1;\n    this.origin_ = options.origin !== void 0 ? options.origin : null;\n    this.origins_ = null;\n    if (options.origins !== void 0) {\n      this.origins_ = options.origins;\n      assert(this.origins_.length == this.resolutions_.length, 20);\n    }\n    var extent2 = options.extent;\n    if (extent2 !== void 0 && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent2);\n    }\n    assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18);\n    this.tileSizes_ = null;\n    if (options.tileSizes !== void 0) {\n      this.tileSizes_ = options.tileSizes;\n      assert(this.tileSizes_.length == this.resolutions_.length, 19);\n    }\n    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;\n    assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22);\n    this.extent_ = extent2 !== void 0 ? extent2 : null;\n    this.fullTileRanges_ = null;\n    this.tmpSize_ = [0, 0];\n    this.tmpExtent_ = [0, 0, 0, 0];\n    if (options.sizes !== void 0) {\n      this.fullTileRanges_ = options.sizes.map(function(size, z2) {\n        var tileRange = new TileRange$1(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n        if (extent2) {\n          var restrictedTileRange = this.getTileRangeForExtentAndZ(extent2, z2);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      }, this);\n    } else if (extent2) {\n      this.calculateTileRanges_(extent2);\n    }\n  }\n  TileGrid2.prototype.forEachTileCoord = function(extent2, zoom, callback) {\n    var tileRange = this.getTileRangeForExtentAndZ(extent2, zoom);\n    for (var i2 = tileRange.minX, ii = tileRange.maxX; i2 <= ii; ++i2) {\n      for (var j2 = tileRange.minY, jj = tileRange.maxY; j2 <= jj; ++j2) {\n        callback([zoom, i2, j2]);\n      }\n    }\n  };\n  TileGrid2.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_tileRange, opt_extent) {\n    var tileRange, x2, y2;\n    var tileCoordExtent = null;\n    var z2 = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x2 = tileCoord[1];\n      y2 = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    }\n    while (z2 >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x2 = Math.floor(x2 / 2);\n        y2 = Math.floor(y2 / 2);\n        tileRange = createOrUpdate$1(x2, x2, y2, y2, opt_tileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z2, opt_tileRange);\n      }\n      if (callback(z2, tileRange)) {\n        return true;\n      }\n      --z2;\n    }\n    return false;\n  };\n  TileGrid2.prototype.getExtent = function() {\n    return this.extent_;\n  };\n  TileGrid2.prototype.getMaxZoom = function() {\n    return this.maxZoom;\n  };\n  TileGrid2.prototype.getMinZoom = function() {\n    return this.minZoom;\n  };\n  TileGrid2.prototype.getOrigin = function(z2) {\n    if (this.origin_) {\n      return this.origin_;\n    } else {\n      return this.origins_[z2];\n    }\n  };\n  TileGrid2.prototype.getResolution = function(z2) {\n    return this.resolutions_[z2];\n  };\n  TileGrid2.prototype.getResolutions = function() {\n    return this.resolutions_;\n  };\n  TileGrid2.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        var minX = tileCoord[1] * 2;\n        var minY = tileCoord[2] * 2;\n        return createOrUpdate$1(minX, minX + 1, minY, minY + 1, opt_tileRange);\n      }\n      var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);\n      return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n    }\n    return null;\n  };\n  TileGrid2.prototype.getTileRangeForTileCoordAndZ = function(tileCoord, z2, opt_tileRange) {\n    if (z2 > this.maxZoom || z2 < this.minZoom) {\n      return null;\n    }\n    var tileCoordZ = tileCoord[0];\n    var tileCoordX = tileCoord[1];\n    var tileCoordY = tileCoord[2];\n    if (z2 === tileCoordZ) {\n      return createOrUpdate$1(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);\n    }\n    if (this.zoomFactor_) {\n      var factor = Math.pow(this.zoomFactor_, z2 - tileCoordZ);\n      var minX = Math.floor(tileCoordX * factor);\n      var minY = Math.floor(tileCoordY * factor);\n      if (z2 < tileCoordZ) {\n        return createOrUpdate$1(minX, minX, minY, minY, opt_tileRange);\n      }\n      var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdate$1(minX, maxX, minY, maxY, opt_tileRange);\n    }\n    var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z2, opt_tileRange);\n  };\n  TileGrid2.prototype.getTileRangeExtent = function(z2, tileRange, opt_extent) {\n    var origin = this.getOrigin(z2);\n    var resolution = this.getResolution(z2);\n    var tileSize = toSize(this.getTileSize(z2), this.tmpSize_);\n    var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);\n  };\n  TileGrid2.prototype.getTileRangeForExtentAndZ = function(extent2, z2, opt_tileRange) {\n    var tileCoord = tmpTileCoord;\n    this.getTileCoordForXYAndZ_(extent2[0], extent2[3], z2, false, tileCoord);\n    var minX = tileCoord[1];\n    var minY = tileCoord[2];\n    this.getTileCoordForXYAndZ_(extent2[2], extent2[1], z2, true, tileCoord);\n    return createOrUpdate$1(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n  };\n  TileGrid2.prototype.getTileCoordCenter = function(tileCoord) {\n    var origin = this.getOrigin(tileCoord[0]);\n    var resolution = this.getResolution(tileCoord[0]);\n    var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution\n    ];\n  };\n  TileGrid2.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {\n    var origin = this.getOrigin(tileCoord[0]);\n    var resolution = this.getResolution(tileCoord[0]);\n    var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    var maxX = minX + tileSize[0] * resolution;\n    var maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate$2(minX, minY, maxX, maxY, opt_extent);\n  };\n  TileGrid2.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n  };\n  TileGrid2.prototype.getTileCoordForXYAndResolution_ = function(x2, y2, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n    var z2 = this.getZForResolution(resolution);\n    var scale2 = resolution / this.getResolution(z2);\n    var origin = this.getOrigin(z2);\n    var tileSize = toSize(this.getTileSize(z2), this.tmpSize_);\n    var tileCoordX = scale2 * (x2 - origin[0]) / resolution / tileSize[0];\n    var tileCoordY = scale2 * (origin[1] - y2) / resolution / tileSize[1];\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil$1(tileCoordX, DECIMALS$1) - 1;\n      tileCoordY = ceil$1(tileCoordY, DECIMALS$1) - 1;\n    } else {\n      tileCoordX = floor$2(tileCoordX, DECIMALS$1);\n      tileCoordY = floor$2(tileCoordY, DECIMALS$1);\n    }\n    return createOrUpdate(z2, tileCoordX, tileCoordY, opt_tileCoord);\n  };\n  TileGrid2.prototype.getTileCoordForXYAndZ_ = function(x2, y2, z2, reverseIntersectionPolicy, opt_tileCoord) {\n    var origin = this.getOrigin(z2);\n    var resolution = this.getResolution(z2);\n    var tileSize = toSize(this.getTileSize(z2), this.tmpSize_);\n    var tileCoordX = (x2 - origin[0]) / resolution / tileSize[0];\n    var tileCoordY = (origin[1] - y2) / resolution / tileSize[1];\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil$1(tileCoordX, DECIMALS$1) - 1;\n      tileCoordY = ceil$1(tileCoordY, DECIMALS$1) - 1;\n    } else {\n      tileCoordX = floor$2(tileCoordX, DECIMALS$1);\n      tileCoordY = floor$2(tileCoordY, DECIMALS$1);\n    }\n    return createOrUpdate(z2, tileCoordX, tileCoordY, opt_tileCoord);\n  };\n  TileGrid2.prototype.getTileCoordForCoordAndZ = function(coordinate, z2, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z2, false, opt_tileCoord);\n  };\n  TileGrid2.prototype.getTileCoordResolution = function(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  };\n  TileGrid2.prototype.getTileSize = function(z2) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    } else {\n      return this.tileSizes_[z2];\n    }\n  };\n  TileGrid2.prototype.getFullTileRange = function(z2) {\n    if (!this.fullTileRanges_) {\n      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z2) : null;\n    } else {\n      return this.fullTileRanges_[z2];\n    }\n  };\n  TileGrid2.prototype.getZForResolution = function(resolution, opt_direction) {\n    var z2 = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n    return clamp(z2, this.minZoom, this.maxZoom);\n  };\n  TileGrid2.prototype.calculateTileRanges_ = function(extent2) {\n    var length = this.resolutions_.length;\n    var fullTileRanges = new Array(length);\n    for (var z2 = this.minZoom; z2 < length; ++z2) {\n      fullTileRanges[z2] = this.getTileRangeForExtentAndZ(extent2, z2);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  };\n  return TileGrid2;\n}();\nvar TileGrid$1 = TileGrid;\nfunction getForProjection(projection) {\n  var tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\nfunction wrapX(tileGrid, tileCoord, projection) {\n  var z2 = tileCoord[0];\n  var center = tileGrid.getTileCoordCenter(tileCoord);\n  var projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    var worldWidth = getWidth(projectionExtent);\n    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z2);\n  } else {\n    return tileCoord;\n  }\n}\nfunction createForExtent(extent2, opt_maxZoom, opt_tileSize, opt_corner) {\n  var corner = opt_corner !== void 0 ? opt_corner : Corner.TOP_LEFT;\n  var resolutions = resolutionsFromExtent(extent2, opt_maxZoom, opt_tileSize);\n  return new TileGrid$1({\n    extent: extent2,\n    origin: getCorner(extent2, corner),\n    resolutions,\n    tileSize: opt_tileSize\n  });\n}\nfunction createXYZ(opt_options) {\n  var xyzOptions = opt_options || {};\n  var extent2 = xyzOptions.extent || get$3(\"EPSG:3857\").getExtent();\n  var gridOptions = {\n    extent: extent2,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(extent2, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)\n  };\n  return new TileGrid$1(gridOptions);\n}\nfunction resolutionsFromExtent(extent2, opt_maxZoom, opt_tileSize, opt_maxResolution) {\n  var maxZoom = opt_maxZoom !== void 0 ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n  var height = getHeight(extent2);\n  var width = getWidth(extent2);\n  var tileSize = toSize(opt_tileSize !== void 0 ? opt_tileSize : DEFAULT_TILE_SIZE);\n  var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);\n  var length = maxZoom + 1;\n  var resolutions = new Array(length);\n  for (var z2 = 0; z2 < length; ++z2) {\n    resolutions[z2] = maxResolution / Math.pow(2, z2);\n  }\n  return resolutions;\n}\nfunction createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n  var extent2 = extentFromProjection(projection);\n  return createForExtent(extent2, opt_maxZoom, opt_tileSize, opt_corner);\n}\nfunction extentFromProjection(projection) {\n  projection = get$3(projection);\n  var extent2 = projection.getExtent();\n  if (!extent2) {\n    var half = 180 * METERS_PER_UNIT$1[Units$2.DEGREES] / projection.getMetersPerUnit();\n    extent2 = createOrUpdate$2(-half, -half, half, half);\n  }\n  return extent2;\n}\nvar __extends$K = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TileSource = function(_super) {\n  __extends$K(TileSource2, _super);\n  function TileSource2(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate\n    }) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.opaque_ = options.opaque !== void 0 ? options.opaque : false;\n    _this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;\n    _this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;\n    var tileSize = [256, 256];\n    if (_this.tileGrid) {\n      toSize(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);\n    }\n    _this.tileCache = new TileCache$1(options.cacheSize || 0);\n    _this.tmpSize = [0, 0];\n    _this.key_ = options.key || \"\";\n    _this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate\n    };\n    _this.zDirection = options.zDirection ? options.zDirection : 0;\n    return _this;\n  }\n  TileSource2.prototype.canExpireCache = function() {\n    return this.tileCache.canExpireCache();\n  };\n  TileSource2.prototype.expireCache = function(projection, usedTiles) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  };\n  TileSource2.prototype.forEachLoadedTile = function(projection, z2, tileRange, callback) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n    var covered = true;\n    var tile2, tileCoordKey, loaded;\n    for (var x2 = tileRange.minX; x2 <= tileRange.maxX; ++x2) {\n      for (var y2 = tileRange.minY; y2 <= tileRange.maxY; ++y2) {\n        tileCoordKey = getKeyZXY(z2, x2, y2);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile2 = tileCache.get(tileCoordKey);\n          loaded = tile2.getState() === TileState.LOADED;\n          if (loaded) {\n            loaded = callback(tile2) !== false;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  };\n  TileSource2.prototype.getGutterForProjection = function(projection) {\n    return 0;\n  };\n  TileSource2.prototype.getKey = function() {\n    return this.key_;\n  };\n  TileSource2.prototype.setKey = function(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  };\n  TileSource2.prototype.getOpaque = function(projection) {\n    return this.opaque_;\n  };\n  TileSource2.prototype.getResolutions = function() {\n    if (!this.tileGrid) {\n      return null;\n    }\n    return this.tileGrid.getResolutions();\n  };\n  TileSource2.prototype.getTile = function(z2, x2, y2, pixelRatio, projection) {\n    return abstract();\n  };\n  TileSource2.prototype.getTileGrid = function() {\n    return this.tileGrid;\n  };\n  TileSource2.prototype.getTileGridForProjection = function(projection) {\n    if (!this.tileGrid) {\n      return getForProjection(projection);\n    } else {\n      return this.tileGrid;\n    }\n  };\n  TileSource2.prototype.getTileCacheForProjection = function(projection) {\n    assert(equivalent(this.getProjection(), projection), 68);\n    return this.tileCache;\n  };\n  TileSource2.prototype.getTilePixelRatio = function(pixelRatio) {\n    return this.tilePixelRatio_;\n  };\n  TileSource2.prototype.getTilePixelSize = function(z2, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    var tileSize = toSize(tileGrid.getTileSize(z2), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return scale(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  };\n  TileSource2.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {\n    var projection = opt_projection !== void 0 ? opt_projection : this.getProjection();\n    var tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  };\n  TileSource2.prototype.clear = function() {\n    this.tileCache.clear();\n  };\n  TileSource2.prototype.refresh = function() {\n    this.clear();\n    _super.prototype.refresh.call(this);\n  };\n  TileSource2.prototype.updateCacheSize = function(tileCount, projection) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    if (tileCount > tileCache.highWaterMark) {\n      tileCache.highWaterMark = tileCount;\n    }\n  };\n  TileSource2.prototype.useTile = function(z2, x2, y2, projection) {\n  };\n  return TileSource2;\n}(ol_source_Source);\nvar TileSourceEvent = function(_super) {\n  __extends$K(TileSourceEvent2, _super);\n  function TileSourceEvent2(type, tile2) {\n    var _this = _super.call(this, type) || this;\n    _this.tile = tile2;\n    return _this;\n  }\n  return TileSourceEvent2;\n}(Event$1);\nvar ol_source_Tile = TileSource;\nfunction createFromTemplate(template, tileGrid) {\n  var zRegEx = /\\{z\\}/g;\n  var xRegEx = /\\{x\\}/g;\n  var yRegEx = /\\{y\\}/g;\n  var dashYRegEx = /\\{-y\\}/g;\n  return function(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return void 0;\n    } else {\n      return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {\n        var z2 = tileCoord[0];\n        var range = tileGrid.getFullTileRange(z2);\n        assert(range, 55);\n        var y2 = range.getHeight() - tileCoord[2] - 1;\n        return y2.toString();\n      });\n    }\n  };\n}\nfunction createFromTemplates(templates, tileGrid) {\n  var len = templates.length;\n  var tileUrlFunctions = new Array(len);\n  for (var i2 = 0; i2 < len; ++i2) {\n    tileUrlFunctions[i2] = createFromTemplate(templates[i2], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\nfunction createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return function(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return void 0;\n    } else {\n      var h2 = hash(tileCoord);\n      var index2 = modulo(h2, tileUrlFunctions.length);\n      return tileUrlFunctions[index2](tileCoord, pixelRatio, projection);\n    }\n  };\n}\nfunction expandUrl(url) {\n  var urls = [];\n  var match2 = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match2) {\n    var startCharCode = match2[1].charCodeAt(0);\n    var stopCharCode = match2[2].charCodeAt(0);\n    var charCode = void 0;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match2[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match2 = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match2) {\n    var stop_1 = parseInt(match2[2], 10);\n    for (var i2 = parseInt(match2[1], 10); i2 <= stop_1; i2++) {\n      urls.push(url.replace(match2[0], i2.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\nvar __extends$J = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar UrlTile = function(_super) {\n  __extends$J(UrlTile2, _super);\n  function UrlTile2(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection\n    }) || this;\n    _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile2.prototype.tileUrlFunction;\n    _this.tileLoadFunction = options.tileLoadFunction;\n    if (options.tileUrlFunction) {\n      _this.tileUrlFunction = options.tileUrlFunction;\n    }\n    _this.urls = null;\n    if (options.urls) {\n      _this.setUrls(options.urls);\n    } else if (options.url) {\n      _this.setUrl(options.url);\n    }\n    _this.tileLoadingKeys_ = {};\n    return _this;\n  }\n  UrlTile2.prototype.getTileLoadFunction = function() {\n    return this.tileLoadFunction;\n  };\n  UrlTile2.prototype.getTileUrlFunction = function() {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;\n  };\n  UrlTile2.prototype.getUrls = function() {\n    return this.urls;\n  };\n  UrlTile2.prototype.handleTileChange = function(event) {\n    var tile2 = event.target;\n    var uid2 = getUid(tile2);\n    var tileState = tile2.getState();\n    var type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid2] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid2 in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid2];\n      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : void 0;\n    }\n    if (type != void 0) {\n      this.dispatchEvent(new TileSourceEvent(type, tile2));\n    }\n  };\n  UrlTile2.prototype.setTileLoadFunction = function(tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  };\n  UrlTile2.prototype.setTileUrlFunction = function(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n    if (typeof key !== \"undefined\") {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  };\n  UrlTile2.prototype.setUrl = function(url) {\n    var urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  };\n  UrlTile2.prototype.setUrls = function(urls) {\n    this.urls = urls;\n    var key = urls.join(\"\\n\");\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  };\n  UrlTile2.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {\n    return void 0;\n  };\n  UrlTile2.prototype.useTile = function(z2, x2, y2) {\n    var tileCoordKey = getKeyZXY(z2, x2, y2);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  };\n  return UrlTile2;\n}(ol_source_Tile);\nvar UrlTile$1 = UrlTile;\nvar __extends$I = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TileImage = function(_super) {\n  __extends$I(TileImage2, _super);\n  function TileImage2(options) {\n    var _this = this;\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection\n    }) || this;\n    _this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;\n    _this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile$1;\n    _this.tileCacheForProjection = {};\n    _this.tileGridForProjection = {};\n    _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n    _this.renderReprojectionEdges_ = false;\n    return _this;\n  }\n  TileImage2.prototype.canExpireCache = function() {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return _super.prototype.canExpireCache.call(this);\n    }\n    if (this.tileCache.canExpireCache()) {\n      return true;\n    } else {\n      for (var key in this.tileCacheForProjection) {\n        if (this.tileCacheForProjection[key].canExpireCache()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  TileImage2.prototype.expireCache = function(projection, usedTiles) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      _super.prototype.expireCache.call(this, projection, usedTiles);\n      return;\n    }\n    var usedTileCache = this.getTileCacheForProjection(projection);\n    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n    for (var id in this.tileCacheForProjection) {\n      var tileCache = this.tileCacheForProjection[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  };\n  TileImage2.prototype.getGutterForProjection = function(projection) {\n    if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\n      return 0;\n    } else {\n      return this.getGutter();\n    }\n  };\n  TileImage2.prototype.getGutter = function() {\n    return 0;\n  };\n  TileImage2.prototype.getKey = function() {\n    var key = _super.prototype.getKey.call(this);\n    if (!this.getInterpolate()) {\n      key += \":disable-interpolation\";\n    }\n    return key;\n  };\n  TileImage2.prototype.getOpaque = function(projection) {\n    if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {\n      return false;\n    } else {\n      return _super.prototype.getOpaque.call(this, projection);\n    }\n  };\n  TileImage2.prototype.getTileGridForProjection = function(projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return _super.prototype.getTileGridForProjection.call(this, projection);\n    }\n    var thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    } else {\n      var projKey = getUid(projection);\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = getForProjection(projection);\n      }\n      return this.tileGridForProjection[projKey];\n    }\n  };\n  TileImage2.prototype.getTileCacheForProjection = function(projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return _super.prototype.getTileCacheForProjection.call(this, projection);\n    }\n    var thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    } else {\n      var projKey = getUid(projection);\n      if (!(projKey in this.tileCacheForProjection)) {\n        this.tileCacheForProjection[projKey] = new TileCache$1(this.tileCache.highWaterMark);\n      }\n      return this.tileCacheForProjection[projKey];\n    }\n  };\n  TileImage2.prototype.createTile_ = function(z2, x2, y2, pixelRatio, projection, key) {\n    var tileCoord = [z2, x2, y2];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;\n    var tile2 = new this.tileClass(tileCoord, tileUrl !== void 0 ? TileState.IDLE : TileState.EMPTY, tileUrl !== void 0 ? tileUrl : \"\", this.crossOrigin, this.tileLoadFunction, this.tileOptions);\n    tile2.key = key;\n    tile2.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n    return tile2;\n  };\n  TileImage2.prototype.getTile = function(z2, x2, y2, pixelRatio, projection) {\n    var sourceProjection = this.getProjection();\n    if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {\n      return this.getTileInternal(z2, x2, y2, pixelRatio, sourceProjection || projection);\n    } else {\n      var cache2 = this.getTileCacheForProjection(projection);\n      var tileCoord = [z2, x2, y2];\n      var tile2 = void 0;\n      var tileCoordKey = getKey(tileCoord);\n      if (cache2.containsKey(tileCoordKey)) {\n        tile2 = cache2.get(tileCoordKey);\n      }\n      var key = this.getKey();\n      if (tile2 && tile2.key == key) {\n        return tile2;\n      } else {\n        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n        var targetTileGrid = this.getTileGridForProjection(projection);\n        var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var newTile = new ReprojTile$1(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function(z3, x3, y3, pixelRatio2) {\n          return this.getTileInternal(z3, x3, y3, pixelRatio2, sourceProjection);\n        }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());\n        newTile.key = key;\n        if (tile2) {\n          newTile.interimTile = tile2;\n          newTile.refreshInterimChain();\n          cache2.replace(tileCoordKey, newTile);\n        } else {\n          cache2.set(tileCoordKey, newTile);\n        }\n        return newTile;\n      }\n    }\n  };\n  TileImage2.prototype.getTileInternal = function(z2, x2, y2, pixelRatio, projection) {\n    var tile2 = null;\n    var tileCoordKey = getKeyZXY(z2, x2, y2);\n    var key = this.getKey();\n    if (!this.tileCache.containsKey(tileCoordKey)) {\n      tile2 = this.createTile_(z2, x2, y2, pixelRatio, projection, key);\n      this.tileCache.set(tileCoordKey, tile2);\n    } else {\n      tile2 = this.tileCache.get(tileCoordKey);\n      if (tile2.key != key) {\n        var interimTile = tile2;\n        tile2 = this.createTile_(z2, x2, y2, pixelRatio, projection, key);\n        if (interimTile.getState() == TileState.IDLE) {\n          tile2.interimTile = interimTile.interimTile;\n        } else {\n          tile2.interimTile = interimTile;\n        }\n        tile2.refreshInterimChain();\n        this.tileCache.replace(tileCoordKey, tile2);\n      }\n    }\n    return tile2;\n  };\n  TileImage2.prototype.setRenderReprojectionEdges = function(render2) {\n    if (!ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render2) {\n      return;\n    }\n    this.renderReprojectionEdges_ = render2;\n    for (var id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n    this.changed();\n  };\n  TileImage2.prototype.setTileGridForProjection = function(projection, tilegrid) {\n    if (ENABLE_RASTER_REPROJECTION) {\n      var proj = get$3(projection);\n      if (proj) {\n        var projKey = getUid(proj);\n        if (!(projKey in this.tileGridForProjection)) {\n          this.tileGridForProjection[projKey] = tilegrid;\n        }\n      }\n    }\n  };\n  return TileImage2;\n}(UrlTile$1);\nfunction defaultTileLoadFunction(imageTile, src) {\n  imageTile.getImage().src = src;\n}\nvar TileImage$1 = TileImage;\nvar __extends$H = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nfunction jsonp(url, callback, opt_errback, opt_callbackParam) {\n  var script = document.createElement(\"script\");\n  var key = \"olc_\" + getUid(callback);\n  function cleanup() {\n    delete window[key];\n    script.parentNode.removeChild(script);\n  }\n  script.async = true;\n  script.src = url + (url.indexOf(\"?\") == -1 ? \"?\" : \"&\") + (opt_callbackParam || \"callback\") + \"=\" + key;\n  var timer = setTimeout(function() {\n    cleanup();\n    if (opt_errback) {\n      opt_errback();\n    }\n  }, 1e4);\n  window[key] = function(data2) {\n    clearTimeout(timer);\n    cleanup();\n    callback(data2);\n  };\n  document.getElementsByTagName(\"head\")[0].appendChild(script);\n}\n(function(_super) {\n  __extends$H(ResponseError, _super);\n  function ResponseError(response) {\n    var _this = this;\n    var message = \"Unexpected response status: \" + response.status;\n    _this = _super.call(this, message) || this;\n    _this.name = \"ResponseError\";\n    _this.response = response;\n    return _this;\n  }\n  return ResponseError;\n})(Error);\n(function(_super) {\n  __extends$H(ClientError, _super);\n  function ClientError(client) {\n    var _this = _super.call(this, \"Failed to issue request\") || this;\n    _this.name = \"ClientError\";\n    _this.client = client;\n    return _this;\n  }\n  return ClientError;\n})(Error);\nvar __extends$G = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nfunction quadKey(tileCoord) {\n  var z2 = tileCoord[0];\n  var digits = new Array(z2);\n  var mask = 1 << z2 - 1;\n  var i2, charCode;\n  for (i2 = 0; i2 < z2; ++i2) {\n    charCode = 48;\n    if (tileCoord[1] & mask) {\n      charCode += 1;\n    }\n    if (tileCoord[2] & mask) {\n      charCode += 2;\n    }\n    digits[i2] = String.fromCharCode(charCode);\n    mask >>= 1;\n  }\n  return digits.join(\"\");\n}\nvar TOS_ATTRIBUTION = '<a class=\"ol-attribution-bing-tos\" href=\"https://www.microsoft.com/maps/product/terms.html\" target=\"_blank\">Terms of Use</a>';\nvar BingMaps = function(_super) {\n  __extends$G(BingMaps2, _super);\n  function BingMaps2(options) {\n    var _this = this;\n    var hidpi = options.hidpi !== void 0 ? options.hidpi : false;\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    _this = _super.call(this, {\n      cacheSize: options.cacheSize,\n      crossOrigin: \"anonymous\",\n      interpolate,\n      opaque: true,\n      projection: get$3(\"EPSG:3857\"),\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: SourceState.LOADING,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: hidpi ? 2 : 1,\n      wrapX: options.wrapX !== void 0 ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection\n    }) || this;\n    _this.hidpi_ = hidpi;\n    _this.culture_ = options.culture !== void 0 ? options.culture : \"en-us\";\n    _this.maxZoom_ = options.maxZoom !== void 0 ? options.maxZoom : -1;\n    _this.apiKey_ = options.key;\n    _this.imagerySet_ = options.imagerySet;\n    var url = \"https://dev.virtualearth.net/REST/v1/Imagery/Metadata/\" + _this.imagerySet_ + \"?uriScheme=https&include=ImageryProviders&key=\" + _this.apiKey_ + \"&c=\" + _this.culture_;\n    jsonp(url, _this.handleImageryMetadataResponse.bind(_this), void 0, \"jsonp\");\n    return _this;\n  }\n  BingMaps2.prototype.getApiKey = function() {\n    return this.apiKey_;\n  };\n  BingMaps2.prototype.getImagerySet = function() {\n    return this.imagerySet_;\n  };\n  BingMaps2.prototype.handleImageryMetadataResponse = function(response) {\n    if (response.statusCode != 200 || response.statusDescription != \"OK\" || response.authenticationResultCode != \"ValidCredentials\" || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {\n      this.setState(SourceState.ERROR);\n      return;\n    }\n    var resource = response.resourceSets[0].resources[0];\n    var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;\n    var sourceProjection = this.getProjection();\n    var extent2 = extentFromProjection(sourceProjection);\n    var scale2 = this.hidpi_ ? 2 : 1;\n    var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale2 : [resource.imageWidth / scale2, resource.imageHeight / scale2];\n    var tileGrid = createXYZ({\n      extent: extent2,\n      minZoom: resource.zoomMin,\n      maxZoom,\n      tileSize\n    });\n    this.tileGrid = tileGrid;\n    var culture = this.culture_;\n    var hidpi = this.hidpi_;\n    this.tileUrlFunction = createFromTileUrlFunctions(resource.imageUrlSubdomains.map(function(subdomain) {\n      var quadKeyTileCoord = [0, 0, 0];\n      var imageUrl = resource.imageUrl.replace(\"{subdomain}\", subdomain).replace(\"{culture}\", culture);\n      return function(tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n          return void 0;\n        } else {\n          createOrUpdate(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);\n          var url = imageUrl;\n          if (hidpi) {\n            url += \"&dpi=d1&device=mobile\";\n          }\n          return url.replace(\"{quadkey}\", quadKey(quadKeyTileCoord));\n        }\n      };\n    }));\n    if (resource.imageryProviders) {\n      var transform_1 = getTransformFromProjections(get$3(\"EPSG:4326\"), this.getProjection());\n      this.setAttributions(function(frameState) {\n        var attributions = [];\n        var viewState = frameState.viewState;\n        var tileGrid2 = this.getTileGrid();\n        var z2 = tileGrid2.getZForResolution(viewState.resolution, this.zDirection);\n        var tileCoord = tileGrid2.getTileCoordForCoordAndZ(viewState.center, z2);\n        var zoom = tileCoord[0];\n        resource.imageryProviders.map(function(imageryProvider) {\n          var intersecting = false;\n          var coverageAreas = imageryProvider.coverageAreas;\n          for (var i2 = 0, ii = coverageAreas.length; i2 < ii; ++i2) {\n            var coverageArea = coverageAreas[i2];\n            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {\n              var bbox2 = coverageArea.bbox;\n              var epsg4326Extent = [bbox2[1], bbox2[0], bbox2[3], bbox2[2]];\n              var extent_1 = applyTransform(epsg4326Extent, transform_1);\n              if (intersects$1(extent_1, frameState.extent)) {\n                intersecting = true;\n                break;\n              }\n            }\n          }\n          if (intersecting) {\n            attributions.push(imageryProvider.attribution);\n          }\n        });\n        attributions.push(TOS_ATTRIBUTION);\n        return attributions;\n      }.bind(this));\n    }\n    this.setState(SourceState.READY);\n  };\n  return BingMaps2;\n}(TileImage$1);\nvar BingMaps$1 = BingMaps;\nvar __extends$F = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar XYZ = function(_super) {\n  __extends$F(XYZ2, _super);\n  function XYZ2(opt_options) {\n    var options = opt_options || {};\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    var projection = options.projection !== void 0 ? options.projection : \"EPSG:3857\";\n    var tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({\n      extent: extentFromProjection(projection),\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize\n    });\n    return _super.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate,\n      opaque: options.opaque,\n      projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== void 0 ? options.wrapX : true,\n      transition: options.transition,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection\n    }) || this;\n  }\n  return XYZ2;\n}(TileImage$1);\nvar XYZ$1 = XYZ;\nvar __extends$E = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Cluster = function(_super) {\n  __extends$E(Cluster2, _super);\n  function Cluster2(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      wrapX: options.wrapX\n    }) || this;\n    _this.resolution = void 0;\n    _this.distance = options.distance !== void 0 ? options.distance : 20;\n    _this.minDistance = options.minDistance || 0;\n    _this.interpolationRatio = 0;\n    _this.features = [];\n    _this.geometryFunction = options.geometryFunction || function(feature2) {\n      var geometry = feature2.getGeometry();\n      assert(geometry.getType() == GeometryType.POINT, 10);\n      return geometry;\n    };\n    _this.createCustomCluster_ = options.createCluster;\n    _this.source = null;\n    _this.boundRefresh_ = _this.refresh.bind(_this);\n    _this.updateDistance(_this.distance, _this.minDistance);\n    _this.setSource(options.source || null);\n    return _this;\n  }\n  Cluster2.prototype.clear = function(opt_fast) {\n    this.features.length = 0;\n    _super.prototype.clear.call(this, opt_fast);\n  };\n  Cluster2.prototype.getDistance = function() {\n    return this.distance;\n  };\n  Cluster2.prototype.getSource = function() {\n    return this.source;\n  };\n  Cluster2.prototype.loadFeatures = function(extent2, resolution, projection) {\n    this.source.loadFeatures(extent2, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.resolution = resolution;\n      this.refresh();\n    }\n  };\n  Cluster2.prototype.setDistance = function(distance2) {\n    this.updateDistance(distance2, this.minDistance);\n  };\n  Cluster2.prototype.setMinDistance = function(minDistance) {\n    this.updateDistance(this.distance, minDistance);\n  };\n  Cluster2.prototype.getMinDistance = function() {\n    return this.minDistance;\n  };\n  Cluster2.prototype.setSource = function(source) {\n    if (this.source) {\n      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.source = source;\n    if (source) {\n      source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.refresh();\n  };\n  Cluster2.prototype.refresh = function() {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  };\n  Cluster2.prototype.updateDistance = function(distance2, minDistance) {\n    var ratio = distance2 === 0 ? 0 : Math.min(minDistance, distance2) / distance2;\n    var changed = distance2 !== this.distance || this.interpolationRatio !== ratio;\n    this.distance = distance2;\n    this.minDistance = minDistance;\n    this.interpolationRatio = ratio;\n    if (changed) {\n      this.refresh();\n    }\n  };\n  Cluster2.prototype.cluster = function() {\n    if (this.resolution === void 0 || !this.source) {\n      return;\n    }\n    var extent2 = createEmpty();\n    var mapDistance = this.distance * this.resolution;\n    var features = this.source.getFeatures();\n    var clustered = {};\n    for (var i2 = 0, ii = features.length; i2 < ii; i2++) {\n      var feature2 = features[i2];\n      if (!(getUid(feature2) in clustered)) {\n        var geometry = this.geometryFunction(feature2);\n        if (geometry) {\n          var coordinates2 = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates2, extent2);\n          buffer$1(extent2, mapDistance, extent2);\n          var neighbors = this.source.getFeaturesInExtent(extent2).filter(function(neighbor) {\n            var uid2 = getUid(neighbor);\n            if (uid2 in clustered) {\n              return false;\n            }\n            clustered[uid2] = true;\n            return true;\n          });\n          this.features.push(this.createCluster(neighbors, extent2));\n        }\n      }\n    }\n  };\n  Cluster2.prototype.createCluster = function(features, extent2) {\n    var centroid2 = [0, 0];\n    for (var i2 = features.length - 1; i2 >= 0; --i2) {\n      var geometry_1 = this.geometryFunction(features[i2]);\n      if (geometry_1) {\n        add$3(centroid2, geometry_1.getCoordinates());\n      } else {\n        features.splice(i2, 1);\n      }\n    }\n    scale$2(centroid2, 1 / features.length);\n    var searchCenter = getCenter(extent2);\n    var ratio = this.interpolationRatio;\n    var geometry = new Point$4([\n      centroid2[0] * (1 - ratio) + searchCenter[0] * ratio,\n      centroid2[1] * (1 - ratio) + searchCenter[1] * ratio\n    ]);\n    if (this.createCustomCluster_) {\n      return this.createCustomCluster_(geometry, features);\n    } else {\n      return new feature({\n        geometry,\n        features\n      });\n    }\n  };\n  return Cluster2;\n}(ol_source_Vector);\nvar Cluster$1 = Cluster;\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : {};\nfunction getAugmentedNamespace(n2) {\n  if (n2.__esModule)\n    return n2;\n  var a2 = Object.defineProperty({}, \"__esModule\", { value: true });\n  Object.keys(n2).forEach(function(k2) {\n    var d2 = Object.getOwnPropertyDescriptor(n2, k2);\n    Object.defineProperty(a2, k2, d2.get ? d2 : {\n      enumerable: true,\n      get: function() {\n        return n2[k2];\n      }\n    });\n  });\n  return a2;\n}\nvar __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to, from, pack2) {\n  if (pack2 || arguments.length === 2)\n    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {\n      if (ar || !(i2 in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i2);\n        ar[i2] = from[i2];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar Versions = {\n  VERSION1: \"version1\",\n  VERSION2: \"version2\",\n  VERSION3: \"version3\"\n};\nvar IIIF_PROFILE_VALUES = {};\nIIIF_PROFILE_VALUES[Versions.VERSION1] = {\n  \"level0\": {\n    supports: [],\n    formats: [],\n    qualities: [\"native\"]\n  },\n  \"level1\": {\n    supports: [\"regionByPx\", \"sizeByW\", \"sizeByH\", \"sizeByPct\"],\n    formats: [\"jpg\"],\n    qualities: [\"native\"]\n  },\n  \"level2\": {\n    supports: [\n      \"regionByPx\",\n      \"regionByPct\",\n      \"sizeByW\",\n      \"sizeByH\",\n      \"sizeByPct\",\n      \"sizeByConfinedWh\",\n      \"sizeByWh\"\n    ],\n    formats: [\"jpg\", \"png\"],\n    qualities: [\"native\", \"color\", \"grey\", \"bitonal\"]\n  }\n};\nIIIF_PROFILE_VALUES[Versions.VERSION2] = {\n  \"level0\": {\n    supports: [],\n    formats: [\"jpg\"],\n    qualities: [\"default\"]\n  },\n  \"level1\": {\n    supports: [\"regionByPx\", \"sizeByW\", \"sizeByH\", \"sizeByPct\"],\n    formats: [\"jpg\"],\n    qualities: [\"default\"]\n  },\n  \"level2\": {\n    supports: [\n      \"regionByPx\",\n      \"regionByPct\",\n      \"sizeByW\",\n      \"sizeByH\",\n      \"sizeByPct\",\n      \"sizeByConfinedWh\",\n      \"sizeByDistortedWh\",\n      \"sizeByWh\"\n    ],\n    formats: [\"jpg\", \"png\"],\n    qualities: [\"default\", \"bitonal\"]\n  }\n};\nIIIF_PROFILE_VALUES[Versions.VERSION3] = {\n  \"level0\": {\n    supports: [],\n    formats: [\"jpg\"],\n    qualities: [\"default\"]\n  },\n  \"level1\": {\n    supports: [\"regionByPx\", \"regionSquare\", \"sizeByW\", \"sizeByH\", \"sizeByWh\"],\n    formats: [\"jpg\"],\n    qualities: [\"default\"]\n  },\n  \"level2\": {\n    supports: [\n      \"regionByPx\",\n      \"regionSquare\",\n      \"regionByPct\",\n      \"sizeByW\",\n      \"sizeByH\",\n      \"sizeByPct\",\n      \"sizeByConfinedWh\",\n      \"sizeByWh\"\n    ],\n    formats: [\"jpg\", \"png\"],\n    qualities: [\"default\"]\n  }\n};\nIIIF_PROFILE_VALUES[\"none\"] = {\n  \"none\": {\n    supports: [],\n    formats: [],\n    qualities: []\n  }\n};\nvar COMPLIANCE_VERSION1 = /^https?:\\/\\/library\\.stanford\\.edu\\/iiif\\/image-api\\/(?:1\\.1\\/)?compliance\\.html#level[0-2]$/;\nvar COMPLIANCE_VERSION2 = /^https?:\\/\\/iiif\\.io\\/api\\/image\\/2\\/level[0-2](?:\\.json)?$/;\nvar COMPLIANCE_VERSION3 = /(^https?:\\/\\/iiif\\.io\\/api\\/image\\/3\\/level[0-2](?:\\.json)?$)|(^level[0-2]$)/;\nfunction generateVersion1Options(iiifInfo) {\n  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();\n  if (levelProfile === void 0) {\n    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1][\"level0\"];\n  }\n  return {\n    url: iiifInfo.imageInfo[\"@id\"] === void 0 ? void 0 : iiifInfo.imageInfo[\"@id\"].replace(/\\/?(?:info\\.json)?$/g, \"\"),\n    supports: levelProfile.supports,\n    formats: __spreadArray$1(__spreadArray$1([], levelProfile.formats, true), [\n      iiifInfo.imageInfo.formats === void 0 ? [] : iiifInfo.imageInfo.formats\n    ], false),\n    qualities: __spreadArray$1(__spreadArray$1([], levelProfile.qualities, true), [\n      iiifInfo.imageInfo.qualities === void 0 ? [] : iiifInfo.imageInfo.qualities\n    ], false),\n    resolutions: iiifInfo.imageInfo.scale_factors,\n    tileSize: iiifInfo.imageInfo.tile_width !== void 0 ? iiifInfo.imageInfo.tile_height !== void 0 ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != void 0 ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : void 0\n  };\n}\nfunction generateVersion2Options(iiifInfo) {\n  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1, profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [], profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [], profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];\n  return {\n    url: iiifInfo.imageInfo[\"@id\"].replace(/\\/?(?:info\\.json)?$/g, \"\"),\n    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {\n      return [size.width, size.height];\n    }),\n    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [\n      iiifInfo.imageInfo.tiles.map(function(tile2) {\n        return tile2.width;\n      })[0],\n      iiifInfo.imageInfo.tiles.map(function(tile2) {\n        return tile2.height === void 0 ? tile2.width : tile2.height;\n      })[0]\n    ],\n    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile2) {\n      return tile2.scaleFactors;\n    })[0],\n    supports: __spreadArray$1(__spreadArray$1([], levelProfile.supports, true), profileSupports, true),\n    formats: __spreadArray$1(__spreadArray$1([], levelProfile.formats, true), profileFormats, true),\n    qualities: __spreadArray$1(__spreadArray$1([], levelProfile.qualities, true), profileQualities, true)\n  };\n}\nfunction generateVersion3Options(iiifInfo) {\n  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), formats = iiifInfo.imageInfo.extraFormats === void 0 ? levelProfile.formats : __spreadArray$1(__spreadArray$1([], levelProfile.formats, true), iiifInfo.imageInfo.extraFormats, true), preferredFormat = iiifInfo.imageInfo.preferredFormats !== void 0 && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function(format2) {\n    return includes([\"jpg\", \"png\", \"gif\"], format2);\n  }).reduce(function(acc, format2) {\n    return acc === void 0 && includes(formats, format2) ? format2 : acc;\n  }, void 0) : void 0;\n  return {\n    url: iiifInfo.imageInfo[\"id\"],\n    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {\n      return [size.width, size.height];\n    }),\n    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [\n      iiifInfo.imageInfo.tiles.map(function(tile2) {\n        return tile2.width;\n      })[0],\n      iiifInfo.imageInfo.tiles.map(function(tile2) {\n        return tile2.height;\n      })[0]\n    ],\n    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile2) {\n      return tile2.scaleFactors;\n    })[0],\n    supports: iiifInfo.imageInfo.extraFeatures === void 0 ? levelProfile.supports : __spreadArray$1(__spreadArray$1([], levelProfile.supports, true), iiifInfo.imageInfo.extraFeatures, true),\n    formats,\n    qualities: iiifInfo.imageInfo.extraQualities === void 0 ? levelProfile.qualities : __spreadArray$1(__spreadArray$1([], levelProfile.qualities, true), iiifInfo.imageInfo.extraQualities, true),\n    preferredFormat\n  };\n}\nvar versionFunctions = {};\nversionFunctions[Versions.VERSION1] = generateVersion1Options;\nversionFunctions[Versions.VERSION2] = generateVersion2Options;\nversionFunctions[Versions.VERSION3] = generateVersion3Options;\nvar IIIFInfo = function() {\n  function IIIFInfo2(imageInfo) {\n    this.setImageInfo(imageInfo);\n  }\n  IIIFInfo2.prototype.setImageInfo = function(imageInfo) {\n    if (typeof imageInfo == \"string\") {\n      this.imageInfo = JSON.parse(imageInfo);\n    } else {\n      this.imageInfo = imageInfo;\n    }\n  };\n  IIIFInfo2.prototype.getImageApiVersion = function() {\n    if (this.imageInfo === void 0) {\n      return;\n    }\n    var context = this.imageInfo[\"@context\"] || \"ol-no-context\";\n    if (typeof context == \"string\") {\n      context = [context];\n    }\n    for (var i2 = 0; i2 < context.length; i2++) {\n      switch (context[i2]) {\n        case \"http://library.stanford.edu/iiif/image-api/1.1/context.json\":\n        case \"http://iiif.io/api/image/1/context.json\":\n          return Versions.VERSION1;\n        case \"http://iiif.io/api/image/2/context.json\":\n          return Versions.VERSION2;\n        case \"http://iiif.io/api/image/3/context.json\":\n          return Versions.VERSION3;\n        case \"ol-no-context\":\n          if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {\n            return Versions.VERSION1;\n          }\n          break;\n      }\n    }\n    assert(false, 61);\n  };\n  IIIFInfo2.prototype.getComplianceLevelEntryFromProfile = function(version2) {\n    if (this.imageInfo === void 0 || this.imageInfo.profile === void 0) {\n      return;\n    }\n    if (version2 === void 0) {\n      version2 = this.getImageApiVersion();\n    }\n    switch (version2) {\n      case Versions.VERSION1:\n        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {\n          return this.imageInfo.profile;\n        }\n        break;\n      case Versions.VERSION3:\n        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {\n          return this.imageInfo.profile;\n        }\n        break;\n      case Versions.VERSION2:\n        if (typeof this.imageInfo.profile === \"string\" && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {\n          return this.imageInfo.profile;\n        }\n        if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === \"string\" && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {\n          return this.imageInfo.profile[0];\n        }\n        break;\n    }\n  };\n  IIIFInfo2.prototype.getComplianceLevelFromProfile = function(version2) {\n    var complianceLevel = this.getComplianceLevelEntryFromProfile(version2);\n    if (complianceLevel === void 0) {\n      return void 0;\n    }\n    var level = complianceLevel.match(/level[0-2](?:\\.json)?$/g);\n    return Array.isArray(level) ? level[0].replace(\".json\", \"\") : void 0;\n  };\n  IIIFInfo2.prototype.getComplianceLevelSupportedFeatures = function() {\n    if (this.imageInfo === void 0) {\n      return;\n    }\n    var version2 = this.getImageApiVersion();\n    var level = this.getComplianceLevelFromProfile(version2);\n    if (level === void 0) {\n      return IIIF_PROFILE_VALUES[\"none\"][\"none\"];\n    }\n    return IIIF_PROFILE_VALUES[version2][level];\n  };\n  IIIFInfo2.prototype.getTileSourceOptions = function(opt_preferredOptions) {\n    var options = opt_preferredOptions || {}, version2 = this.getImageApiVersion();\n    if (version2 === void 0) {\n      return;\n    }\n    var imageOptions = version2 === void 0 ? void 0 : versionFunctions[version2](this);\n    if (imageOptions === void 0) {\n      return;\n    }\n    return {\n      url: imageOptions.url,\n      version: version2,\n      size: [this.imageInfo.width, this.imageInfo.height],\n      sizes: imageOptions.sizes,\n      format: options.format !== void 0 && includes(imageOptions.formats, options.format) ? options.format : imageOptions.preferredFormat !== void 0 ? imageOptions.preferredFormat : \"jpg\",\n      supports: imageOptions.supports,\n      quality: options.quality && includes(imageOptions.qualities, options.quality) ? options.quality : includes(imageOptions.qualities, \"native\") ? \"native\" : \"default\",\n      resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function(a2, b2) {\n        return b2 - a2;\n      }) : void 0,\n      tileSize: imageOptions.tileSize\n    };\n  };\n  return IIIFInfo2;\n}();\nvar IIIFInfo$1 = IIIFInfo;\nvar __extends$D = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ReprojImage = function(_super) {\n  __extends$D(ReprojImage2, _super);\n  function ReprojImage2(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {\n    var _this = this;\n    var maxSourceExtent = sourceProj.getExtent();\n    var maxTargetExtent = targetProj.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    var targetCenter = getCenter(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n    var errorThresholdInPixels = ERROR_THRESHOLD;\n    var triangulation = new Triangulation$1(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n    var sourceExtent = triangulation.calculateSourceExtent();\n    var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);\n    var state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;\n    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\n    _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;\n    _this.targetProj_ = targetProj;\n    _this.maxSourceExtent_ = maxSourceExtent;\n    _this.triangulation_ = triangulation;\n    _this.targetResolution_ = targetResolution;\n    _this.targetExtent_ = targetExtent;\n    _this.sourceImage_ = sourceImage;\n    _this.sourcePixelRatio_ = sourcePixelRatio;\n    _this.interpolate_ = interpolate;\n    _this.canvas_ = null;\n    _this.sourceListenerKey_ = null;\n    return _this;\n  }\n  ReprojImage2.prototype.disposeInternal = function() {\n    if (this.state == ImageState.LOADING) {\n      this.unlistenSource_();\n    }\n    _super.prototype.disposeInternal.call(this);\n  };\n  ReprojImage2.prototype.getImage = function() {\n    return this.canvas_;\n  };\n  ReprojImage2.prototype.getProjection = function() {\n    return this.targetProj_;\n  };\n  ReprojImage2.prototype.reproject_ = function() {\n    var sourceState = this.sourceImage_.getState();\n    if (sourceState == ImageState.LOADED) {\n      var width = getWidth(this.targetExtent_) / this.targetResolution_;\n      var height = getHeight(this.targetExtent_) / this.targetResolution_;\n      this.canvas_ = render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [\n        {\n          extent: this.sourceImage_.getExtent(),\n          image: this.sourceImage_.getImage()\n        }\n      ], 0, void 0, this.interpolate_);\n    }\n    this.state = sourceState;\n    this.changed();\n  };\n  ReprojImage2.prototype.load = function() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      var sourceState = this.sourceImage_.getState();\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n        this.reproject_();\n      } else {\n        this.sourceListenerKey_ = listen(this.sourceImage_, EventType.CHANGE, function(e2) {\n          var sourceState2 = this.sourceImage_.getState();\n          if (sourceState2 == ImageState.LOADED || sourceState2 == ImageState.ERROR) {\n            this.unlistenSource_();\n            this.reproject_();\n          }\n        }, this);\n        this.sourceImage_.load();\n      }\n    }\n  };\n  ReprojImage2.prototype.unlistenSource_ = function() {\n    unlistenByKey(this.sourceListenerKey_);\n    this.sourceListenerKey_ = null;\n  };\n  return ReprojImage2;\n}(ImageBase$1);\nvar ReprojImage$1 = ReprojImage;\nvar __extends$C = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ImageSourceEventType = {\n  IMAGELOADSTART: \"imageloadstart\",\n  IMAGELOADEND: \"imageloadend\",\n  IMAGELOADERROR: \"imageloaderror\"\n};\nvar ImageSourceEvent = function(_super) {\n  __extends$C(ImageSourceEvent2, _super);\n  function ImageSourceEvent2(type, image2) {\n    var _this = _super.call(this, type) || this;\n    _this.image = image2;\n    return _this;\n  }\n  return ImageSourceEvent2;\n}(Event$1);\nvar ImageSource = function(_super) {\n  __extends$C(ImageSource2, _super);\n  function ImageSource2(options) {\n    var _this = this;\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      projection: options.projection,\n      state: options.state,\n      interpolate\n    }) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    _this.resolutions_ = options.resolutions !== void 0 ? options.resolutions : null;\n    _this.reprojectedImage_ = null;\n    _this.reprojectedRevision_ = 0;\n    return _this;\n  }\n  ImageSource2.prototype.getResolutions = function() {\n    return this.resolutions_;\n  };\n  ImageSource2.prototype.findNearestResolution = function(resolution) {\n    if (this.resolutions_) {\n      var idx = linearFindNearest(this.resolutions_, resolution, 0);\n      resolution = this.resolutions_[idx];\n    }\n    return resolution;\n  };\n  ImageSource2.prototype.getImage = function(extent2, resolution, pixelRatio, projection) {\n    var sourceProjection = this.getProjection();\n    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n      return this.getImageInternal(extent2, resolution, pixelRatio, projection);\n    } else {\n      if (this.reprojectedImage_) {\n        if (this.reprojectedRevision_ == this.getRevision() && equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && equals$1(this.reprojectedImage_.getExtent(), extent2)) {\n          return this.reprojectedImage_;\n        }\n        this.reprojectedImage_.dispose();\n        this.reprojectedImage_ = null;\n      }\n      this.reprojectedImage_ = new ReprojImage$1(sourceProjection, projection, extent2, resolution, pixelRatio, function(extent3, resolution2, pixelRatio2) {\n        return this.getImageInternal(extent3, resolution2, pixelRatio2, sourceProjection);\n      }.bind(this), this.getInterpolate());\n      this.reprojectedRevision_ = this.getRevision();\n      return this.reprojectedImage_;\n    }\n  };\n  ImageSource2.prototype.getImageInternal = function(extent2, resolution, pixelRatio, projection) {\n    return abstract();\n  };\n  ImageSource2.prototype.handleImageChange = function(event) {\n    var image2 = event.target;\n    var type;\n    switch (image2.getState()) {\n      case ImageState.LOADING:\n        this.loading = true;\n        type = ImageSourceEventType.IMAGELOADSTART;\n        break;\n      case ImageState.LOADED:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADEND;\n        break;\n      case ImageState.ERROR:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADERROR;\n        break;\n      default:\n        return;\n    }\n    if (this.hasListener(type)) {\n      this.dispatchEvent(new ImageSourceEvent(type, image2));\n    }\n  };\n  return ImageSource2;\n}(ol_source_Source);\nfunction defaultImageLoadFunction(image2, src) {\n  image2.getImage().src = src;\n}\nvar ImageSource$1 = ImageSource;\nfunction appendParams(uri, params2) {\n  var keyParams = [];\n  Object.keys(params2).forEach(function(k2) {\n    if (params2[k2] !== null && params2[k2] !== void 0) {\n      keyParams.push(k2 + \"=\" + encodeURIComponent(params2[k2]));\n    }\n  });\n  var qs = keyParams.join(\"&\");\n  uri = uri.replace(/[?&]$/, \"\");\n  uri = uri.indexOf(\"?\") === -1 ? uri + \"?\" : uri + \"&\";\n  return uri + qs;\n}\nvar __extends$B = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Static = function(_super) {\n  __extends$B(Static2, _super);\n  function Static2(options) {\n    var _this = this;\n    var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;\n    var imageLoadFunction = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      interpolate,\n      projection: get$3(options.projection)\n    }) || this;\n    _this.url_ = options.url;\n    _this.imageExtent_ = options.imageExtent;\n    _this.image_ = new ImageWrapper$1(_this.imageExtent_, void 0, 1, _this.url_, crossOrigin, imageLoadFunction);\n    _this.imageSize_ = options.imageSize ? options.imageSize : null;\n    _this.image_.addEventListener(EventType.CHANGE, _this.handleImageChange.bind(_this));\n    return _this;\n  }\n  Static2.prototype.getImageExtent = function() {\n    return this.imageExtent_;\n  };\n  Static2.prototype.getImageInternal = function(extent2, resolution, pixelRatio, projection) {\n    if (intersects$1(extent2, this.image_.getExtent())) {\n      return this.image_;\n    }\n    return null;\n  };\n  Static2.prototype.getUrl = function() {\n    return this.url_;\n  };\n  Static2.prototype.handleImageChange = function(evt) {\n    if (this.image_.getState() == ImageState.LOADED) {\n      var imageExtent = this.image_.getExtent();\n      var image2 = this.image_.getImage();\n      var imageWidth = void 0, imageHeight = void 0;\n      if (this.imageSize_) {\n        imageWidth = this.imageSize_[0];\n        imageHeight = this.imageSize_[1];\n      } else {\n        imageWidth = image2.width;\n        imageHeight = image2.height;\n      }\n      var extentWidth = getWidth(imageExtent);\n      var extentHeight = getHeight(imageExtent);\n      var xResolution = extentWidth / imageWidth;\n      var yResolution = extentHeight / imageHeight;\n      var targetWidth = imageWidth;\n      var targetHeight = imageHeight;\n      if (xResolution > yResolution) {\n        targetWidth = Math.round(extentWidth / yResolution);\n      } else {\n        targetHeight = Math.round(extentHeight / xResolution);\n      }\n      if (targetWidth !== imageWidth || targetHeight !== imageHeight) {\n        var context = createCanvasContext2D(targetWidth, targetHeight);\n        if (!this.getInterpolate()) {\n          assign(context, IMAGE_SMOOTHING_DISABLED);\n        }\n        var canvas = context.canvas;\n        context.drawImage(image2, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);\n        this.image_.setImage(canvas);\n      }\n    }\n    _super.prototype.handleImageChange.call(this, evt);\n  };\n  return Static2;\n}(ImageSource$1);\nvar Static$1 = Static;\nvar DEFAULT_WMS_VERSION = \"1.3.0\";\nvar WMSServerType = {\n  CARMENTA_SERVER: \"carmentaserver\",\n  GEOSERVER: \"geoserver\",\n  MAPSERVER: \"mapserver\",\n  QGIS: \"qgis\"\n};\nvar __extends$A = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar DECIMALS = 4;\nvar GETFEATUREINFO_IMAGE_SIZE = [101, 101];\nvar ImageWMS = function(_super) {\n  __extends$A(ImageWMS2, _super);\n  function ImageWMS2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      interpolate,\n      projection: options.projection,\n      resolutions: options.resolutions\n    }) || this;\n    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;\n    _this.url_ = options.url;\n    _this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;\n    _this.params_ = options.params || {};\n    _this.v13_ = true;\n    _this.updateV13_();\n    _this.serverType_ = options.serverType;\n    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;\n    _this.image_ = null;\n    _this.imageSize_ = [0, 0];\n    _this.renderedRevision_ = 0;\n    _this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;\n    return _this;\n  }\n  ImageWMS2.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params2) {\n    if (this.url_ === void 0) {\n      return void 0;\n    }\n    var projectionObj = get$3(projection);\n    var sourceProjectionObj = this.getProjection();\n    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {\n      resolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);\n      coordinate = transform$3(coordinate, projectionObj, sourceProjectionObj);\n    }\n    var extent2 = getForViewAndSize(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);\n    var baseParams = {\n      \"SERVICE\": \"WMS\",\n      \"VERSION\": DEFAULT_WMS_VERSION,\n      \"REQUEST\": \"GetFeatureInfo\",\n      \"FORMAT\": \"image/png\",\n      \"TRANSPARENT\": true,\n      \"QUERY_LAYERS\": this.params_[\"LAYERS\"]\n    };\n    assign(baseParams, this.params_, params2);\n    var x2 = floor$2((coordinate[0] - extent2[0]) / resolution, DECIMALS);\n    var y2 = floor$2((extent2[3] - coordinate[1]) / resolution, DECIMALS);\n    baseParams[this.v13_ ? \"I\" : \"X\"] = x2;\n    baseParams[this.v13_ ? \"J\" : \"Y\"] = y2;\n    return this.getRequestUrl_(extent2, GETFEATUREINFO_IMAGE_SIZE, 1, sourceProjectionObj || projectionObj, baseParams);\n  };\n  ImageWMS2.prototype.getLegendUrl = function(resolution, params2) {\n    if (this.url_ === void 0) {\n      return void 0;\n    }\n    var baseParams = {\n      \"SERVICE\": \"WMS\",\n      \"VERSION\": DEFAULT_WMS_VERSION,\n      \"REQUEST\": \"GetLegendGraphic\",\n      \"FORMAT\": \"image/png\"\n    };\n    if (params2 === void 0 || params2[\"LAYER\"] === void 0) {\n      var layers = this.params_.LAYERS;\n      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;\n      if (!isSingleLayer) {\n        return void 0;\n      }\n      baseParams[\"LAYER\"] = layers;\n    }\n    if (resolution !== void 0) {\n      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;\n      var pixelSize = 28e-5;\n      baseParams[\"SCALE\"] = resolution * mpu / pixelSize;\n    }\n    assign(baseParams, params2);\n    return appendParams(this.url_, baseParams);\n  };\n  ImageWMS2.prototype.getParams = function() {\n    return this.params_;\n  };\n  ImageWMS2.prototype.getImageInternal = function(extent2, resolution, pixelRatio, projection) {\n    if (this.url_ === void 0) {\n      return null;\n    }\n    resolution = this.findNearestResolution(resolution);\n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {\n      pixelRatio = 1;\n    }\n    var imageResolution = resolution / pixelRatio;\n    var center = getCenter(extent2);\n    var viewWidth = ceil$1(getWidth(extent2) / imageResolution, DECIMALS);\n    var viewHeight = ceil$1(getHeight(extent2) / imageResolution, DECIMALS);\n    var viewExtent = getForViewAndSize(center, imageResolution, 0, [\n      viewWidth,\n      viewHeight\n    ]);\n    var requestWidth = ceil$1(this.ratio_ * getWidth(extent2) / imageResolution, DECIMALS);\n    var requestHeight = ceil$1(this.ratio_ * getHeight(extent2) / imageResolution, DECIMALS);\n    var requestExtent = getForViewAndSize(center, imageResolution, 0, [\n      requestWidth,\n      requestHeight\n    ]);\n    var image2 = this.image_;\n    if (image2 && this.renderedRevision_ == this.getRevision() && image2.getResolution() == resolution && image2.getPixelRatio() == pixelRatio && containsExtent(image2.getExtent(), viewExtent)) {\n      return image2;\n    }\n    var params2 = {\n      \"SERVICE\": \"WMS\",\n      \"VERSION\": DEFAULT_WMS_VERSION,\n      \"REQUEST\": \"GetMap\",\n      \"FORMAT\": \"image/png\",\n      \"TRANSPARENT\": true\n    };\n    assign(params2, this.params_);\n    this.imageSize_[0] = round(getWidth(requestExtent) / imageResolution, DECIMALS);\n    this.imageSize_[1] = round(getHeight(requestExtent) / imageResolution, DECIMALS);\n    var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params2);\n    this.image_ = new ImageWrapper$1(requestExtent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);\n    this.renderedRevision_ = this.getRevision();\n    this.image_.addEventListener(EventType.CHANGE, this.handleImageChange.bind(this));\n    return this.image_;\n  };\n  ImageWMS2.prototype.getImageLoadFunction = function() {\n    return this.imageLoadFunction_;\n  };\n  ImageWMS2.prototype.getRequestUrl_ = function(extent2, size, pixelRatio, projection, params2) {\n    assert(this.url_ !== void 0, 9);\n    params2[this.v13_ ? \"CRS\" : \"SRS\"] = projection.getCode();\n    if (!(\"STYLES\" in this.params_)) {\n      params2[\"STYLES\"] = \"\";\n    }\n    if (pixelRatio != 1) {\n      switch (this.serverType_) {\n        case WMSServerType.GEOSERVER:\n          var dpi = 90 * pixelRatio + 0.5 | 0;\n          if (\"FORMAT_OPTIONS\" in params2) {\n            params2[\"FORMAT_OPTIONS\"] += \";dpi:\" + dpi;\n          } else {\n            params2[\"FORMAT_OPTIONS\"] = \"dpi:\" + dpi;\n          }\n          break;\n        case WMSServerType.MAPSERVER:\n          params2[\"MAP_RESOLUTION\"] = 90 * pixelRatio;\n          break;\n        case WMSServerType.CARMENTA_SERVER:\n        case WMSServerType.QGIS:\n          params2[\"DPI\"] = 90 * pixelRatio;\n          break;\n        default:\n          assert(false, 8);\n          break;\n      }\n    }\n    params2[\"WIDTH\"] = size[0];\n    params2[\"HEIGHT\"] = size[1];\n    var axisOrientation = projection.getAxisOrientation();\n    var bbox2;\n    if (this.v13_ && axisOrientation.substr(0, 2) == \"ne\") {\n      bbox2 = [extent2[1], extent2[0], extent2[3], extent2[2]];\n    } else {\n      bbox2 = extent2;\n    }\n    params2[\"BBOX\"] = bbox2.join(\",\");\n    return appendParams(this.url_, params2);\n  };\n  ImageWMS2.prototype.getUrl = function() {\n    return this.url_;\n  };\n  ImageWMS2.prototype.setImageLoadFunction = function(imageLoadFunction) {\n    this.image_ = null;\n    this.imageLoadFunction_ = imageLoadFunction;\n    this.changed();\n  };\n  ImageWMS2.prototype.setUrl = function(url) {\n    if (url != this.url_) {\n      this.url_ = url;\n      this.image_ = null;\n      this.changed();\n    }\n  };\n  ImageWMS2.prototype.updateParams = function(params2) {\n    assign(this.params_, params2);\n    this.updateV13_();\n    this.image_ = null;\n    this.changed();\n  };\n  ImageWMS2.prototype.updateV13_ = function() {\n    var version2 = this.params_[\"VERSION\"] || DEFAULT_WMS_VERSION;\n    this.v13_ = compareVersions(version2, \"1.3\") >= 0;\n  };\n  return ImageWMS2;\n}(ImageSource$1);\nvar ImageWMS$1 = ImageWMS;\nvar __extends$z = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar ATTRIBUTION = '&#169; <a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">OpenStreetMap</a> contributors.';\nvar OSM = function(_super) {\n  __extends$z(OSM2, _super);\n  function OSM2(opt_options) {\n    var options = opt_options || {};\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    var attributions;\n    if (options.attributions !== void 0) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ATTRIBUTION];\n    }\n    var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : \"anonymous\";\n    var url = options.url !== void 0 ? options.url : \"https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png\";\n    return _super.call(this, {\n      attributions,\n      attributionsCollapsible: false,\n      cacheSize: options.cacheSize,\n      crossOrigin,\n      interpolate,\n      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,\n      opaque: options.opaque !== void 0 ? options.opaque : true,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      transition: options.transition,\n      url,\n      wrapX: options.wrapX,\n      zDirection: options.zDirection\n    }) || this;\n  }\n  return OSM2;\n}(XYZ$1);\nvar OSM$1 = OSM;\nvar __extends$y = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TileWMS = function(_super) {\n  __extends$y(TileWMS2, _super);\n  function TileWMS2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    var params2 = options.params || {};\n    var transparent = \"TRANSPARENT\" in params2 ? params2[\"TRANSPARENT\"] : true;\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate,\n      opaque: !transparent,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== void 0 ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection\n    }) || this;\n    _this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;\n    _this.params_ = params2;\n    _this.v13_ = true;\n    _this.serverType_ = options.serverType;\n    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;\n    _this.tmpExtent_ = createEmpty();\n    _this.updateV13_();\n    _this.setKey(_this.getKeyForParams_());\n    return _this;\n  }\n  TileWMS2.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params2) {\n    var projectionObj = get$3(projection);\n    var sourceProjectionObj = this.getProjection();\n    var tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projectionObj);\n    }\n    var z2 = tileGrid.getZForResolution(resolution, this.zDirection);\n    var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z2);\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return void 0;\n    }\n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n    var gutter = this.gutter_;\n    if (gutter !== 0) {\n      tileSize = buffer(tileSize, gutter, this.tmpSize);\n      tileExtent = buffer$1(tileExtent, tileResolution * gutter, tileExtent);\n    }\n    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {\n      tileResolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);\n      tileExtent = transformExtent(tileExtent, projectionObj, sourceProjectionObj);\n      coordinate = transform$3(coordinate, projectionObj, sourceProjectionObj);\n    }\n    var baseParams = {\n      \"SERVICE\": \"WMS\",\n      \"VERSION\": DEFAULT_WMS_VERSION,\n      \"REQUEST\": \"GetFeatureInfo\",\n      \"FORMAT\": \"image/png\",\n      \"TRANSPARENT\": true,\n      \"QUERY_LAYERS\": this.params_[\"LAYERS\"]\n    };\n    assign(baseParams, this.params_, params2);\n    var x2 = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);\n    var y2 = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);\n    baseParams[this.v13_ ? \"I\" : \"X\"] = x2;\n    baseParams[this.v13_ ? \"J\" : \"Y\"] = y2;\n    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);\n  };\n  TileWMS2.prototype.getLegendUrl = function(resolution, params2) {\n    if (this.urls[0] === void 0) {\n      return void 0;\n    }\n    var baseParams = {\n      \"SERVICE\": \"WMS\",\n      \"VERSION\": DEFAULT_WMS_VERSION,\n      \"REQUEST\": \"GetLegendGraphic\",\n      \"FORMAT\": \"image/png\"\n    };\n    if (params2 === void 0 || params2[\"LAYER\"] === void 0) {\n      var layers = this.params_.LAYERS;\n      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;\n      if (!isSingleLayer) {\n        return void 0;\n      }\n      baseParams[\"LAYER\"] = layers;\n    }\n    if (resolution !== void 0) {\n      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;\n      var pixelSize = 28e-5;\n      baseParams[\"SCALE\"] = resolution * mpu / pixelSize;\n    }\n    assign(baseParams, params2);\n    return appendParams(this.urls[0], baseParams);\n  };\n  TileWMS2.prototype.getGutter = function() {\n    return this.gutter_;\n  };\n  TileWMS2.prototype.getParams = function() {\n    return this.params_;\n  };\n  TileWMS2.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent, pixelRatio, projection, params2) {\n    var urls = this.urls;\n    if (!urls) {\n      return void 0;\n    }\n    params2[\"WIDTH\"] = tileSize[0];\n    params2[\"HEIGHT\"] = tileSize[1];\n    params2[this.v13_ ? \"CRS\" : \"SRS\"] = projection.getCode();\n    if (!(\"STYLES\" in this.params_)) {\n      params2[\"STYLES\"] = \"\";\n    }\n    if (pixelRatio != 1) {\n      switch (this.serverType_) {\n        case WMSServerType.GEOSERVER:\n          var dpi = 90 * pixelRatio + 0.5 | 0;\n          if (\"FORMAT_OPTIONS\" in params2) {\n            params2[\"FORMAT_OPTIONS\"] += \";dpi:\" + dpi;\n          } else {\n            params2[\"FORMAT_OPTIONS\"] = \"dpi:\" + dpi;\n          }\n          break;\n        case WMSServerType.MAPSERVER:\n          params2[\"MAP_RESOLUTION\"] = 90 * pixelRatio;\n          break;\n        case WMSServerType.CARMENTA_SERVER:\n        case WMSServerType.QGIS:\n          params2[\"DPI\"] = 90 * pixelRatio;\n          break;\n        default:\n          assert(false, 52);\n          break;\n      }\n    }\n    var axisOrientation = projection.getAxisOrientation();\n    var bbox2 = tileExtent;\n    if (this.v13_ && axisOrientation.substr(0, 2) == \"ne\") {\n      var tmp = void 0;\n      tmp = tileExtent[0];\n      bbox2[0] = tileExtent[1];\n      bbox2[1] = tmp;\n      tmp = tileExtent[2];\n      bbox2[2] = tileExtent[3];\n      bbox2[3] = tmp;\n    }\n    params2[\"BBOX\"] = bbox2.join(\",\");\n    var url;\n    if (urls.length == 1) {\n      url = urls[0];\n    } else {\n      var index2 = modulo(hash(tileCoord), urls.length);\n      url = urls[index2];\n    }\n    return appendParams(url, params2);\n  };\n  TileWMS2.prototype.getTilePixelRatio = function(pixelRatio) {\n    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : pixelRatio;\n  };\n  TileWMS2.prototype.getKeyForParams_ = function() {\n    var i2 = 0;\n    var res = [];\n    for (var key in this.params_) {\n      res[i2++] = key + \"-\" + this.params_[key];\n    }\n    return res.join(\"/\");\n  };\n  TileWMS2.prototype.updateParams = function(params2) {\n    assign(this.params_, params2);\n    this.updateV13_();\n    this.setKey(this.getKeyForParams_());\n  };\n  TileWMS2.prototype.updateV13_ = function() {\n    var version2 = this.params_[\"VERSION\"] || DEFAULT_WMS_VERSION;\n    this.v13_ = compareVersions(version2, \"1.3\") >= 0;\n  };\n  TileWMS2.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {\n    var tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projection);\n    }\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return void 0;\n    }\n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {\n      pixelRatio = 1;\n    }\n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);\n    var gutter = this.gutter_;\n    if (gutter !== 0) {\n      tileSize = buffer(tileSize, gutter, this.tmpSize);\n      tileExtent = buffer$1(tileExtent, tileResolution * gutter, tileExtent);\n    }\n    if (pixelRatio != 1) {\n      tileSize = scale(tileSize, pixelRatio, this.tmpSize);\n    }\n    var baseParams = {\n      \"SERVICE\": \"WMS\",\n      \"VERSION\": DEFAULT_WMS_VERSION,\n      \"REQUEST\": \"GetMap\",\n      \"FORMAT\": \"image/png\",\n      \"TRANSPARENT\": true\n    };\n    assign(baseParams, this.params_);\n    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);\n  };\n  return TileWMS2;\n}(TileImage$1);\nvar ol_source_TileWMS = TileWMS;\nvar WMTSRequestEncoding = {\n  KVP: \"KVP\",\n  REST: \"REST\"\n};\nvar __extends$x = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar WMTSTileGrid = function(_super) {\n  __extends$x(WMTSTileGrid2, _super);\n  function WMTSTileGrid2(options) {\n    var _this = _super.call(this, {\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes\n    }) || this;\n    _this.matrixIds_ = options.matrixIds;\n    return _this;\n  }\n  WMTSTileGrid2.prototype.getMatrixId = function(z2) {\n    return this.matrixIds_[z2];\n  };\n  WMTSTileGrid2.prototype.getMatrixIds = function() {\n    return this.matrixIds_;\n  };\n  return WMTSTileGrid2;\n}(TileGrid$1);\nvar TileGridWMTS = WMTSTileGrid;\nvar __extends$w = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar WMTS = function(_super) {\n  __extends$w(WMTS2, _super);\n  function WMTS2(options) {\n    var _this = this;\n    var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;\n    if (options.interpolate !== void 0) {\n      interpolate = options.interpolate;\n    }\n    var requestEncoding = options.requestEncoding !== void 0 ? options.requestEncoding : WMTSRequestEncoding.KVP;\n    var tileGrid = options.tileGrid;\n    var urls = options.urls;\n    if (urls === void 0 && options.url !== void 0) {\n      urls = expandUrl(options.url);\n    }\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      urls,\n      wrapX: options.wrapX !== void 0 ? options.wrapX : false,\n      transition: options.transition,\n      zDirection: options.zDirection\n    }) || this;\n    _this.version_ = options.version !== void 0 ? options.version : \"1.0.0\";\n    _this.format_ = options.format !== void 0 ? options.format : \"image/jpeg\";\n    _this.dimensions_ = options.dimensions !== void 0 ? options.dimensions : {};\n    _this.layer_ = options.layer;\n    _this.matrixSet_ = options.matrixSet;\n    _this.style_ = options.style;\n    _this.requestEncoding_ = requestEncoding;\n    _this.setKey(_this.getKeyForDimensions_());\n    if (urls && urls.length > 0) {\n      _this.tileUrlFunction = createFromTileUrlFunctions(urls.map(_this.createFromWMTSTemplate.bind(_this)));\n    }\n    return _this;\n  }\n  WMTS2.prototype.setUrls = function(urls) {\n    this.urls = urls;\n    var key = urls.join(\"\\n\");\n    this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);\n  };\n  WMTS2.prototype.getDimensions = function() {\n    return this.dimensions_;\n  };\n  WMTS2.prototype.getFormat = function() {\n    return this.format_;\n  };\n  WMTS2.prototype.getLayer = function() {\n    return this.layer_;\n  };\n  WMTS2.prototype.getMatrixSet = function() {\n    return this.matrixSet_;\n  };\n  WMTS2.prototype.getRequestEncoding = function() {\n    return this.requestEncoding_;\n  };\n  WMTS2.prototype.getStyle = function() {\n    return this.style_;\n  };\n  WMTS2.prototype.getVersion = function() {\n    return this.version_;\n  };\n  WMTS2.prototype.getKeyForDimensions_ = function() {\n    var i2 = 0;\n    var res = [];\n    for (var key in this.dimensions_) {\n      res[i2++] = key + \"-\" + this.dimensions_[key];\n    }\n    return res.join(\"/\");\n  };\n  WMTS2.prototype.updateDimensions = function(dimensions) {\n    assign(this.dimensions_, dimensions);\n    this.setKey(this.getKeyForDimensions_());\n  };\n  WMTS2.prototype.createFromWMTSTemplate = function(template) {\n    var requestEncoding = this.requestEncoding_;\n    var context = {\n      \"layer\": this.layer_,\n      \"style\": this.style_,\n      \"tilematrixset\": this.matrixSet_\n    };\n    if (requestEncoding == WMTSRequestEncoding.KVP) {\n      assign(context, {\n        \"Service\": \"WMTS\",\n        \"Request\": \"GetTile\",\n        \"Version\": this.version_,\n        \"Format\": this.format_\n      });\n    }\n    template = requestEncoding == WMTSRequestEncoding.KVP ? appendParams(template, context) : template.replace(/\\{(\\w+?)\\}/g, function(m2, p5) {\n      return p5.toLowerCase() in context ? context[p5.toLowerCase()] : m2;\n    });\n    var tileGrid = this.tileGrid;\n    var dimensions = this.dimensions_;\n    return function(tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return void 0;\n      } else {\n        var localContext_1 = {\n          \"TileMatrix\": tileGrid.getMatrixId(tileCoord[0]),\n          \"TileCol\": tileCoord[1],\n          \"TileRow\": tileCoord[2]\n        };\n        assign(localContext_1, dimensions);\n        var url = template;\n        if (requestEncoding == WMTSRequestEncoding.KVP) {\n          url = appendParams(url, localContext_1);\n        } else {\n          url = url.replace(/\\{(\\w+?)\\}/g, function(m2, p5) {\n            return localContext_1[p5];\n          });\n        }\n        return url;\n      }\n    };\n  };\n  return WMTS2;\n}(TileImage$1);\nvar WMTSSource = WMTS;\nif (window.ol && !ol.ext) {\n  ol.ext = {};\n}\nvar ol_ext_inherits = function(child, parent) {\n  child.prototype = Object.create(parent.prototype);\n  child.prototype.constructor = child;\n};\nif (window.ol) {\n  if (!ol.inherits)\n    ol.inherits = ol_ext_inherits;\n}\nif (window.NodeList && !NodeList.prototype.forEach) {\n  NodeList.prototype.forEach = Array.prototype.forEach;\n}\nif (window.Element && !Element.prototype.remove) {\n  Element.prototype.remove = function() {\n    if (this.parentNode)\n      this.parentNode.removeChild(this);\n  };\n}\nfunction getVectorContext(event) {\n  const frameState = event.frameState;\n  const transform2 = multiply(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);\n  return new CanvasImmediateRenderer$1(event.context, frameState.pixelRatio, frameState.extent, transform2, frameState.viewState.rotation);\n}\nif (window.ol) {\n  if (!ol.util) {\n    ol.util = {\n      VERSION: ol.VERSION || \"5.3.0\"\n    };\n  } else if (!ol.util.VERSION) {\n    ol.util.VERSION = ol.VERSION || \"6.1.0\";\n  }\n}\nvar ol_ext_olVersion = VERSION.split(\".\");\nol_ext_olVersion = parseInt(ol_ext_olVersion[0]) * 100 + parseInt(ol_ext_olVersion[1]);\nvar ol_ext_getVectorContextStyle = function(e2, s2) {\n  var ratio = e2.frameState.pixelRatio;\n  if (ol_ext_olVersion > 605 && ratio !== 1 && s2.getImage() instanceof Icon$2) {\n    s2 = s2.clone();\n    var img = s2.getImage();\n    img.setScale(img.getScale() * ratio);\n    var anchor = img.getAnchor();\n    if (img.setDisplacement) {\n      var disp = img.getDisplacement();\n      if (disp) {\n        disp[0] -= anchor[0] / ratio;\n        disp[1] += anchor[1] / ratio;\n        img.setAnchor([0, 0]);\n      }\n    } else {\n      if (anchor) {\n        anchor[0] /= ratio;\n        anchor[1] /= ratio;\n      }\n    }\n  }\n  return s2;\n};\nvar ol_layer_AnimatedCluster = function(opt_options) {\n  var options = opt_options || {};\n  ol_layer_Vector.call(this, options);\n  this.oldcluster = new ol_source_Vector();\n  this.clusters = [];\n  this.animation = { start: false };\n  this.set(\"animationDuration\", typeof options.animationDuration == \"number\" ? options.animationDuration : 700);\n  this.set(\"animationMethod\", options.animationMethod || easeOut);\n  this.getSource().on(\"change\", this.saveCluster.bind(this));\n  this.on([\"precompose\", \"prerender\"], this.animate.bind(this));\n  this.on([\"postcompose\", \"postrender\"], this.postanimate.bind(this));\n};\nol_ext_inherits(ol_layer_AnimatedCluster, ol_layer_Vector);\nol_layer_AnimatedCluster.prototype.saveCluster = function() {\n  if (this.oldcluster) {\n    this.oldcluster.clear();\n    if (!this.get(\"animationDuration\"))\n      return;\n    var features = this.getSource().getFeatures();\n    if (features.length && features[0].get(\"features\")) {\n      this.oldcluster.addFeatures(this.clusters);\n      this.clusters = features.slice(0);\n      this.sourceChanged = true;\n    }\n  }\n};\nol_layer_AnimatedCluster.prototype.getClusterForFeature = function(f2, cluster) {\n  for (var j2 = 0, c2; c2 = cluster[j2]; j2++) {\n    var features = c2.get(\"features\");\n    if (features && features.length) {\n      for (var k2 = 0, f22; f22 = features[k2]; k2++) {\n        if (f2 === f22) {\n          return c2;\n        }\n      }\n    }\n  }\n  return false;\n};\nol_layer_AnimatedCluster.prototype.stopAnimation = function() {\n  this.animation.start = false;\n  this.animation.cA = [];\n  this.animation.cB = [];\n};\nol_layer_AnimatedCluster.prototype.animate = function(e2) {\n  var duration2 = this.get(\"animationDuration\");\n  if (!duration2)\n    return;\n  var resolution = e2.frameState.viewState.resolution;\n  var i2, c0, a2 = this.animation;\n  var time2 = e2.frameState.time;\n  if (a2.resolution != resolution && this.sourceChanged) {\n    var extent2 = e2.frameState.extent;\n    if (a2.resolution < resolution) {\n      extent2 = buffer$1(extent2, 100 * resolution);\n      a2.cA = this.oldcluster.getFeaturesInExtent(extent2);\n      a2.cB = this.getSource().getFeaturesInExtent(extent2);\n      a2.revers = false;\n    } else {\n      extent2 = buffer$1(extent2, 100 * resolution);\n      a2.cA = this.getSource().getFeaturesInExtent(extent2);\n      a2.cB = this.oldcluster.getFeaturesInExtent(extent2);\n      a2.revers = true;\n    }\n    a2.clusters = [];\n    for (i2 = 0, c0; c0 = a2.cA[i2]; i2++) {\n      var f2 = c0.get(\"features\");\n      if (f2 && f2.length) {\n        var c2 = this.getClusterForFeature(f2[0], a2.cB);\n        if (c2)\n          a2.clusters.push({ f: c0, pt: c2.getGeometry().getCoordinates() });\n      }\n    }\n    a2.resolution = resolution;\n    this.sourceChanged = false;\n    if (!a2.clusters.length || a2.clusters.length > 1e3) {\n      this.stopAnimation();\n      return;\n    }\n    time2 = a2.start = new Date().getTime();\n  }\n  if (a2.start) {\n    var vectorContext = e2.vectorContext || getVectorContext(e2);\n    var d2 = (time2 - a2.start) / duration2;\n    if (d2 > 1) {\n      this.stopAnimation();\n      d2 = 1;\n    }\n    d2 = this.get(\"animationMethod\")(d2);\n    var style2 = this.getStyle();\n    var stylefn = typeof style2 == \"function\" ? style2 : style2.length ? function() {\n      return style2;\n    } : function() {\n      return [style2];\n    };\n    e2.context.save();\n    e2.context.globalAlpha = this.getOpacity();\n    for (i2 = 0, c2; c2 = a2.clusters[i2]; i2++) {\n      var pt2 = c2.f.getGeometry().getCoordinates();\n      var dx = pt2[0] - c2.pt[0];\n      var dy = pt2[1] - c2.pt[1];\n      if (a2.revers) {\n        pt2[0] = c2.pt[0] + d2 * dx;\n        pt2[1] = c2.pt[1] + d2 * dy;\n      } else {\n        pt2[0] = pt2[0] - d2 * dx;\n        pt2[1] = pt2[1] - d2 * dy;\n      }\n      var st2 = stylefn(c2.f, resolution, true);\n      if (!st2.length)\n        st2 = [st2];\n      if (c2.f.get(\"features\").length === 1 && !dx && !dy) {\n        f2 = c2.f.get(\"features\")[0];\n      } else {\n        var geo = new Point$4(pt2);\n        f2 = new feature(geo);\n      }\n      for (var k2 = 0, s2; s2 = st2[k2]; k2++) {\n        if (s2.getText() && /\\n/.test(s2.getText().getText())) {\n          var offsetX = s2.getText().getOffsetX();\n          var offsetY = s2.getText().getOffsetY();\n          var rot = s2.getText().getRotation() || 0;\n          var fontSize2 = Number((s2.getText().getFont() || \"10px\").match(/\\d+/)) * 1.2;\n          var str = s2.getText().getText().split(\"\\n\");\n          var dl, nb = str.length - 1;\n          var s22 = s2.clone();\n          str.forEach(function(t3, i3) {\n            if (i3 == 1) {\n              s22.setImage();\n              s22.setFill();\n              s22.setStroke();\n            }\n            switch (s2.getText().getTextBaseline()) {\n              case \"alphabetic\":\n              case \"ideographic\":\n              case \"bottom\": {\n                dl = nb;\n                break;\n              }\n              case \"hanging\":\n              case \"top\": {\n                dl = 0;\n                break;\n              }\n              default: {\n                dl = nb / 2;\n                break;\n              }\n            }\n            s22.getText().setOffsetX(offsetX - Math.sin(rot) * fontSize2 * (i3 - dl));\n            s22.getText().setOffsetY(offsetY + Math.cos(rot) * fontSize2 * (i3 - dl));\n            s22.getText().setText(t3);\n            vectorContext.drawFeature(f2, ol_ext_getVectorContextStyle(e2, s22));\n          });\n        } else {\n          vectorContext.drawFeature(f2, ol_ext_getVectorContextStyle(e2, s2));\n        }\n      }\n    }\n    e2.context.restore();\n    e2.frameState.animate = true;\n    e2.context.save();\n    e2.context.beginPath();\n    e2.context.rect(0, 0, 0, 0);\n    e2.context.clip();\n    this.clip_ = true;\n  }\n  return;\n};\nol_layer_AnimatedCluster.prototype.postanimate = function(e2) {\n  if (this.clip_) {\n    e2.context.restore();\n    this.clip_ = false;\n  }\n};\nconst _sfc_main$W = {\n  extends: BaseLayer,\n  name: \"ol-animated-clusterlayer\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const vectorLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let ac = new ol_layer_AnimatedCluster(__spreadProps(__spreadValues({}, properties), {\n        source: new Cluster$1({\n          distance: properties.distance,\n          geometryFunction: (feature2) => feature2.getGeometry()\n        })\n      }));\n      return ac;\n    });\n    const source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => vectorLayer.value.getSource());\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      vectorLayer.value.setProperties(properties);\n      vectorLayer.value.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addLayer(vectorLayer.value);\n      vectorLayer.value.changed();\n      map.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeLayer(vectorLayer.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"vectorLayer\", source);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"stylable\", vectorLayer);\n    return {\n      vectorLayer,\n      map\n    };\n  },\n  props: {\n    animationDuration: {\n      type: Number,\n      default: 700\n    },\n    distance: {\n      type: Number,\n      default: 20\n    },\n    animationMethod: {\n      type: Function,\n      default: easeOut\n    },\n    updateWhileAnimating: {\n      type: Boolean,\n      default: false\n    },\n    updateWhileInteracting: {\n      type: Boolean,\n      default: false\n    }\n  }\n};\nfunction _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar AnimatedClusterLayer = /* @__PURE__ */ _export_sfc(_sfc_main$W, [[\"render\", _sfc_render$W]]);\nvar tmpArray4 = new Uint8Array(4);\nvar WebGLRenderTarget = function() {\n  function WebGLRenderTarget2(helper, opt_size) {\n    this.helper_ = helper;\n    var gl = helper.getGL();\n    this.texture_ = gl.createTexture();\n    this.framebuffer_ = gl.createFramebuffer();\n    this.size_ = opt_size || [1, 1];\n    this.data_ = new Uint8Array(0);\n    this.dataCacheDirty_ = true;\n    this.updateSize_();\n  }\n  WebGLRenderTarget2.prototype.setSize = function(size) {\n    if (equals$2(size, this.size_)) {\n      return;\n    }\n    this.size_[0] = size[0];\n    this.size_[1] = size[1];\n    this.updateSize_();\n  };\n  WebGLRenderTarget2.prototype.getSize = function() {\n    return this.size_;\n  };\n  WebGLRenderTarget2.prototype.clearCachedData = function() {\n    this.dataCacheDirty_ = true;\n  };\n  WebGLRenderTarget2.prototype.readAll = function() {\n    if (this.dataCacheDirty_) {\n      var size = this.size_;\n      var gl = this.helper_.getGL();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n      gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);\n      this.dataCacheDirty_ = false;\n    }\n    return this.data_;\n  };\n  WebGLRenderTarget2.prototype.readPixel = function(x2, y2) {\n    if (x2 < 0 || y2 < 0 || x2 > this.size_[0] || y2 >= this.size_[1]) {\n      tmpArray4[0] = 0;\n      tmpArray4[1] = 0;\n      tmpArray4[2] = 0;\n      tmpArray4[3] = 0;\n      return tmpArray4;\n    }\n    this.readAll();\n    var index2 = Math.floor(x2) + (this.size_[1] - Math.floor(y2) - 1) * this.size_[0];\n    tmpArray4[0] = this.data_[index2 * 4];\n    tmpArray4[1] = this.data_[index2 * 4 + 1];\n    tmpArray4[2] = this.data_[index2 * 4 + 2];\n    tmpArray4[3] = this.data_[index2 * 4 + 3];\n    return tmpArray4;\n  };\n  WebGLRenderTarget2.prototype.getTexture = function() {\n    return this.texture_;\n  };\n  WebGLRenderTarget2.prototype.getFramebuffer = function() {\n    return this.framebuffer_;\n  };\n  WebGLRenderTarget2.prototype.updateSize_ = function() {\n    var size = this.size_;\n    var gl = this.helper_.getGL();\n    this.texture_ = this.helper_.createTexture(size, null, this.texture_);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);\n    this.data_ = new Uint8Array(size[0] * size[1] * 4);\n  };\n  return WebGLRenderTarget2;\n}();\nvar WebGLRenderTarget$1 = WebGLRenderTarget;\nfunction create$4() {\n  var source = 'var e=\"function\"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError(\"Cannot convert undefined or null to object\");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n=\"GENERATE_BUFFERS\",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,a){var u=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=a?a.vertexPosition:0,h=a?a.indexPosition:0,d=b/u;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=u,l,v,1),c.length&&i.set(c,b+3),o(i,b+=u,l,v,2),c.length&&i.set(c,b+3),o(i,b+=u,l,v,3),c.length&&i.set(c,b+3),b+=u,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o,s=r.customAttributesCount,a=2+s,u=new Float32Array(r.renderInstructions),l=u.length/a,v=4*l*(s+3),c=new Uint32Array(6*l),g=new Float32Array(v),b=0;b<u.length;b+=a)o=i(u,b,g,c,s,o);var h=e({vertexBuffer:g.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[g.buffer,c.buffer,u.buffer])}};';\n  return new Worker(typeof Blob === \"undefined\" ? \"data:application/javascript;base64,\" + Buffer.from(source, \"binary\").toString(\"base64\") : URL.createObjectURL(new Blob([source], { type: \"application/javascript\" })));\n}\nvar __extends$v = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar WebGLPointsLayerRenderer = function(_super) {\n  __extends$v(WebGLPointsLayerRenderer2, _super);\n  function WebGLPointsLayerRenderer2(layer, options) {\n    var _this = this;\n    var uniforms = options.uniforms || {};\n    var projectionMatrixTransform = create$6();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n    _this = _super.call(this, layer, {\n      uniforms,\n      postProcesses: options.postProcesses\n    }) || this;\n    _this.ready = false;\n    _this.sourceRevision_ = -1;\n    _this.verticesBuffer_ = new WebGLArrayBuffer$1(ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.hitVerticesBuffer_ = new WebGLArrayBuffer$1(ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.indicesBuffer_ = new WebGLArrayBuffer$1(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.vertexShader_ = options.vertexShader;\n    _this.fragmentShader_ = options.fragmentShader;\n    _this.program_;\n    _this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;\n    _this.hitVertexShader_ = options.hitVertexShader;\n    _this.hitFragmentShader_ = options.hitFragmentShader;\n    _this.hitProgram_;\n    var customAttributes = options.attributes ? options.attributes.map(function(attribute) {\n      return {\n        name: \"a_\" + attribute.name,\n        size: 1,\n        type: AttributeType.FLOAT\n      };\n    }) : [];\n    _this.attributes = [\n      {\n        name: \"a_position\",\n        size: 2,\n        type: AttributeType.FLOAT\n      },\n      {\n        name: \"a_index\",\n        size: 1,\n        type: AttributeType.FLOAT\n      }\n    ].concat(customAttributes);\n    _this.hitDetectionAttributes = [\n      {\n        name: \"a_position\",\n        size: 2,\n        type: AttributeType.FLOAT\n      },\n      {\n        name: \"a_index\",\n        size: 1,\n        type: AttributeType.FLOAT\n      },\n      {\n        name: \"a_hitColor\",\n        size: 4,\n        type: AttributeType.FLOAT\n      },\n      {\n        name: \"a_featureUid\",\n        size: 1,\n        type: AttributeType.FLOAT\n      }\n    ].concat(customAttributes);\n    _this.customAttributes = options.attributes ? options.attributes : [];\n    _this.previousExtent_ = createEmpty();\n    _this.currentTransform_ = projectionMatrixTransform;\n    _this.renderTransform_ = create$6();\n    _this.invertRenderTransform_ = create$6();\n    _this.renderInstructions_ = new Float32Array(0);\n    _this.hitRenderInstructions_ = new Float32Array(0);\n    _this.hitRenderTarget_;\n    _this.generateBuffersRun_ = 0;\n    _this.worker_ = create$4();\n    _this.worker_.addEventListener(\"message\", function(event) {\n      var received = event.data;\n      if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n        var projectionTransform = received.projectionTransform;\n        if (received.hitDetection) {\n          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.hitVerticesBuffer_);\n        } else {\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n        }\n        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n        this.helper.flushBufferData(this.indicesBuffer_);\n        this.renderTransform_ = projectionTransform;\n        makeInverse(this.invertRenderTransform_, this.renderTransform_);\n        if (received.hitDetection) {\n          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n        } else {\n          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n          if (received.generateBuffersRun === this.generateBuffersRun_) {\n            this.ready = true;\n          }\n        }\n        this.getLayer().changed();\n      }\n    }.bind(_this));\n    _this.featureCache_ = {};\n    _this.featureCount_ = 0;\n    var source = _this.getLayer().getSource();\n    _this.sourceListenKeys_ = [\n      listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n      listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n      listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n      listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this)\n    ];\n    source.forEachFeature(function(feature2) {\n      this.featureCache_[getUid(feature2)] = {\n        feature: feature2,\n        properties: feature2.getProperties(),\n        geometry: feature2.getGeometry()\n      };\n      this.featureCount_++;\n    }.bind(_this));\n    return _this;\n  }\n  WebGLPointsLayerRenderer2.prototype.afterHelperCreated = function() {\n    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    if (this.hitDetectionEnabled_) {\n      this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);\n      this.hitRenderTarget_ = new WebGLRenderTarget$1(this.helper);\n    }\n  };\n  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureAdded_ = function(event) {\n    var feature2 = event.feature;\n    this.featureCache_[getUid(feature2)] = {\n      feature: feature2,\n      properties: feature2.getProperties(),\n      geometry: feature2.getGeometry()\n    };\n    this.featureCount_++;\n  };\n  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureChanged_ = function(event) {\n    var feature2 = event.feature;\n    this.featureCache_[getUid(feature2)] = {\n      feature: feature2,\n      properties: feature2.getProperties(),\n      geometry: feature2.getGeometry()\n    };\n  };\n  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureDelete_ = function(event) {\n    var feature2 = event.feature;\n    delete this.featureCache_[getUid(feature2)];\n    this.featureCount_--;\n  };\n  WebGLPointsLayerRenderer2.prototype.handleSourceFeatureClear_ = function() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  };\n  WebGLPointsLayerRenderer2.prototype.renderFrame = function(frameState) {\n    var gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    var renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    var canvas = this.helper.getCanvas();\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState);\n      this.hitRenderTarget_.clearCachedData();\n    }\n    this.postRender(gl, frameState);\n    return canvas;\n  };\n  WebGLPointsLayerRenderer2.prototype.prepareFrameInternal = function(frameState) {\n    var layer = this.getLayer();\n    var vectorSource = layer.getSource();\n    var viewState = frameState.viewState;\n    var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];\n    var extentChanged = !equals$1(this.previousExtent_, frameState.extent);\n    var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      var projection = viewState.projection;\n      var resolution = viewState.resolution;\n      var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      var extent2 = buffer$1(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent2, resolution, projection);\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n    this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n    multiply(this.currentTransform_, this.invertRenderTransform_);\n    this.helper.useProgram(this.program_);\n    this.helper.prepareDraw(frameState);\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n    return true;\n  };\n  WebGLPointsLayerRenderer2.prototype.rebuildBuffers_ = function(frameState) {\n    var projectionTransform = create$6();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n    var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n    if (this.hitDetectionEnabled_) {\n      var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n      }\n    }\n    var featureCache, geometry;\n    var tmpCoords = [];\n    var tmpColor = [];\n    var renderIndex = 0;\n    var hitIndex = 0;\n    var hitColor;\n    for (var featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = featureCache.geometry;\n      if (!geometry || geometry.getType() !== GeometryType.POINT) {\n        continue;\n      }\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      apply$5(projectionTransform, tmpCoords);\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1];\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      }\n      var value = void 0;\n      for (var j2 = 0; j2 < this.customAttributes.length; j2++) {\n        value = this.customAttributes[j2].callback(featureCache.feature, featureCache.properties);\n        this.renderInstructions_[renderIndex++] = value;\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n    var message = {\n      type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesCount: this.customAttributes.length\n    };\n    message[\"projectionTransform\"] = projectionTransform;\n    message[\"generateBuffersRun\"] = ++this.generateBuffersRun_;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n    if (this.hitDetectionEnabled_) {\n      var hitMessage = {\n        type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesCount: 5 + this.customAttributes.length\n      };\n      hitMessage[\"projectionTransform\"] = projectionTransform;\n      hitMessage[\"hitDetection\"] = true;\n      this.worker_.postMessage(hitMessage, [\n        this.hitRenderInstructions_.buffer\n      ]);\n      this.hitRenderInstructions_ = null;\n    }\n  };\n  WebGLPointsLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {\n    assert(this.hitDetectionEnabled_, 66);\n    if (!this.hitRenderInstructions_) {\n      return void 0;\n    }\n    var pixel = apply$5(frameState.coordinateToPixelTransform, coordinate.slice());\n    var data2 = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    var color2 = [data2[0] / 255, data2[1] / 255, data2[2] / 255, data2[3] / 255];\n    var index2 = colorDecodeId(color2);\n    var opacity2 = this.hitRenderInstructions_[index2];\n    var uid2 = Math.floor(opacity2).toString();\n    var source = this.getLayer().getSource();\n    var feature2 = source.getFeatureByUid(uid2);\n    if (feature2) {\n      return callback(feature2, this.getLayer(), null);\n    }\n    return void 0;\n  };\n  WebGLPointsLayerRenderer2.prototype.renderHitDetection = function(frameState) {\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n    this.hitRenderTarget_.setSize([\n      Math.floor(frameState.size[0] / 2),\n      Math.floor(frameState.size[1] / 2)\n    ]);\n    this.helper.useProgram(this.hitProgram_);\n    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n    var renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n  };\n  WebGLPointsLayerRenderer2.prototype.disposeInternal = function() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function(key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    _super.prototype.disposeInternal.call(this);\n  };\n  return WebGLPointsLayerRenderer2;\n}(WebGLLayerRenderer$1);\nvar WebGLPointsLayerRenderer$1 = WebGLPointsLayerRenderer;\nvar ShaderBuilder = function() {\n  function ShaderBuilder2() {\n    this.uniforms = [];\n    this.attributes = [];\n    this.varyings = [];\n    this.sizeExpression = \"vec2(1.0)\";\n    this.rotationExpression = \"0.0\";\n    this.offsetExpression = \"vec2(0.0)\";\n    this.colorExpression = \"vec4(1.0)\";\n    this.texCoordExpression = \"vec4(0.0, 0.0, 1.0, 1.0)\";\n    this.discardExpression = \"false\";\n    this.rotateWithView = false;\n  }\n  ShaderBuilder2.prototype.addUniform = function(name) {\n    this.uniforms.push(name);\n    return this;\n  };\n  ShaderBuilder2.prototype.addAttribute = function(name) {\n    this.attributes.push(name);\n    return this;\n  };\n  ShaderBuilder2.prototype.addVarying = function(name, type, expression) {\n    this.varyings.push({\n      name,\n      type,\n      expression\n    });\n    return this;\n  };\n  ShaderBuilder2.prototype.setSizeExpression = function(expression) {\n    this.sizeExpression = expression;\n    return this;\n  };\n  ShaderBuilder2.prototype.setRotationExpression = function(expression) {\n    this.rotationExpression = expression;\n    return this;\n  };\n  ShaderBuilder2.prototype.setSymbolOffsetExpression = function(expression) {\n    this.offsetExpression = expression;\n    return this;\n  };\n  ShaderBuilder2.prototype.setColorExpression = function(expression) {\n    this.colorExpression = expression;\n    return this;\n  };\n  ShaderBuilder2.prototype.setTextureCoordinateExpression = function(expression) {\n    this.texCoordExpression = expression;\n    return this;\n  };\n  ShaderBuilder2.prototype.setFragmentDiscardExpression = function(expression) {\n    this.discardExpression = expression;\n    return this;\n  };\n  ShaderBuilder2.prototype.setSymbolRotateWithView = function(rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  };\n  ShaderBuilder2.prototype.getSizeExpression = function() {\n    return this.sizeExpression;\n  };\n  ShaderBuilder2.prototype.getOffsetExpression = function() {\n    return this.offsetExpression;\n  };\n  ShaderBuilder2.prototype.getColorExpression = function() {\n    return this.colorExpression;\n  };\n  ShaderBuilder2.prototype.getTextureCoordinateExpression = function() {\n    return this.texCoordExpression;\n  };\n  ShaderBuilder2.prototype.getFragmentDiscardExpression = function() {\n    return this.discardExpression;\n  };\n  ShaderBuilder2.prototype.getSymbolVertexShader = function(forHitDetection) {\n    var offsetMatrix = this.rotateWithView ? \"u_offsetScaleMatrix * u_offsetRotateMatrix\" : \"u_offsetScaleMatrix\";\n    var attributes = this.attributes;\n    var varyings = this.varyings;\n    if (forHitDetection) {\n      attributes = attributes.concat(\"vec4 a_hitColor\");\n      varyings = varyings.concat({\n        name: \"v_hitColor\",\n        type: \"vec4\",\n        expression: \"a_hitColor\"\n      });\n    }\n    return \"precision mediump float;\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\".concat(this.uniforms.map(function(uniform) {\n      return \"uniform \" + uniform + \";\";\n    }).join(\"\\n\"), \"\\nattribute vec2 a_position;\\nattribute float a_index;\\n\").concat(attributes.map(function(attribute) {\n      return \"attribute \" + attribute + \";\";\n    }).join(\"\\n\"), \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\").concat(varyings.map(function(varying) {\n      return \"varying \" + varying.type + \" \" + varying.name + \";\";\n    }).join(\"\\n\"), \"\\nvoid main(void) {\\n  mat4 offsetMatrix = \").concat(offsetMatrix, \";\\n  vec2 halfSize = \").concat(this.sizeExpression, \" * 0.5;\\n  vec2 offset = \").concat(this.offsetExpression, \";\\n  float angle = \").concat(this.rotationExpression, \";\\n  float offsetX;\\n  float offsetY;\\n  if (a_index == 0.0) {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  } else if (a_index == 1.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else if (a_index == 2.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  }\\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  vec4 texCoord = \").concat(this.texCoordExpression, \";\\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\\n  v_texCoord = vec2(u, v);\\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v_quadCoord = vec2(u, v);\\n\").concat(varyings.map(function(varying) {\n      return \"  \" + varying.name + \" = \" + varying.expression + \";\";\n    }).join(\"\\n\"), \"\\n}\");\n  };\n  ShaderBuilder2.prototype.getSymbolFragmentShader = function(forHitDetection) {\n    var hitDetectionBypass = forHitDetection ? \"  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;\" : \"\";\n    var varyings = this.varyings;\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: \"v_hitColor\",\n        type: \"vec4\",\n        expression: \"a_hitColor\"\n      });\n    }\n    return \"precision mediump float;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\".concat(this.uniforms.map(function(uniform) {\n      return \"uniform \" + uniform + \";\";\n    }).join(\"\\n\"), \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\").concat(varyings.map(function(varying) {\n      return \"varying \" + varying.type + \" \" + varying.name + \";\";\n    }).join(\"\\n\"), \"\\nvoid main(void) {\\n  if (\").concat(this.discardExpression, \") { discard; }\\n  gl_FragColor = \").concat(this.colorExpression, \";\\n  gl_FragColor.rgb *= gl_FragColor.a;\\n\").concat(hitDetectionBypass, \"\\n}\");\n  };\n  return ShaderBuilder2;\n}();\nfunction parseLiteralStyle(style2) {\n  var symbStyle = style2.symbol;\n  var size = symbStyle.size !== void 0 ? symbStyle.size : 1;\n  var color2 = symbStyle.color || \"white\";\n  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  var offset2 = symbStyle.offset || [0, 0];\n  var opacity2 = symbStyle.opacity !== void 0 ? symbStyle.opacity : 1;\n  var rotation = symbStyle.rotation !== void 0 ? symbStyle.rotation : 0;\n  var vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {}\n  };\n  var parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n  var parsedOffset = expressionToGlsl(vertContext, offset2, ValueTypes.NUMBER_ARRAY);\n  var parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);\n  var parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);\n  var fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {}\n  };\n  var parsedColor = expressionToGlsl(fragContext, color2, ValueTypes.COLOR);\n  var parsedOpacity = expressionToGlsl(fragContext, opacity2, ValueTypes.NUMBER);\n  var opacityFilter = \"1.0\";\n  var visibleSize = \"vec2(\".concat(expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER), \").x\");\n  switch (symbStyle.symbolType) {\n    case \"square\":\n      break;\n    case \"image\":\n      break;\n    case \"circle\":\n      opacityFilter = \"(1.0-smoothstep(1.-4./\".concat(visibleSize, \",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))\");\n      break;\n    case \"triangle\":\n      var st2 = \"(v_quadCoord*2.-1.)\";\n      var a2 = \"(atan(\".concat(st2, \".x,\").concat(st2, \".y))\");\n      opacityFilter = \"(1.0-smoothstep(.5-3./\".concat(visibleSize, \",.5,cos(floor(.5+\").concat(a2, \"/2.094395102)*2.094395102-\").concat(a2, \")*length(\").concat(st2, \")))\");\n      break;\n    default:\n      throw new Error(\"Unexpected symbol type: \" + symbStyle.symbolType);\n  }\n  var builder = new ShaderBuilder().setSizeExpression(\"vec2(\".concat(parsedSize, \")\")).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(\"vec4(\".concat(parsedColor, \".rgb, \").concat(parsedColor, \".a * \").concat(parsedOpacity, \" * \").concat(opacityFilter, \")\"));\n  if (style2.filter) {\n    var parsedFilter = expressionToGlsl(fragContext, style2.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(\"!\".concat(parsedFilter));\n  }\n  var uniforms = {};\n  fragContext.variables.forEach(function(varName) {\n    var uniformName = uniformNameForVariable(varName);\n    builder.addUniform(\"float \".concat(uniformName));\n    uniforms[uniformName] = function() {\n      if (!style2.variables || style2.variables[varName] === void 0) {\n        throw new Error(\"The following variable is missing from the style: \".concat(varName));\n      }\n      var value = style2.variables[varName];\n      if (typeof value === \"string\") {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n      return value !== void 0 ? value : -9999999;\n    };\n  });\n  if (symbStyle.symbolType === \"image\" && symbStyle.src) {\n    var texture = new Image();\n    texture.crossOrigin = symbStyle.crossOrigin === void 0 ? \"anonymous\" : symbStyle.crossOrigin;\n    texture.src = symbStyle.src;\n    builder.addUniform(\"sampler2D u_texture\").setColorExpression(builder.getColorExpression() + \" * texture2D(u_texture, v_texCoord)\");\n    uniforms[\"u_texture\"] = texture;\n  }\n  fragContext.attributes.forEach(function(attrName) {\n    if (vertContext.attributes.indexOf(attrName) === -1) {\n      vertContext.attributes.push(attrName);\n    }\n    builder.addVarying(\"v_\".concat(attrName), \"float\", \"a_\".concat(attrName));\n  });\n  vertContext.attributes.forEach(function(attrName) {\n    builder.addAttribute(\"float a_\".concat(attrName));\n  });\n  return {\n    builder,\n    attributes: vertContext.attributes.map(function(attributeName) {\n      return {\n        name: attributeName,\n        callback: function(feature2, props) {\n          var value = props[attributeName];\n          if (typeof value === \"string\") {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n          return value !== void 0 ? value : -9999999;\n        }\n      };\n    }),\n    uniforms\n  };\n}\nvar __extends$u = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar WebGLPointsLayer = function(_super) {\n  __extends$u(WebGLPointsLayer2, _super);\n  function WebGLPointsLayer2(options) {\n    var _this = this;\n    var baseOptions = assign({}, options);\n    _this = _super.call(this, baseOptions) || this;\n    _this.parseResult_ = parseLiteralStyle(options.style);\n    _this.styleVariables_ = options.style.variables || {};\n    _this.hitDetectionDisabled_ = !!options.disableHitDetection;\n    return _this;\n  }\n  WebGLPointsLayer2.prototype.createRenderer = function() {\n    return new WebGLPointsLayerRenderer$1(this, {\n      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),\n      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),\n      hitVertexShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolVertexShader(true),\n      hitFragmentShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolFragmentShader(true),\n      uniforms: this.parseResult_.uniforms,\n      attributes: this.parseResult_.attributes\n    });\n  };\n  WebGLPointsLayer2.prototype.updateStyleVariables = function(variables) {\n    assign(this.styleVariables_, variables);\n    this.changed();\n  };\n  return WebGLPointsLayer2;\n}(ol_layer_Base);\nvar WebGLPointsLayer$1 = WebGLPointsLayer;\nconst _sfc_main$V = {\n  extends: BaseLayer,\n  name: \"ol-webglpoints-layer\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const webglPointsLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new WebGLPointsLayer$1(properties));\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      webglPointsLayer.value.setProperties(properties);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addLayer(webglPointsLayer.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeLayer(webglPointsLayer.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"webglPointsLayer\", webglPointsLayer);\n    return {\n      webglPointsLayer\n    };\n  },\n  props: {\n    disableHitDetection: {\n      type: Boolean,\n      default: false\n    },\n    style: {\n      type: Object,\n      default: () => ({\n        symbol: {\n          symbolType: \"circle\",\n          size: 8,\n          color: \"#33AAFF\",\n          opacity: 0.9\n        }\n      })\n    }\n  }\n};\nfunction _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar WebglPointsLayer = /* @__PURE__ */ _export_sfc(_sfc_main$V, [[\"render\", _sfc_render$V]]);\nfunction install$7(app) {\n  if (install$7.installed) {\n    return;\n  }\n  install$7.installed = true;\n  app.component(TileLayer$1.name, TileLayer$1);\n  app.component(WebGLTileLayer.name, WebGLTileLayer);\n  app.component(ImageLayer.name, ImageLayer);\n  app.component(VectorLayer.name, VectorLayer);\n  app.component(AnimatedClusterLayer.name, AnimatedClusterLayer);\n  app.component(WebglPointsLayer.name, WebglPointsLayer);\n}\nvar Layers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": install$7,\n  install: install$7,\n  TileLayer: TileLayer$1,\n  WebGLTileLayer,\n  ImageLayer,\n  VectorLayer,\n  AnimatedClusterLayer,\n  WebglPointsLayer\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst _sfc_main$U = {\n  name: \"ol-source-xyz\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"tileLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new XYZ$1(properties));\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(source, () => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(layer, () => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.value.setSource(null);\n    });\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    attributions: {\n      type: [String, Array]\n    },\n    url: {\n      type: String\n    },\n    cacheSize: {\n      type: Number,\n      default: 2048\n    },\n    crossOrigin: {\n      type: String\n    },\n    maxZoom: {\n      type: Number,\n      default: 28\n    },\n    minZoom: {\n      type: Number,\n      default: 0\n    },\n    opaque: {\n      type: Boolean\n    },\n    projection: {\n      type: String,\n      default: \"EPSG:3857\"\n    },\n    reprojectionErrorThreshold: {\n      type: Number,\n      default: 0.5\n    },\n    tileSize: {\n      type: Array,\n      default: () => [256, 256]\n    },\n    tilePixelRatio: {\n      type: Number,\n      default: 1\n    },\n    tileKey: {\n      type: String\n    },\n    transition: {\n      type: Number\n    },\n    tileGrid: {\n      type: Object\n    }\n  }\n};\nfunction _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar SourceXYZ = /* @__PURE__ */ _export_sfc(_sfc_main$U, [[\"render\", _sfc_render$U]]);\nconst _sfc_main$T = {\n  name: \"ol-source-osm\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"tileLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new OSM$1(properties));\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(source, () => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(layer, () => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.value.setSource(null);\n    });\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    attributions: {\n      type: String\n    },\n    cacheSize: {\n      type: Number,\n      default: 2048\n    },\n    crossOrigin: {\n      type: String,\n      default: \"anonymous\"\n    },\n    imageSmoothing: {\n      type: Boolean,\n      default: true\n    },\n    minZoom: {\n      type: Number,\n      default: 0\n    },\n    maxZoom: {\n      type: Number,\n      default: 19\n    },\n    opaque: {\n      type: Boolean,\n      default: true\n    },\n    reprojectionErrorThreshold: {\n      type: Number,\n      default: 0.5\n    },\n    transition: {\n      type: Number,\n      default: 250\n    },\n    url: {\n      type: String,\n      default: \"https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n    },\n    wrapX: {\n      type: Boolean,\n      default: true\n    }\n  }\n};\nfunction _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar SourceOSM = /* @__PURE__ */ _export_sfc(_sfc_main$T, [[\"render\", _sfc_render$T]]);\nconst _sfc_main$S = {\n  name: \"ol-source-image-static\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"imageLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const createSource = () => {\n      return new Static$1(__spreadProps(__spreadValues({}, properties), {\n        projection: typeof properties.projection == \"string\" ? properties.projection : new Projection$3(__spreadValues({}, properties.projection))\n      }));\n    };\n    let source = createSource();\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      layer.setSource(null);\n      source = createSource();\n      layer.setSource(source);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.setSource(source);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.setSource(null);\n    });\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    attributions: {\n      type: String\n    },\n    crossOrigin: {\n      type: String\n    },\n    imageExtent: {\n      type: Array\n    },\n    projection: {\n      type: [String, Object]\n    },\n    imageSmoothing: {\n      type: Boolean,\n      default: true\n    },\n    imageSize: {\n      type: Array\n    },\n    url: {\n      type: String\n    }\n  }\n};\nfunction _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar SourceImageStatic = /* @__PURE__ */ _export_sfc(_sfc_main$S, [[\"render\", _sfc_render$S]]);\nconst _sfc_main$R = {\n  name: \"ol-source-wmts\",\n  setup(props) {\n    const tileLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"tileLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const extent2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => get$3(properties.projection).getExtent());\n    const origin = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => getTopLeft(extent2.value));\n    const size = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => getWidth(extent2.value) / 256);\n    const getTileGrid = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      const resolutions = new Array(properties.tileZoomLevel);\n      const matrixIds = new Array(properties.tileZoomLevel);\n      for (var z2 = 0; z2 < properties.tileZoomLevel; ++z2) {\n        resolutions[z2] = size.value / Math.pow(2, z2);\n        matrixIds[z2] = z2;\n      }\n      return new TileGridWMTS({\n        origin: origin.value,\n        resolutions,\n        matrixIds\n      });\n    });\n    const source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new WMTSSource(__spreadProps(__spreadValues({}, properties), {\n      projection: typeof properties.projection == \"string\" ? properties.projection : new Projection$3(__spreadValues({}, properties.projection)),\n      tileGrid: getTileGrid.value\n    })));\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(source, () => {\n      tileLayer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(tileLayer, () => {\n      tileLayer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      tileLayer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      tileLayer.value.setSource(null);\n    });\n    return {\n      tileLayer,\n      source\n    };\n  },\n  props: {\n    tileZoomLevel: {\n      type: Number,\n      default: 30\n    },\n    attributions: {\n      type: String\n    },\n    cacheSize: {\n      type: Number\n    },\n    crossOrigin: {\n      type: String\n    },\n    imageSmoothing: {\n      type: Boolean,\n      default: true\n    },\n    projection: {\n      type: [String, Object],\n      default: \"EPSG:3857\"\n    },\n    reprojectionErrorThreshold: {\n      type: Number,\n      default: 0.5\n    },\n    tilePixelRatio: {\n      type: Number,\n      default: 1\n    },\n    format: {\n      type: String,\n      default: \"image/jpeg\"\n    },\n    version: {\n      type: String,\n      default: \"1.0.0\"\n    },\n    matrixSet: {\n      type: String\n    },\n    dimensions: {\n      type: Object\n    },\n    requestEncoding: {\n      type: String,\n      default: \"KVP\"\n    },\n    url: {\n      type: String\n    },\n    urls: {\n      type: Array\n    },\n    wrapX: {\n      type: Boolean,\n      default: false\n    },\n    transition: {\n      type: Number\n    },\n    layer: {\n      type: String\n    },\n    style: {\n      type: String\n    }\n  }\n};\nfunction _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar SourceWMTS = /* @__PURE__ */ _export_sfc(_sfc_main$R, [[\"render\", _sfc_render$R]]);\nconst _sfc_main$Q = {\n  name: \"ol-source-vector\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"vectorLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new ol_source_Vector(properties));\n    const applySource = () => {\n      layer.value.setSource(null);\n      layer.value.setSource(source.value);\n      layer.value.changed();\n    };\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      applySource();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(layer, () => {\n      applySource();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.value.setSource(null);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"vectorSource\", source);\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    attributions: {\n      type: [String, Array]\n    },\n    features: {\n      type: Array,\n      default: () => []\n    },\n    format: {\n      type: Object\n    },\n    loader: {\n      type: Function\n    },\n    overlaps: {\n      type: Boolean,\n      default: true\n    },\n    projection: {\n      type: String,\n      default: \"EPSG:3857\"\n    },\n    strategy: {\n      type: Function\n    },\n    url: {\n      type: [String, Function]\n    },\n    useSpatialIndex: {\n      type: Boolean,\n      default: true\n    },\n    wrapX: {\n      type: Boolean,\n      default: true\n    }\n  }\n};\nfunction _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar SourceVector = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [[\"render\", _sfc_render$Q]]);\nconst _sfc_main$P = {\n  name: \"ol-source-cluster\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"vectorLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let c2 = new Cluster$1(properties);\n      return c2;\n    });\n    const applySource = () => {\n      layer.value.setSource(null);\n      layer.value.setSource(source.value);\n      layer.value.changed();\n    };\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      applySource();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(layer, () => {\n      applySource();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.value.setSource(source.value);\n      layer.value.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.value.setSource(null);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"vectorLayer\", source);\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    attributions: {\n      type: [String, Array]\n    },\n    distance: {\n      type: Number,\n      default: 20\n    },\n    geometryFunction: {\n      type: Function,\n      default: (feature2) => feature2.getGeometry()\n    },\n    wrapX: {\n      type: Boolean,\n      default: true\n    }\n  }\n};\nfunction _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar SourceCluster = /* @__PURE__ */ _export_sfc(_sfc_main$P, [[\"render\", _sfc_render$P]]);\nconst _sfc_main$O = {\n  name: \"ol-source-bingmaps\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"tileLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new BingMaps$1(__spreadProps(__spreadValues({}, properties), {\n      key: properties.apiKey\n    })));\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(source, () => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(layer, () => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.value.setSource(null);\n    });\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    cacheSize: {\n      type: Number\n    },\n    hidpi: {\n      type: Boolean,\n      default: false\n    },\n    culture: {\n      type: String,\n      default: \"en-us\"\n    },\n    apiKey: {\n      type: String\n    },\n    imagerySet: {\n      type: String\n    },\n    imageSmoothing: {\n      type: Boolean,\n      default: true\n    },\n    maxZoom: {\n      type: Number,\n      default: 21\n    },\n    reprojectionErrorThreshold: {\n      type: Number,\n      default: 0.5\n    },\n    tileLoadFunction: {\n      type: Function,\n      default: (imageTile, src) => imageTile.getImage().src = src\n    },\n    wrapX: {\n      type: Boolean,\n      default: true\n    },\n    transition: {\n      type: Number\n    }\n  }\n};\nfunction _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar SourceBingMaps = /* @__PURE__ */ _export_sfc(_sfc_main$O, [[\"render\", _sfc_render$O]]);\nclass Tianditu extends WMTSSource {\n  constructor(opt_options) {\n    Tianditu.layerLabelMap = {\n      vec: \"cva\",\n      ter: \"cta\",\n      img: \"cia\"\n    };\n    Tianditu.layerZoomMap = {\n      vec: 18,\n      ter: 14,\n      img: 18\n    };\n    let options = opt_options || {};\n    options.layerType = options.layerType || \"vec\";\n    options.layerType = options.isLabel ? Tianditu.layerLabelMap[options.layerType] : options.layerType;\n    options.matrixSet = options.projection === \"EPSG:4326\" || options.projection === \"EPSG:4490\" ? \"c\" : \"w\";\n    if (!options.url && !options.urls) {\n      options.url = \"https://t{0-7}.tianditu.gov.cn/{layer}_{proj}/wmts?\";\n    }\n    if (options.tk) {\n      options.url = `${options.url}tk=${options.tk}`;\n    }\n    options.url = options.url.replace(\"{layer}\", options.layerType).replace(\"{proj}\", options.matrixSet);\n    let tileGrid = options.tileGrid || Tianditu.getTileGrid(options.projection || \"EPSG:3857\");\n    let crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : \"anonymous\";\n    let superOptions = {\n      version: options.version || \"1.0.0\",\n      format: options.format || \"tiles\",\n      dimensions: options.dimensions || {},\n      layer: options.layerType,\n      matrixSet: options.matrixSet,\n      tileGrid,\n      style: options.style || \"default\",\n      cacheSize: options.cacheSize,\n      crossOrigin,\n      opaque: options.opaque === void 0 ? true : options.opaque,\n      maxZoom: Tianditu.layerZoomMap[options.layerType],\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      url: options.url,\n      urls: options.urls,\n      projection: options.projection || \"EPSG:3857\",\n      wrapX: options.wrapX\n    };\n    if (options.tileProxy) {\n      superOptions.tileLoadFunction = tileLoadFunction;\n    }\n    super(superOptions);\n    if (options.tileProxy) {\n      this.tileProxy = options.tileProxy;\n    }\n    let me2 = this;\n    function tileLoadFunction(imageTile, src) {\n      imageTile.getImage().src = me2.tileProxy + encodeURIComponent(src);\n    }\n  }\n  static getTileGrid(projection) {\n    if (projection === \"EPSG:4326\" || projection === \"EPSG:4490\") {\n      return Tianditu.default4326TileGrid();\n    }\n    return Tianditu.default3857TileGrid();\n  }\n  static default4326TileGrid() {\n    let tdt_WGS84_resolutions = [];\n    let matrixIds = [];\n    for (let i2 = 1; i2 < 19; i2++) {\n      tdt_WGS84_resolutions.push(0.703125 * 2 / Math.pow(2, i2));\n      matrixIds.push(i2);\n    }\n    let tileGird = new TileGridWMTS({\n      extent: [-180, -90, 180, 90],\n      resolutions: tdt_WGS84_resolutions,\n      origin: [-180, 90],\n      matrixIds,\n      minZoom: 1\n    });\n    return tileGird;\n  }\n  static default3857TileGrid() {\n    let tdt_Mercator_resolutions = [];\n    let matrixIds = [];\n    for (let i2 = 1; i2 < 19; i2++) {\n      tdt_Mercator_resolutions.push(78271.51696402031 * 2 / Math.pow(2, i2));\n      matrixIds.push(i2);\n    }\n    let tileGird = new TileGridWMTS({\n      extent: [\n        -200375083427892e-7,\n        -200375083427892e-7,\n        200375083427892e-7,\n        200375083427892e-7\n      ],\n      resolutions: tdt_Mercator_resolutions,\n      matrixIds,\n      origin: [-200375083427892e-7, 200375083427892e-7],\n      minZoom: 1\n    });\n    return tileGird;\n  }\n}\nconst _sfc_main$N = {\n  name: \"ol-source-tianditu\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"tileLayer\");\n    const { properties } = usePropsAsObjectProperties(props);\n    let source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      return new Tianditu(properties);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(source, () => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(layer, () => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.value.setSource(null);\n    });\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    layerType: {\n      type: String,\n      default: \"img\"\n    },\n    tk: {\n      type: String\n    },\n    isLabel: {\n      type: Boolean,\n      default: false\n    },\n    cacheSize: {\n      type: Number\n    },\n    crossOrigin: {\n      type: String\n    },\n    projection: {\n      Type: String,\n      default: \"EPSG:3857\"\n    },\n    hidpi: {\n      type: Boolean,\n      default: false\n    },\n    requestEncoding: {\n      type: String,\n      default: \"KVP\"\n    },\n    format: {\n      type: String\n    },\n    version: {\n      type: String,\n      default: \"1.0.0\"\n    },\n    culture: {\n      type: String,\n      default: \"en-us\"\n    },\n    matrixSet: {\n      type: String\n    },\n    dimensions: {\n      type: Object,\n      default: () => {\n      }\n    },\n    imageSmoothing: {\n      type: Boolean,\n      default: true\n    },\n    maxZoom: {\n      type: Number,\n      default: 21\n    },\n    reprojectionErrorThreshold: {\n      type: Number\n    },\n    tileLoadFunction: {\n      type: Function,\n      default: (imageTile, src) => imageTile.getImage().src = src\n    },\n    wrapX: {\n      type: Boolean,\n      default: true\n    },\n    transition: {\n      type: Number\n    }\n  }\n};\nfunction _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar SourceTianDiTu = /* @__PURE__ */ _export_sfc(_sfc_main$N, [[\"render\", _sfc_render$N]]);\nconst _sfc_main$M = {\n  name: \"ol-source-image-wms\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"imageLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const createSource = () => {\n      return new ImageWMS$1(__spreadProps(__spreadValues({}, properties), {\n        params: {\n          \"LAYERS\": props.layers,\n          \"STYLES\": props.styles,\n          \"TIME\": props.time\n        },\n        projection: typeof properties.projection == \"string\" ? properties.projection : new Projection$3(__spreadValues({}, properties.projection))\n      }));\n    };\n    let source = createSource();\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      layer.setSource(null);\n      source = createSource();\n      layer.setSource(source);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.setSource(source);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.setSource(null);\n    });\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    attributions: {\n      type: String\n    },\n    crossOrigin: {\n      type: String\n    },\n    imageExtent: {\n      type: Array\n    },\n    projection: {\n      type: [String, Object],\n      default: \"EPSG:3857\"\n    },\n    reprojectionErrorThreshold: {\n      type: Number,\n      default: 0.5\n    },\n    format: {\n      type: String,\n      default: \"image/png\"\n    },\n    version: {\n      type: String,\n      default: \"1.3.0\"\n    },\n    matrixSet: {\n      type: String\n    },\n    serverType: {\n      type: String,\n      default: \"mapserver\"\n    },\n    imageSmoothing: {\n      type: Boolean,\n      default: true\n    },\n    layers: {\n      type: [String, Array],\n      required: true\n    },\n    styles: {\n      type: [String, Array],\n      default: \"\"\n    },\n    time: {\n      type: String\n    },\n    ratio: {\n      type: Number,\n      default: 1\n    },\n    imageSize: {\n      type: Array\n    },\n    url: {\n      type: String\n    },\n    params: {\n      type: Object\n    }\n  }\n};\nfunction _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar SourceImageWMS = /* @__PURE__ */ _export_sfc(_sfc_main$M, [[\"render\", _sfc_render$M]]);\nconst _sfc_main$L = {\n  name: \"ol-source-webglpoints\",\n  setup(props) {\n    const layer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"webglPointsLayer\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new ol_source_Vector(properties));\n    const applySource = () => {\n      layer.value.setSource(null);\n      layer.value.setSource(source.value);\n      layer.value.changed();\n    };\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      applySource();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(layer, () => {\n      applySource();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      layer.value.setSource(source.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      layer.value.setSource(null);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"vectorSource\", source);\n    return {\n      layer,\n      source\n    };\n  },\n  props: {\n    attributions: {\n      type: [String, Array]\n    },\n    features: {\n      type: Array,\n      default: () => []\n    },\n    format: {\n      type: Object\n    },\n    loader: {\n      type: Function\n    },\n    overlaps: {\n      type: Boolean,\n      default: true\n    },\n    projection: {\n      type: String,\n      default: \"EPSG:3857\"\n    },\n    strategy: {\n      type: Function\n    },\n    url: {\n      type: [String, Function]\n    },\n    useSpatialIndex: {\n      type: Boolean,\n      default: true\n    },\n    wrapX: {\n      type: Boolean,\n      default: true\n    }\n  }\n};\nfunction _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar SourceWebglPoints = /* @__PURE__ */ _export_sfc(_sfc_main$L, [[\"render\", _sfc_render$L]]);\nfunction install$6(app) {\n  if (install$6.installed) {\n    return;\n  }\n  install$6.installed = true;\n  app.component(SourceXYZ.name, SourceXYZ);\n  app.component(SourceOSM.name, SourceOSM);\n  app.component(SourceImageStatic.name, SourceImageStatic);\n  app.component(SourceWMTS.name, SourceWMTS);\n  app.component(SourceVector.name, SourceVector);\n  app.component(SourceCluster.name, SourceCluster);\n  app.component(SourceBingMaps.name, SourceBingMaps);\n  app.component(SourceTianDiTu.name, SourceTianDiTu);\n  app.component(SourceImageWMS.name, SourceImageWMS);\n  app.component(SourceWebglPoints.name, SourceWebglPoints);\n}\nvar Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": install$6,\n  install: install$6,\n  SourceXYZ,\n  SourceOSM,\n  SourceImageStatic,\n  SourceWMTS,\n  SourceVector,\n  SourceCluster,\n  SourceTianDiTu,\n  SourceImageWMS,\n  SourceWebglPoints,\n  SourceBingMaps\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction useControl(ControlType, props, context) {\n  const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n  const controlBar = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"controlBar\", null);\n  const parent = controlBar != null ? controlBar.value : map;\n  const {\n    properties\n  } = usePropsAsObjectProperties(props);\n  let control = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new ControlType(__spreadValues({}, properties)));\n  control.value.set(\"order\", context.attrs.order == void 0 ? 0 : context.attrs.order);\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(control, (newVal, oldVal) => {\n    if (parent.removeControl) {\n      parent.removeControl(oldVal);\n      parent.addControl(newVal);\n      map.changed();\n    }\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n    parent.addControl(control.value);\n    if (parent.controls_ != void 0) {\n      let sortedControls = [...parent.controls_];\n      sortedControls.sort((a2, b2) => a2.get(\"order\") - b2.get(\"order\"));\n      parent.controls_ = [];\n      sortedControls.forEach((c2) => {\n        parent.addControl(c2);\n      });\n      parent.changed();\n    }\n    map.changed();\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n    if (parent.removeControl) {\n      parent.removeControl(control.value);\n    } else {\n      let index2 = parent.controls_.findIndex((a2) => a2 == control.value);\n      parent.controls_.splice(index2, 1);\n      control.value.dispose();\n    }\n    map.changed();\n  });\n  return {\n    map,\n    control\n  };\n}\nconst _sfc_main$K = {\n  name: \"ol-fullscreen-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(FullScreen$1, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String,\n      default: \"ol-full-screen\"\n    },\n    label: {\n      type: String,\n      default: \"\\u2922\"\n    },\n    labelActive: {\n      type: String,\n      default: \"\\xD7\"\n    },\n    activeClassName: {\n      type: String,\n      default: \"ol-full-screen-true\"\n    },\n    inactiveClassName: {\n      type: String,\n      default: \"ol-full-screen-false\"\n    },\n    tipLabel: {\n      type: String,\n      default: \"Toggle full-screen\"\n    },\n    keys: {\n      type: Boolean,\n      default: false\n    },\n    target: {\n      type: Object,\n      default: void 0\n    },\n    source: {\n      type: Object,\n      default: void 0\n    }\n  }\n};\nfunction _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar FullScreenControl = /* @__PURE__ */ _export_sfc(_sfc_main$K, [[\"render\", _sfc_render$K]]);\nconst _sfc_main$J = {\n  name: \"ol-mouseposition-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(MousePosition$1, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String,\n      default: \"ol-mouse-position\"\n    },\n    coordinateFormat: {\n      type: [String, Function]\n    },\n    projection: {\n      type: String\n    },\n    render: {\n      type: Function\n    },\n    target: {\n      type: HTMLElement\n    },\n    undefinedHTML: {\n      type: String,\n      default: \"&#160;\"\n    }\n  }\n};\nfunction _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar MousePositionControl = /* @__PURE__ */ _export_sfc(_sfc_main$J, [[\"render\", _sfc_render$J]]);\nconst _sfc_main$I = {\n  name: \"ol-attribution-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(Attribution$1, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String,\n      default: \"ol-attribution\"\n    },\n    target: {\n      type: HTMLElement\n    },\n    collapsible: {\n      type: Boolean\n    },\n    collapsed: {\n      type: Boolean,\n      default: true\n    },\n    tipLabel: {\n      type: String,\n      default: \"Attributions\"\n    },\n    label: {\n      type: String,\n      default: \"i\"\n    },\n    expandClassName: {\n      type: String,\n      default: \"ol-attribution-expand\"\n    },\n    collapseLabel: {\n      type: String,\n      default: \"\\xBB\"\n    },\n    collapseClassName: {\n      type: String,\n      default: \"ol-attribution-collapse\"\n    },\n    render: {\n      type: Function\n    }\n  }\n};\nfunction _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar AttributionControl = /* @__PURE__ */ _export_sfc(_sfc_main$I, [[\"render\", _sfc_render$I]]);\nconst _sfc_main$H = {\n  name: \"ol-overviewmap-control\",\n  setup(props, context) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      control\n    } = useControl(OverviewMap$1, props, context);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      control.value.setMap(map);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      control.value.setMap(null);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"overviewMap\", control);\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String,\n      default: \"ol-overviewmap\"\n    },\n    collapsed: {\n      type: Boolean,\n      default: true\n    },\n    collapseLabel: {\n      type: String,\n      default: \"\\xAB\"\n    },\n    collapsible: {\n      type: Boolean,\n      default: true\n    },\n    label: {\n      type: String,\n      default: \"\\xBB\"\n    },\n    render: {\n      type: Function\n    },\n    rotateWithView: {\n      type: Boolean,\n      default: false\n    },\n    target: {\n      type: HTMLElement\n    },\n    tipLabel: {\n      type: String,\n      default: \"Overview map\"\n    }\n  }\n};\nfunction _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar OverviewMapControl = /* @__PURE__ */ _export_sfc(_sfc_main$H, [[\"render\", _sfc_render$H]]);\nconst _sfc_main$G = {\n  name: \"ol-scaleline-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ScaleLine$1, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String,\n      default: \"ol-scale-line\"\n    },\n    minWidth: {\n      type: Number,\n      default: 64\n    },\n    render: {\n      type: Function\n    },\n    target: {\n      type: HTMLElement\n    },\n    units: {\n      type: String,\n      default: \"metric\"\n    },\n    bar: {\n      type: Boolean,\n      default: false\n    },\n    steps: {\n      type: Number,\n      default: 4\n    },\n    text: {\n      type: Boolean,\n      default: false\n    },\n    dpi: {\n      type: Number,\n      default: void 0\n    }\n  }\n};\nfunction _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar ScaleLineControl = /* @__PURE__ */ _export_sfc(_sfc_main$G, [[\"render\", _sfc_render$G]]);\nconst _sfc_main$F = {\n  name: \"ol-zoom-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(Zoom$1, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    duration: {\n      type: Number,\n      default: 250\n    },\n    className: {\n      type: String,\n      default: \"ol-zoom\"\n    },\n    zoomInClassName: {\n      type: String,\n      default: \"ol-zoom-in\"\n    },\n    zoomOutClassName: {\n      type: String,\n      default: \"ol-zoom-out\"\n    },\n    zoomInLabel: {\n      type: String,\n      default: \"+\"\n    },\n    zoomOutLabel: {\n      type: String,\n      default: \"-\"\n    },\n    zoomInTipLabel: {\n      type: String,\n      default: \"Zoom in\"\n    },\n    zoomOutTipLabel: {\n      type: String,\n      default: \"Zoom Out\"\n    },\n    delta: {\n      type: Number,\n      default: 1\n    },\n    target: {\n      type: HTMLElement\n    }\n  }\n};\nfunction _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar ZoomControl = /* @__PURE__ */ _export_sfc(_sfc_main$F, [[\"render\", _sfc_render$F]]);\nconst _sfc_main$E = {\n  name: \"ol-zoomslider-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ZoomSlider$1, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    duration: {\n      type: Number,\n      default: 200\n    },\n    className: {\n      type: String,\n      default: \"ol-zoomslider\"\n    },\n    render: {\n      type: Function\n    }\n  }\n};\nfunction _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar ZoomSliderControl = /* @__PURE__ */ _export_sfc(_sfc_main$E, [[\"render\", _sfc_render$E]]);\nconst _sfc_main$D = {\n  name: \"ol-zoomtoextent-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ZoomToExtent$1, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String,\n      default: \"ol-zoom-extent\"\n    },\n    target: {\n      type: HTMLElement\n    },\n    label: {\n      type: String,\n      default: \"E\"\n    },\n    tipLabel: {\n      type: String,\n      default: \"Fit to extent\"\n    },\n    extent: {\n      type: Array\n    }\n  }\n};\nfunction _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar ZoomToExtentControl = /* @__PURE__ */ _export_sfc(_sfc_main$D, [[\"render\", _sfc_render$D]]);\nconst _sfc_main$C = {\n  name: \"ol-rotate-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(Rotate$2, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String,\n      default: \"ol-rotate\"\n    },\n    label: {\n      type: String,\n      default: \"\\u21E7\"\n    },\n    tipLabel: {\n      type: String,\n      default: \"Reset rotation\"\n    },\n    compassClassName: {\n      type: String,\n      default: \"ol-compass\"\n    },\n    duration: {\n      type: Number,\n      default: 250\n    },\n    autoHide: {\n      type: Boolean,\n      default: false\n    },\n    render: {\n      type: Function\n    },\n    resetNorth: {\n      type: Function\n    },\n    target: {\n      type: HTMLElement\n    }\n  }\n};\nfunction _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar RotateControl = /* @__PURE__ */ _export_sfc(_sfc_main$C, [[\"render\", _sfc_render$C]]);\nvar olContextmenu$1 = { exports: {} };\nvar require$$0 = /* @__PURE__ */ getAugmentedNamespace(Control$2);\n/*!\n  * ol-contextmenu - v4.1.0\n  * https://github.com/jonataswalker/ol-contextmenu\n  * Built: Sat Aug 15 2020 10:43:26 GMT-0300 (Brasilia Standard Time)\n  */\n(function(module, exports2) {\n  !function(t3, e2) {\n    module.exports = e2(require$$0);\n  }(commonjsGlobal, function(t3) {\n    function e2(t4) {\n      return t4 && typeof t4 == \"object\" && \"default\" in t4 ? t4 : { default: t4 };\n    }\n    var n2 = e2(t3), i2 = \"ol-ctx-menu\", o2 = { namespace: i2, container: i2 + \"-container\", separator: i2 + \"-separator\", submenu: i2 + \"-submenu\", hidden: i2 + \"-hidden\", icon: i2 + \"-icon\", zoomIn: i2 + \"-zoom-in\", zoomOut: i2 + \"-zoom-out\", unselectable: \"ol-unselectable\" }, s2 = o2, a2 = \"beforeopen\", r2 = \"open\", l2 = \"close\", c2 = \"contextmenu\", h2 = { width: 150, scrollAt: 4, eventType: c2, defaultItems: true }, p5 = [{ text: \"Zoom In\", classname: o2.zoomIn + \" \" + o2.icon, callback: function(t4, e3) {\n      var n3 = e3.getView();\n      n3.animate({ zoom: +n3.getZoom() + 1, duration: 700, center: t4.coordinate });\n    } }, { text: \"Zoom Out\", classname: o2.zoomOut + \" \" + o2.icon, callback: function(t4, e3) {\n      var n3 = e3.getView();\n      n3.animate({ zoom: +n3.getZoom() - 1, duration: 700, center: t4.coordinate });\n    } }];\n    function u2(t4, e3) {\n      if (e3 === void 0 && (e3 = \"Assertion failed\"), !t4) {\n        if (typeof Error != \"undefined\")\n          throw new Error(e3);\n        throw e3;\n      }\n    }\n    function d2(t4) {\n      return /^\\d+$/.test(t4);\n    }\n    function m2(t4, e3) {\n      return t4.classList ? t4.classList.contains(e3) : g2(e3).test(t4.className);\n    }\n    function f2(t4, e3, n3) {\n      e3 === void 0 && (e3 = window.document);\n      var i3 = Array.prototype.slice, o3 = [];\n      if (/^(#?[\\w-]+|\\.[\\w-.]+)$/.test(t4))\n        switch (t4[0]) {\n          case \"#\":\n            o3 = [y2(t4.substr(1))];\n            break;\n          case \".\":\n            o3 = i3.call(e3.getElementsByClassName(t4.substr(1).replace(/\\./g, \" \")));\n            break;\n          default:\n            o3 = i3.call(e3.getElementsByTagName(t4));\n        }\n      else\n        o3 = i3.call(e3.querySelectorAll(t4));\n      return n3 ? o3 : o3[0];\n    }\n    function y2(t4) {\n      return t4 = t4[0] === \"#\" ? t4.substr(1, t4.length) : t4, document.getElementById(t4);\n    }\n    function v2(t4) {\n      var e3 = document.createDocumentFragment(), n3 = document.createElement(\"div\");\n      for (n3.innerHTML = t4; n3.firstChild; )\n        e3.appendChild(n3.firstChild);\n      return e3;\n    }\n    function g2(t4) {\n      return new RegExp(\"(^|\\\\s+) \" + t4 + \" (\\\\s+|$)\");\n    }\n    function b2(t4, e3, n3) {\n      t4.classList ? t4.classList.add(e3) : t4.className = (t4.className + \" \" + e3).trim(), n3 && d2(n3) && window.setTimeout(function() {\n        return C2(t4, e3);\n      }, n3);\n    }\n    function C2(t4, e3, n3) {\n      t4.classList ? t4.classList.remove(e3) : t4.className = t4.className.replace(g2(e3), \" \").trim(), n3 && d2(n3) && window.setTimeout(function() {\n        return b2(t4, e3);\n      }, n3);\n    }\n    var E2 = function(t4) {\n      return this.Base = t4, this.map = void 0, this.viewport = void 0, this.coordinateClicked = void 0, this.pixelClicked = void 0, this.lineHeight = 0, this.items = {}, this.opened = false, this.submenu = { left: t4.options.width - 15 + \"px\", lastLeft: \"\" }, this.eventHandler = this.handleEvent.bind(this), this.eventMapMoveHandler = this.handleMapMoveEvent.bind(this), this;\n    };\n    E2.prototype.init = function(t4) {\n      this.map = t4, this.viewport = t4.getViewport(), this.setListeners(), this.Base.Html.createMenu(), this.lineHeight = this.getItemsLength() > 0 ? this.Base.container.offsetHeight / this.getItemsLength() : this.Base.Html.cloneAndGetLineHeight();\n    }, E2.prototype.getItemsLength = function() {\n      var t4 = this, e3 = 0;\n      return Object.keys(this.items).forEach(function(n3) {\n        t4.items[n3].submenu || t4.items[n3].separator || e3++;\n      }), e3;\n    }, E2.prototype.getPixelClicked = function() {\n      return this.pixelClicked;\n    }, E2.prototype.getCoordinateClicked = function() {\n      return this.coordinateClicked;\n    }, E2.prototype.positionContainer = function(t4) {\n      var e3 = this, n3 = this.Base.container, i3 = this.map.getSize(), o3 = i3[1] - t4[1], a3 = i3[0] - t4[0], r3 = n3.offsetWidth, l3 = Math.round(this.lineHeight * this.getItemsLength()), c3 = f2(\"li.\" + s2.submenu + \">div\", n3, true);\n      a3 >= r3 ? (n3.style.right = \"auto\", n3.style.left = t4[0] + 5 + \"px\") : (n3.style.left = \"auto\", n3.style.right = \"15px\"), o3 >= l3 ? (n3.style.bottom = \"auto\", n3.style.top = t4[1] - 10 + \"px\") : (n3.style.top = \"auto\", n3.style.bottom = 0), function t5(e4, n4, i4) {\n        if (Array.isArray(e4))\n          e4.forEach(function(e5) {\n            return t5(e5, n4, i4);\n          });\n        else\n          for (var o4 = Array.isArray(n4) ? n4 : n4.split(/\\s+/), s3 = o4.length; s3--; )\n            m2(e4, o4[s3]) && C2(e4, o4[s3], i4);\n      }(n3, s2.hidden), c3.length && (this.submenu.lastLeft = a3 < 2 * r3 ? \"-\" + r3 + \"px\" : this.submenu.left, c3.forEach(function(t5) {\n        var n4, i4, s3, a4 = { w: window.innerWidth || document.documentElement.clientWidth, h: window.innerHeight || document.documentElement.clientHeight }, r4 = (i4 = (n4 = t5).getBoundingClientRect(), s3 = document.documentElement, { left: i4.left + window.pageXOffset - s3.clientLeft, top: i4.top + window.pageYOffset - s3.clientTop, width: n4.offsetWidth, height: n4.offsetHeight }), l4 = r4.height, c4 = o3 - l4;\n        c4 < 0 && (c4 = l4 - (a4.h - r4.top), t5.style.top = \"-\" + c4 + \"px\"), t5.style.left = e3.submenu.lastLeft;\n      }));\n    }, E2.prototype.openMenu = function(t4, e3) {\n      this.Base.dispatchEvent({ type: r2, pixel: t4, coordinate: e3 }), this.opened = true, this.positionContainer(t4);\n    }, E2.prototype.closeMenu = function() {\n      this.opened = false, function t4(e3, n3, i3) {\n        if (Array.isArray(e3))\n          e3.forEach(function(e4) {\n            return t4(e4, n3);\n          });\n        else\n          for (var o3 = Array.isArray(n3) ? n3 : n3.split(/\\s+/), s3 = o3.length; s3--; )\n            m2(e3, o3[s3]) || b2(e3, o3[s3], i3);\n      }(this.Base.container, s2.hidden), this.Base.dispatchEvent({ type: l2 });\n    }, E2.prototype.setListeners = function() {\n      this.viewport.addEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.on(\"movestart\", this.eventMapMoveHandler);\n    }, E2.prototype.removeListeners = function() {\n      this.viewport.removeEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.un(\"movestart\", this.eventMapMoveHandler);\n    }, E2.prototype.handleEvent = function(t4) {\n      var e3 = this;\n      this.coordinateClicked = this.map.getEventCoordinate(t4), this.pixelClicked = this.map.getEventPixel(t4), this.Base.dispatchEvent({ type: a2, pixel: this.pixelClicked, coordinate: this.coordinateClicked }), this.Base.disabled || (this.Base.options.eventType === c2 && (t4.stopPropagation(), t4.preventDefault()), this.openMenu(this.pixelClicked, this.coordinateClicked), t4.target.addEventListener(\"pointerdown\", { handleEvent: function(n3) {\n        e3.opened && (e3.closeMenu(), n3.stopPropagation(), t4.target.removeEventListener(n3.type, this, false));\n      } }, false));\n    }, E2.prototype.handleMapMoveEvent = function(t4) {\n      this.closeMenu();\n    }, E2.prototype.setItemListener = function(t4, e3) {\n      var n3, i3 = this;\n      t4 && typeof this.items[e3].callback == \"function\" && (n3 = this.items[e3].callback, t4.addEventListener(\"click\", function(t5) {\n        t5.preventDefault();\n        var o3 = { coordinate: i3.getCoordinateClicked(), data: i3.items[e3].data || null };\n        i3.closeMenu(), n3(o3, i3.map);\n      }, false));\n    };\n    var w2 = function(t4) {\n      return this.Base = t4, this.Base.container = this.container = this.createContainer(true), this;\n    };\n    return w2.prototype.createContainer = function(t4) {\n      var e3 = document.createElement(\"div\"), n3 = document.createElement(\"ul\"), i3 = [s2.container, s2.unselectable];\n      return t4 && i3.push(s2.hidden), e3.className = i3.join(\" \"), e3.style.width = parseInt(this.Base.options.width, 10) + \"px\", e3.appendChild(n3), e3;\n    }, w2.prototype.createMenu = function() {\n      var t4 = [];\n      if (\"items\" in this.Base.options ? t4 = this.Base.options.defaultItems ? this.Base.options.items.concat(p5) : this.Base.options.items : this.Base.options.defaultItems && (t4 = p5), t4.length === 0)\n        return false;\n      t4.forEach(this.addMenuEntry, this);\n    }, w2.prototype.addMenuEntry = function(t4) {\n      var e3, n3 = this;\n      if (t4.items && Array.isArray(t4.items)) {\n        t4.classname = t4.classname || \"\", e3 = s2.submenu, ~t4.classname.indexOf(e3) || (t4.classname = t4.classname.length ? \" \" + s2.submenu : s2.submenu);\n        var i3 = this.generateHtmlAndPublish(this.container, t4), o3 = this.createContainer();\n        o3.style.left = this.Base.Internal.submenu.lastLeft || this.Base.Internal.submenu.left, i3.appendChild(o3), t4.items.forEach(function(t5) {\n          n3.generateHtmlAndPublish(o3, t5, true);\n        });\n      } else\n        this.generateHtmlAndPublish(this.container, t4);\n    }, w2.prototype.generateHtmlAndPublish = function(t4, e3, n3) {\n      var i3, o3, a3 = \"_\" + Math.random().toString(36).substr(2, 9), r3 = false;\n      return typeof e3 == \"string\" && e3.trim() === \"-\" ? (i3 = v2('<li id=\"' + a3 + '\" class=\"' + s2.separator + '\"><hr></li>'), o3 = [].slice.call(i3.childNodes, 0)[0], t4.firstChild.appendChild(i3), r3 = true) : (e3.classname = e3.classname || \"\", i3 = v2(\"<span>\" + e3.text + \"</span>\"), o3 = document.createElement(\"li\"), e3.icon && (e3.classname === \"\" ? e3.classname = s2.icon : e3.classname.indexOf(s2.icon) === -1 && (e3.classname += \" \" + s2.icon), o3.setAttribute(\"style\", \"background-image:url(\" + e3.icon + \")\")), o3.id = a3, o3.className = e3.classname, o3.appendChild(i3), t4.firstChild.appendChild(o3)), this.Base.Internal.items[a3] = { id: a3, submenu: n3 || 0, separator: r3, callback: e3.callback, data: e3.data || null }, this.Base.Internal.setItemListener(o3, a3), o3;\n    }, w2.prototype.removeMenuEntry = function(t4) {\n      var e3 = f2(\"#\" + t4, this.container.firstChild);\n      e3 && this.container.firstChild.removeChild(e3), delete this.Base.Internal.items[t4];\n    }, w2.prototype.cloneAndGetLineHeight = function() {\n      var t4 = this.container.cloneNode(), e3 = v2(\"<span>Foo</span>\"), n3 = v2(\"<span>Foo</span>\"), i3 = document.createElement(\"li\"), o3 = document.createElement(\"li\");\n      i3.appendChild(e3), o3.appendChild(n3), t4.appendChild(i3), t4.appendChild(o3), this.container.parentNode.appendChild(t4);\n      var s3 = t4.offsetHeight / 2;\n      return this.container.parentNode.removeChild(t4), s3;\n    }, function(t4) {\n      function e3(e4) {\n        e4 === void 0 && (e4 = {}), u2(typeof e4 == \"object\", \"@param `opt_options` should be object type!\"), this.options = function(t5, e5) {\n          var n3 = {};\n          for (var i3 in t5)\n            n3[i3] = t5[i3];\n          for (var o3 in e5)\n            n3[o3] = e5[o3];\n          return n3;\n        }(h2, e4), this.disabled = false, this.Internal = new E2(this), this.Html = new w2(this), t4.call(this, { element: this.container });\n      }\n      return t4 && (e3.__proto__ = t4), e3.prototype = Object.create(t4 && t4.prototype), e3.prototype.constructor = e3, e3.prototype.clear = function() {\n        Object.keys(this.Internal.items).forEach(this.Html.removeMenuEntry, this.Html);\n      }, e3.prototype.close = function() {\n        this.Internal.closeMenu();\n      }, e3.prototype.enable = function() {\n        this.disabled = false;\n      }, e3.prototype.disable = function() {\n        this.disabled = true;\n      }, e3.prototype.getDefaultItems = function() {\n        return p5;\n      }, e3.prototype.countItems = function() {\n        return Object.keys(this.Internal.items).length;\n      }, e3.prototype.extend = function(t5) {\n        u2(Array.isArray(t5), \"@param `arr` should be an Array.\"), t5.forEach(this.push, this);\n      }, e3.prototype.isOpen = function() {\n        return this.Internal.opened;\n      }, e3.prototype.updatePosition = function(t5) {\n        u2(Array.isArray(t5), \"@param `pixel` should be an Array.\"), this.isOpen() && this.Internal.positionContainer(t5);\n      }, e3.prototype.pop = function() {\n        var t5 = Object.keys(this.Internal.items);\n        this.Html.removeMenuEntry(t5[t5.length - 1]);\n      }, e3.prototype.push = function(t5) {\n        u2(t5 != null, \"@param `item` must be informed.\"), this.Html.addMenuEntry(t5);\n      }, e3.prototype.shift = function() {\n        this.Html.removeMenuEntry(Object.keys(this.Internal.items)[0]);\n      }, e3.prototype.setMap = function(e4) {\n        t4.prototype.setMap.call(this, e4), e4 ? this.Internal.init(e4, this) : this.Internal.removeListeners();\n      }, e3;\n    }(n2.default);\n  });\n})(olContextmenu$1);\nvar ContextMenu = olContextmenu$1.exports;\nconst _sfc_main$B = {\n  name: \"ol-context-menu\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ContextMenu, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    eventType: {\n      type: String,\n      default: \"contextmenu\"\n    },\n    defaultItems: {\n      type: Boolean,\n      default: true\n    },\n    width: {\n      type: Number,\n      default: 150\n    },\n    items: {\n      type: Array,\n      default: () => []\n    }\n  }\n};\nfunction _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar ContextMenuControl = /* @__PURE__ */ _export_sfc(_sfc_main$B, [[\"render\", _sfc_render$B]]);\nvar ol_control_Swipe = function(options) {\n  options = options || {};\n  var button = document.createElement(\"button\");\n  var element = document.createElement(\"div\");\n  element.className = (options.className || \"ol-swipe\") + \" ol-unselectable ol-control\";\n  element.appendChild(button);\n  element.addEventListener(\"mousedown\", this.move.bind(this));\n  element.addEventListener(\"touchstart\", this.move.bind(this));\n  ol_control_Control.call(this, {\n    element\n  });\n  this.precomposeRight_ = this.precomposeRight.bind(this);\n  this.precomposeLeft_ = this.precomposeLeft.bind(this);\n  this.postcompose_ = this.postcompose.bind(this);\n  this.layers = [];\n  if (options.layers)\n    this.addLayer(options.layers, false);\n  if (options.rightLayers)\n    this.addLayer(options.rightLayers, true);\n  this.on(\"propertychange\", function(e2) {\n    if (this.getMap()) {\n      try {\n        this.getMap().renderSync();\n      } catch (e3) {\n      }\n    }\n    if (this.get(\"orientation\") === \"horizontal\") {\n      this.element.style.top = this.get(\"position\") * 100 + \"%\";\n      this.element.style.left = \"\";\n    } else {\n      if (this.get(\"orientation\") !== \"vertical\")\n        this.set(\"orientation\", \"vertical\");\n      this.element.style.left = this.get(\"position\") * 100 + \"%\";\n      this.element.style.top = \"\";\n    }\n    if (e2.key === \"orientation\") {\n      this.element.classList.remove(\"horizontal\", \"vertical\");\n      this.element.classList.add(this.get(\"orientation\"));\n    }\n    if (!this.isMoving) {\n      this.layers.forEach(function(l2) {\n        if (l2.layer.getImageRatio)\n          l2.layer.changed();\n      });\n    }\n  }.bind(this));\n  this.set(\"position\", options.position || 0.5);\n  this.set(\"orientation\", options.orientation || \"vertical\");\n};\nol_ext_inherits(ol_control_Swipe, ol_control_Control);\nol_control_Swipe.prototype.setMap = function(map) {\n  var i2;\n  var l2;\n  if (this.getMap()) {\n    for (i2 = 0; i2 < this.layers.length; i2++) {\n      l2 = this.layers[i2];\n      if (l2.right)\n        l2.layer.un([\"precompose\", \"prerender\"], this.precomposeRight_);\n      else\n        l2.layer.un([\"precompose\", \"prerender\"], this.precomposeLeft_);\n      l2.layer.un([\"postcompose\", \"postrender\"], this.postcompose_);\n    }\n    try {\n      this.getMap().renderSync();\n    } catch (e2) {\n    }\n  }\n  ol_control_Control.prototype.setMap.call(this, map);\n  if (map) {\n    this._listener = [];\n    for (i2 = 0; i2 < this.layers.length; i2++) {\n      l2 = this.layers[i2];\n      if (l2.right)\n        l2.layer.on([\"precompose\", \"prerender\"], this.precomposeRight_);\n      else\n        l2.layer.on([\"precompose\", \"prerender\"], this.precomposeLeft_);\n      l2.layer.on([\"postcompose\", \"postrender\"], this.postcompose_);\n    }\n    try {\n      map.renderSync();\n    } catch (e2) {\n    }\n  }\n};\nol_control_Swipe.prototype.isLayer_ = function(layer) {\n  for (var k2 = 0; k2 < this.layers.length; k2++) {\n    if (this.layers[k2].layer === layer)\n      return k2;\n  }\n  return -1;\n};\nol_control_Swipe.prototype.addLayer = function(layers, right) {\n  if (!(layers instanceof Array))\n    layers = [layers];\n  for (var i2 = 0; i2 < layers.length; i2++) {\n    var l2 = layers[i2];\n    if (this.isLayer_(l2) < 0) {\n      this.layers.push({ layer: l2, right });\n      if (this.getMap()) {\n        if (right)\n          l2.on([\"precompose\", \"prerender\"], this.precomposeRight_);\n        else\n          l2.on([\"precompose\", \"prerender\"], this.precomposeLeft_);\n        l2.on([\"postcompose\", \"postrender\"], this.postcompose_);\n        try {\n          this.getMap().renderSync();\n        } catch (e2) {\n        }\n      }\n    }\n  }\n};\nol_control_Swipe.prototype.removeLayers = function() {\n  var layers = [];\n  this.layers.forEach(function(l2) {\n    layers.push(l2.layer);\n  });\n  this.removeLayer(layers);\n};\nol_control_Swipe.prototype.removeLayer = function(layers) {\n  if (!(layers instanceof Array))\n    layers = [layers];\n  for (var i2 = 0; i2 < layers.length; i2++) {\n    var k2 = this.isLayer_(layers[i2]);\n    if (k2 >= 0 && this.getMap()) {\n      if (this.layers[k2].right)\n        layers[i2].un([\"precompose\", \"prerender\"], this.precomposeRight_);\n      else\n        layers[i2].un([\"precompose\", \"prerender\"], this.precomposeLeft_);\n      layers[i2].un([\"postcompose\", \"postrender\"], this.postcompose_);\n      this.layers.splice(k2, 1);\n    }\n  }\n  if (this.getMap()) {\n    try {\n      this.getMap().renderSync();\n    } catch (e2) {\n    }\n  }\n};\nol_control_Swipe.prototype.getRectangle = function() {\n  var s2;\n  if (this.get(\"orientation\") === \"vertical\") {\n    s2 = this.getMap().getSize();\n    return [0, 0, s2[0] * this.get(\"position\"), s2[1]];\n  } else {\n    s2 = this.getMap().getSize();\n    return [0, 0, s2[0], s2[1] * this.get(\"position\")];\n  }\n};\nol_control_Swipe.prototype.move = function(e2) {\n  var self2 = this;\n  var l2;\n  if (!this._movefn)\n    this._movefn = this.move.bind(this);\n  switch (e2.type) {\n    case \"touchcancel\":\n    case \"touchend\":\n    case \"mouseup\": {\n      self2.isMoving = false;\n      [\"mouseup\", \"mousemove\", \"touchend\", \"touchcancel\", \"touchmove\"].forEach(function(eventName) {\n        document.removeEventListener(eventName, self2._movefn);\n      });\n      this.layers.forEach(function(l3) {\n        if (l3.layer.getImageRatio)\n          l3.layer.changed();\n      });\n      break;\n    }\n    case \"mousedown\":\n    case \"touchstart\": {\n      self2.isMoving = true;\n      [\"mouseup\", \"mousemove\", \"touchend\", \"touchcancel\", \"touchmove\"].forEach(function(eventName) {\n        document.addEventListener(eventName, self2._movefn);\n      });\n    }\n    case \"mousemove\":\n    case \"touchmove\": {\n      if (self2.isMoving) {\n        if (self2.get(\"orientation\") === \"vertical\") {\n          var pageX = e2.pageX || e2.touches && e2.touches.length && e2.touches[0].pageX || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageX;\n          if (!pageX)\n            break;\n          pageX -= self2.getMap().getTargetElement().getBoundingClientRect().left + window.pageXOffset - document.documentElement.clientLeft;\n          l2 = self2.getMap().getSize()[0];\n          var w2 = l2 - Math.min(Math.max(0, l2 - pageX), l2);\n          l2 = w2 / l2;\n          self2.set(\"position\", l2);\n          self2.dispatchEvent({ type: \"moving\", size: [w2, self2.getMap().getSize()[1]], position: [l2, 0] });\n        } else {\n          var pageY = e2.pageY || e2.touches && e2.touches.length && e2.touches[0].pageY || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageY;\n          if (!pageY)\n            break;\n          pageY -= self2.getMap().getTargetElement().getBoundingClientRect().top + window.pageYOffset - document.documentElement.clientTop;\n          l2 = self2.getMap().getSize()[1];\n          var h2 = l2 - Math.min(Math.max(0, l2 - pageY), l2);\n          l2 = h2 / l2;\n          self2.set(\"position\", l2);\n          self2.dispatchEvent({ type: \"moving\", size: [self2.getMap().getSize()[0], h2], position: [0, l2] });\n        }\n      }\n      break;\n    }\n  }\n};\nol_control_Swipe.prototype._transformPt = function(e2, pt2) {\n  var tr = e2.inversePixelTransform;\n  var x2 = pt2[0];\n  var y2 = pt2[1];\n  pt2[0] = tr[0] * x2 + tr[2] * y2 + tr[4];\n  pt2[1] = tr[1] * x2 + tr[3] * y2 + tr[5];\n  return pt2;\n};\nol_control_Swipe.prototype._drawRect = function(e2, pts) {\n  var tr = e2.inversePixelTransform;\n  if (tr) {\n    var r2 = [\n      [pts[0][0], pts[0][1]],\n      [pts[0][0], pts[1][1]],\n      [pts[1][0], pts[1][1]],\n      [pts[1][0], pts[0][1]],\n      [pts[0][0], pts[0][1]]\n    ];\n    e2.context.save();\n    if (e2.target.getImageRatio) {\n      var rot = -Math.atan2(e2.frameState.pixelToCoordinateTransform[1], e2.frameState.pixelToCoordinateTransform[0]);\n      e2.context.translate(e2.frameState.size[0] / 2, e2.frameState.size[1] / 2);\n      e2.context.rotate(rot);\n      e2.context.translate(-e2.frameState.size[0] / 2, -e2.frameState.size[1] / 2);\n    }\n    r2.forEach(function(pt2, i2) {\n      pt2 = [\n        pt2[0] * tr[0] - pt2[1] * tr[1] + tr[4],\n        -pt2[0] * tr[2] + pt2[1] * tr[3] + tr[5]\n      ];\n      if (!i2) {\n        e2.context.moveTo(pt2[0], pt2[1]);\n      } else {\n        e2.context.lineTo(pt2[0], pt2[1]);\n      }\n    });\n    e2.context.restore();\n  } else {\n    var ratio = e2.frameState.pixelRatio;\n    e2.context.rect(pts[0][0] * ratio, pts[0][1] * ratio, pts[1][0] * ratio, pts[1][1] * ratio);\n  }\n};\nol_control_Swipe.prototype.precomposeLeft = function(e2) {\n  var ctx = e2.context;\n  if (ctx instanceof WebGLRenderingContext) {\n    if (e2.type === \"prerender\") {\n      ctx.clearColor(0, 0, 0, 0);\n      ctx.clear(ctx.COLOR_BUFFER_BIT);\n      ctx.enable(ctx.SCISSOR_TEST);\n      var mapSize = this.getMap().getSize();\n      var bottomLeft = this._transformPt(e2, [0, mapSize[1]]);\n      var topRight = this._transformPt(e2, [mapSize[0], 0]);\n      var width = topRight[0] - bottomLeft[0];\n      var height = topRight[1] - bottomLeft[1];\n      if (this.get(\"orientation\") === \"vertical\") {\n        width = Math.round(width * this.get(\"position\"));\n      } else {\n        height = Math.round(height * this.get(\"position\"));\n        bottomLeft[1] += mapSize[1] - height;\n      }\n      ctx.scissor(bottomLeft[0], bottomLeft[1], width, height);\n    }\n  } else {\n    var size = e2.frameState.size;\n    ctx.save();\n    ctx.beginPath();\n    var pts = [[0, 0], [size[0], size[1]]];\n    if (this.get(\"orientation\") === \"vertical\") {\n      pts[1] = [\n        size[0] * 0.5 + this.getMap().getSize()[0] * (this.get(\"position\") - 0.5),\n        size[1]\n      ];\n    } else {\n      pts[1] = [\n        size[0],\n        size[1] * 0.5 + this.getMap().getSize()[1] * (this.get(\"position\") - 0.5)\n      ];\n    }\n    this._drawRect(e2, pts);\n    ctx.clip();\n  }\n};\nol_control_Swipe.prototype.precomposeRight = function(e2) {\n  var ctx = e2.context;\n  if (ctx instanceof WebGLRenderingContext) {\n    if (e2.type === \"prerender\") {\n      ctx.clearColor(0, 0, 0, 0);\n      ctx.clear(ctx.COLOR_BUFFER_BIT);\n      ctx.enable(ctx.SCISSOR_TEST);\n      var mapSize = this.getMap().getSize();\n      var bottomLeft = this._transformPt(e2, [0, mapSize[1]]);\n      var topRight = this._transformPt(e2, [mapSize[0], 0]);\n      var width = topRight[0] - bottomLeft[0];\n      var height = topRight[1] - bottomLeft[1];\n      if (this.get(\"orientation\") === \"vertical\") {\n        width = Math.round(width * (1 - this.get(\"position\")));\n        bottomLeft[0] += mapSize[0] - width;\n      } else {\n        height = Math.round(height * (1 - this.get(\"position\")));\n      }\n      ctx.scissor(bottomLeft[0], bottomLeft[1], width, height);\n    }\n  } else {\n    var size = e2.frameState.size;\n    ctx.save();\n    ctx.beginPath();\n    var pts = [[0, 0], [size[0], size[1]]];\n    if (this.get(\"orientation\") === \"vertical\") {\n      pts[0] = [\n        size[0] * 0.5 + this.getMap().getSize()[0] * (this.get(\"position\") - 0.5),\n        0\n      ];\n    } else {\n      pts[0] = [\n        0,\n        size[1] * 0.5 + this.getMap().getSize()[1] * (this.get(\"position\") - 0.5)\n      ];\n    }\n    this._drawRect(e2, pts);\n    ctx.clip();\n  }\n};\nol_control_Swipe.prototype.postcompose = function(e2) {\n  if (e2.context instanceof WebGLRenderingContext) {\n    if (e2.type === \"postrender\") {\n      var gl = e2.context;\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  } else {\n    if (e2.target.getClassName && e2.target.getClassName() !== \"ol-layer\" && e2.target.get(\"declutter\")) {\n      setTimeout(function() {\n        e2.context.restore();\n      }, 0);\n    } else {\n      e2.context.restore();\n    }\n  }\n};\nconst _sfc_main$A = {\n  name: \"ol-swipe-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_Swipe, props, context);\n    const {\n      layerList\n    } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(props);\n    layerList.value.forEach((layer, index2) => {\n      control.value.addLayer(layer, index2 == 1 ? true : false);\n    });\n    return {\n      control\n    };\n  },\n  props: {\n    layerList: {\n      type: Array\n    },\n    className: {\n      type: String,\n      default: \"ol-swipe\"\n    },\n    position: {\n      type: Number,\n      default: 0.5\n    },\n    orientation: {\n      type: String,\n      default: \"vertical\"\n    }\n  }\n};\nfunction _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar SwipeControl = /* @__PURE__ */ _export_sfc(_sfc_main$A, [[\"render\", _sfc_render$A]]);\nvar ol_control_Bar = function(options) {\n  if (!options)\n    options = {};\n  var element = document.createElement(\"div\");\n  element.classList.add(\"ol-unselectable\", \"ol-control\", \"ol-bar\");\n  if (options.className) {\n    var classes = options.className.split(\" \").filter(function(className) {\n      return className.length > 0;\n    });\n    element.classList.add.apply(element.classList, classes);\n  }\n  if (options.group)\n    element.classList.add(\"ol-group\");\n  ol_control_Control.call(this, {\n    element,\n    target: options.target\n  });\n  this.set(\"toggleOne\", options.toggleOne);\n  this.set(\"autoDeactivate\", options.autoDeactivate);\n  this.controls_ = [];\n  if (options.controls instanceof Array) {\n    for (var i2 = 0; i2 < options.controls.length; i2++) {\n      this.addControl(options.controls[i2]);\n    }\n  }\n};\nol_ext_inherits(ol_control_Bar, ol_control_Control);\nol_control_Bar.prototype.setVisible = function(val) {\n  if (val)\n    this.element.style.display = \"\";\n  else\n    this.element.style.display = \"none\";\n};\nol_control_Bar.prototype.getVisible = function() {\n  return this.element.style.display != \"none\";\n};\nol_control_Bar.prototype.setMap = function(map) {\n  ol_control_Control.prototype.setMap.call(this, map);\n  for (var i2 = 0; i2 < this.controls_.length; i2++) {\n    var c2 = this.controls_[i2];\n    c2.setMap(map);\n  }\n};\nol_control_Bar.prototype.getControls = function() {\n  return this.controls_;\n};\nol_control_Bar.prototype.setPosition = function(pos) {\n  this.element.classList.remove(\"ol-left\", \"ol-top\", \"ol-bottom\", \"ol-right\");\n  pos = pos.split(\"-\");\n  for (var i2 = 0; i2 < pos.length; i2++) {\n    switch (pos[i2]) {\n      case \"top\":\n      case \"left\":\n      case \"bottom\":\n      case \"right\":\n        this.element.classList.add(\"ol-\" + pos[i2]);\n        break;\n    }\n  }\n};\nol_control_Bar.prototype.addControl = function(c2) {\n  this.controls_.push(c2);\n  c2.setTarget(this.element);\n  if (this.getMap()) {\n    this.getMap().addControl(c2);\n  }\n  c2.on(\"change:active\", function(e2) {\n    this.onActivateControl_(e2, c2);\n  }.bind(this));\n  if (c2.getActive) {\n    this.onActivateControl_({ target: c2, active: c2.getActive() }, c2);\n  }\n};\nol_control_Bar.prototype.deactivateControls = function(except) {\n  for (var i2 = 0; i2 < this.controls_.length; i2++) {\n    if (this.controls_[i2] !== except && this.controls_[i2].setActive) {\n      this.controls_[i2].setActive(false);\n    }\n  }\n};\nol_control_Bar.prototype.getActiveControls = function() {\n  var active = [];\n  for (var i2 = 0, c2; c2 = this.controls_[i2]; i2++) {\n    if (c2.getActive && c2.getActive())\n      active.push(c2);\n  }\n  return active;\n};\nol_control_Bar.prototype.setActive = function(b2) {\n  if (!b2 && this.get(\"autoDeactivate\")) {\n    this.deactivateControls();\n  }\n  if (b2) {\n    var ctrls = this.getControls();\n    for (var i2 = 0, sb; sb = ctrls[i2]; i2++) {\n      if (sb.get(\"autoActivate\"))\n        sb.setActive(true);\n    }\n  }\n};\nol_control_Bar.prototype.onActivateControl_ = function(e2, ctrl) {\n  if (this.get(\"toggleOne\")) {\n    if (e2.active) {\n      var n2;\n      for (n2 = 0; n2 < this.controls_.length; n2++) {\n        if (this.controls_[n2] === ctrl)\n          break;\n      }\n      if (n2 == this.controls_.length)\n        return;\n      this.deactivateControls(this.controls_[n2]);\n    } else {\n      if (!this.getActiveControls().length) {\n        for (var i2 = 0, c2; c2 = this.controls_[i2]; i2++) {\n          if (c2.get(\"autoActivate\")) {\n            c2.setActive(true);\n            break;\n          }\n        }\n      }\n    }\n  }\n};\nol_control_Bar.prototype.getControlsByName = function(name) {\n  var controls = this.getControls();\n  return controls.filter(function(control) {\n    return control.get(\"name\") === name;\n  });\n};\nconst _sfc_main$z = {\n  name: \"ol-control-bar\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_Bar, props, context);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"controlBar\", control);\n    return {\n      control\n    };\n  },\n  props: {\n    toggleOne: {\n      type: Boolean,\n      default: true\n    },\n    group: {\n      type: Boolean,\n      default: true\n    }\n  }\n};\nfunction _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar ControlBar = /* @__PURE__ */ _export_sfc(_sfc_main$z, [[\"render\", _sfc_render$z]]);\nif (window.ol) {\n  ol.ext.input = {};\n}\nvar ol_ext_input_Base = function(options) {\n  options = options || {};\n  ol_Object.call(this);\n  var input = this.input = options.input;\n  if (!input) {\n    input = this.input = document.createElement(\"INPUT\");\n    if (options.type)\n      input.setAttribute(\"type\", options.type);\n    if (options.min !== void 0)\n      input.setAttribute(\"min\", options.min);\n    if (options.max !== void 0)\n      input.setAttribute(\"max\", options.max);\n    if (options.step !== void 0)\n      input.setAttribute(\"step\", options.step);\n    if (options.parent)\n      options.parent.appendChild(input);\n  }\n  if (options.disabled)\n    input.disabled = true;\n  if (options.checked !== void 0)\n    input.checked = !!options.checked;\n  if (options.val !== void 0)\n    input.value = options.val;\n  if (options.hidden)\n    input.style.display = \"none\";\n  input.addEventListener(\"focus\", function() {\n    if (this.element)\n      this.element.classList.add(\"ol-focus\");\n  }.bind(this));\n  var tout;\n  input.addEventListener(\"focusout\", function() {\n    if (this.element) {\n      if (tout)\n        clearTimeout(tout);\n      tout = setTimeout(function() {\n        this.element.classList.remove(\"ol-focus\");\n      }.bind(this), 0);\n    }\n  }.bind(this));\n};\nol_ext_inherits(ol_ext_input_Base, ol_Object);\nol_ext_input_Base.prototype._listenDrag = function(elt, cback) {\n  var handle = function(e2) {\n    this.moving = true;\n    var listen2 = function(e3) {\n      if (e3.type === \"pointerup\") {\n        document.removeEventListener(\"pointermove\", listen2);\n        document.removeEventListener(\"pointerup\", listen2);\n        document.removeEventListener(\"pointercancel\", listen2);\n        setTimeout(function() {\n          this.moving = false;\n        }.bind(this));\n      }\n      if (e3.target === elt)\n        cback(e3);\n      e3.stopPropagation();\n      e3.preventDefault();\n    }.bind(this);\n    document.addEventListener(\"pointermove\", listen2, false);\n    document.addEventListener(\"pointerup\", listen2, false);\n    document.addEventListener(\"pointercancel\", listen2, false);\n    e2.stopPropagation();\n    e2.preventDefault();\n  }.bind(this);\n  elt.addEventListener(\"mousedown\", handle, false);\n  elt.addEventListener(\"touchstart\", handle, false);\n};\nol_ext_input_Base.prototype.setValue = function(v2) {\n  if (v2 !== void 0)\n    this.input.value = v2;\n  this.input.dispatchEvent(new Event(\"change\"));\n};\nol_ext_input_Base.prototype.getValue = function() {\n  return this.input.value;\n};\nol_ext_input_Base.prototype.getInputElement = function() {\n  return this.input;\n};\nvar ol_ext_input_Checkbox = function(options) {\n  options = options || {};\n  ol_ext_input_Base.call(this, options);\n  var label = this.element = document.createElement(\"LABEL\");\n  if (options.html instanceof Element)\n    label.appendChild(options.html);\n  else if (options.html !== void 0)\n    label.innerHTML = options.html;\n  label.className = (\"ol-ext-check ol-ext-checkbox \" + (options.className || \"\")).trim();\n  if (this.input.parentNode)\n    this.input.parentNode.insertBefore(label, this.input);\n  label.appendChild(this.input);\n  label.appendChild(document.createElement(\"SPAN\"));\n  if (options.after) {\n    label.appendChild(document.createTextNode(options.after));\n  }\n  this.input.addEventListener(\"change\", function() {\n    this.dispatchEvent({ type: \"check\", checked: this.input.checked, value: this.input.value });\n  }.bind(this));\n};\nol_ext_inherits(ol_ext_input_Checkbox, ol_ext_input_Base);\nol_ext_input_Checkbox.prototype.isChecked = function() {\n  return this.input.checked;\n};\nvar ol_ext_input_Switch = function(options) {\n  options = options || {};\n  ol_ext_input_Checkbox.call(this, options);\n  this.element.className = (\"ol-ext-toggle-switch \" + (options.className || \"\")).trim();\n};\nol_ext_inherits(ol_ext_input_Switch, ol_ext_input_Checkbox);\nvar ol_ext_input_Radio = function(options) {\n  options = options || {};\n  ol_ext_input_Checkbox.call(this, options);\n  this.element.className = (\"ol-ext-check ol-ext-radio \" + (options.className || \"\")).trim();\n};\nol_ext_inherits(ol_ext_input_Radio, ol_ext_input_Checkbox);\nvar ol_ext_element = {};\nol_ext_element.create = function(tagName, options) {\n  options = options || {};\n  var elt;\n  if (tagName === \"TEXT\") {\n    elt = document.createTextNode(options.html || \"\");\n    if (options.parent)\n      options.parent.appendChild(elt);\n  } else {\n    elt = document.createElement(tagName);\n    if (/button/i.test(tagName))\n      elt.setAttribute(\"type\", \"button\");\n    for (var attr in options) {\n      switch (attr) {\n        case \"className\": {\n          if (options.className && options.className.trim)\n            elt.setAttribute(\"class\", options.className.trim());\n          break;\n        }\n        case \"text\": {\n          elt.innerText = options.text;\n          break;\n        }\n        case \"html\": {\n          if (options.html instanceof Element)\n            elt.appendChild(options.html);\n          else if (options.html !== void 0)\n            elt.innerHTML = options.html;\n          break;\n        }\n        case \"parent\": {\n          if (options.parent)\n            options.parent.appendChild(elt);\n          break;\n        }\n        case \"options\": {\n          if (/select/i.test(tagName)) {\n            for (var i2 in options.options) {\n              ol_ext_element.create(\"OPTION\", {\n                html: i2,\n                value: options.options[i2],\n                parent: elt\n              });\n            }\n          }\n          break;\n        }\n        case \"style\": {\n          this.setStyle(elt, options.style);\n          break;\n        }\n        case \"change\":\n        case \"click\": {\n          ol_ext_element.addListener(elt, attr, options[attr]);\n          break;\n        }\n        case \"on\": {\n          for (var e2 in options.on) {\n            ol_ext_element.addListener(elt, e2, options.on[e2]);\n          }\n          break;\n        }\n        case \"checked\": {\n          elt.checked = !!options.checked;\n          break;\n        }\n        default: {\n          elt.setAttribute(attr, options[attr]);\n          break;\n        }\n      }\n    }\n  }\n  return elt;\n};\nol_ext_element.createSwitch = function(options) {\n  var input = ol_ext_element.create(\"INPUT\", {\n    type: \"checkbox\",\n    on: options.on,\n    click: options.click,\n    change: options.change,\n    parent: options.parent\n  });\n  var opt = Object.assign({ input }, options || {});\n  new ol_ext_input_Switch(opt);\n  return input;\n};\nol_ext_element.createCheck = function(options) {\n  var input = ol_ext_element.create(\"INPUT\", {\n    name: options.name,\n    type: options.type === \"radio\" ? \"radio\" : \"checkbox\",\n    on: options.on,\n    parent: options.parent\n  });\n  console.log(input);\n  var opt = Object.assign({ input }, options || {});\n  if (options.type === \"radio\") {\n    new ol_ext_input_Radio(opt);\n  } else {\n    new ol_ext_input_Checkbox(opt);\n  }\n  return input;\n};\nol_ext_element.setHTML = function(element, html2) {\n  if (html2 instanceof Element)\n    element.appendChild(html2);\n  else if (html2 !== void 0)\n    element.innerHTML = html2;\n};\nol_ext_element.appendText = function(element, text2) {\n  element.appendChild(document.createTextNode(text2 || \"\"));\n};\nol_ext_element.addListener = function(element, eventType, fn, useCapture) {\n  if (typeof eventType === \"string\")\n    eventType = eventType.split(\" \");\n  eventType.forEach(function(e2) {\n    element.addEventListener(e2, fn, useCapture);\n  });\n};\nol_ext_element.removeListener = function(element, eventType, fn) {\n  if (typeof eventType === \"string\")\n    eventType = eventType.split(\" \");\n  eventType.forEach(function(e2) {\n    element.removeEventListener(e2, fn);\n  });\n};\nol_ext_element.show = function(element) {\n  element.style.display = \"\";\n};\nol_ext_element.hide = function(element) {\n  element.style.display = \"none\";\n};\nol_ext_element.hidden = function(element) {\n  return ol_ext_element.getStyle(element, \"display\") === \"none\";\n};\nol_ext_element.toggle = function(element) {\n  element.style.display = element.style.display === \"none\" ? \"\" : \"none\";\n};\nol_ext_element.setStyle = function(el, st2) {\n  for (var s2 in st2) {\n    switch (s2) {\n      case \"top\":\n      case \"left\":\n      case \"bottom\":\n      case \"right\":\n      case \"minWidth\":\n      case \"maxWidth\":\n      case \"width\":\n      case \"height\": {\n        if (typeof st2[s2] === \"number\") {\n          el.style[s2] = st2[s2] + \"px\";\n        } else {\n          el.style[s2] = st2[s2];\n        }\n        break;\n      }\n      default: {\n        el.style[s2] = st2[s2];\n      }\n    }\n  }\n};\nol_ext_element.getStyle = function(el, styleProp) {\n  var value, defaultView = (el.ownerDocument || document).defaultView;\n  if (defaultView && defaultView.getComputedStyle) {\n    styleProp = styleProp.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n    value = defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);\n  } else if (el.currentStyle) {\n    styleProp = styleProp.replace(/-(\\w)/g, function(str, letter) {\n      return letter.toUpperCase();\n    });\n    value = el.currentStyle[styleProp];\n    if (/^\\d+(em|pt|%|ex)?$/i.test(value)) {\n      return function(value2) {\n        var oldLeft = el.style.left, oldRsLeft = el.runtimeStyle.left;\n        el.runtimeStyle.left = el.currentStyle.left;\n        el.style.left = value2 || 0;\n        value2 = el.style.pixelLeft + \"px\";\n        el.style.left = oldLeft;\n        el.runtimeStyle.left = oldRsLeft;\n        return value2;\n      }(value);\n    }\n  }\n  if (/px$/.test(value))\n    return parseInt(value);\n  return value;\n};\nol_ext_element.outerHeight = function(elt) {\n  return elt.offsetHeight + ol_ext_element.getStyle(elt, \"marginBottom\");\n};\nol_ext_element.outerWidth = function(elt) {\n  return elt.offsetWidth + ol_ext_element.getStyle(elt, \"marginLeft\");\n};\nol_ext_element.offsetRect = function(elt) {\n  var rect = elt.getBoundingClientRect();\n  return {\n    top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),\n    left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0),\n    height: rect.height || rect.bottom - rect.top,\n    width: rect.width || rect.right - rect.left\n  };\n};\nol_ext_element.getFixedOffset = function(elt) {\n  var offset2 = {\n    left: 0,\n    top: 0\n  };\n  var getOffset = function(parent) {\n    if (!parent)\n      return offset2;\n    if (ol_ext_element.getStyle(parent, \"position\") === \"absolute\" && ol_ext_element.getStyle(parent, \"transform\") !== \"none\") {\n      var r2 = parent.getBoundingClientRect();\n      offset2.left += r2.left;\n      offset2.top += r2.top;\n      return offset2;\n    }\n    return getOffset(parent.offsetParent);\n  };\n  return getOffset(elt.offsetParent);\n};\nol_ext_element.positionRect = function(elt, fixed) {\n  var gleft = 0;\n  var gtop = 0;\n  var getRect = function(parent) {\n    if (parent) {\n      gleft += parent.offsetLeft;\n      gtop += parent.offsetTop;\n      return getRect(parent.offsetParent);\n    } else {\n      var r2 = {\n        top: elt.offsetTop + gtop,\n        left: elt.offsetLeft + gleft\n      };\n      if (fixed) {\n        r2.top -= window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n        r2.left -= window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;\n      }\n      r2.bottom = r2.top + elt.offsetHeight;\n      r2.right = r2.top + elt.offsetWidth;\n      return r2;\n    }\n  };\n  return getRect(elt.offsetParent);\n};\nol_ext_element.scrollDiv = function(elt, options) {\n  options = options || {};\n  var pos = false;\n  var speed = 0;\n  var d2, dt2 = 0;\n  var onmove = typeof options.onmove === \"function\" ? options.onmove : function() {\n  };\n  var page = options.vertical ? \"screenY\" : \"screenX\";\n  var scroll = options.vertical ? \"scrollTop\" : \"scrollLeft\";\n  var moving = false;\n  var scale2, isbar;\n  var updateCounter = 0;\n  var updateMinibar = function() {\n    if (scrollbar) {\n      updateCounter++;\n      setTimeout(updateMinibarDelay);\n    }\n  };\n  var updateMinibarDelay = function() {\n    if (scrollbar) {\n      updateCounter--;\n      if (updateCounter)\n        return;\n      var pheight = elt.clientHeight;\n      var height = elt.scrollHeight;\n      scale2 = pheight / height;\n      scrollbar.style.height = scale2 * 100 + \"%\";\n      scrollbar.style.top = elt.scrollTop / height * 100 + \"%\";\n      scrollContainer.style.height = pheight + \"px\";\n      if (pheight > height - 0.5)\n        scrollContainer.classList.add(\"ol-100pc\");\n      else\n        scrollContainer.classList.remove(\"ol-100pc\");\n    }\n  };\n  var onPointerDown = function(e2) {\n    if (e2.target.classList.contains(\"ol-noscroll\"))\n      return;\n    moving = false;\n    pos = e2[page];\n    dt2 = new Date();\n    elt.classList.add(\"ol-move\");\n    e2.preventDefault();\n    window.addEventListener(\"pointermove\", onPointerMove);\n    ol_ext_element.addListener(window, [\"pointerup\", \"pointercancel\"], onPointerUp);\n  };\n  var onPointerMove = function(e2) {\n    moving = true;\n    if (pos !== false) {\n      var delta = (isbar ? -1 / scale2 : 1) * (pos - e2[page]);\n      elt[scroll] += delta;\n      d2 = new Date();\n      if (d2 - dt2) {\n        speed = (speed + delta / (d2 - dt2)) / 2;\n      }\n      pos = e2[page];\n      dt2 = d2;\n      if (delta)\n        onmove(true);\n    }\n  };\n  var animate = function(to) {\n    var step = to > 0 ? Math.min(100, to / 2) : Math.max(-100, to / 2);\n    to -= step;\n    elt[scroll] += step;\n    if (-1 < to && to < 1) {\n      if (moving)\n        setTimeout(function() {\n          elt.classList.remove(\"ol-move\");\n        });\n      else\n        elt.classList.remove(\"ol-move\");\n      moving = false;\n      onmove(false);\n    } else {\n      setTimeout(function() {\n        animate(to);\n      }, 40);\n    }\n  };\n  var scrollContainer, scrollbar;\n  if (options.vertical && options.minibar) {\n    var init2 = function(b2) {\n      elt.removeEventListener(\"pointermove\", init2);\n      elt.parentNode.classList.add(\"ol-miniscroll\");\n      scrollbar = ol_ext_element.create(\"DIV\");\n      scrollContainer = ol_ext_element.create(\"DIV\", {\n        className: \"ol-scroll\",\n        html: scrollbar\n      });\n      elt.parentNode.insertBefore(scrollContainer, elt);\n      scrollbar.addEventListener(\"pointerdown\", function(e2) {\n        isbar = true;\n        onPointerDown(e2);\n      });\n      if (options.mousewheel) {\n        ol_ext_element.addListener(scrollContainer, [\"mousewheel\", \"DOMMouseScroll\", \"onmousewheel\"], function(e2) {\n          onMouseWheel(e2);\n        });\n        ol_ext_element.addListener(scrollbar, [\"mousewheel\", \"DOMMouseScroll\", \"onmousewheel\"], function(e2) {\n          onMouseWheel(e2);\n        });\n      }\n      elt.parentNode.addEventListener(\"pointerenter\", updateMinibar);\n      window.addEventListener(\"resize\", updateMinibar);\n      if (b2 !== false)\n        updateMinibar();\n    };\n    if (elt.parentNode)\n      init2(false);\n    else\n      elt.addEventListener(\"pointermove\", init2);\n    elt.addEventListener(\"scroll\", function() {\n      updateMinibar();\n    });\n  }\n  elt.style[\"touch-action\"] = \"none\";\n  elt.style[\"overflow\"] = \"hidden\";\n  elt.classList.add(\"ol-scrolldiv\");\n  ol_ext_element.addListener(elt, [\"pointerdown\"], function(e2) {\n    isbar = false;\n    onPointerDown(e2);\n  });\n  elt.addEventListener(\"click\", function(e2) {\n    if (elt.classList.contains(\"ol-move\")) {\n      e2.preventDefault();\n      e2.stopPropagation();\n    }\n  }, true);\n  var onPointerUp = function(e2) {\n    dt2 = new Date() - dt2;\n    if (dt2 > 100 || isbar) {\n      speed = 0;\n    } else if (dt2 > 0) {\n      speed = ((speed || 0) + (pos - e2[page]) / dt2) / 2;\n    }\n    animate(options.animate === false ? 0 : speed * 200);\n    pos = false;\n    speed = 0;\n    dt2 = 0;\n    if (!elt.classList.contains(\"ol-move\")) {\n      elt.classList.add(\"ol-hasClick\");\n      setTimeout(function() {\n        elt.classList.remove(\"ol-hasClick\");\n      }, 500);\n    } else {\n      elt.classList.remove(\"ol-hasClick\");\n    }\n    isbar = false;\n    window.removeEventListener(\"pointermove\", onPointerMove);\n    ol_ext_element.removeListener(window, [\"pointerup\", \"pointercancel\"], onPointerUp);\n  };\n  var onMouseWheel = function(e2) {\n    var delta = Math.max(-1, Math.min(1, e2.wheelDelta || -e2.detail));\n    elt.classList.add(\"ol-move\");\n    elt[scroll] -= delta * 30;\n    elt.classList.remove(\"ol-move\");\n    return false;\n  };\n  if (options.mousewheel) {\n    ol_ext_element.addListener(elt, [\"mousewheel\", \"DOMMouseScroll\", \"onmousewheel\"], onMouseWheel);\n  }\n  return {\n    refresh: updateMinibar\n  };\n};\nol_ext_element.dispatchEvent = function(eventName, element) {\n  var event;\n  try {\n    event = new CustomEvent(eventName);\n  } catch (e2) {\n    event = document.createEvent(\"CustomEvent\");\n    event.initCustomEvent(eventName, true, true, {});\n  }\n  element.dispatchEvent(event);\n};\nvar ol_control_Button = function(options) {\n  options = options || {};\n  var element = document.createElement(\"div\");\n  element.className = (options.className || \"\") + \" ol-button ol-unselectable ol-control\";\n  var self2 = this;\n  var bt2 = this.button_ = document.createElement(/ol-text-button/.test(options.className) ? \"div\" : \"button\");\n  bt2.type = \"button\";\n  if (options.title)\n    bt2.title = options.title;\n  if (options.name)\n    bt2.name = options.name;\n  if (options.html instanceof Element)\n    bt2.appendChild(options.html);\n  else\n    bt2.innerHTML = options.html || \"\";\n  var evtFunction = function(e2) {\n    if (e2 && e2.preventDefault) {\n      e2.preventDefault();\n      e2.stopPropagation();\n    }\n    if (options.handleClick) {\n      options.handleClick.call(self2, e2);\n    }\n  };\n  bt2.addEventListener(\"click\", evtFunction);\n  element.appendChild(bt2);\n  if (!options.title && bt2.firstElementChild) {\n    bt2.title = bt2.firstElementChild.title;\n  }\n  ol_control_Control.call(this, {\n    element,\n    target: options.target\n  });\n  if (options.title) {\n    this.set(\"title\", options.title);\n  }\n  if (options.title)\n    this.set(\"title\", options.title);\n  if (options.name)\n    this.set(\"name\", options.name);\n};\nol_ext_inherits(ol_control_Button, ol_control_Control);\nol_control_Button.prototype.setVisible = function(val) {\n  if (val)\n    ol_ext_element.show(this.element);\n  else\n    ol_ext_element.hide(this.element);\n};\nol_control_Button.prototype.setTitle = function(title) {\n  this.button_.setAttribute(\"title\", title);\n};\nol_control_Button.prototype.setHtml = function(html2) {\n  ol_ext_element.setHTML(this.button_, html2);\n};\nol_control_Button.prototype.getButtonElement = function() {\n  return this.button_;\n};\nvar ol_control_Toggle = function(options) {\n  options = options || {};\n  var self2 = this;\n  this.interaction_ = options.interaction;\n  if (this.interaction_) {\n    this.interaction_.setActive(options.active);\n    this.interaction_.on(\"change:active\", function() {\n      self2.setActive(self2.interaction_.getActive());\n    });\n  }\n  if (options.toggleFn)\n    options.onToggle = options.toggleFn;\n  options.handleClick = function() {\n    self2.toggle();\n    if (options.onToggle)\n      options.onToggle.call(self2, self2.getActive());\n  };\n  options.className = (options.className || \"\") + \" ol-toggle\";\n  ol_control_Button.call(this, options);\n  this.set(\"title\", options.title);\n  this.set(\"autoActivate\", options.autoActivate);\n  if (options.bar)\n    this.setSubBar(options.bar);\n  this.setActive(options.active);\n  this.setDisable(options.disable);\n};\nol_ext_inherits(ol_control_Toggle, ol_control_Button);\nol_control_Toggle.prototype.setMap = function(map) {\n  if (!map && this.getMap()) {\n    if (this.interaction_) {\n      this.getMap().removeInteraction(this.interaction_);\n    }\n    if (this.subbar_)\n      this.getMap().removeControl(this.subbar_);\n  }\n  ol_control_Button.prototype.setMap.call(this, map);\n  if (map) {\n    if (this.interaction_)\n      map.addInteraction(this.interaction_);\n    if (this.subbar_)\n      map.addControl(this.subbar_);\n  }\n};\nol_control_Toggle.prototype.getSubBar = function() {\n  return this.subbar_;\n};\nol_control_Toggle.prototype.setSubBar = function(bar) {\n  var map = this.getMap();\n  if (map && this.subbar_)\n    map.removeControl(this.subbar_);\n  this.subbar_ = bar;\n  if (bar) {\n    this.subbar_.setTarget(this.element);\n    this.subbar_.element.classList.add(\"ol-option-bar\");\n    if (map)\n      map.addControl(this.subbar_);\n  }\n};\nol_control_Toggle.prototype.getDisable = function() {\n  var button = this.element.querySelector(\"button\");\n  return button && button.disabled;\n};\nol_control_Toggle.prototype.setDisable = function(b2) {\n  if (this.getDisable() == b2)\n    return;\n  this.element.querySelector(\"button\").disabled = b2;\n  if (b2 && this.getActive())\n    this.setActive(false);\n  this.dispatchEvent({ type: \"change:disable\", key: \"disable\", oldValue: !b2, disable: b2 });\n};\nol_control_Toggle.prototype.getActive = function() {\n  return this.element.classList.contains(\"ol-active\");\n};\nol_control_Toggle.prototype.toggle = function() {\n  if (this.getActive())\n    this.setActive(false);\n  else\n    this.setActive(true);\n};\nol_control_Toggle.prototype.setActive = function(b2) {\n  if (this.interaction_)\n    this.interaction_.setActive(b2);\n  if (this.subbar_)\n    this.subbar_.setActive(b2);\n  if (this.getActive() === b2)\n    return;\n  if (b2)\n    this.element.classList.add(\"ol-active\");\n  else\n    this.element.classList.remove(\"ol-active\");\n  this.dispatchEvent({ type: \"change:active\", key: \"active\", oldValue: !b2, active: b2 });\n};\nol_control_Toggle.prototype.setInteraction = function(i2) {\n  this.interaction_ = i2;\n};\nol_control_Toggle.prototype.getInteraction = function() {\n  return this.interaction_;\n};\nconst _sfc_main$y = {\n  name: \"ol-control-toggle\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_Toggle, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    html: {\n      type: String\n    },\n    interaction: {\n      type: Object\n    },\n    className: {\n      type: String\n    },\n    title: {\n      type: String\n    },\n    onToggle: {\n      type: Function\n    }\n  }\n};\nfunction _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar ToggleControl = /* @__PURE__ */ _export_sfc(_sfc_main$y, [[\"render\", _sfc_render$y]]);\nconst _sfc_main$x = {\n  name: \"ol-control-button\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_Button, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    html: {\n      type: String\n    },\n    name: {\n      type: String\n    },\n    className: {\n      type: String\n    },\n    title: {\n      type: String\n    },\n    handleClick: {\n      type: Function\n    }\n  }\n};\nfunction _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar ButtonControl = /* @__PURE__ */ _export_sfc(_sfc_main$x, [[\"render\", _sfc_render$x]]);\nvar ol_control_Dialog = function(options) {\n  options = options || {};\n  if (options.fullscreen)\n    options.target = document.body;\n  var element = ol_ext_element.create(\"DIV\", {\n    className: ((options.className || \"\") + (options.zoom ? \" ol-zoom\" : \"\") + \" ol-ext-dialog\").trim(),\n    click: function(e2) {\n      if (this.get(\"hideOnBack\") && e2.target === element)\n        this.close();\n      if (this.get(\"hideOnClick\"))\n        this.close();\n    }.bind(this)\n  });\n  var form = ol_ext_element.create(\"FORM\", {\n    on: {\n      submit: this._onButton(\"submit\")\n    },\n    parent: element\n  });\n  ol_ext_element.create(\"H2\", {\n    parent: form\n  });\n  ol_ext_element.create(\"DIV\", {\n    className: \"ol-closebox\",\n    click: this._onButton(\"cancel\"),\n    parent: form\n  });\n  ol_ext_element.create(\"DIV\", {\n    className: \"ol-content\",\n    parent: form\n  });\n  this._progress = ol_ext_element.create(\"DIV\", {\n    style: { display: \"none\" },\n    parent: form\n  });\n  var bar = ol_ext_element.create(\"DIV\", {\n    className: \"ol-progress-bar\",\n    parent: this._progress\n  });\n  this._progressbar = ol_ext_element.create(\"DIV\", {\n    parent: bar\n  });\n  this._progressMessage = ol_ext_element.create(\"DIV\", {\n    className: \"ol-progress-message\",\n    parent: this._progress\n  });\n  ol_ext_element.create(\"DIV\", {\n    className: \"ol-buttons\",\n    parent: form\n  });\n  ol_control_Control.call(this, {\n    element,\n    target: options.target\n  });\n  this.set(\"closeBox\", options.closeBox !== false);\n  this.set(\"zoom\", !!options.zoom);\n  this.set(\"hideOnClick\", !!options.hideOnClick);\n  this.set(\"hideOnBack\", !!options.hideOnBack);\n  this.set(\"className\", element.className);\n  this.set(\"closeOnSubmit\", options.closeOnSubmit);\n  this.set(\"buttons\", options.buttons);\n  this.setContent(options);\n};\nol_ext_inherits(ol_control_Dialog, ol_control_Control);\nol_control_Dialog.prototype.show = function(options) {\n  if (options) {\n    if (options instanceof Element || typeof options === \"string\") {\n      options = { content: options };\n    }\n    this.setContent(options);\n  }\n  this.element.classList.add(\"ol-visible\");\n  var input = this.element.querySelector('input[type=\"text\"],input[type=\"search\"],input[type=\"number\"]');\n  if (input)\n    input.focus();\n  this.dispatchEvent({ type: \"show\" });\n  if (options) {\n    if (options.autoclose) {\n      var listener2 = setTimeout(function() {\n        this.hide();\n      }.bind(this), options.autoclose);\n      this.once(\"hide\", function() {\n        clearTimeout(listener2);\n      });\n    }\n    if (options.hideOnBack) {\n      var value = this.get(\"hideOnBack\");\n      this.set(\"hideOnBack\", true);\n      this.once(\"hide\", function() {\n        this.set(\"hideOnBack\", value);\n      }.bind(this));\n    }\n  }\n};\nol_control_Dialog.prototype.open = function() {\n  this.show();\n};\nol_control_Dialog.prototype.setContentMessage = function(content2) {\n  if (content2 !== void 0) {\n    var elt = this.getContentElement();\n    if (content2 instanceof Element)\n      ol_ext_element.setHTML(elt, \"\");\n    ol_ext_element.setHTML(elt, content2 || \"\");\n  }\n};\nol_control_Dialog.prototype.setTitle = function(title) {\n  var form = this.element.querySelector(\"form\");\n  form.querySelector(\"h2\").innerText = title || \"\";\n  if (title) {\n    form.classList.add(\"ol-title\");\n  } else {\n    form.classList.remove(\"ol-title\");\n  }\n};\nol_control_Dialog.prototype.setContent = function(options) {\n  if (!options)\n    return;\n  this.element.className = this.get(\"className\");\n  if (typeof options === \"string\")\n    options = { content: options };\n  options = options || {};\n  this.setProgress(false);\n  if (options.max)\n    this.setProgress(0, options.max);\n  if (options.progress !== void 0)\n    this.setProgress(options.progress);\n  if (this.get(\"zoom\"))\n    this.element.classList.add(\"ol-zoom\");\n  else\n    this.element.classList.remove(\"ol-zoom\");\n  if (options.className) {\n    options.className.split(\" \").forEach(function(c2) {\n      this.element.classList.add(c2);\n    }.bind(this));\n  }\n  var form = this.element.querySelector(\"form\");\n  if (options.content !== void 0) {\n    if (options.content instanceof Element)\n      ol_ext_element.setHTML(form.querySelector(\".ol-content\"), \"\");\n    ol_ext_element.setHTML(form.querySelector(\".ol-content\"), options.content || \"\");\n  }\n  this.setTitle(options.title);\n  if (options.closeBox || this.get(\"closeBox\") && options.closeBox !== false) {\n    form.classList.add(\"ol-closebox\");\n  } else {\n    form.classList.remove(\"ol-closebox\");\n  }\n  var buttons = this.element.querySelector(\".ol-buttons\");\n  buttons.innerHTML = \"\";\n  var btn = options.buttons || this.get(\"buttons\");\n  if (btn) {\n    form.classList.add(\"ol-button\");\n    for (var i2 in btn) {\n      ol_ext_element.create(\"INPUT\", {\n        type: i2 === \"submit\" ? \"submit\" : \"button\",\n        value: btn[i2],\n        click: this._onButton(i2, options.onButton),\n        parent: buttons\n      });\n    }\n  } else {\n    form.classList.remove(\"ol-button\");\n  }\n};\nol_control_Dialog.prototype.getContentElement = function() {\n  return this.element.querySelector(\"form .ol-content\");\n};\nol_control_Dialog.prototype.setProgress = function(val, max2, message) {\n  if (val === false) {\n    ol_ext_element.setStyle(this._progress, { display: \"none\" });\n    return;\n  }\n  if (max2 > 0) {\n    this.set(\"max\", Number(max2));\n  } else {\n    max2 = this.get(\"max\");\n  }\n  if (!max2) {\n    ol_ext_element.setStyle(this._progress, { display: \"none\" });\n  } else {\n    var p5 = Math.round(val / max2 * 100);\n    ol_ext_element.setStyle(this._progress, { display: \"\" });\n    this._progressbar.className = p5 ? \"\" : \"notransition\";\n    ol_ext_element.setStyle(this._progressbar, { width: p5 + \"%\" });\n  }\n  this._progressMessage.innerHTML = \"\";\n  ol_ext_element.setHTML(this._progressMessage, message || \"\");\n};\nol_control_Dialog.prototype._onButton = function(button, callback) {\n  var fn = function(e2) {\n    e2.preventDefault();\n    if (button !== \"submit\" || this.get(\"closeOnSubmit\") !== false)\n      this.hide();\n    var inputs = this.getInputs();\n    this.dispatchEvent({ type: \"button\", button, inputs });\n    if (typeof callback === \"function\")\n      callback(button, inputs);\n  }.bind(this);\n  return fn;\n};\nol_control_Dialog.prototype.getInputs = function() {\n  var inputs = {};\n  [\"input\", \"textarea\", \"select\"].forEach(function(type) {\n    this.element.querySelectorAll(\"form \" + type).forEach(function(input) {\n      if (input.className) {\n        input.className.split(\" \").forEach(function(n2) {\n          inputs[n2] = input;\n        });\n      }\n    });\n  }.bind(this));\n  return inputs;\n};\nol_control_Dialog.prototype.hide = function() {\n  this.element.classList.remove(\"ol-visible\");\n  this.dispatchEvent({ type: \"hide\" });\n};\nol_control_Dialog.prototype.close = ol_control_Dialog.prototype.hide;\nol_control_Dialog.prototype.isOpen = function() {\n  return this.element.classList.contains(\"ol-visible\");\n};\nvar ol_ext_getMapCanvas = function(map) {\n  if (!map)\n    return null;\n  var canvas = map.getViewport().getElementsByClassName(\"ol-fixedoverlay\")[0];\n  if (!canvas) {\n    if (map.getViewport().querySelector(\".ol-layers\")) {\n      canvas = document.createElement(\"canvas\");\n      canvas.className = \"ol-fixedoverlay\";\n      map.getViewport().querySelector(\".ol-layers\").after(canvas);\n      map.on(\"precompose\", function(e2) {\n        canvas.width = map.getSize()[0] * e2.frameState.pixelRatio;\n        canvas.height = map.getSize()[1] * e2.frameState.pixelRatio;\n      });\n    } else {\n      canvas = map.getViewport().querySelector(\"canvas\");\n    }\n  }\n  return canvas;\n};\nvar ol_control_CanvasBase = function(options) {\n  if (!options)\n    options = {};\n  this.setStyle(options.style);\n  ol_control_Control.call(this, options);\n};\nol_ext_inherits(ol_control_CanvasBase, ol_control_Control);\nol_control_CanvasBase.prototype.setMap = function(map) {\n  this.getCanvas(map);\n  var oldmap = this.getMap();\n  if (this._listener) {\n    unByKey(this._listener);\n    this._listener = null;\n  }\n  ol_control_Control.prototype.setMap.call(this, map);\n  if (oldmap) {\n    try {\n      oldmap.renderSync();\n    } catch (e2) {\n    }\n  }\n  if (map) {\n    this._listener = map.on(\"postcompose\", this._draw.bind(this));\n  }\n};\nol_control_CanvasBase.prototype.getCanvas = function(map) {\n  return ol_ext_getMapCanvas(map);\n};\nol_control_CanvasBase.prototype.getContext = function(e2) {\n  var ctx = e2.context;\n  if (!ctx && this.getMap()) {\n    var c2 = this.getMap().getViewport().getElementsByClassName(\"ol-fixedoverlay\")[0];\n    ctx = c2 ? c2.getContext(\"2d\") : null;\n  }\n  return ctx;\n};\nol_control_CanvasBase.prototype.setStyle = function(style2) {\n  this._style = style2 || new Style$2({});\n};\nol_control_CanvasBase.prototype.getStyle = function() {\n  return this._style;\n};\nol_control_CanvasBase.prototype.getStroke = function() {\n  var t3 = this._style.getStroke();\n  if (!t3)\n    this._style.setStroke(new Stroke$2({ color: \"#000\", width: 1.25 }));\n  return this._style.getStroke();\n};\nol_control_CanvasBase.prototype.getFill = function() {\n  var t3 = this._style.getFill();\n  if (!t3)\n    this._style.setFill(new Fill$2({ color: \"#fff\" }));\n  return this._style.getFill();\n};\nol_control_CanvasBase.prototype.getTextStroke = function() {\n  var t3 = this._style.getText();\n  if (!t3)\n    t3 = new Text$2({});\n  if (!t3.getStroke())\n    t3.setStroke(new Stroke$2({ color: \"#fff\", width: 3 }));\n  return t3.getStroke();\n};\nol_control_CanvasBase.prototype.getTextFill = function() {\n  var t3 = this._style.getText();\n  if (!t3)\n    t3 = new Text$2({});\n  if (!t3.getFill())\n    t3.setFill(new Fill$2({ color: \"#fff\" }));\n  return t3.getFill();\n};\nol_control_CanvasBase.prototype.getTextFont = function() {\n  var t3 = this._style.getText();\n  if (!t3)\n    t3 = new Text$2({});\n  if (!t3.getFont())\n    t3.setFont(\"12px sans-serif\");\n  return t3.getFont();\n};\nol_control_CanvasBase.prototype._draw = function() {\n  console.warn(\"[CanvasBase] draw function not implemented.\");\n};\nfunction toContext(context, opt_options) {\n  var canvas = context.canvas;\n  var options = opt_options ? opt_options : {};\n  var pixelRatio = options.pixelRatio || DEVICE_PIXEL_RATIO;\n  var size = options.size;\n  if (size) {\n    canvas.width = size[0] * pixelRatio;\n    canvas.height = size[1] * pixelRatio;\n    canvas.style.width = size[0] + \"px\";\n    canvas.style.height = size[1] + \"px\";\n  }\n  var extent2 = [0, 0, canvas.width, canvas.height];\n  var transform2 = scale$3(create$6(), pixelRatio, pixelRatio);\n  return new CanvasImmediateRenderer$1(context, pixelRatio, extent2, transform2, 0);\n}\nvar ol_legend_Item = function(options) {\n  options = options || {};\n  ol_Object.call(this, options);\n  if (options.feature)\n    this.set(\"feature\", options.feature.clone());\n};\nol_ext_inherits(ol_legend_Item, ol_Object);\nol_legend_Item.prototype.setTitle = function(title) {\n  this.set(\"title\", title || \"\");\n  this.changed();\n};\nol_legend_Item.prototype.getElement = function(size, onclick) {\n  var element = ol_ext_element.create(\"LI\", {\n    className: this.get(\"className\"),\n    click: function(e2) {\n      onclick(false);\n      e2.stopPropagation();\n    },\n    style: { height: size[1] + \"px\" },\n    \"aria-label\": this.get(\"title\")\n  });\n  ol_ext_element.create(\"DIV\", {\n    click: function(e2) {\n      onclick(true);\n      e2.stopPropagation();\n    },\n    style: {\n      width: size[0] + \"px\",\n      height: size[1] + \"px\"\n    },\n    parent: element\n  });\n  return element;\n};\nif (window.ol && !ol.legend) {\n  ol.legend = {};\n}\nvar ol_legend_Legend = function(options) {\n  options = options || {};\n  ol_Object.call(this);\n  this._items = new ol_Collection();\n  var listeners = [];\n  var tout;\n  this._items.on(\"add\", function(e2) {\n    listeners.push({\n      item: e2.element,\n      on: e2.element.on(\"change\", function() {\n        this.refresh();\n      }.bind(this))\n    });\n    if (tout) {\n      clearTimeout(tout);\n      tout = null;\n    }\n    tout = setTimeout(function() {\n      this.refresh();\n    }.bind(this), 0);\n  }.bind(this));\n  this._items.on(\"remove\", function(e2) {\n    for (var i2 = 0; i2 < listeners; i2++) {\n      if (e2.element === listeners[i2].item) {\n        unByKey(listeners[i2].on);\n        listeners.splice(i2, 1);\n        break;\n      }\n    }\n    if (tout) {\n      clearTimeout(tout);\n      tout = null;\n    }\n    tout = setTimeout(function() {\n      this.refresh();\n    }.bind(this), 0);\n  }.bind(this));\n  this._listElement = ol_ext_element.create(\"UL\", {\n    className: \"ol-legend\"\n  });\n  this._canvas = document.createElement(\"canvas\");\n  this.set(\"size\", options.size || [40, 25], true);\n  this.set(\"margin\", options.margin === 0 ? 0 : options.margin || 10, true);\n  this._textStyle = options.textStyle || new Text$2({\n    font: \"16px sans-serif\",\n    fill: new Fill$2({\n      color: \"#333\"\n    }),\n    backgroundFill: new Fill$2({\n      color: \"rgba(255,255,255,.8)\"\n    })\n  });\n  this._title = new ol_legend_Item({ title: options.title || \"\", className: \"ol-title\" });\n  if (options.titleStyle) {\n    this._titleStyle = options.titleStyle;\n  } else {\n    this._titleStyle = this._textStyle.clone();\n    this._titleStyle.setFont(\"bold \" + this._titleStyle.getFont());\n  }\n  this.setStyle(options.style);\n  if (options.items instanceof Array) {\n    options.items.forEach(function(item) {\n      this.addItem(item);\n    }.bind(this));\n  }\n  this.refresh();\n};\nol_ext_inherits(ol_legend_Legend, ol_Object);\nol_legend_Legend.prototype.setTitle = function(title) {\n  this._title.setTitle(title);\n  this.refresh();\n};\nol_legend_Legend.prototype.getTitle = function() {\n  return this._title.get(\"title\");\n};\nol_legend_Legend.prototype.getTextStyle = function() {\n  return this._textStyle;\n};\nol_legend_Legend.prototype.set = function(key, value, opt_silent) {\n  ol_Object.prototype.set.call(this, key, value, opt_silent);\n  if (!opt_silent)\n    this.refresh();\n};\nol_legend_Legend.prototype.getListElement = function() {\n  return this._listElement;\n};\nol_legend_Legend.prototype.getCanvas = function() {\n  return this._canvas;\n};\nol_legend_Legend.prototype.setStyle = function(style2) {\n  this._style = style2;\n  this.refresh();\n};\nol_legend_Legend.prototype.addItem = function(item) {\n  if (item instanceof ol_legend_Item) {\n    this._items.push(item);\n  } else {\n    this._items.push(new ol_legend_Item(item));\n  }\n};\nol_legend_Legend.prototype.getItems = function() {\n  return this._items;\n};\nol_legend_Legend.prototype._drawText = function(ctx, text2, x2, y2) {\n  ctx.save();\n  ctx.scale(DEVICE_PIXEL_RATIO, DEVICE_PIXEL_RATIO);\n  text2 = text2 || \"\";\n  var txt = text2.split(\"\\n\");\n  if (txt.length === 1) {\n    ctx.fillText(text2, x2, y2);\n  } else {\n    ctx.textBaseline = \"bottom\";\n    ctx.fillText(txt[0], x2, y2);\n    ctx.textBaseline = \"top\";\n    ctx.fillText(txt[1], x2, y2);\n  }\n  ctx.restore();\n};\nol_legend_Legend.prototype._measureText = function(ctx, text2) {\n  var txt = (text2 || \"\").split(\"\\n\");\n  if (txt.length === 1) {\n    return ctx.measureText(text2);\n  } else {\n    var m1 = ctx.measureText(txt[0]);\n    var m2 = ctx.measureText(txt[1]);\n    return { width: Math.max(m1.width, m2.width), height: m1.height + m2.height };\n  }\n};\nol_legend_Legend.prototype.refresh = function() {\n  var table = this._listElement;\n  table.innerHTML = \"\";\n  var margin = this.get(\"margin\");\n  var width = this.get(\"size\")[0] + 2 * margin;\n  var height = this.get(\"lineHeight\") || this.get(\"size\")[1] + 2 * margin;\n  var canvas = this.getCanvas();\n  var ctx = canvas.getContext(\"2d\");\n  ctx.textAlign = \"left\";\n  ctx.textBaseline = \"middle\";\n  var ratio = DEVICE_PIXEL_RATIO;\n  ctx.font = this._titleStyle.getFont();\n  var textWidth = this._measureText(ctx, this.getTitle(\"title\")).width;\n  this._items.forEach(function(r2) {\n    if (r2.get(\"feature\") || r2.get(\"typeGeom\")) {\n      ctx.font = r2.get(\"textStyle\") ? r2.get(\"textStyle\").getFont() : this._textStyle.getFont();\n      textWidth = Math.max(textWidth, this._measureText(ctx, r2.get(\"title\")).width + width);\n    } else {\n      ctx.font = r2.get(\"textStyle\") ? r2.get(\"textStyle\").getFont() : this._titleStyle.getFont();\n      textWidth = Math.max(textWidth, this._measureText(ctx, r2.get(\"title\")).width);\n    }\n  }.bind(this));\n  canvas.width = (textWidth + 2 * margin) * ratio;\n  canvas.height = (this._items.getLength() + 1) * height * ratio;\n  canvas.style.height = (this._items.getLength() + 1) * height + \"px\";\n  ctx.textBaseline = \"middle\";\n  ctx.fillStyle = asString$1(this._textStyle.getFill().getColor());\n  if (this.getTitle()) {\n    table.appendChild(this._title.getElement([width, height], function(b2) {\n      this.dispatchEvent({\n        type: \"select\",\n        index: -1,\n        symbol: b2,\n        item: this._title\n      });\n    }.bind(this)));\n    ctx.font = this._titleStyle.getFont();\n    ctx.textAlign = \"center\";\n    this._drawText(ctx, this.getTitle(), canvas.width / ratio / 2, height / 2);\n  }\n  this._items.forEach(function(r2, i2) {\n    var index2 = i2 + (this.getTitle() ? 1 : 0);\n    table.appendChild(r2.getElement([width, height], function(b2) {\n      this.dispatchEvent({\n        type: \"select\",\n        index: i2,\n        symbol: b2,\n        item: r2\n      });\n    }.bind(this)));\n    var item = r2.getProperties();\n    ctx.textAlign = \"left\";\n    if (item.feature || item.typeGeom) {\n      canvas = this.getLegendImage(item, canvas, index2);\n      ctx.font = r2.get(\"textStyle\") ? r2.get(\"textStyle\").getFont() : this._textStyle.getFont();\n      this._drawText(ctx, r2.get(\"title\"), width + margin, (i2 + 1.5) * height);\n    } else {\n      ctx.font = r2.get(\"textStyle\") ? r2.get(\"textStyle\").getFont() : this._titleStyle.getFont();\n      if (/\\bcenter\\b/.test(item.className)) {\n        ctx.textAlign = \"center\";\n        this._drawText(ctx, r2.get(\"title\"), canvas.width / ratio / 2, (i2 + 1.5) * height);\n      } else {\n        this._drawText(ctx, r2.get(\"title\"), margin, (i2 + 1.5) * height);\n      }\n    }\n  }.bind(this));\n  this.dispatchEvent({\n    type: \"refresh\",\n    width,\n    height: (this._items.length + 1) * height\n  });\n};\nol_legend_Legend.prototype.getLegendImage = function(options, canvas, row) {\n  options = options || {};\n  return ol_legend_Legend.getLegendImage({\n    className: options.className,\n    feature: options.feature,\n    typeGeom: options.typeGeom,\n    style: options.style || this._style,\n    properties: options.properties,\n    margin: options.margin || this.get(\"margin\"),\n    size: options.size || this.get(\"size\"),\n    lineHeight: options.lineHeight || this.get(\"lineHeight\"),\n    onload: function() {\n      this.refresh();\n    }.bind(this)\n  }, canvas, row);\n};\nol_legend_Legend.getLegendImage = function(item, canvas, row) {\n  item = item || {};\n  if (typeof item.margin === \"undefined\")\n    item.margin = 10;\n  var size = item.size || [40, 25];\n  item.onload = item.onload || function() {\n    setTimeout(function() {\n      ol_legend_Legend.getLegendImage(item, canvas, row);\n    }, 100);\n  };\n  var width = size[0] + 2 * item.margin;\n  var height = item.lineHeight || size[1] + 2 * item.margin;\n  var ratio = DEVICE_PIXEL_RATIO;\n  if (!canvas) {\n    row = 0;\n    canvas = document.createElement(\"canvas\");\n    canvas.width = width * ratio;\n    canvas.height = height * ratio;\n  }\n  var ctx = canvas.getContext(\"2d\");\n  ctx.save();\n  var vectorContext = toContext(ctx, { pixelRatio: ratio });\n  var typeGeom = item.typeGeom;\n  var style2;\n  var feature$1 = item.feature;\n  if (!feature$1 && typeGeom) {\n    if (/Point/.test(typeGeom))\n      feature$1 = new feature(new Point$4([0, 0]));\n    else if (/LineString/.test(typeGeom))\n      feature$1 = new feature(new LineString$2([0, 0]));\n    else\n      feature$1 = new feature(new Polygon$2([[0, 0]]));\n    if (item.properties)\n      feature$1.setProperties(item.properties);\n  }\n  if (feature$1) {\n    style2 = feature$1.getStyle();\n    if (typeof style2 === \"function\")\n      style2 = style2(feature$1);\n    if (!style2) {\n      style2 = typeof item.style === \"function\" ? item.style(feature$1) : item.style || [];\n    }\n    typeGeom = feature$1.getGeometry().getType();\n  } else {\n    style2 = [];\n  }\n  if (!(style2 instanceof Array))\n    style2 = [style2];\n  var cx = width / 2;\n  var cy = height / 2;\n  var sx = size[0] / 2;\n  var sy = size[1] / 2;\n  var i2, s2;\n  if (typeGeom === \"Point\") {\n    var extent2 = null;\n    for (i2 = 0; s2 = style2[i2]; i2++) {\n      var img = s2.getImage();\n      if (img) {\n        var imgElt = img.getImage();\n        if (imgElt && imgElt.complete && !imgElt.naturalWidth) {\n          if (typeof item.onload === \"function\") {\n            imgElt.addEventListener(\"load\", function() {\n              setTimeout(function() {\n                item.onload();\n              }, 100);\n            });\n          }\n          img.load();\n        }\n        if (img.getAnchor) {\n          var anchor = img.getAnchor();\n          if (anchor) {\n            var si = img.getSize();\n            var dx = anchor[0] - si[0];\n            var dy = anchor[1] - si[1];\n            if (!extent2) {\n              extent2 = [dx, dy, dx + si[0], dy + si[1]];\n            } else {\n              extend$2(extent2, [dx, dy, dx + si[0], dy + si[1]]);\n            }\n          }\n        }\n      }\n    }\n    if (extent2) {\n      cx = cx + (extent2[2] + extent2[0]) / 2;\n      cy = cy + (extent2[3] + extent2[1]) / 2;\n    }\n  }\n  cy += row * height || 0;\n  for (i2 = 0; s2 = style2[i2]; i2++) {\n    vectorContext.setStyle(s2);\n    switch (typeGeom) {\n      case Point$4:\n      case \"Point\":\n      case \"MultiPoint\":\n        vectorContext.drawGeometry(new Point$4([cx, cy]));\n        break;\n      case LineString$2:\n      case \"LineString\":\n      case \"MultiLineString\":\n        ctx.save();\n        ctx.rect(item.margin * ratio, 0, size[0] * ratio, canvas.height);\n        ctx.clip();\n        vectorContext.drawGeometry(new LineString$2([[cx - sx, cy], [cx + sx, cy]]));\n        ctx.restore();\n        break;\n      case Polygon$2:\n      case \"Polygon\":\n      case \"MultiPolygon\":\n        vectorContext.drawGeometry(new Polygon$2([[[cx - sx, cy - sy], [cx + sx, cy - sy], [cx + sx, cy + sy], [cx - sx, cy + sy], [cx - sx, cy - sy]]]));\n        break;\n    }\n  }\n  ctx.restore();\n  return canvas;\n};\nvar ol_control_Legend = function(options) {\n  options = options || {};\n  var element = document.createElement(\"div\");\n  if (options.target) {\n    element.className = options.className || \"ol-legend\";\n  } else {\n    element.className = (options.className || \"ol-legend\") + \" ol-unselectable ol-control\" + (options.collapsible === false ? \" ol-uncollapsible\" : \" ol-collapsed\");\n    var button = document.createElement(\"button\");\n    button.setAttribute(\"type\", \"button\");\n    button.addEventListener(\"click\", function() {\n      this.toggle();\n    }.bind(this));\n    element.appendChild(button);\n    button = document.createElement(\"button\");\n    button.setAttribute(\"type\", \"button\");\n    button.className = \"ol-closebox\";\n    button.addEventListener(\"click\", function() {\n      this.toggle();\n    }.bind(this));\n    element.appendChild(button);\n  }\n  ol_control_CanvasBase.call(this, {\n    element,\n    target: options.target\n  });\n  this._legend = options.legend;\n  this._legend.getCanvas().className = \"ol-legendImg\";\n  element.appendChild(this._legend.getCanvas());\n  element.appendChild(this._legend.getListElement());\n  if (options.collapsible !== false && options.collapsed === false)\n    this.show();\n  this._legend.on(\"select\", function(e2) {\n    this.dispatchEvent(e2);\n  }.bind(this));\n  this._legend.on(\"refresh\", function() {\n    if (this._onCanvas && this.getMap()) {\n      try {\n        this.getMap().renderSync();\n      } catch (e2) {\n      }\n    }\n  }.bind(this));\n};\nol_ext_inherits(ol_control_Legend, ol_control_CanvasBase);\nol_control_Legend.prototype.getLegend = function() {\n  return this._legend;\n};\nol_control_Legend.prototype.setCanvas = function(b2) {\n  this._onCanvas = b2;\n  this.element.style.visibility = b2 ? \"hidden\" : \"visible\";\n  if (this.getMap()) {\n    try {\n      this.getMap().renderSync();\n    } catch (e2) {\n    }\n  }\n};\nol_control_Legend.prototype.onCanvas = function() {\n  return !!this._onCanvas;\n};\nol_control_Legend.prototype._draw = function(e2) {\n  if (this._onCanvas && !this.element.classList.contains(\"ol-collapsed\")) {\n    var canvas = this._legend.getCanvas();\n    var ctx = this.getContext(e2);\n    var h2 = ctx.canvas.height - canvas.height;\n    ctx.save();\n    ctx.rect(0, h2, canvas.width, canvas.height);\n    var col = \"#fff\";\n    if (this._legend.getTextStyle().getBackgroundFill()) {\n      col = asString$1(this._legend.getTextStyle().getBackgroundFill().getColor());\n    }\n    ctx.fillStyle = ctx.strokeStyle = col;\n    ctx.lineWidth = 10;\n    ctx.lineJoin = \"round\";\n    ctx.stroke();\n    ctx.clearRect(0, h2, canvas.width, canvas.height);\n    ctx.fill();\n    ctx.drawImage(canvas, 0, h2);\n    ctx.restore();\n  }\n};\nol_control_Legend.prototype.show = function() {\n  if (this.element.classList.contains(\"ol-collapsed\")) {\n    this.element.classList.remove(\"ol-collapsed\");\n    this.dispatchEvent({ type: \"change:collapse\", collapsed: false });\n    if (this.getMap()) {\n      try {\n        this.getMap().renderSync();\n      } catch (e2) {\n      }\n    }\n  }\n};\nol_control_Legend.prototype.hide = function() {\n  if (!this.element.classList.contains(\"ol-collapsed\")) {\n    this.element.classList.add(\"ol-collapsed\");\n    this.dispatchEvent({ type: \"change:collapse\", collapsed: true });\n    if (this.getMap()) {\n      try {\n        this.getMap().renderSync();\n      } catch (e2) {\n      }\n    }\n  }\n};\nol_control_Legend.prototype.collapse = function(b2) {\n  if (b2 === false)\n    this.show();\n  else\n    this.hide();\n};\nol_control_Legend.prototype.isCollapsed = function() {\n  return this.element.classList.contains(\"ol-collapsed\");\n};\nol_control_Legend.prototype.toggle = function() {\n  this.element.classList.toggle(\"ol-collapsed\");\n  this.dispatchEvent({ type: \"change:collapse\", collapsed: this.element.classList.contains(\"ol-collapsed\") });\n  if (this.getMap()) {\n    try {\n      this.getMap().renderSync();\n    } catch (e2) {\n    }\n  }\n};\nvar ol_control_Print = function(options) {\n  if (!options)\n    options = {};\n  var element = ol_ext_element.create(\"DIV\", {\n    className: options.className || \"ol-print\"\n  });\n  if (!options.target) {\n    element.classList.add(\"ol-unselectable\", \"ol-control\");\n    ol_ext_element.create(\"BUTTON\", {\n      type: \"button\",\n      title: options.title || \"Print\",\n      click: function() {\n        this.print();\n      }.bind(this),\n      parent: element\n    });\n  }\n  ol_control_Control.call(this, {\n    element,\n    target: options.target\n  });\n  this.set(\"immediate\", options.immediate);\n  this.set(\"imageType\", options.imageType || \"image/jpeg\");\n  this.set(\"quality\", options.quality || 0.8);\n  this.set(\"orientation\", options.orientation);\n};\nol_ext_inherits(ol_control_Print, ol_control_Control);\nol_control_Print.prototype.toClipboard = function(e2, callback) {\n  try {\n    e2.canvas.toBlob(function(blob) {\n      try {\n        navigator.clipboard.write([\n          new window.ClipboardItem(Object.defineProperty({}, blob.type, {\n            value: blob,\n            enumerable: true\n          }))\n        ]);\n        if (typeof callback === \"function\")\n          callback(true);\n      } catch (err) {\n        if (typeof callback === \"function\")\n          callback(false);\n      }\n    });\n  } catch (err) {\n    if (typeof callback === \"function\")\n      callback(false);\n  }\n};\nol_control_Print.prototype.copyMap = function(options, callback) {\n  this.once(\"print\", function(e2) {\n    this.toClipboard(e2, callback);\n  }.bind(this));\n  this.print(options);\n};\nol_control_Print.prototype._getCanvas = function(event, imageType, canvas) {\n  var ctx;\n  if (event.context) {\n    canvas = event.context.canvas;\n  } else {\n    if (!canvas) {\n      canvas = document.createElement(\"canvas\");\n      var size = this.getMap().getSize();\n      canvas.width = size[0];\n      canvas.height = size[1];\n      ctx = canvas.getContext(\"2d\");\n      if (/jp.*g$/.test(imageType)) {\n        ctx.fillStyle = this.get(\"bgColor\") || \"white\";\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      }\n    } else {\n      ctx = canvas.getContext(\"2d\");\n    }\n    this.getMap().getViewport().querySelectorAll(\".ol-layers canvas, canvas.ol-fixedoverlay\").forEach(function(c2) {\n      if (c2.width) {\n        ctx.save();\n        if (c2.parentNode.style.opacity === \"0\")\n          return;\n        ctx.globalAlpha = parseFloat(c2.parentNode.style.opacity) || 1;\n        if (ol_ext_element.getStyle(c2.parentNode, \"mix-blend-mode\") === \"multiply\") {\n          ctx.globalCompositeOperation = \"multiply\";\n        }\n        var tr = ol_ext_element.getStyle(c2, \"transform\") || ol_ext_element.getStyle(c2, \"-webkit-transform\");\n        if (/^matrix/.test(tr)) {\n          tr = tr.replace(/^matrix\\(|\\)$/g, \"\").split(\",\");\n          tr.forEach(function(t3, i2) {\n            tr[i2] = parseFloat(t3);\n          });\n          ctx.transform(tr[0], tr[1], tr[2], tr[3], tr[4], tr[5]);\n          ctx.drawImage(c2, 0, 0);\n        } else {\n          ctx.drawImage(c2, 0, 0, ol_ext_element.getStyle(c2, \"width\"), ol_ext_element.getStyle(c2, \"height\"));\n        }\n        ctx.restore();\n      }\n    }.bind(this));\n  }\n  return canvas;\n};\nol_control_Print.prototype.fastPrint = function(options, callback) {\n  options = options || {};\n  if (this._ol6) {\n    requestAnimationFrame(function() {\n      callback(this._getCanvas({}, options.imageType, options.canvas));\n    }.bind(this));\n  } else {\n    this.getMap().once(\"postcompose\", function(event) {\n      if (!event.context)\n        this._ol6 = true;\n      callback(this._getCanvas(event, options.imageType, options.canvas));\n    }.bind(this));\n    this.getMap().render();\n  }\n};\nol_control_Print.prototype.print = function(options) {\n  options = options || {};\n  var imageType = options.imageType || this.get(\"imageType\");\n  var quality = options.quality || this.get(\"quality\");\n  if (this.getMap()) {\n    if (options.immediate !== \"silent\") {\n      this.dispatchEvent(Object.assign({\n        type: \"printing\"\n      }, options));\n    }\n    if (!options.immediate) {\n      setTimeout(function() {\n        options = Object.assign({}, options);\n        options.immediate = \"silent\";\n        this.print(options);\n      }.bind(this), 200);\n      return;\n    }\n    this.getMap().once(this.get(\"immediate\") ? \"postcompose\" : \"rendercomplete\", function(event) {\n      var canvas = this._getCanvas(event, imageType);\n      var size = options.size || [210, 297];\n      var format2 = options.format || \"a4\";\n      var w2, h2, position2;\n      var orient = options.orient || this.get(\"orientation\");\n      var margin = typeof options.margin === \"number\" ? options.margin : 10;\n      if (canvas) {\n        if (orient !== \"landscape\" && orient !== \"portrait\") {\n          orient = canvas.width > canvas.height ? \"landscape\" : \"portrait\";\n        }\n        if (orient === \"landscape\")\n          size = [size[1], size[0]];\n        var sc = Math.min((size[0] - 2 * margin) / canvas.width, (size[1] - 2 * margin) / canvas.height);\n        w2 = sc * canvas.width;\n        h2 = sc * canvas.height;\n        position2 = [(size[0] - w2) / 2, (size[1] - h2) / 2];\n      }\n      var image2;\n      try {\n        image2 = canvas ? canvas.toDataURL(imageType, quality) : null;\n      } catch (e3) {\n        this.dispatchEvent({\n          type: \"error\",\n          canvas\n        });\n        return;\n      }\n      var e2 = Object.assign({\n        type: \"print\",\n        print: {\n          format: format2,\n          orientation: orient,\n          unit: \"mm\",\n          size,\n          position: position2,\n          imageWidth: w2,\n          imageHeight: h2\n        },\n        image: image2,\n        imageType,\n        quality,\n        canvas\n      }, options);\n      this.dispatchEvent(e2);\n    }.bind(this));\n    this.getMap().render();\n  }\n};\nvar ol_control_CanvasTitle = function(options) {\n  if (!options)\n    options = {};\n  var elt = ol_ext_element.create(\"DIV\", {\n    className: (options.className || \"\") + \" ol-control-title ol-unselectable\",\n    style: {\n      display: \"block\",\n      visibility: \"hidden\"\n    }\n  });\n  ol_control_CanvasBase.call(this, {\n    element: elt,\n    style: options.style\n  });\n  this.setTitle(options.title || \"\");\n  this.setVisible(options.visible);\n  this.element.style.font = this.getTextFont();\n};\nol_ext_inherits(ol_control_CanvasTitle, ol_control_CanvasBase);\nol_control_CanvasTitle.prototype.setStyle = function(style2) {\n  ol_control_CanvasBase.prototype.setStyle.call(this, style2);\n  if (this.element) {\n    this.element.style.font = this.getTextFont();\n  }\n  if (this.getMap())\n    this.getMap().render();\n};\nol_control_CanvasTitle.prototype.setTitle = function(title) {\n  this.element.textContent = title;\n  this.set(\"title\", title);\n  if (this.getMap()) {\n    try {\n      this.getMap().renderSync();\n    } catch (e2) {\n    }\n  }\n};\nol_control_CanvasTitle.prototype.getTitle = function() {\n  return this.get(\"title\");\n};\nol_control_CanvasTitle.prototype.setVisible = function(b2) {\n  this.element.style.display = b2 ? \"block\" : \"none\";\n  if (this.getMap()) {\n    try {\n      this.getMap().renderSync();\n    } catch (e2) {\n    }\n  }\n};\nol_control_CanvasTitle.prototype.getVisible = function() {\n  return this.element.style.display !== \"none\";\n};\nol_control_CanvasTitle.prototype._draw = function(e2) {\n  if (!this.getVisible())\n    return;\n  var ctx = this.getContext(e2);\n  if (!ctx)\n    return;\n  var ratio = e2.frameState.pixelRatio;\n  ctx.save();\n  ctx.scale(ratio, ratio);\n  var eltRect = this.element.getBoundingClientRect();\n  var mapRect = this.getMap().getViewport().getBoundingClientRect();\n  var sc = this.getMap().getSize()[0] / mapRect.width;\n  ctx.translate(Math.round((eltRect.left - mapRect.left) * sc), Math.round((eltRect.top - mapRect.top) * sc));\n  var h2 = this.element.clientHeight;\n  var w2 = this.element.clientWidth;\n  var left = w2 / 2;\n  ctx.beginPath();\n  ctx.fillStyle = asString$1(this.getFill().getColor());\n  ctx.rect(0, 0, w2, h2);\n  ctx.fill();\n  ctx.closePath();\n  ctx.beginPath();\n  ctx.fillStyle = asString$1(this.getTextFill().getColor());\n  ctx.strokeStyle = asString$1(this.getTextStroke().getColor());\n  ctx.lineWidth = this.getTextStroke().getWidth();\n  ctx.textAlign = \"center\";\n  ctx.textBaseline = \"middle\";\n  ctx.font = this.getTextFont();\n  if (ctx.lineWidth)\n    ctx.strokeText(this.getTitle(), left, h2 / 2);\n  ctx.fillText(this.getTitle(), left, h2 / 2);\n  ctx.closePath();\n  ctx.restore();\n};\nvar ol_sphere_getMapScale = function(map, dpi) {\n  var view = map.getView();\n  var proj = view.getProjection();\n  var center = view.getCenter();\n  var px = map.getPixelFromCoordinate(center);\n  px[1] += 1;\n  var coord = map.getCoordinateFromPixel(px);\n  var d2 = getDistance(transform$3(center, proj, \"EPSG:4326\"), transform$3(coord, proj, \"EPSG:4326\"));\n  d2 *= (dpi || 96) / 0.0254;\n  return d2;\n};\nvar ol_sphere_setMapScale = function(map, scale2, dpi) {\n  if (map && scale2) {\n    var fac = scale2;\n    if (typeof scale2 === \"string\") {\n      fac = scale2.split(\"/\")[1];\n      if (!fac)\n        fac = scale2;\n      fac = fac.replace(/[^\\d]/g, \"\");\n      fac = parseInt(fac);\n    }\n    if (!fac)\n      return;\n    var view = map.getView();\n    var proj = view.getProjection();\n    var center = view.getCenter();\n    var px = map.getPixelFromCoordinate(center);\n    px[1] += 1;\n    var coord = map.getCoordinateFromPixel(px);\n    var d2 = getDistance(transform$3(center, proj, \"EPSG:4326\"), transform$3(coord, proj, \"EPSG:4326\"));\n    d2 *= (dpi || 96) / 0.0254;\n    view.setResolution(view.getResolution() * fac / d2);\n    return fac;\n  }\n};\nvar ol_control_Compass = function(options) {\n  if (!options)\n    options = {};\n  var elt = document.createElement(\"div\");\n  elt.className = \"ol-control ol-compassctrl ol-unselectable ol-hidden\" + (options.className ? \" \" + options.className : \"\");\n  elt.style.position = \"absolute\";\n  elt.style.visibility = \"hidden\";\n  var style2 = options.style instanceof Stroke$2 ? new Style$2({ stroke: options.style }) : options.style;\n  if (!options.style) {\n    style2 = new Style$2({ stroke: new Stroke$2({ width: 0 }) });\n  }\n  ol_control_CanvasBase.call(this, {\n    element: elt,\n    style: style2\n  });\n  this.set(\"rotateVithView\", options.rotateWithView !== false);\n  this.setVisible(options.visible !== false);\n  this.setImage(options.image || options.src);\n};\nol_ext_inherits(ol_control_Compass, ol_control_CanvasBase);\nol_control_Compass.prototype.setImage = function(img) {\n  if (img instanceof Image) {\n    this.img_ = img;\n    this.img_.onload = function() {\n      if (this.getMap()) {\n        try {\n          this.getMap().renderSync();\n        } catch (e2) {\n        }\n      }\n    }.bind(this);\n  } else if (typeof img === \"string\") {\n    switch (img) {\n      case \"compact\": {\n        this.img_ = this.compactCompass_(this.element.clientWidth, this.getStroke().getColor());\n        break;\n      }\n      case \"default\": {\n        this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());\n        break;\n      }\n      default: {\n        this.img_ = new Image();\n        this.img_.onload = function() {\n          if (this.getMap()) {\n            try {\n              this.getMap().renderSync();\n            } catch (e2) {\n            }\n          }\n        }.bind(this);\n        this.img_.src = img;\n        break;\n      }\n    }\n  } else {\n    this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());\n  }\n};\nol_control_Compass.prototype.compactCompass_ = function(s2, color2) {\n  var canvas = document.createElement(\"canvas\");\n  var ctx = canvas.getContext(\"2d\");\n  s2 = canvas.width = canvas.height = s2 || 150;\n  var r2 = s2 / 2;\n  ctx.translate(r2, r2);\n  ctx.fillStyle = color2 || \"#963\";\n  ctx.lineWidth = 5;\n  ctx.lineJoin = ctx.lineCap = \"round\";\n  ctx.font = \"bold \" + r2 * 0.4 + \"px sans-serif\";\n  ctx.textBaseline = \"bottom\";\n  ctx.textAlign = \"center\";\n  ctx.strokeStyle = \"#fff\";\n  ctx.globalAlpha = 0.75;\n  ctx.strokeText(\"N\", 0, -r2 / 2);\n  ctx.globalAlpha = 1;\n  ctx.fillText(\"N\", 0, -r2 / 2);\n  ctx.beginPath();\n  ctx.moveTo(0, r2 / 4);\n  ctx.lineTo(r2 / 3, r2 / 2);\n  ctx.lineTo(0, -r2 / 2);\n  ctx.lineTo(-r2 / 3, r2 / 2);\n  ctx.lineTo(0, r2 / 4);\n  ctx.lineWidth = 12;\n  ctx.fillStyle = \"#fff\";\n  ctx.globalAlpha = 0.75;\n  ctx.fill();\n  ctx.stroke();\n  ctx.globalAlpha = 1;\n  ctx.fillStyle = ctx.strokeStyle = color2 || \"#963\";\n  ctx.lineWidth = 5;\n  ctx.beginPath();\n  ctx.moveTo(0, r2 / 4);\n  ctx.lineTo(0, -r2 / 2);\n  ctx.lineTo(r2 / 3, r2 / 2);\n  ctx.lineTo(0, r2 / 4);\n  ctx.fill();\n  ctx.stroke();\n  ctx.beginPath();\n  ctx.moveTo(0, r2 / 4);\n  ctx.lineTo(0, -r2 / 2);\n  ctx.lineTo(-r2 / 3, r2 / 2);\n  ctx.lineTo(0, r2 / 4);\n  ctx.stroke();\n  return canvas;\n};\nol_control_Compass.prototype.defaultCompass_ = function(s2, color2) {\n  var canvas = document.createElement(\"canvas\");\n  var ctx = canvas.getContext(\"2d\");\n  s2 = canvas.width = canvas.height = s2 || 150;\n  var r2 = s2 / 2;\n  var r22 = 0.22 * r2;\n  function draw(r3, r23) {\n    ctx.fillStyle = color2 || \"#963\";\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(r3, 0);\n    ctx.lineTo(r23, r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(-r3, 0);\n    ctx.lineTo(-r23, -r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, r3);\n    ctx.lineTo(-r23, r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, -r3);\n    ctx.lineTo(r23, -r23);\n    ctx.moveTo(0, 0);\n    ctx.fill();\n    ctx.stroke();\n  }\n  function draw2(r3, r23) {\n    ctx.globalCompositeOperation = \"destination-out\";\n    ctx.fillStyle = \"#fff\";\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(r3, 0);\n    ctx.lineTo(r23, -r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(-r3, 0);\n    ctx.lineTo(-r23, r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, r3);\n    ctx.lineTo(r23, r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, -r3);\n    ctx.lineTo(-r23, -r23);\n    ctx.moveTo(0, 0);\n    ctx.fill();\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(r3, 0);\n    ctx.lineTo(r23, -r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(-r3, 0);\n    ctx.lineTo(-r23, r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, r3);\n    ctx.lineTo(r23, r23);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(0, -r3);\n    ctx.lineTo(-r23, -r23);\n    ctx.moveTo(0, 0);\n    ctx.stroke();\n  }\n  ctx.translate(r2, r2);\n  ctx.strokeStyle = color2 || \"#963\";\n  ctx.lineWidth = 1.5;\n  ctx.beginPath();\n  ctx.arc(0, 0, s2 * 0.41, 0, 2 * Math.PI);\n  ctx.arc(0, 0, s2 * 0.44, 0, 2 * Math.PI);\n  ctx.stroke();\n  ctx.rotate(Math.PI / 4);\n  draw(r2 * 0.9, r22 * 0.8);\n  draw2(r2 * 0.9, r22 * 0.8);\n  ctx.rotate(-Math.PI / 4);\n  draw(r2, r22);\n  draw2(r2, r22);\n  return canvas;\n};\nol_control_Compass.prototype.getVisible = function() {\n  return ol_ext_element.getStyle(this.element, \"display\") === \"block\";\n};\nol_control_Compass.prototype.setVisible = function(b2) {\n  if (b2)\n    this.element.classList.add(\"ol-visible\");\n  else\n    this.element.classList.remove(\"ol-visible\");\n  if (this.getMap())\n    this.getMap().render();\n};\nol_control_Compass.prototype._draw = function(e2) {\n  var ctx = this.getContext(e2);\n  if (!ctx || !this.getVisible())\n    return;\n  var canvas = ctx.canvas;\n  var i2, da = [];\n  for (i2 = 0; i2 < 8; i2++)\n    da[i2] = [Math.cos(Math.PI * i2 / 8), Math.sin(Math.PI * i2 / 8)];\n  var ratio = e2.frameState.pixelRatio;\n  ctx.save();\n  ctx.scale(ratio, ratio);\n  var w2 = this.element.clientWidth;\n  var h2 = this.element.clientHeight;\n  var pos = { left: this.element.offsetLeft, top: this.element.offsetTop };\n  var compass = this.img_;\n  var rot = e2.frameState.viewState.rotation;\n  ctx.beginPath();\n  ctx.translate(pos.left + w2 / 2, pos.top + h2 / 2);\n  if (this.get(\"rotateVithView\"))\n    ctx.rotate(rot);\n  if (this.getStroke().getWidth()) {\n    ctx.beginPath();\n    ctx.strokeStyle = this.getStroke().getColor();\n    ctx.lineWidth = this.getStroke().getWidth();\n    var m2 = Math.max(canvas.width, canvas.height);\n    for (i2 = 0; i2 < 8; i2++) {\n      ctx.moveTo(-da[i2][0] * m2, -da[i2][1] * m2);\n      ctx.lineTo(da[i2][0] * m2, da[i2][1] * m2);\n    }\n    ctx.stroke();\n  }\n  if (compass.width) {\n    ctx.drawImage(compass, -w2 / 2, -h2 / 2, w2, h2);\n  }\n  ctx.closePath();\n  ctx.restore();\n};\nvar ol_control_PrintDialog = function(options) {\n  if (!options)\n    options = {};\n  this._lang = options.lang || \"en\";\n  var element = ol_ext_element.create(\"DIV\", {\n    className: (options.className || \"ol-print\") + \" ol-unselectable ol-control\"\n  });\n  ol_ext_element.create(\"BUTTON\", {\n    type: \"button\",\n    title: options.title || \"Print\",\n    click: function() {\n      this.print();\n    }.bind(this),\n    parent: element\n  });\n  ol_control_Control.call(this, {\n    element\n  });\n  if (options.openWindow) {\n    this.on(\"print\", function(e2) {\n      if (e2.canvas) {\n        window.open().document.write('<img src=\"' + e2.canvas.toDataURL() + '\"/>');\n      }\n    });\n  }\n  options.target = ol_ext_element.create(\"DIV\");\n  var printCtrl = this._printCtrl = new ol_control_Print(options);\n  printCtrl.on([\"print\", \"error\", \"printing\"], function(e2) {\n    content2.setAttribute(\"data-status\", e2.type);\n    if (!e2.clipboard) {\n      this.dispatchEvent(e2);\n    }\n  }.bind(this));\n  this._compass = new ol_control_Compass({\n    src: options.northImage || \"compact\",\n    visible: false,\n    className: \"olext-print-compass\",\n    style: new Stroke$2({ color: \"#333\", width: 0 })\n  });\n  var printDialog = this._printDialog = new ol_control_Dialog({\n    target: document.body,\n    closeBox: true,\n    className: \"ol-ext-print-dialog\"\n  });\n  var content2 = printDialog.getContentElement();\n  this._input = {};\n  var param = ol_ext_element.create(\"DIV\", {\n    className: \"ol-print-param\",\n    parent: content2\n  });\n  this._pages = [ol_ext_element.create(\"DIV\", {\n    className: \"ol-page\"\n  })];\n  var printMap = ol_ext_element.create(\"DIV\", {\n    className: \"ol-map\",\n    parent: this._pages[0]\n  });\n  ol_ext_element.create(\"DIV\", {\n    html: this._pages[0],\n    className: \"ol-print-map\",\n    parent: content2\n  });\n  ol_ext_element.create(\"H2\", {\n    html: this.i18n(\"title\"),\n    parent: param\n  });\n  var ul = ol_ext_element.create(\"UL\", { parent: param });\n  var li = ol_ext_element.create(\"LI\", {\n    className: \"ol-orientation\",\n    parent: ul\n  });\n  this._input.orientation = { list: li };\n  var label = ol_ext_element.create(\"LABEL\", {\n    className: \"portrait\",\n    parent: li\n  });\n  this._input.orientation.portrait = ol_ext_element.create(\"INPUT\", {\n    type: \"radio\",\n    name: \"ol-print-orientation\",\n    value: \"portrait\",\n    checked: true,\n    on: { change: function(e2) {\n      this.setOrientation(e2.target.value);\n    }.bind(this) },\n    parent: label\n  });\n  ol_ext_element.create(\"SPAN\", {\n    html: this.i18n(\"portrait\"),\n    parent: label\n  });\n  label = ol_ext_element.create(\"LABEL\", {\n    className: \"landscape\",\n    parent: li\n  });\n  this._input.orientation.landscape = ol_ext_element.create(\"INPUT\", {\n    type: \"radio\",\n    name: \"ol-print-orientation\",\n    value: \"landscape\",\n    on: { change: function(e2) {\n      this.setOrientation(e2.target.value);\n    }.bind(this) },\n    parent: label\n  });\n  ol_ext_element.create(\"SPAN\", {\n    html: this.i18n(\"landscape\"),\n    parent: label\n  });\n  var s2;\n  li = ol_ext_element.create(\"LI\", {\n    html: ol_ext_element.create(\"LABEL\", {\n      html: this.i18n(\"size\")\n    }),\n    className: \"ol-size\",\n    parent: ul\n  });\n  var size = this._input.size = ol_ext_element.create(\"SELECT\", {\n    on: { change: function() {\n      this.setSize(size.value || originalSize);\n    }.bind(this) },\n    parent: li\n  });\n  for (s2 in this.paperSize) {\n    ol_ext_element.create(\"OPTION\", {\n      html: s2 + (this.paperSize[s2] ? \" - \" + this.paperSize[s2][0] + \"x\" + this.paperSize[s2][1] + \" mm\" : this.i18n(\"custom\")),\n      value: s2,\n      parent: size\n    });\n  }\n  li = ol_ext_element.create(\"LI\", {\n    html: ol_ext_element.create(\"LABEL\", {\n      html: this.i18n(\"margin\")\n    }),\n    className: \"ol-margin\",\n    parent: ul\n  });\n  var margin = this._input.margin = ol_ext_element.create(\"SELECT\", {\n    on: { change: function() {\n      this.setMargin(margin.value);\n    }.bind(this) },\n    parent: li\n  });\n  for (s2 in this.marginSize) {\n    ol_ext_element.create(\"OPTION\", {\n      html: this.i18n(s2) + \" - \" + this.marginSize[s2] + \" mm\",\n      value: this.marginSize[s2],\n      parent: margin\n    });\n  }\n  li = ol_ext_element.create(\"LI\", {\n    html: ol_ext_element.create(\"LABEL\", {\n      html: this.i18n(\"scale\")\n    }),\n    className: \"ol-scale\",\n    parent: ul\n  });\n  var scale2 = this._input.scale = ol_ext_element.create(\"SELECT\", {\n    on: { change: function() {\n      this.setScale(parseInt(scale2.value));\n    }.bind(this) },\n    parent: li\n  });\n  Object.keys(this.scales).forEach(function(s3) {\n    ol_ext_element.create(\"OPTION\", {\n      html: this.scales[s3],\n      value: s3,\n      parent: scale2\n    });\n  }.bind(this));\n  li = ol_ext_element.create(\"LI\", {\n    className: \"ol-legend\",\n    parent: ul\n  });\n  var legend = ol_ext_element.createSwitch({\n    html: this.i18n(\"legend\"),\n    checked: false,\n    on: { change: function() {\n      extraCtrl.legend.control.setCanvas(legend.checked);\n    }.bind(this) },\n    parent: li\n  });\n  li = ol_ext_element.create(\"LI\", {\n    className: \"ol-print-north\",\n    parent: ul\n  });\n  var north = this._input.north = ol_ext_element.createSwitch({\n    html: this.i18n(\"north\"),\n    checked: \"checked\",\n    on: { change: function() {\n      if (north.checked)\n        this._compass.element.classList.add(\"ol-print-compass\");\n      else\n        this._compass.element.classList.remove(\"ol-print-compass\");\n      this.getMap().render();\n    }.bind(this) },\n    parent: li\n  });\n  li = ol_ext_element.create(\"LI\", {\n    className: \"ol-print-title\",\n    parent: ul\n  });\n  var title = ol_ext_element.createSwitch({\n    html: this.i18n(\"mapTitle\"),\n    checked: false,\n    on: { change: function(e2) {\n      extraCtrl.title.control.setVisible(e2.target.checked);\n    }.bind(this) },\n    parent: li\n  });\n  var titleText = ol_ext_element.create(\"INPUT\", {\n    type: \"text\",\n    placeholder: this.i18n(\"mapTitle\"),\n    on: {\n      keydown: function(e2) {\n        if (e2.keyCode === 13)\n          e2.preventDefault();\n      },\n      keyup: function() {\n        extraCtrl.title.control.setTitle(titleText.value);\n      },\n      change: function() {\n        extraCtrl.title.control.setTitle(titleText.value);\n      }.bind(this)\n    },\n    parent: li\n  });\n  var userElt = ol_ext_element.create(\"DIV\", {\n    className: \"ol-user-param\",\n    parent: param\n  });\n  li = ol_ext_element.create(\"LI\", {\n    className: \"ol-saveas\",\n    parent: ul\n  });\n  var copied = ol_ext_element.create(\"DIV\", {\n    html: this.i18n(\"copied\"),\n    className: \"ol-clipboard-copy\",\n    parent: li\n  });\n  var save = ol_ext_element.create(\"SELECT\", {\n    on: { change: function() {\n      if (this.formats[save.value].clipboard) {\n        printCtrl.copyMap(this.formats[save.value], function(isok) {\n          if (isok) {\n            copied.classList.add(\"visible\");\n            setTimeout(function() {\n              copied.classList.remove(\"visible\");\n            }, 1e3);\n          }\n        });\n      } else {\n        var format2 = typeof this.getSize() === \"string\" ? this.getSize() : null;\n        var opt = Object.assign({\n          format: format2,\n          size: format2 ? this.paperSize[format2] : null,\n          orient: this.getOrientation(),\n          margin: this.getMargin()\n        }, this.formats[save.value]);\n        printCtrl.print(opt);\n      }\n      save.value = \"\";\n    }.bind(this) },\n    parent: li\n  });\n  ol_ext_element.create(\"OPTION\", {\n    html: this.i18n(\"saveas\"),\n    style: { display: \"none\" },\n    value: \"\",\n    parent: save\n  });\n  this.formats.forEach(function(format2, i2) {\n    if (format2.pdf) {\n      if (options.pdf === false)\n        return;\n    } else if (format2.clipboard) {\n      if (options.copy === false)\n        return;\n    } else if (options.save === false) {\n      return;\n    }\n    ol_ext_element.create(\"OPTION\", {\n      html: this.i18n(format2.title),\n      value: i2,\n      parent: save\n    });\n  }.bind(this));\n  li = ol_ext_element.create(\"LI\", {\n    className: \"ol-savelegend\",\n    parent: ul\n  });\n  var copylegend = ol_ext_element.create(\"DIV\", {\n    html: this.i18n(\"copied\"),\n    className: \"ol-clipboard-copy\",\n    parent: li\n  });\n  var saveLegend = ol_ext_element.create(\"SELECT\", {\n    on: { change: function() {\n      var clegend = extraCtrl.legend.control.getLegend().getCanvas();\n      var canvas = document.createElement(\"CANVAS\");\n      canvas.width = clegend.width;\n      canvas.height = clegend.height;\n      var ctx = canvas.getContext(\"2d\");\n      ctx.fillStyle = \"#fff\";\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.drawImage(clegend, 0, 0);\n      if (this.formats[saveLegend.value].clipboard) {\n        canvas.toBlob(function(blob) {\n          try {\n            navigator.clipboard.write([\n              new window.ClipboardItem(Object.defineProperty({}, blob.type, {\n                value: blob,\n                enumerable: true\n              }))\n            ]);\n            copylegend.classList.add(\"visible\");\n            setTimeout(function() {\n              copylegend.classList.remove(\"visible\");\n            }, 1e3);\n          } catch (err) {\n          }\n        }, \"image/png\");\n      } else {\n        var image2;\n        try {\n          image2 = canvas.toDataURL(this.formats[saveLegend.value].imageType, this.formats[saveLegend.value].quality);\n          var format2 = typeof this.getSize() === \"string\" ? this.getSize() : \"A4\";\n          var w2 = canvas.width / 96 * 25.4;\n          var h2 = canvas.height / 96 * 25.4;\n          var size2 = this.paperSize[format2];\n          if (this.getOrientation() === \"landscape\")\n            size2 = [size2[1], size2[0]];\n          var position2 = [\n            (size2[0] - w2) / 2,\n            (size2[1] - h2) / 2\n          ];\n          this.dispatchEvent({\n            type: \"print\",\n            print: {\n              legend: true,\n              format: format2,\n              orientation: this.getOrientation(),\n              unit: \"mm\",\n              size: this.paperSize[format2],\n              position: position2,\n              imageWidth: w2,\n              imageHeight: h2\n            },\n            image: image2,\n            imageType: this.formats[saveLegend.value].imageType,\n            pdf: this.formats[saveLegend.value].pdf,\n            quality: this.formats[saveLegend.value].quality,\n            canvas\n          });\n        } catch (err) {\n        }\n      }\n      saveLegend.value = \"\";\n    }.bind(this) },\n    parent: li\n  });\n  ol_ext_element.create(\"OPTION\", {\n    html: this.i18n(\"saveLegend\"),\n    style: { display: \"none\" },\n    value: \"\",\n    parent: saveLegend\n  });\n  this.formats.forEach(function(format2, i2) {\n    ol_ext_element.create(\"OPTION\", {\n      html: this.i18n(format2.title),\n      value: i2,\n      parent: saveLegend\n    });\n  }.bind(this));\n  var prButtons = ol_ext_element.create(\"DIV\", {\n    className: \"ol-ext-buttons\",\n    parent: param\n  });\n  ol_ext_element.create(\"BUTTON\", {\n    html: this.i18n(\"printBt\"),\n    type: \"submit\",\n    click: function(e2) {\n      e2.preventDefault();\n      window.print();\n    },\n    parent: prButtons\n  });\n  ol_ext_element.create(\"BUTTON\", {\n    html: this.i18n(\"cancel\"),\n    type: \"button\",\n    click: function() {\n      printDialog.hide();\n    },\n    parent: prButtons\n  });\n  ol_ext_element.create(\"DIV\", {\n    html: this.i18n(\"errorMsg\"),\n    className: \"ol-error\",\n    parent: param\n  });\n  var originalTarget;\n  var originalSize;\n  var scalelistener;\n  var extraCtrl = {};\n  printDialog.on(\"show\", function() {\n    this.dispatchEvent({ type: \"show\", userElement: userElt, dialog: this._printDialog, page: this.getPage() });\n    var map = this.getMap();\n    if (!map)\n      return;\n    document.body.classList.add(\"ol-print-document\");\n    originalTarget = map.getTargetElement();\n    originalSize = map.getSize();\n    if (typeof this.getSize() === \"string\")\n      this.setSize(this.getSize());\n    else\n      this.setSize(originalSize);\n    map.setTarget(printMap);\n    if (scalelistener)\n      unByKey(scalelistener);\n    scalelistener = map.on(\"moveend\", function() {\n      this.setScale(ol_sphere_getMapScale(map));\n    }.bind(this));\n    this.setScale(ol_sphere_getMapScale(map));\n    extraCtrl = {};\n    this.getMap().getControls().forEach(function(c2) {\n      if (c2 instanceof ol_control_Legend) {\n        extraCtrl.legend = { control: c2 };\n      }\n      if (c2 instanceof ol_control_CanvasTitle) {\n        extraCtrl.title = { control: c2 };\n      }\n      if (c2 instanceof ol_control_Compass) {\n        if (extraCtrl.compass) {\n          c2.element.classList.remove(\"ol-print-compass\");\n        } else {\n          if (this._input.north.checked)\n            c2.element.classList.add(\"ol-print-compass\");\n          else\n            c2.element.classList.remove(\"ol-print-compass\");\n          this._compass = c2;\n          extraCtrl.compass = { control: c2 };\n        }\n      }\n    }.bind(this));\n    if (extraCtrl.title) {\n      title.checked = extraCtrl.title.isVisible = extraCtrl.title.control.getVisible();\n      titleText.value = extraCtrl.title.control.getTitle();\n      title.parentNode.parentNode.classList.remove(\"hidden\");\n    } else {\n      title.parentNode.parentNode.classList.add(\"hidden\");\n    }\n    if (extraCtrl.legend) {\n      extraCtrl.legend.ison = extraCtrl.legend.control.onCanvas();\n      extraCtrl.legend.collapsed = extraCtrl.legend.control.isCollapsed();\n      extraCtrl.legend.control.collapse(false);\n      saveLegend.parentNode.classList.remove(\"hidden\");\n      legend.parentNode.parentNode.classList.remove(\"hidden\");\n      legend.checked = !extraCtrl.legend.collapsed;\n      extraCtrl.legend.control.setCanvas(!extraCtrl.legend.collapsed);\n    } else {\n      saveLegend.parentNode.classList.add(\"hidden\");\n      legend.parentNode.parentNode.classList.add(\"hidden\");\n    }\n  }.bind(this));\n  printDialog.on(\"hide\", function() {\n    document.body.classList.remove(\"ol-print-document\");\n    if (!originalTarget)\n      return;\n    this.getMap().setTarget(originalTarget);\n    originalTarget = null;\n    if (scalelistener)\n      unByKey(scalelistener);\n    if (extraCtrl.title) {\n      extraCtrl.title.control.setVisible(extraCtrl.title.isVisible);\n    }\n    if (extraCtrl.legend) {\n      extraCtrl.legend.control.setCanvas(extraCtrl.legend.ison);\n      extraCtrl.legend.control.collapse(extraCtrl.legend.collapsed);\n    }\n    this.dispatchEvent({ type: \"hide\" });\n  }.bind(this));\n  window.addEventListener(\"resize\", function() {\n    this.setSize();\n  }.bind(this));\n  if (options.saveAs) {\n    this.on(\"print\", function(e2) {\n      if (!e2.pdf) {\n        e2.canvas.toBlob(function(blob) {\n          var name = (e2.print.legend ? \"legend.\" : \"map.\") + e2.imageType.replace(\"image/\", \"\");\n          options.saveAs(blob, name);\n        }, e2.imageType, e2.quality);\n      }\n    });\n  }\n  if (options.jsPDF) {\n    this.on(\"print\", function(e2) {\n      if (e2.pdf) {\n        var pdf = new options.jsPDF({\n          orientation: e2.print.orientation,\n          unit: e2.print.unit,\n          format: e2.print.size\n        });\n        pdf.addImage(e2.image, \"JPEG\", e2.print.position[0], e2.print.position[0], e2.print.imageWidth, e2.print.imageHeight);\n        pdf.save(e2.print.legend ? \"legend.pdf\" : \"map.pdf\");\n      }\n    });\n  }\n};\nol_ext_inherits(ol_control_PrintDialog, ol_control_Control);\nol_control_PrintDialog.prototype.isOpen = function() {\n  return this._printDialog.isOpen();\n};\nol_control_PrintDialog.addLang = function(lang, labels) {\n  ol_control_PrintDialog.prototype._labels[lang] = labels;\n};\nol_control_PrintDialog.prototype.i18n = function(what) {\n  var rep = this._labels.en[what] || \"bad param\";\n  if (this._labels[this._lang] && this._labels[this._lang][what]) {\n    rep = this._labels[this._lang][what];\n  }\n  return rep;\n};\nol_control_PrintDialog.prototype._labels = {\n  en: {\n    title: \"Print\",\n    orientation: \"Orientation\",\n    portrait: \"Portrait\",\n    landscape: \"Landscape\",\n    size: \"Page size\",\n    custom: \"screen size\",\n    margin: \"Margin\",\n    scale: \"Scale\",\n    legend: \"Legend\",\n    north: \"North arrow\",\n    mapTitle: \"Map title\",\n    saveas: \"Save as...\",\n    saveLegend: \"Save legend...\",\n    copied: \"\\u2714 Copied to clipboard\",\n    errorMsg: \"Can't save map canvas...\",\n    printBt: \"Print...\",\n    clipboardFormat: \"copy to clipboard...\",\n    jpegFormat: \"save as jpeg\",\n    pngFormat: \"save as png\",\n    pdfFormat: \"save as pdf\",\n    none: \"none\",\n    small: \"small\",\n    large: \"large\",\n    cancel: \"cancel\"\n  },\n  fr: {\n    title: \"Imprimer\",\n    orientation: \"Orientation\",\n    portrait: \"Portrait\",\n    landscape: \"Paysage\",\n    size: \"Taille du papier\",\n    custom: \"taille \\xE9cran\",\n    margin: \"Marges\",\n    scale: \"Echelle\",\n    legend: \"L\\xE9gende\",\n    north: \"Fl\\xE8che du nord\",\n    mapTitle: \"Titre de la carte\",\n    saveas: \"Enregistrer sous...\",\n    saveLegend: \"Enregistrer la l\\xE9gende...\",\n    copied: \"\\u2714 Carte copi\\xE9e\",\n    errorMsg: \"Impossible d'enregistrer la carte\",\n    printBt: \"Imprimer\",\n    clipboardFormat: \"copier dans le presse-papier...\",\n    jpegFormat: \"enregistrer un jpeg\",\n    pngFormat: \"enregistrer un png\",\n    pdfFormat: \"enregistrer un pdf\",\n    none: \"aucune\",\n    small: \"petites\",\n    large: \"larges\",\n    cancel: \"annuler\"\n  },\n  de: {\n    title: \"Drucken\",\n    orientation: \"Ausrichtung\",\n    portrait: \"Hochformat\",\n    landscape: \"Querformat\",\n    size: \"Papierformat\",\n    custom: \"Bildschirmgr\\xF6\\xDFe\",\n    margin: \"Rand\",\n    scale: \"Ma\\xDFstab\",\n    legend: \"Legende\",\n    north: \"Nordpfeil\",\n    mapTitle: \"Kartentitel\",\n    saveas: \"Speichern als...\",\n    saveLegend: \"Legende speichern...\",\n    copied: \"\\u2714 In die Zwischenablage kopiert\",\n    errorMsg: \"Kann Karte nicht speichern...\",\n    printBt: \"Drucken...\",\n    clipboardFormat: \"in die Zwischenablage kopieren...\",\n    jpegFormat: \"speichern als jpeg\",\n    pngFormat: \"speichern als png\",\n    pdfFormat: \"speichern als pdf\",\n    none: \"kein\",\n    small: \"klein\",\n    large: \"gro\\xDF\",\n    cancel: \"abbrechen\"\n  },\n  zh: {\n    title: \"\\u6253\\u5370\",\n    orientation: \"\\u65B9\\u5411\",\n    portrait: \"\\u7EB5\\u5411\",\n    landscape: \"\\u6A2A\\u5411\",\n    size: \"\\u9875\\u9762\\u5927\\u5C0F\",\n    custom: \"\\u5C4F\\u5E55\\u5927\\u5C0F\",\n    margin: \"\\u5916\\u8FB9\\u8DDD\",\n    scale: \"\\u5C3A\\u5EA6\",\n    legend: \"\\u56FE\\u4F8B\",\n    north: \"\\u6307\\u5317\\u9488\",\n    mapTitle: \"\\u5730\\u56FE\\u540D\\u5B57\",\n    saveas: \"\\u4FDD\\u5B58\\u4E3A...\",\n    saveLegend: \"\\u4FDD\\u5B58\\u56FE\\u4F8B\\u4E3A...\",\n    copied: \"\\u2714 \\u5DF2\\u590D\\u5236\\u5230\\u526A\\u8D34\\u677F\",\n    errorMsg: \"\\u65E0\\u6CD5\\u4FDD\\u5B58\\u5730\\u56FE...\",\n    printBt: \"\\u6253\\u5370...\",\n    cancel: \"\\u53D6\\u6D88\"\n  }\n};\nol_control_PrintDialog.prototype.paperSize = {\n  \"\": null,\n  \"A0\": [841, 1189],\n  \"A1\": [594, 841],\n  \"A2\": [420, 594],\n  \"A3\": [297, 420],\n  \"A4\": [210, 297],\n  \"US Letter\": [215.9, 279.4],\n  \"A5\": [148, 210],\n  \"B4\": [257, 364],\n  \"B5\": [182, 257]\n};\nol_control_PrintDialog.prototype.marginSize = {\n  none: 0,\n  small: 5,\n  large: 10\n};\nol_control_PrintDialog.prototype.formats = [\n  {\n    title: \"clipboardFormat\",\n    imageType: \"image/png\",\n    clipboard: true\n  },\n  {\n    title: \"jpegFormat\",\n    imageType: \"image/jpeg\",\n    quality: 0.8\n  },\n  {\n    title: \"pngFormat\",\n    imageType: \"image/png\",\n    quality: 0.8\n  },\n  {\n    title: \"pdfFormat\",\n    imageType: \"image/jpeg\",\n    pdf: true\n  }\n];\nol_control_PrintDialog.prototype.scales = {\n  \" 5000\": \"1/5.000\",\n  \" 10000\": \"1/10.000\",\n  \" 25000\": \"1/25.000\",\n  \" 50000\": \"1/50.000\",\n  \" 100000\": \"1/100.000\",\n  \" 250000\": \"1/250.000\",\n  \" 1000000\": \"1/1.000.000\"\n};\nol_control_PrintDialog.prototype.getOrientation = function() {\n  return this._orientation || \"portrait\";\n};\nol_control_PrintDialog.prototype.setOrientation = function(ori) {\n  this._orientation = ori === \"landscape\" ? \"landscape\" : \"portrait\";\n  this._input.orientation[this._orientation].checked = true;\n  this.setSize();\n};\nol_control_PrintDialog.prototype.getMargin = function() {\n  return this._margin || 0;\n};\nol_control_PrintDialog.prototype.setMargin = function(margin) {\n  this._margin = margin;\n  this._input.margin.value = margin;\n  this.setSize();\n};\nol_control_PrintDialog.prototype.getSize = function() {\n  return this._size;\n};\nol_control_PrintDialog.prototype.setSize = function(size) {\n  this._printDialog.getContentElement().setAttribute(\"data-status\", \"\");\n  if (size)\n    this._size = size;\n  else\n    size = this._size;\n  if (!size)\n    return;\n  if (typeof size === \"string\") {\n    for (var k2 in this.paperSize) {\n      if (k2 && new RegExp(k2, \"i\").test(size)) {\n        size = k2;\n      }\n    }\n    if (!this.paperSize[size])\n      size = this._size = \"A4\";\n    this._input.size.value = size;\n    size = [\n      Math.trunc(this.paperSize[size][0] * 96 / 25.4),\n      Math.trunc(this.paperSize[size][1] * 96 / 25.4)\n    ];\n    if (this.getOrientation() === \"landscape\") {\n      size = [size[1], size[0]];\n    }\n    this.getPage().classList.remove(\"margin\");\n  } else {\n    this._input.size.value = \"\";\n    this.getPage().classList.add(\"margin\");\n  }\n  var printElement = this.getPage();\n  var s2 = printElement.parentNode.getBoundingClientRect();\n  var scx = (s2.width - 40) / size[0];\n  var scy = (s2.height - 40) / size[1];\n  var sc = Math.min(scx, scy, 1);\n  printElement.style.width = size[0] + \"px\";\n  printElement.style.height = size[1] + \"px\";\n  printElement.style[\"-webkit-transform\"] = printElement.style.transform = \"translate(-50%,-50%) scale(\" + sc + \")\";\n  var px = Math.round(5 / sc);\n  printElement.style[\"-webkit-box-shadow\"] = printElement.style[\"box-shadow\"] = px + \"px \" + px + \"px \" + px + \"px rgba(0,0,0,.6)\";\n  printElement.style[\"padding\"] = this.getMargin() * 96 / 25.4 + \"px\";\n  if (this.getMap()) {\n    this.getMap().updateSize();\n  }\n  this.dispatchEvent({ type: \"dialog:refresh\" });\n};\nol_control_PrintDialog.prototype.getContentElement = function() {\n  return this._printDialog.getContentElement();\n};\nol_control_PrintDialog.prototype.getUserElement = function() {\n  return this._printDialog.getContentElement().querySelector(\".ol-user-param\");\n};\nol_control_PrintDialog.prototype.getPage = function() {\n  return this._pages[0];\n};\nol_control_PrintDialog.prototype.setMap = function(map) {\n  if (this.getMap()) {\n    this.getMap().removeControl(this._compass);\n    this.getMap().removeControl(this._printCtrl);\n    this.getMap().removeControl(this._printDialog);\n  }\n  ol_control_Control.prototype.setMap.call(this, map);\n  if (this.getMap()) {\n    this.getMap().addControl(this._compass);\n    this.getMap().addControl(this._printCtrl);\n    this.getMap().addControl(this._printDialog);\n  }\n};\nol_control_PrintDialog.prototype.setScale = function(value) {\n  ol_sphere_setMapScale(this.getMap(), value);\n  this._input.scale.value = \" \" + Math.round(value / 100) * 100;\n};\nol_control_PrintDialog.prototype.getScale = function() {\n  return ol_sphere_getMapScale(this.getMap());\n};\nol_control_PrintDialog.prototype.print = function(options) {\n  options = options || {};\n  if (options.size)\n    this.setSize(options.size);\n  if (options.scale)\n    this.setScale(options.scale);\n  if (options.orientation)\n    this.setOrientation(options.orientation);\n  if (options.margin)\n    this.setMargin(options.margin);\n  this._printDialog.show();\n};\nol_control_PrintDialog.prototype.getrintControl = function() {\n  return this._printCtrl;\n};\nvar FileSaver_min = { exports: {} };\n(function(module, exports2) {\n  (function(a2, b2) {\n    b2();\n  })(commonjsGlobal, function() {\n    function b2(a3, b3) {\n      return typeof b3 == \"undefined\" ? b3 = { autoBom: false } : typeof b3 != \"object\" && (console.warn(\"Deprecated: Expected third argument to be a object\"), b3 = { autoBom: !b3 }), b3.autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a3.type) ? new Blob([\"\\uFEFF\", a3], { type: a3.type }) : a3;\n    }\n    function c2(a3, b3, c3) {\n      var d3 = new XMLHttpRequest();\n      d3.open(\"GET\", a3), d3.responseType = \"blob\", d3.onload = function() {\n        g2(d3.response, b3, c3);\n      }, d3.onerror = function() {\n        console.error(\"could not download file\");\n      }, d3.send();\n    }\n    function d2(a3) {\n      var b3 = new XMLHttpRequest();\n      b3.open(\"HEAD\", a3, false);\n      try {\n        b3.send();\n      } catch (a4) {\n      }\n      return 200 <= b3.status && 299 >= b3.status;\n    }\n    function e2(a3) {\n      try {\n        a3.dispatchEvent(new MouseEvent(\"click\"));\n      } catch (c3) {\n        var b3 = document.createEvent(\"MouseEvents\");\n        b3.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);\n      }\n    }\n    var f2 = typeof window == \"object\" && window.window === window ? window : typeof self == \"object\" && self.self === self ? self : typeof commonjsGlobal == \"object\" && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || (typeof window != \"object\" || window !== f2 ? function() {\n    } : \"download\" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {\n      var i2 = f2.URL || f2.webkitURL, j2 = document.createElement(\"a\");\n      g3 = g3 || b3.name || \"download\", j2.download = g3, j2.rel = \"noopener\", typeof b3 == \"string\" ? (j2.href = b3, j2.origin === location.origin ? e2(j2) : d2(j2.href) ? c2(b3, g3, h2) : e2(j2, j2.target = \"_blank\")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {\n        i2.revokeObjectURL(j2.href);\n      }, 4e4), setTimeout(function() {\n        e2(j2);\n      }, 0));\n    } : \"msSaveOrOpenBlob\" in navigator ? function(f3, g3, h2) {\n      if (g3 = g3 || f3.name || \"download\", typeof f3 != \"string\")\n        navigator.msSaveOrOpenBlob(b2(f3, h2), g3);\n      else if (d2(f3))\n        c2(f3, g3, h2);\n      else {\n        var i2 = document.createElement(\"a\");\n        i2.href = f3, i2.target = \"_blank\", setTimeout(function() {\n          e2(i2);\n        });\n      }\n    } : function(b3, d3, e3, g3) {\n      if (g3 = g3 || open(\"\", \"_blank\"), g3 && (g3.document.title = g3.document.body.innerText = \"downloading...\"), typeof b3 == \"string\")\n        return c2(b3, d3, e3);\n      var h2 = b3.type === \"application/octet-stream\", i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n      if ((j2 || h2 && i2 || a2) && typeof FileReader != \"undefined\") {\n        var k2 = new FileReader();\n        k2.onloadend = function() {\n          var a3 = k2.result;\n          a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, \"data:attachment/file;\"), g3 ? g3.location.href = a3 : location = a3, g3 = null;\n        }, k2.readAsDataURL(b3);\n      } else {\n        var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);\n        g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {\n          l2.revokeObjectURL(m2);\n        }, 4e4);\n      }\n    });\n    f2.saveAs = g2.saveAs = g2, module.exports = g2;\n  });\n})(FileSaver_min);\nfunction _typeof$2(obj) {\n  \"@babel/helpers - typeof\";\n  return _typeof$2 = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(obj2) {\n    return typeof obj2;\n  } : function(obj2) {\n    return obj2 && typeof Symbol == \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n  }, _typeof$2(obj);\n}\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nvar freb = function(eb, start2) {\n  var b2 = new u16(31);\n  for (var i2 = 0; i2 < 31; ++i2) {\n    b2[i2] = start2 += 1 << eb[i2 - 1];\n  }\n  var r2 = new u32(b2[30]);\n  for (var i2 = 1; i2 < 30; ++i2) {\n    for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {\n      r2[j2] = j2 - b2[i2] << 5 | i2;\n    }\n  }\n  return [b2, r2];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\nvar rev = new u16(32768);\nfor (var i$6 = 0; i$6 < 32768; ++i$6) {\n  var x$1 = (i$6 & 43690) >>> 1 | (i$6 & 21845) << 1;\n  x$1 = (x$1 & 52428) >>> 2 | (x$1 & 13107) << 2;\n  x$1 = (x$1 & 61680) >>> 4 | (x$1 & 3855) << 4;\n  rev[i$6] = ((x$1 & 65280) >>> 8 | (x$1 & 255) << 8) >>> 1;\n}\nvar hMap = function(cd, mb, r2) {\n  var s2 = cd.length;\n  var i2 = 0;\n  var l2 = new u16(mb);\n  for (; i2 < s2; ++i2)\n    ++l2[cd[i2] - 1];\n  var le2 = new u16(mb);\n  for (i2 = 0; i2 < mb; ++i2) {\n    le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;\n  }\n  var co;\n  if (r2) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i2 = 0; i2 < s2; ++i2) {\n      if (cd[i2]) {\n        var sv = i2 << 4 | cd[i2];\n        var r_1 = mb - cd[i2];\n        var v2 = le2[cd[i2] - 1]++ << r_1;\n        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {\n          co[rev[v2] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s2);\n    for (i2 = 0; i2 < s2; ++i2)\n      co[i2] = rev[le2[cd[i2] - 1]++] >>> 15 - cd[i2];\n  }\n  return co;\n};\nvar flt = new u8(288);\nfor (var i$6 = 0; i$6 < 144; ++i$6)\n  flt[i$6] = 8;\nfor (var i$6 = 144; i$6 < 256; ++i$6)\n  flt[i$6] = 9;\nfor (var i$6 = 256; i$6 < 280; ++i$6)\n  flt[i$6] = 7;\nfor (var i$6 = 280; i$6 < 288; ++i$6)\n  flt[i$6] = 8;\nvar fdt = new u8(32);\nfor (var i$6 = 0; i$6 < 32; ++i$6)\n  fdt[i$6] = 5;\nvar flm = /* @__PURE__ */ hMap(flt, 9, 0), flrm = /* @__PURE__ */ hMap(flt, 9, 1);\nvar fdm = /* @__PURE__ */ hMap(fdt, 5, 0), fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\nvar max$3 = function(a2) {\n  var m2 = a2[0];\n  for (var i2 = 1; i2 < a2.length; ++i2) {\n    if (a2[i2] > m2)\n      m2 = a2[i2];\n  }\n  return m2;\n};\nvar bits = function(d2, p5, m2) {\n  var o2 = p5 / 8 >> 0;\n  return (d2[o2] | d2[o2 + 1] << 8) >>> (p5 & 7) & m2;\n};\nvar bits16 = function(d2, p5) {\n  var o2 = p5 / 8 >> 0;\n  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >>> (p5 & 7);\n};\nvar shft = function(p5) {\n  return (p5 / 8 >> 0) + (p5 & 7 && 1);\n};\nvar slc = function(v2, s2, e2) {\n  if (s2 == null || s2 < 0)\n    s2 = 0;\n  if (e2 == null || e2 > v2.length)\n    e2 = v2.length;\n  var n2 = new (v2 instanceof u16 ? u16 : v2 instanceof u32 ? u32 : u8)(e2 - s2);\n  n2.set(v2.subarray(s2, e2));\n  return n2;\n};\nvar inflt = function(dat, buf, st2) {\n  var sl = dat.length;\n  var noBuf = !buf || st2;\n  var noSt = !st2 || st2.i;\n  if (!st2)\n    st2 = {};\n  if (!buf)\n    buf = new u8(sl * 3);\n  var cbuf = function(l3) {\n    var bl = buf.length;\n    if (l3 > bl) {\n      var nbuf = new u8(Math.max(bl * 2, l3));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;\n  var tbts = sl * 8;\n  do {\n    if (!lm) {\n      st2.f = final = bits(dat, pos, 1);\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if (!type) {\n        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t3 = s2 + l2;\n        if (t3 > sl) {\n          if (noSt)\n            throw \"unexpected EOF\";\n          break;\n        }\n        if (noBuf)\n          cbuf(bt2 + l2);\n        buf.set(dat.subarray(s2, t3), bt2);\n        st2.b = bt2 += l2, st2.p = pos = t3 * 8;\n        continue;\n      } else if (type == 1)\n        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        var ldt = new u8(tl);\n        var clt = new u8(19);\n        for (var i2 = 0; i2 < hcLen; ++i2) {\n          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n        }\n        pos += hcLen * 3;\n        var clb = max$3(clt), clbmsk = (1 << clb) - 1;\n        if (!noSt && pos + tl * (clb + 7) > tbts)\n          break;\n        var clm = hMap(clt, clb, 1);\n        for (var i2 = 0; i2 < tl; ) {\n          var r2 = clm[bits(dat, pos, clbmsk)];\n          pos += r2 & 15;\n          var s2 = r2 >>> 4;\n          if (s2 < 16) {\n            ldt[i2++] = s2;\n          } else {\n            var c2 = 0, n2 = 0;\n            if (s2 == 16)\n              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];\n            else if (s2 == 17)\n              n2 = 3 + bits(dat, pos, 7), pos += 3;\n            else if (s2 == 18)\n              n2 = 11 + bits(dat, pos, 127), pos += 7;\n            while (n2--)\n              ldt[i2++] = c2;\n          }\n        }\n        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);\n        lbt = max$3(lt2);\n        dbt = max$3(dt2);\n        lm = hMap(lt2, lbt, 1);\n        dm = hMap(dt2, dbt, 1);\n      } else\n        throw \"invalid block type\";\n      if (pos > tbts)\n        throw \"unexpected EOF\";\n    }\n    if (noBuf)\n      cbuf(bt2 + 131072);\n    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    var mxa = lbt + dbt + 18;\n    while (noSt || pos + mxa < tbts) {\n      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >>> 4;\n      pos += c2 & 15;\n      if (pos > tbts)\n        throw \"unexpected EOF\";\n      if (!c2)\n        throw \"invalid length/literal\";\n      if (sym < 256)\n        buf[bt2++] = sym;\n      else if (sym == 256) {\n        lm = null;\n        break;\n      } else {\n        var add2 = sym - 254;\n        if (sym > 264) {\n          var i2 = sym - 257, b2 = fleb[i2];\n          add2 = bits(dat, pos, (1 << b2) - 1) + fl[i2];\n          pos += b2;\n        }\n        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >>> 4;\n        if (!d2)\n          throw \"invalid distance\";\n        pos += d2 & 15;\n        var dt2 = fd[dsym];\n        if (dsym > 3) {\n          var b2 = fdeb[dsym];\n          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;\n        }\n        if (pos > tbts)\n          throw \"unexpected EOF\";\n        if (noBuf)\n          cbuf(bt2 + 131072);\n        var end = bt2 + add2;\n        for (; bt2 < end; bt2 += 4) {\n          buf[bt2] = buf[bt2 - dt2];\n          buf[bt2 + 1] = buf[bt2 + 1 - dt2];\n          buf[bt2 + 2] = buf[bt2 + 2 - dt2];\n          buf[bt2 + 3] = buf[bt2 + 3 - dt2];\n        }\n        bt2 = end;\n      }\n    }\n    st2.l = lm, st2.p = pos, st2.b = bt2;\n    if (lm)\n      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;\n  } while (!final);\n  return bt2 == buf.length ? buf : slc(buf, 0, bt2);\n};\nvar wbits = function(d2, p5, v2) {\n  v2 <<= p5 & 7;\n  var o2 = p5 / 8 >> 0;\n  d2[o2] |= v2;\n  d2[o2 + 1] |= v2 >>> 8;\n};\nvar wbits16 = function(d2, p5, v2) {\n  v2 <<= p5 & 7;\n  var o2 = p5 / 8 >> 0;\n  d2[o2] |= v2;\n  d2[o2 + 1] |= v2 >>> 8;\n  d2[o2 + 2] |= v2 >>> 16;\n};\nvar hTree = function(d2, mb) {\n  var t3 = [];\n  for (var i2 = 0; i2 < d2.length; ++i2) {\n    if (d2[i2])\n      t3.push({ s: i2, f: d2[i2] });\n  }\n  var s2 = t3.length;\n  var t22 = t3.slice();\n  if (!s2)\n    return [new u8(0), 0];\n  if (s2 == 1) {\n    var v2 = new u8(t3[0].s + 1);\n    v2[t3[0].s] = 1;\n    return [v2, 1];\n  }\n  t3.sort(function(a2, b2) {\n    return a2.f - b2.f;\n  });\n  t3.push({ s: -1, f: 25001 });\n  var l2 = t3[0], r2 = t3[1], i0 = 0, i1 = 1, i22 = 2;\n  t3[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };\n  while (i1 != s2 - 1) {\n    l2 = t3[t3[i0].f < t3[i22].f ? i0++ : i22++];\n    r2 = t3[i0 != i1 && t3[i0].f < t3[i22].f ? i0++ : i22++];\n    t3[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };\n  }\n  var maxSym = t22[0].s;\n  for (var i2 = 1; i2 < s2; ++i2) {\n    if (t22[i2].s > maxSym)\n      maxSym = t22[i2].s;\n  }\n  var tr = new u16(maxSym + 1);\n  var mbt = ln(t3[i1 - 1], tr, 0);\n  if (mbt > mb) {\n    var i2 = 0, dt2 = 0;\n    var lft = mbt - mb, cst = 1 << lft;\n    t22.sort(function(a2, b2) {\n      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;\n    });\n    for (; i2 < s2; ++i2) {\n      var i2_1 = t22[i2].s;\n      if (tr[i2_1] > mb) {\n        dt2 += cst - (1 << mbt - tr[i2_1]);\n        tr[i2_1] = mb;\n      } else\n        break;\n    }\n    dt2 >>>= lft;\n    while (dt2 > 0) {\n      var i2_2 = t22[i2].s;\n      if (tr[i2_2] < mb)\n        dt2 -= 1 << mb - tr[i2_2]++ - 1;\n      else\n        ++i2;\n    }\n    for (; i2 >= 0 && dt2; --i2) {\n      var i2_3 = t22[i2].s;\n      if (tr[i2_3] == mb) {\n        --tr[i2_3];\n        ++dt2;\n      }\n    }\n    mbt = mb;\n  }\n  return [new u8(tr), mbt];\n};\nvar ln = function(n2, l2, d2) {\n  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;\n};\nvar lc = function(c2) {\n  var s2 = c2.length;\n  while (s2 && !c2[--s2])\n    ;\n  var cl = new u16(++s2);\n  var cli = 0, cln = c2[0], cls = 1;\n  var w2 = function(v2) {\n    cl[cli++] = v2;\n  };\n  for (var i2 = 1; i2 <= s2; ++i2) {\n    if (c2[i2] == cln && i2 != s2)\n      ++cls;\n    else {\n      if (!cln && cls > 2) {\n        for (; cls > 138; cls -= 138)\n          w2(32754);\n        if (cls > 2) {\n          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n          cls = 0;\n        }\n      } else if (cls > 3) {\n        w2(cln), --cls;\n        for (; cls > 6; cls -= 6)\n          w2(8304);\n        if (cls > 2)\n          w2(cls - 3 << 5 | 8208), cls = 0;\n      }\n      while (cls--)\n        w2(cln);\n      cls = 1;\n      cln = c2[i2];\n    }\n  }\n  return [cl.subarray(0, cli), s2];\n};\nvar clen = function(cf, cl) {\n  var l2 = 0;\n  for (var i2 = 0; i2 < cl.length; ++i2)\n    l2 += cf[i2] * cl[i2];\n  return l2;\n};\nvar wfblk = function(out, pos, dat) {\n  var s2 = dat.length;\n  var o2 = shft(pos + 2);\n  out[o2] = s2 & 255;\n  out[o2 + 1] = s2 >>> 8;\n  out[o2 + 2] = out[o2] ^ 255;\n  out[o2 + 3] = out[o2 + 1] ^ 255;\n  for (var i2 = 0; i2 < s2; ++i2)\n    out[o2 + i2 + 4] = dat[i2];\n  return (o2 + 4 + s2) * 8;\n};\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p5) {\n  wbits(out, p5++, final);\n  ++lf[256];\n  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];\n  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];\n  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n  var lcfreq = new u16(19);\n  for (var i2 = 0; i2 < lclt.length; ++i2)\n    lcfreq[lclt[i2] & 31]++;\n  for (var i2 = 0; i2 < lcdt.length; ++i2)\n    lcfreq[lcdt[i2] & 31]++;\n  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n  var nlcc = 19;\n  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n    ;\n  var flen = bl + 5 << 3;\n  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n  if (flen <= ftlen && flen <= dtlen)\n    return wfblk(out, p5, dat.subarray(bs, bs + bl));\n  var lm, ll, dm, dl;\n  wbits(out, p5, 1 + (dtlen < ftlen)), p5 += 2;\n  if (dtlen < ftlen) {\n    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n    var llm = hMap(lct, mlcb, 0);\n    wbits(out, p5, nlc - 257);\n    wbits(out, p5 + 5, ndc - 1);\n    wbits(out, p5 + 10, nlcc - 4);\n    p5 += 14;\n    for (var i2 = 0; i2 < nlcc; ++i2)\n      wbits(out, p5 + 3 * i2, lct[clim[i2]]);\n    p5 += 3 * nlcc;\n    var lcts = [lclt, lcdt];\n    for (var it2 = 0; it2 < 2; ++it2) {\n      var clct = lcts[it2];\n      for (var i2 = 0; i2 < clct.length; ++i2) {\n        var len = clct[i2] & 31;\n        wbits(out, p5, llm[len]), p5 += lct[len];\n        if (len > 15)\n          wbits(out, p5, clct[i2] >>> 5 & 127), p5 += clct[i2] >>> 12;\n      }\n    }\n  } else {\n    lm = flm, ll = flt, dm = fdm, dl = fdt;\n  }\n  for (var i2 = 0; i2 < li; ++i2) {\n    if (syms[i2] > 255) {\n      var len = syms[i2] >>> 18 & 31;\n      wbits16(out, p5, lm[len + 257]), p5 += ll[len + 257];\n      if (len > 7)\n        wbits(out, p5, syms[i2] >>> 23 & 31), p5 += fleb[len];\n      var dst = syms[i2] & 31;\n      wbits16(out, p5, dm[dst]), p5 += dl[dst];\n      if (dst > 3)\n        wbits16(out, p5, syms[i2] >>> 5 & 8191), p5 += fdeb[dst];\n    } else {\n      wbits16(out, p5, lm[syms[i2]]), p5 += ll[syms[i2]];\n    }\n  }\n  wbits16(out, p5, lm[256]);\n  return p5 + ll[256];\n};\nvar deo = /* @__PURE__ */ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\nvar et$1 = /* @__PURE__ */ new u8(0);\nvar dflt = function(dat, lvl, plvl, pre, post2, lst) {\n  var s2 = dat.length;\n  var o2 = new u8(pre + s2 + 5 * (1 + Math.floor(s2 / 7e3)) + post2);\n  var w2 = o2.subarray(pre, o2.length - post2);\n  var pos = 0;\n  if (!lvl || s2 < 8) {\n    for (var i2 = 0; i2 <= s2; i2 += 65535) {\n      var e2 = i2 + 65535;\n      if (e2 < s2) {\n        pos = wfblk(w2, pos, dat.subarray(i2, e2));\n      } else {\n        w2[i2] = lst;\n        pos = wfblk(w2, pos, dat.subarray(i2, s2));\n      }\n    }\n  } else {\n    var opt = deo[lvl - 1];\n    var n2 = opt >>> 13, c2 = opt & 8191;\n    var msk_1 = (1 << plvl) - 1;\n    var prev = new u16(32768), head2 = new u16(msk_1 + 1);\n    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n    var hsh = function(i3) {\n      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;\n    };\n    var syms = new u32(25e3);\n    var lf = new u16(288), df = new u16(32);\n    var lc_1 = 0, eb = 0, i2 = 0, li = 0, wi = 0, bs = 0;\n    for (; i2 < s2; ++i2) {\n      var hv = hsh(i2);\n      var imod = i2 & 32767;\n      var pimod = head2[hv];\n      prev[imod] = pimod;\n      head2[hv] = imod;\n      if (wi <= i2) {\n        var rem = s2 - i2;\n        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {\n          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);\n          li = lc_1 = eb = 0, bs = i2;\n          for (var j2 = 0; j2 < 286; ++j2)\n            lf[j2] = 0;\n          for (var j2 = 0; j2 < 30; ++j2)\n            df[j2] = 0;\n        }\n        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;\n        if (rem > 2 && hv == hsh(i2 - dif)) {\n          var maxn = Math.min(n2, rem) - 1;\n          var maxd = Math.min(32767, i2);\n          var ml = Math.min(258, rem);\n          while (dif <= maxd && --ch_1 && imod != pimod) {\n            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {\n              var nl = 0;\n              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)\n                ;\n              if (nl > l2) {\n                l2 = nl, d2 = dif;\n                if (nl > maxn)\n                  break;\n                var mmd = Math.min(dif, nl - 2);\n                var md = 0;\n                for (var j2 = 0; j2 < mmd; ++j2) {\n                  var ti = i2 - dif + j2 + 32768 & 32767;\n                  var pti = prev[ti];\n                  var cd = ti - pti + 32768 & 32767;\n                  if (cd > md)\n                    md = cd, pimod = ti;\n                }\n              }\n            }\n            imod = pimod, pimod = prev[imod];\n            dif += imod - pimod + 32768 & 32767;\n          }\n        }\n        if (d2) {\n          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];\n          var lin = revfl[l2] & 31, din = revfd[d2] & 31;\n          eb += fleb[lin] + fdeb[din];\n          ++lf[257 + lin];\n          ++df[din];\n          wi = i2 + l2;\n          ++lc_1;\n        } else {\n          syms[li++] = dat[i2];\n          ++lf[dat[i2]];\n        }\n      }\n    }\n    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);\n    if (!lst)\n      pos = wfblk(w2, pos, et$1);\n  }\n  return slc(o2, 0, pre + shft(pos) + post2);\n};\nvar adler = function() {\n  var a2 = 1, b2 = 0;\n  return {\n    p: function(d2) {\n      var n2 = a2, m2 = b2;\n      var l2 = d2.length;\n      for (var i2 = 0; i2 != l2; ) {\n        var e2 = Math.min(i2 + 5552, l2);\n        for (; i2 < e2; ++i2)\n          n2 += d2[i2], m2 += n2;\n        n2 %= 65521, m2 %= 65521;\n      }\n      a2 = n2, b2 = m2;\n    },\n    d: function() {\n      return (a2 >>> 8 << 16 | (b2 & 255) << 8 | b2 >>> 8) + ((a2 & 255) << 23) * 2;\n    }\n  };\n};\nvar dopt = function(dat, opt, pre, post2, st2) {\n  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post2, !st2);\n};\nvar wbytes = function(d2, b2, v2) {\n  for (; v2; ++b2)\n    d2[b2] = v2, v2 >>>= 8;\n};\nvar zlh = function(c2, o2) {\n  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n  c2[0] = 120, c2[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);\n};\nvar zlv = function(d2) {\n  if ((d2[0] & 15) != 8 || d2[0] >>> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)\n    throw \"invalid zlib data\";\n  if (d2[1] & 32)\n    throw \"invalid zlib data: preset dictionaries not supported\";\n};\nfunction zlibSync(data2, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  var a2 = adler();\n  a2.p(data2);\n  var d2 = dopt(data2, opts, 2, 4);\n  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;\n}\nfunction unzlibSync(data2, out) {\n  return inflt((zlv(data2), data2.subarray(2, -4)), out);\n}\n/** @license\n *\n * jsPDF - PDF Document creation from JavaScript\n * Version 2.5.0 Built on 2021-12-21T09:44:51.866Z\n *                      CommitID 00000000\n *\n * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF\n *               2015-2021 yWorks GmbH, http://www.yworks.com\n *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX\n *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>\n *               2010 Aaron Spike, https://github.com/acspike\n *               2012 Willow Systems Corporation, https://github.com/willowsystems\n *               2012 Pablo Hess, https://github.com/pablohess\n *               2012 Florian Jenett, https://github.com/fjenett\n *               2013 Warren Weckesser, https://github.com/warrenweckesser\n *               2013 Youssef Beddad, https://github.com/lifof\n *               2013 Lee Driscoll, https://github.com/lsdriscoll\n *               2013 Stefan Slonevskiy, https://github.com/stefslon\n *               2013 Jeremy Morel, https://github.com/jmorel\n *               2013 Christoph Hartmann, https://github.com/chris-rock\n *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria\n *               2014 James Makes, https://github.com/dollaruw\n *               2014 Diego Casorran, https://github.com/diegocr\n *               2014 Steven Spungin, https://github.com/Flamenco\n *               2014 Kenneth Glassey, https://github.com/Gavvers\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Contributor(s):\n *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,\n *    kim3er, mfo, alnorth, Flamenco\n */\nvar n$1 = function() {\n  return typeof window != \"undefined\" ? window : typeof __webpack_require__.g != \"undefined\" ? __webpack_require__.g : typeof self != \"undefined\" ? self : this;\n}();\nfunction i$5() {\n  n$1.console && typeof n$1.console.log == \"function\" && n$1.console.log.apply(n$1.console, arguments);\n}\nvar a$2 = { log: i$5, warn: function(t3) {\n  n$1.console && (typeof n$1.console.warn == \"function\" ? n$1.console.warn.apply(n$1.console, arguments) : i$5.call(null, arguments));\n}, error: function(t3) {\n  n$1.console && (typeof n$1.console.error == \"function\" ? n$1.console.error.apply(n$1.console, arguments) : i$5(t3));\n} };\nfunction o$1(t3, e2, r2) {\n  var n2 = new XMLHttpRequest();\n  n2.open(\"GET\", t3), n2.responseType = \"blob\", n2.onload = function() {\n    l$1(n2.response, e2, r2);\n  }, n2.onerror = function() {\n    a$2.error(\"could not download file\");\n  }, n2.send();\n}\nfunction s$1(t3) {\n  var e2 = new XMLHttpRequest();\n  e2.open(\"HEAD\", t3, false);\n  try {\n    e2.send();\n  } catch (t4) {\n  }\n  return e2.status >= 200 && e2.status <= 299;\n}\nfunction c$2(t3) {\n  try {\n    t3.dispatchEvent(new MouseEvent(\"click\"));\n  } catch (r2) {\n    var e2 = document.createEvent(\"MouseEvents\");\n    e2.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t3.dispatchEvent(e2);\n  }\n}\nvar u$2, h$1, l$1 = n$1.saveAs || ((typeof window == \"undefined\" ? \"undefined\" : _typeof$2(window)) !== \"object\" || window !== n$1 ? function() {\n} : typeof HTMLAnchorElement != \"undefined\" && \"download\" in HTMLAnchorElement.prototype ? function(t3, e2, r2) {\n  var i2 = n$1.URL || n$1.webkitURL, a2 = document.createElement(\"a\");\n  e2 = e2 || t3.name || \"download\", a2.download = e2, a2.rel = \"noopener\", typeof t3 == \"string\" ? (a2.href = t3, a2.origin !== location.origin ? s$1(a2.href) ? o$1(t3, e2, r2) : c$2(a2, a2.target = \"_blank\") : c$2(a2)) : (a2.href = i2.createObjectURL(t3), setTimeout(function() {\n    i2.revokeObjectURL(a2.href);\n  }, 4e4), setTimeout(function() {\n    c$2(a2);\n  }, 0));\n} : \"msSaveOrOpenBlob\" in navigator ? function(e2, r2, n2) {\n  if (r2 = r2 || e2.name || \"download\", typeof e2 == \"string\")\n    if (s$1(e2))\n      o$1(e2, r2, n2);\n    else {\n      var i2 = document.createElement(\"a\");\n      i2.href = e2, i2.target = \"_blank\", setTimeout(function() {\n        c$2(i2);\n      });\n    }\n  else\n    navigator.msSaveOrOpenBlob(function(e3, r3) {\n      return r3 === void 0 ? r3 = { autoBom: false } : _typeof$2(r3) !== \"object\" && (a$2.warn(\"Deprecated: Expected third argument to be a object\"), r3 = { autoBom: !r3 }), r3.autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;\n    }(e2, n2), r2);\n} : function(e2, r2, i2, a2) {\n  if ((a2 = a2 || open(\"\", \"_blank\")) && (a2.document.title = a2.document.body.innerText = \"downloading...\"), typeof e2 == \"string\")\n    return o$1(e2, r2, i2);\n  var s2 = e2.type === \"application/octet-stream\", c2 = /constructor/i.test(n$1.HTMLElement) || n$1.safari, u2 = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n  if ((u2 || s2 && c2) && (typeof FileReader == \"undefined\" ? \"undefined\" : _typeof$2(FileReader)) === \"object\") {\n    var h2 = new FileReader();\n    h2.onloadend = function() {\n      var t3 = h2.result;\n      t3 = u2 ? t3 : t3.replace(/^data:[^;]*;/, \"data:attachment/file;\"), a2 ? a2.location.href = t3 : location = t3, a2 = null;\n    }, h2.readAsDataURL(e2);\n  } else {\n    var l2 = n$1.URL || n$1.webkitURL, f2 = l2.createObjectURL(e2);\n    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {\n      l2.revokeObjectURL(f2);\n    }, 4e4);\n  }\n});\n/**\n * A class to parse color values\n * @author Stoyan Stefanov <sstoo@gmail.com>\n * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}\n * @license Use it if you like it\n */\nfunction f$2(t3) {\n  var e2;\n  t3 = t3 || \"\", this.ok = false, t3.charAt(0) == \"#\" && (t3 = t3.substr(1, 6));\n  t3 = { aliceblue: \"f0f8ff\", antiquewhite: \"faebd7\", aqua: \"00ffff\", aquamarine: \"7fffd4\", azure: \"f0ffff\", beige: \"f5f5dc\", bisque: \"ffe4c4\", black: \"000000\", blanchedalmond: \"ffebcd\", blue: \"0000ff\", blueviolet: \"8a2be2\", brown: \"a52a2a\", burlywood: \"deb887\", cadetblue: \"5f9ea0\", chartreuse: \"7fff00\", chocolate: \"d2691e\", coral: \"ff7f50\", cornflowerblue: \"6495ed\", cornsilk: \"fff8dc\", crimson: \"dc143c\", cyan: \"00ffff\", darkblue: \"00008b\", darkcyan: \"008b8b\", darkgoldenrod: \"b8860b\", darkgray: \"a9a9a9\", darkgreen: \"006400\", darkkhaki: \"bdb76b\", darkmagenta: \"8b008b\", darkolivegreen: \"556b2f\", darkorange: \"ff8c00\", darkorchid: \"9932cc\", darkred: \"8b0000\", darksalmon: \"e9967a\", darkseagreen: \"8fbc8f\", darkslateblue: \"483d8b\", darkslategray: \"2f4f4f\", darkturquoise: \"00ced1\", darkviolet: \"9400d3\", deeppink: \"ff1493\", deepskyblue: \"00bfff\", dimgray: \"696969\", dodgerblue: \"1e90ff\", feldspar: \"d19275\", firebrick: \"b22222\", floralwhite: \"fffaf0\", forestgreen: \"228b22\", fuchsia: \"ff00ff\", gainsboro: \"dcdcdc\", ghostwhite: \"f8f8ff\", gold: \"ffd700\", goldenrod: \"daa520\", gray: \"808080\", green: \"008000\", greenyellow: \"adff2f\", honeydew: \"f0fff0\", hotpink: \"ff69b4\", indianred: \"cd5c5c\", indigo: \"4b0082\", ivory: \"fffff0\", khaki: \"f0e68c\", lavender: \"e6e6fa\", lavenderblush: \"fff0f5\", lawngreen: \"7cfc00\", lemonchiffon: \"fffacd\", lightblue: \"add8e6\", lightcoral: \"f08080\", lightcyan: \"e0ffff\", lightgoldenrodyellow: \"fafad2\", lightgrey: \"d3d3d3\", lightgreen: \"90ee90\", lightpink: \"ffb6c1\", lightsalmon: \"ffa07a\", lightseagreen: \"20b2aa\", lightskyblue: \"87cefa\", lightslateblue: \"8470ff\", lightslategray: \"778899\", lightsteelblue: \"b0c4de\", lightyellow: \"ffffe0\", lime: \"00ff00\", limegreen: \"32cd32\", linen: \"faf0e6\", magenta: \"ff00ff\", maroon: \"800000\", mediumaquamarine: \"66cdaa\", mediumblue: \"0000cd\", mediumorchid: \"ba55d3\", mediumpurple: \"9370d8\", mediumseagreen: \"3cb371\", mediumslateblue: \"7b68ee\", mediumspringgreen: \"00fa9a\", mediumturquoise: \"48d1cc\", mediumvioletred: \"c71585\", midnightblue: \"191970\", mintcream: \"f5fffa\", mistyrose: \"ffe4e1\", moccasin: \"ffe4b5\", navajowhite: \"ffdead\", navy: \"000080\", oldlace: \"fdf5e6\", olive: \"808000\", olivedrab: \"6b8e23\", orange: \"ffa500\", orangered: \"ff4500\", orchid: \"da70d6\", palegoldenrod: \"eee8aa\", palegreen: \"98fb98\", paleturquoise: \"afeeee\", palevioletred: \"d87093\", papayawhip: \"ffefd5\", peachpuff: \"ffdab9\", peru: \"cd853f\", pink: \"ffc0cb\", plum: \"dda0dd\", powderblue: \"b0e0e6\", purple: \"800080\", red: \"ff0000\", rosybrown: \"bc8f8f\", royalblue: \"4169e1\", saddlebrown: \"8b4513\", salmon: \"fa8072\", sandybrown: \"f4a460\", seagreen: \"2e8b57\", seashell: \"fff5ee\", sienna: \"a0522d\", silver: \"c0c0c0\", skyblue: \"87ceeb\", slateblue: \"6a5acd\", slategray: \"708090\", snow: \"fffafa\", springgreen: \"00ff7f\", steelblue: \"4682b4\", tan: \"d2b48c\", teal: \"008080\", thistle: \"d8bfd8\", tomato: \"ff6347\", turquoise: \"40e0d0\", violet: \"ee82ee\", violetred: \"d02090\", wheat: \"f5deb3\", white: \"ffffff\", whitesmoke: \"f5f5f5\", yellow: \"ffff00\", yellowgreen: \"9acd32\" }[t3 = (t3 = t3.replace(/ /g, \"\")).toLowerCase()] || t3;\n  for (var r2 = [{ re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/, example: [\"rgb(123, 234, 45)\", \"rgb(255,234,245)\"], process: function(t4) {\n    return [parseInt(t4[1]), parseInt(t4[2]), parseInt(t4[3])];\n  } }, { re: /^(\\w{2})(\\w{2})(\\w{2})$/, example: [\"#00ff00\", \"336699\"], process: function(t4) {\n    return [parseInt(t4[1], 16), parseInt(t4[2], 16), parseInt(t4[3], 16)];\n  } }, { re: /^(\\w{1})(\\w{1})(\\w{1})$/, example: [\"#fb0\", \"f0f\"], process: function(t4) {\n    return [parseInt(t4[1] + t4[1], 16), parseInt(t4[2] + t4[2], 16), parseInt(t4[3] + t4[3], 16)];\n  } }], n2 = 0; n2 < r2.length; n2++) {\n    var i2 = r2[n2].re, a2 = r2[n2].process, o2 = i2.exec(t3);\n    o2 && (e2 = a2(o2), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);\n  }\n  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {\n    return \"rgb(\" + this.r + \", \" + this.g + \", \" + this.b + \")\";\n  }, this.toHex = function() {\n    var t4 = this.r.toString(16), e3 = this.g.toString(16), r3 = this.b.toString(16);\n    return t4.length == 1 && (t4 = \"0\" + t4), e3.length == 1 && (e3 = \"0\" + e3), r3.length == 1 && (r3 = \"0\" + r3), \"#\" + t4 + e3 + r3;\n  };\n}\n/**\n * @license\n * Joseph Myers does not specify a particular license for his work.\n *\n * Author: Joseph Myers\n * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js\n *\n * Modified by: Owen Leong\n */\nfunction d(t3, e2) {\n  var r2 = t3[0], n2 = t3[1], i2 = t3[2], a2 = t3[3];\n  r2 = g(r2, n2, i2, a2, e2[0], 7, -680876936), a2 = g(a2, r2, n2, i2, e2[1], 12, -389564586), i2 = g(i2, a2, r2, n2, e2[2], 17, 606105819), n2 = g(n2, i2, a2, r2, e2[3], 22, -1044525330), r2 = g(r2, n2, i2, a2, e2[4], 7, -176418897), a2 = g(a2, r2, n2, i2, e2[5], 12, 1200080426), i2 = g(i2, a2, r2, n2, e2[6], 17, -1473231341), n2 = g(n2, i2, a2, r2, e2[7], 22, -45705983), r2 = g(r2, n2, i2, a2, e2[8], 7, 1770035416), a2 = g(a2, r2, n2, i2, e2[9], 12, -1958414417), i2 = g(i2, a2, r2, n2, e2[10], 17, -42063), n2 = g(n2, i2, a2, r2, e2[11], 22, -1990404162), r2 = g(r2, n2, i2, a2, e2[12], 7, 1804603682), a2 = g(a2, r2, n2, i2, e2[13], 12, -40341101), i2 = g(i2, a2, r2, n2, e2[14], 17, -1502002290), r2 = m$2(r2, n2 = g(n2, i2, a2, r2, e2[15], 22, 1236535329), i2, a2, e2[1], 5, -165796510), a2 = m$2(a2, r2, n2, i2, e2[6], 9, -1069501632), i2 = m$2(i2, a2, r2, n2, e2[11], 14, 643717713), n2 = m$2(n2, i2, a2, r2, e2[0], 20, -373897302), r2 = m$2(r2, n2, i2, a2, e2[5], 5, -701558691), a2 = m$2(a2, r2, n2, i2, e2[10], 9, 38016083), i2 = m$2(i2, a2, r2, n2, e2[15], 14, -660478335), n2 = m$2(n2, i2, a2, r2, e2[4], 20, -405537848), r2 = m$2(r2, n2, i2, a2, e2[9], 5, 568446438), a2 = m$2(a2, r2, n2, i2, e2[14], 9, -1019803690), i2 = m$2(i2, a2, r2, n2, e2[3], 14, -187363961), n2 = m$2(n2, i2, a2, r2, e2[8], 20, 1163531501), r2 = m$2(r2, n2, i2, a2, e2[13], 5, -1444681467), a2 = m$2(a2, r2, n2, i2, e2[2], 9, -51403784), i2 = m$2(i2, a2, r2, n2, e2[7], 14, 1735328473), r2 = v$1(r2, n2 = m$2(n2, i2, a2, r2, e2[12], 20, -1926607734), i2, a2, e2[5], 4, -378558), a2 = v$1(a2, r2, n2, i2, e2[8], 11, -2022574463), i2 = v$1(i2, a2, r2, n2, e2[11], 16, 1839030562), n2 = v$1(n2, i2, a2, r2, e2[14], 23, -35309556), r2 = v$1(r2, n2, i2, a2, e2[1], 4, -1530992060), a2 = v$1(a2, r2, n2, i2, e2[4], 11, 1272893353), i2 = v$1(i2, a2, r2, n2, e2[7], 16, -155497632), n2 = v$1(n2, i2, a2, r2, e2[10], 23, -1094730640), r2 = v$1(r2, n2, i2, a2, e2[13], 4, 681279174), a2 = v$1(a2, r2, n2, i2, e2[0], 11, -358537222), i2 = v$1(i2, a2, r2, n2, e2[3], 16, -722521979), n2 = v$1(n2, i2, a2, r2, e2[6], 23, 76029189), r2 = v$1(r2, n2, i2, a2, e2[9], 4, -640364487), a2 = v$1(a2, r2, n2, i2, e2[12], 11, -421815835), i2 = v$1(i2, a2, r2, n2, e2[15], 16, 530742520), r2 = b(r2, n2 = v$1(n2, i2, a2, r2, e2[2], 23, -995338651), i2, a2, e2[0], 6, -198630844), a2 = b(a2, r2, n2, i2, e2[7], 10, 1126891415), i2 = b(i2, a2, r2, n2, e2[14], 15, -1416354905), n2 = b(n2, i2, a2, r2, e2[5], 21, -57434055), r2 = b(r2, n2, i2, a2, e2[12], 6, 1700485571), a2 = b(a2, r2, n2, i2, e2[3], 10, -1894986606), i2 = b(i2, a2, r2, n2, e2[10], 15, -1051523), n2 = b(n2, i2, a2, r2, e2[1], 21, -2054922799), r2 = b(r2, n2, i2, a2, e2[8], 6, 1873313359), a2 = b(a2, r2, n2, i2, e2[15], 10, -30611744), i2 = b(i2, a2, r2, n2, e2[6], 15, -1560198380), n2 = b(n2, i2, a2, r2, e2[13], 21, 1309151649), r2 = b(r2, n2, i2, a2, e2[4], 6, -145523070), a2 = b(a2, r2, n2, i2, e2[11], 10, -1120210379), i2 = b(i2, a2, r2, n2, e2[2], 15, 718787259), n2 = b(n2, i2, a2, r2, e2[9], 21, -343485551), t3[0] = _$1(r2, t3[0]), t3[1] = _$1(n2, t3[1]), t3[2] = _$1(i2, t3[2]), t3[3] = _$1(a2, t3[3]);\n}\nfunction p$1(t3, e2, r2, n2, i2, a2) {\n  return e2 = _$1(_$1(e2, t3), _$1(n2, a2)), _$1(e2 << i2 | e2 >>> 32 - i2, r2);\n}\nfunction g(t3, e2, r2, n2, i2, a2, o2) {\n  return p$1(e2 & r2 | ~e2 & n2, t3, e2, i2, a2, o2);\n}\nfunction m$2(t3, e2, r2, n2, i2, a2, o2) {\n  return p$1(e2 & n2 | r2 & ~n2, t3, e2, i2, a2, o2);\n}\nfunction v$1(t3, e2, r2, n2, i2, a2, o2) {\n  return p$1(e2 ^ r2 ^ n2, t3, e2, i2, a2, o2);\n}\nfunction b(t3, e2, r2, n2, i2, a2, o2) {\n  return p$1(r2 ^ (e2 | ~n2), t3, e2, i2, a2, o2);\n}\nfunction y$1(t3) {\n  var e2, r2 = t3.length, n2 = [1732584193, -271733879, -1732584194, 271733878];\n  for (e2 = 64; e2 <= t3.length; e2 += 64)\n    d(n2, w(t3.substring(e2 - 64, e2)));\n  t3 = t3.substring(e2 - 64);\n  var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  for (e2 = 0; e2 < t3.length; e2++)\n    i2[e2 >> 2] |= t3.charCodeAt(e2) << (e2 % 4 << 3);\n  if (i2[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55)\n    for (d(n2, i2), e2 = 0; e2 < 16; e2++)\n      i2[e2] = 0;\n  return i2[14] = 8 * r2, d(n2, i2), n2;\n}\nfunction w(t3) {\n  var e2, r2 = [];\n  for (e2 = 0; e2 < 64; e2 += 4)\n    r2[e2 >> 2] = t3.charCodeAt(e2) + (t3.charCodeAt(e2 + 1) << 8) + (t3.charCodeAt(e2 + 2) << 16) + (t3.charCodeAt(e2 + 3) << 24);\n  return r2;\n}\nu$2 = n$1.atob.bind(n$1), h$1 = n$1.btoa.bind(n$1);\nvar N$1 = \"0123456789abcdef\".split(\"\");\nfunction L$1(t3) {\n  for (var e2 = \"\", r2 = 0; r2 < 4; r2++)\n    e2 += N$1[t3 >> 8 * r2 + 4 & 15] + N$1[t3 >> 8 * r2 & 15];\n  return e2;\n}\nfunction A$1(t3) {\n  return String.fromCharCode((255 & t3) >> 0, (65280 & t3) >> 8, (16711680 & t3) >> 16, (4278190080 & t3) >> 24);\n}\nfunction x(t3) {\n  return y$1(t3).map(A$1).join(\"\");\n}\nvar S = function(t3) {\n  for (var e2 = 0; e2 < t3.length; e2++)\n    t3[e2] = L$1(t3[e2]);\n  return t3.join(\"\");\n}(y$1(\"hello\")) != \"5d41402abc4b2a76b9719d911017c592\";\nfunction _$1(t3, e2) {\n  if (S) {\n    var r2 = (65535 & t3) + (65535 & e2);\n    return (t3 >> 16) + (e2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;\n  }\n  return t3 + e2 & 4294967295;\n}\n/**\n * @license\n * FPDF is released under a permissive license: there is no usage restriction.\n * You may embed it freely in your application (commercial or not), with or\n * without modifications.\n *\n * Reference: http://www.fpdf.org/en/script/script37.php\n */\nfunction P(t3, e2) {\n  var r2, n2, i2, a2;\n  if (t3 !== r2) {\n    for (var o2 = (i2 = t3, a2 = 1 + (256 / t3.length >> 0), new Array(a2 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++)\n      s2[c2] = c2;\n    var u2 = 0;\n    for (c2 = 0; c2 < 256; c2++) {\n      var h2 = s2[c2];\n      u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;\n    }\n    r2 = t3, n2 = s2;\n  } else\n    s2 = n2;\n  var l2 = e2.length, f2 = 0, d2 = 0, p5 = \"\";\n  for (c2 = 0; c2 < l2; c2++)\n    d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p5 += String.fromCharCode(e2.charCodeAt(c2) ^ o2);\n  return p5;\n}\n/**\n * @license\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n * Author: Owen Leong (@owenl131)\n * Date: 15 Oct 2020\n * References:\n * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt\n * https://github.com/foliojs/pdfkit/blob/master/lib/security.js\n * http://www.fpdf.org/en/script/script37.php\n */\nvar k = { print: 4, modify: 8, copy: 16, \"annot-forms\": 32 };\nfunction I(t3, e2, r2, n2) {\n  this.v = 1, this.r = 2;\n  var i2 = 192;\n  t3.forEach(function(t4) {\n    if (k.perm !== void 0)\n      throw new Error(\"Invalid permission: \" + t4);\n    i2 += k[t4];\n  }), this.padding = \"(\\xBFN^Nu\\x8AAd\\0NV\\xFF\\xFA\u0001\\b..\\0\\xB6\\xD0h>\\x80/\\f\\xA9\\xFEdSiz\";\n  var a2 = (e2 + this.padding).substr(0, 32), o2 = (r2 + this.padding).substr(0, 32);\n  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);\n}\nfunction F$1(t3) {\n  if (/[^\\u0000-\\u00ff]/.test(t3))\n    throw new Error(\"Invalid PDF Name Object: \" + t3 + \", Only accept ASCII characters.\");\n  for (var e2 = \"\", r2 = t3.length, n2 = 0; n2 < r2; n2++) {\n    var i2 = t3.charCodeAt(n2);\n    if (i2 < 33 || i2 === 35 || i2 === 37 || i2 === 40 || i2 === 41 || i2 === 47 || i2 === 60 || i2 === 62 || i2 === 91 || i2 === 93 || i2 === 123 || i2 === 125 || i2 > 126)\n      e2 += \"#\" + (\"0\" + i2.toString(16)).slice(-2);\n    else\n      e2 += t3[n2];\n  }\n  return e2;\n}\nfunction C(e2) {\n  if (_typeof$2(e2) !== \"object\")\n    throw new Error(\"Invalid Context passed to initialize PubSub (jsPDF-module)\");\n  var r2 = {};\n  this.subscribe = function(t3, e3, n2) {\n    if (n2 = n2 || false, typeof t3 != \"string\" || typeof e3 != \"function\" || typeof n2 != \"boolean\")\n      throw new Error(\"Invalid arguments passed to PubSub.subscribe (jsPDF-module)\");\n    r2.hasOwnProperty(t3) || (r2[t3] = {});\n    var i2 = Math.random().toString(35);\n    return r2[t3][i2] = [e3, !!n2], i2;\n  }, this.unsubscribe = function(t3) {\n    for (var e3 in r2)\n      if (r2[e3][t3])\n        return delete r2[e3][t3], Object.keys(r2[e3]).length === 0 && delete r2[e3], true;\n    return false;\n  }, this.publish = function(t3) {\n    if (r2.hasOwnProperty(t3)) {\n      var i2 = Array.prototype.slice.call(arguments, 1), o2 = [];\n      for (var s2 in r2[t3]) {\n        var c2 = r2[t3][s2];\n        try {\n          c2[0].apply(e2, i2);\n        } catch (t4) {\n          n$1.console && a$2.error(\"jsPDF PubSub Error\", t4.message, t4);\n        }\n        c2[1] && o2.push(s2);\n      }\n      o2.length && o2.forEach(this.unsubscribe);\n    }\n  }, this.getTopics = function() {\n    return r2;\n  };\n}\nfunction j(t3) {\n  if (!(this instanceof j))\n    return new j(t3);\n  var e2 = \"opacity,stroke-opacity\".split(\",\");\n  for (var r2 in t3)\n    t3.hasOwnProperty(r2) && e2.indexOf(r2) >= 0 && (this[r2] = t3[r2]);\n  this.id = \"\", this.objectNumber = -1;\n}\nfunction O$1(t3, e2) {\n  this.gState = t3, this.matrix = e2, this.id = \"\", this.objectNumber = -1;\n}\nfunction B(t3, e2, r2, n2, i2) {\n  if (!(this instanceof B))\n    return new B(t3, e2, r2, n2, i2);\n  this.type = t3 === \"axial\" ? 2 : 3, this.coords = e2, this.colors = r2, O$1.call(this, n2, i2);\n}\nfunction M$1(t3, e2, r2, n2, i2) {\n  if (!(this instanceof M$1))\n    return new M$1(t3, e2, r2, n2, i2);\n  this.boundingBox = t3, this.xStep = e2, this.yStep = r2, this.stream = \"\", this.cloneIndex = 0, O$1.call(this, n2, i2);\n}\nfunction E$1(e2) {\n  var r2, i2 = typeof arguments[0] == \"string\" ? arguments[0] : \"p\", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p5 = 16, g2 = \"S\", m2 = null;\n  _typeof$2(e2 = e2 || {}) === \"object\" && (i2 = e2.orientation, o2 = e2.unit || o2, s2 = e2.format || s2, c2 = e2.compress || e2.compressPdf || c2, (m2 = e2.encryption || null) !== null && (m2.userPassword = m2.userPassword || \"\", m2.ownerPassword = m2.ownerPassword || \"\", m2.userPermissions = m2.userPermissions || []), d2 = typeof e2.userUnit == \"number\" ? Math.abs(e2.userUnit) : 1, e2.precision !== void 0 && (r2 = e2.precision), e2.floatPrecision !== void 0 && (p5 = e2.floatPrecision), g2 = e2.defaultPathOperation || \"S\"), u2 = e2.filters || (c2 === true ? [\"FlateEncode\"] : u2), o2 = o2 || \"mm\", i2 = (\"\" + (i2 || \"P\")).toLowerCase();\n  var v2 = e2.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };\n  y2.__private__.PubSub = C;\n  var w2 = \"1.3\", N2 = y2.__private__.getPdfVersion = function() {\n    return w2;\n  };\n  y2.__private__.setPdfVersion = function(t3) {\n    w2 = t3;\n  };\n  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], \"government-letter\": [576, 756], legal: [612, 1008], \"junior-legal\": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], \"credit-card\": [153, 243] };\n  y2.__private__.getPageFormats = function() {\n    return L2;\n  };\n  var A2 = y2.__private__.getPageFormat = function(t3) {\n    return L2[t3];\n  };\n  s2 = s2 || \"a4\";\n  var x2 = { COMPAT: \"compat\", ADVANCED: \"advanced\" }, S2 = x2.COMPAT;\n  function _2() {\n    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + \" cm\"), this.setFontSize(this.getFontSize() / _t2), g2 = \"n\", S2 = x2.ADVANCED;\n  }\n  function P2() {\n    this.restoreGraphicsState(), g2 = \"S\", S2 = x2.COMPAT;\n  }\n  var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t3, e3) {\n    if (t3 == \"bold\" && e3 == \"normal\" || t3 == \"bold\" && e3 == 400 || t3 == \"normal\" && e3 == \"italic\" || t3 == \"bold\" && e3 == \"italic\")\n      throw new Error(\"Invalid Combination of fontweight and fontstyle\");\n    return e3 && (t3 = e3 == 400 || e3 === \"normal\" ? t3 === \"italic\" ? \"italic\" : \"normal\" : e3 != 700 && e3 !== \"bold\" || t3 !== \"normal\" ? (e3 == 700 ? \"bold\" : e3) + \"\" + t3 : \"bold\"), t3;\n  };\n  y2.advancedAPI = function(t3) {\n    var e3 = S2 === x2.COMPAT;\n    return e3 && _2.call(this), typeof t3 != \"function\" || (t3(this), e3 && P2.call(this)), this;\n  }, y2.compatAPI = function(t3) {\n    var e3 = S2 === x2.ADVANCED;\n    return e3 && P2.call(this), typeof t3 != \"function\" || (t3(this), e3 && _2.call(this)), this;\n  }, y2.isAdvancedAPI = function() {\n    return S2 === x2.ADVANCED;\n  };\n  var O2, q2 = function(t3) {\n    if (S2 !== x2.ADVANCED)\n      throw new Error(t3 + \" is only available in 'advanced' API mode. You need to call advancedAPI() first.\");\n  }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t3, e3) {\n    var n2 = r2 || e3;\n    if (isNaN(t3) || isNaN(n2))\n      throw new Error(\"Invalid argument passed to jsPDF.roundToPrecision\");\n    return t3.toFixed(n2).replace(/0+$/, \"\");\n  };\n  O2 = y2.hpf = y2.__private__.hpf = typeof p5 == \"number\" ? function(t3) {\n    if (isNaN(t3))\n      throw new Error(\"Invalid argument passed to jsPDF.hpf\");\n    return D2(t3, p5);\n  } : p5 === \"smart\" ? function(t3) {\n    if (isNaN(t3))\n      throw new Error(\"Invalid argument passed to jsPDF.hpf\");\n    return D2(t3, t3 > -1 && t3 < 1 ? 16 : 5);\n  } : function(t3) {\n    if (isNaN(t3))\n      throw new Error(\"Invalid argument passed to jsPDF.hpf\");\n    return D2(t3, 16);\n  };\n  var R2 = y2.f2 = y2.__private__.f2 = function(t3) {\n    if (isNaN(t3))\n      throw new Error(\"Invalid argument passed to jsPDF.f2\");\n    return D2(t3, 2);\n  }, T2 = y2.__private__.f3 = function(t3) {\n    if (isNaN(t3))\n      throw new Error(\"Invalid argument passed to jsPDF.f3\");\n    return D2(t3, 3);\n  }, z2 = y2.scale = y2.__private__.scale = function(t3) {\n    if (isNaN(t3))\n      throw new Error(\"Invalid argument passed to jsPDF.scale\");\n    return S2 === x2.COMPAT ? t3 * _t2 : S2 === x2.ADVANCED ? t3 : void 0;\n  }, U2 = function(t3) {\n    return S2 === x2.COMPAT ? Rr() - t3 : S2 === x2.ADVANCED ? t3 : void 0;\n  }, H4 = function(t3) {\n    return z2(U2(t3));\n  };\n  y2.__private__.setPrecision = y2.setPrecision = function(t3) {\n    typeof parseInt(t3, 10) == \"number\" && (r2 = parseInt(t3, 10));\n  };\n  var W2, V2 = \"00000000000000000000000000000000\", G2 = y2.__private__.getFileId = function() {\n    return V2;\n  }, Y2 = y2.__private__.setFileId = function(t3) {\n    return V2 = t3 !== void 0 && /^[a-fA-F0-9]{32}$/.test(t3) ? t3.toUpperCase() : V2.split(\"\").map(function() {\n      return \"ABCDEF0123456789\".charAt(Math.floor(16 * Math.random()));\n    }).join(\"\"), m2 !== null && (Ye = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;\n  };\n  y2.setFileId = function(t3) {\n    return Y2(t3), this;\n  }, y2.getFileId = function() {\n    return G2();\n  };\n  var J2 = y2.__private__.convertDateToPDFDate = function(t3) {\n    var e3 = t3.getTimezoneOffset(), r3 = e3 < 0 ? \"+\" : \"-\", n2 = Math.floor(Math.abs(e3 / 60)), i3 = Math.abs(e3 % 60), a2 = [r3, Q2(n2), \"'\", Q2(i3), \"'\"].join(\"\");\n    return [\"D:\", t3.getFullYear(), Q2(t3.getMonth() + 1), Q2(t3.getDate()), Q2(t3.getHours()), Q2(t3.getMinutes()), Q2(t3.getSeconds()), a2].join(\"\");\n  }, X2 = y2.__private__.convertPDFDateToDate = function(t3) {\n    var e3 = parseInt(t3.substr(2, 4), 10), r3 = parseInt(t3.substr(6, 2), 10) - 1, n2 = parseInt(t3.substr(8, 2), 10), i3 = parseInt(t3.substr(10, 2), 10), a2 = parseInt(t3.substr(12, 2), 10), o3 = parseInt(t3.substr(14, 2), 10);\n    return new Date(e3, r3, n2, i3, a2, o3, 0);\n  }, K2 = y2.__private__.setCreationDate = function(t3) {\n    var e3;\n    if (t3 === void 0 && (t3 = new Date()), t3 instanceof Date)\n      e3 = J2(t3);\n    else {\n      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\\+0[0-9]|\\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t3))\n        throw new Error(\"Invalid argument passed to jsPDF.setCreationDate\");\n      e3 = t3;\n    }\n    return W2 = e3;\n  }, Z2 = y2.__private__.getCreationDate = function(t3) {\n    var e3 = W2;\n    return t3 === \"jsDate\" && (e3 = X2(W2)), e3;\n  };\n  y2.setCreationDate = function(t3) {\n    return K2(t3), this;\n  }, y2.getCreationDate = function(t3) {\n    return Z2(t3);\n  };\n  var $2, Q2 = y2.__private__.padd2 = function(t3) {\n    return (\"0\" + parseInt(t3)).slice(-2);\n  }, tt2 = y2.__private__.padd2Hex = function(t3) {\n    return (\"00\" + (t3 = t3.toString())).substr(t3.length);\n  }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {\n    et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();\n  };\n  y2.__private__.setCustomOutputDestination = function(t3) {\n    st2 = true, ct2 = t3;\n  };\n  var ht2 = function(t3) {\n    st2 || (ct2 = t3);\n  };\n  y2.__private__.resetCustomOutputDestination = function() {\n    st2 = false, ct2 = nt2;\n  };\n  var lt2 = y2.__private__.out = function(t3) {\n    return t3 = t3.toString(), it2 += t3.length + 1, ct2.push(t3), ct2;\n  }, ft2 = y2.__private__.write = function(t3) {\n    return lt2(arguments.length === 1 ? t3.toString() : Array.prototype.join.call(arguments, \" \"));\n  }, dt2 = y2.__private__.getArrayBuffer = function(t3) {\n    for (var e3 = t3.length, r3 = new ArrayBuffer(e3), n2 = new Uint8Array(r3); e3--; )\n      n2[e3] = t3.charCodeAt(e3);\n    return r3;\n  }, pt2 = [[\"Helvetica\", \"helvetica\", \"normal\", \"WinAnsiEncoding\"], [\"Helvetica-Bold\", \"helvetica\", \"bold\", \"WinAnsiEncoding\"], [\"Helvetica-Oblique\", \"helvetica\", \"italic\", \"WinAnsiEncoding\"], [\"Helvetica-BoldOblique\", \"helvetica\", \"bolditalic\", \"WinAnsiEncoding\"], [\"Courier\", \"courier\", \"normal\", \"WinAnsiEncoding\"], [\"Courier-Bold\", \"courier\", \"bold\", \"WinAnsiEncoding\"], [\"Courier-Oblique\", \"courier\", \"italic\", \"WinAnsiEncoding\"], [\"Courier-BoldOblique\", \"courier\", \"bolditalic\", \"WinAnsiEncoding\"], [\"Times-Roman\", \"times\", \"normal\", \"WinAnsiEncoding\"], [\"Times-Bold\", \"times\", \"bold\", \"WinAnsiEncoding\"], [\"Times-Italic\", \"times\", \"italic\", \"WinAnsiEncoding\"], [\"Times-BoldItalic\", \"times\", \"bolditalic\", \"WinAnsiEncoding\"], [\"ZapfDingbats\", \"zapfdingbats\", \"normal\", null], [\"Symbol\", \"symbol\", \"normal\", null]];\n  y2.__private__.getStandardFonts = function() {\n    return pt2;\n  };\n  var gt2 = e2.fontSize || 16;\n  y2.__private__.setFontSize = y2.setFontSize = function(t3) {\n    return gt2 = S2 === x2.ADVANCED ? t3 / _t2 : t3, this;\n  };\n  var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {\n    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;\n  }, bt2 = e2.R2L || false;\n  y2.__private__.setR2L = y2.setR2L = function(t3) {\n    return bt2 = t3, this;\n  }, y2.__private__.getR2L = y2.getR2L = function() {\n    return bt2;\n  };\n  var yt2, wt2 = y2.__private__.setZoomMode = function(t3) {\n    var e3 = [void 0, null, \"fullwidth\", \"fullheight\", \"fullpage\", \"original\"];\n    if (/^\\d*\\.?\\d*%$/.test(t3))\n      mt2 = t3;\n    else if (isNaN(t3)) {\n      if (e3.indexOf(t3) === -1)\n        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. \"' + t3 + '\" is not recognized.');\n      mt2 = t3;\n    } else\n      mt2 = parseInt(t3, 10);\n  };\n  y2.__private__.getZoomMode = function() {\n    return mt2;\n  };\n  var Nt2, Lt2 = y2.__private__.setPageMode = function(t3) {\n    if ([void 0, null, \"UseNone\", \"UseOutlines\", \"UseThumbs\", \"FullScreen\"].indexOf(t3) == -1)\n      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. \"' + t3 + '\" is not recognized.');\n    yt2 = t3;\n  };\n  y2.__private__.getPageMode = function() {\n    return yt2;\n  };\n  var At2 = y2.__private__.setLayoutMode = function(t3) {\n    if ([void 0, null, \"continuous\", \"single\", \"twoleft\", \"tworight\", \"two\"].indexOf(t3) == -1)\n      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. \"' + t3 + '\" is not recognized.');\n    Nt2 = t3;\n  };\n  y2.__private__.getLayoutMode = function() {\n    return Nt2;\n  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t3, e3, r3) {\n    return wt2(t3), At2(e3), Lt2(r3), this;\n  };\n  var xt2 = { title: \"\", subject: \"\", author: \"\", keywords: \"\", creator: \"\" };\n  y2.__private__.getDocumentProperty = function(t3) {\n    if (Object.keys(xt2).indexOf(t3) === -1)\n      throw new Error(\"Invalid argument passed to jsPDF.getDocumentProperty\");\n    return xt2[t3];\n  }, y2.__private__.getDocumentProperties = function() {\n    return xt2;\n  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t3) {\n    for (var e3 in xt2)\n      xt2.hasOwnProperty(e3) && t3[e3] && (xt2[e3] = t3[e3]);\n    return this;\n  }, y2.__private__.setDocumentProperty = function(t3, e3) {\n    if (Object.keys(xt2).indexOf(t3) === -1)\n      throw new Error(\"Invalid arguments passed to jsPDF.setDocumentProperty\");\n    return xt2[t3] = e3;\n  };\n  var St, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), zt2 = e2.hotfixes || [], Ut2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t3(e3, r3, n2, i3, a2, o3) {\n    if (!(this instanceof t3))\n      return new t3(e3, r3, n2, i3, a2, o3);\n    isNaN(e3) && (e3 = 1), isNaN(r3) && (r3 = 0), isNaN(n2) && (n2 = 0), isNaN(i3) && (i3 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e3, r3, n2, i3, a2, o3];\n  };\n  Object.defineProperty(Vt2.prototype, \"sx\", { get: function() {\n    return this._matrix[0];\n  }, set: function(t3) {\n    this._matrix[0] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"shy\", { get: function() {\n    return this._matrix[1];\n  }, set: function(t3) {\n    this._matrix[1] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"shx\", { get: function() {\n    return this._matrix[2];\n  }, set: function(t3) {\n    this._matrix[2] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"sy\", { get: function() {\n    return this._matrix[3];\n  }, set: function(t3) {\n    this._matrix[3] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"tx\", { get: function() {\n    return this._matrix[4];\n  }, set: function(t3) {\n    this._matrix[4] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"ty\", { get: function() {\n    return this._matrix[5];\n  }, set: function(t3) {\n    this._matrix[5] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"a\", { get: function() {\n    return this._matrix[0];\n  }, set: function(t3) {\n    this._matrix[0] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"b\", { get: function() {\n    return this._matrix[1];\n  }, set: function(t3) {\n    this._matrix[1] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"c\", { get: function() {\n    return this._matrix[2];\n  }, set: function(t3) {\n    this._matrix[2] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"d\", { get: function() {\n    return this._matrix[3];\n  }, set: function(t3) {\n    this._matrix[3] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"e\", { get: function() {\n    return this._matrix[4];\n  }, set: function(t3) {\n    this._matrix[4] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"f\", { get: function() {\n    return this._matrix[5];\n  }, set: function(t3) {\n    this._matrix[5] = t3;\n  } }), Object.defineProperty(Vt2.prototype, \"rotation\", { get: function() {\n    return Math.atan2(this.shx, this.sx);\n  } }), Object.defineProperty(Vt2.prototype, \"scaleX\", { get: function() {\n    return this.decompose().scale.sx;\n  } }), Object.defineProperty(Vt2.prototype, \"scaleY\", { get: function() {\n    return this.decompose().scale.sy;\n  } }), Object.defineProperty(Vt2.prototype, \"isIdentity\", { get: function() {\n    return this.sx === 1 && (this.shy === 0 && (this.shx === 0 && (this.sy === 1 && (this.tx === 0 && this.ty === 0))));\n  } }), Vt2.prototype.join = function(t3) {\n    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t3);\n  }, Vt2.prototype.multiply = function(t3) {\n    var e3 = t3.sx * this.sx + t3.shy * this.shx, r3 = t3.sx * this.shy + t3.shy * this.sy, n2 = t3.shx * this.sx + t3.sy * this.shx, i3 = t3.shx * this.shy + t3.sy * this.sy, a2 = t3.tx * this.sx + t3.ty * this.shx + this.tx, o3 = t3.tx * this.shy + t3.ty * this.sy + this.ty;\n    return new Vt2(e3, r3, n2, i3, a2, o3);\n  }, Vt2.prototype.decompose = function() {\n    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = Math.sqrt(t3 * t3 + e3 * e3), s3 = (t3 /= o3) * r3 + (e3 /= o3) * n2;\n    r3 -= t3 * s3, n2 -= e3 * s3;\n    var c3 = Math.sqrt(r3 * r3 + n2 * n2);\n    return s3 /= c3, t3 * (n2 /= c3) < e3 * (r3 /= c3) && (t3 = -t3, e3 = -e3, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i3, a2), rotate: new Vt2(t3, e3, -e3, t3, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };\n  }, Vt2.prototype.toString = function(t3) {\n    return this.join(\" \");\n  }, Vt2.prototype.inversed = function() {\n    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = 1 / (t3 * n2 - e3 * r3), s3 = n2 * o3, c3 = -e3 * o3, u3 = -r3 * o3, h2 = t3 * o3;\n    return new Vt2(s3, c3, u3, h2, -s3 * i3 - u3 * a2, -c3 * i3 - h2 * a2);\n  }, Vt2.prototype.applyToPoint = function(t3) {\n    var e3 = t3.x * this.sx + t3.y * this.shx + this.tx, r3 = t3.x * this.shy + t3.y * this.sy + this.ty;\n    return new Cr(e3, r3);\n  }, Vt2.prototype.applyToRectangle = function(t3) {\n    var e3 = this.applyToPoint(t3), r3 = this.applyToPoint(new Cr(t3.x + t3.w, t3.y + t3.h));\n    return new jr(e3.x, e3.y, r3.x - e3.x, r3.y - e3.y);\n  }, Vt2.prototype.clone = function() {\n    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty;\n    return new Vt2(t3, e3, r3, n2, i3, a2);\n  }, y2.Matrix = Vt2;\n  var Gt2 = y2.matrixMult = function(t3, e3) {\n    return e3.multiply(t3);\n  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);\n  y2.unitMatrix = y2.identityMatrix = Yt2;\n  var Jt2 = function(t3, e3) {\n    if (!Bt2[t3]) {\n      var r3 = (e3 instanceof B ? \"Sh\" : \"P\") + (Object.keys(Ot2).length + 1).toString(10);\n      e3.id = r3, Bt2[t3] = r3, Ot2[r3] = e3, Tt2.publish(\"addPattern\", e3);\n    }\n  };\n  y2.ShadingPattern = B, y2.TilingPattern = M$1, y2.addShadingPattern = function(t3, e3) {\n    return q2(\"addShadingPattern()\"), Jt2(t3, e3), this;\n  }, y2.beginTilingPattern = function(t3) {\n    q2(\"beginTilingPattern()\"), Br(t3.boundingBox[0], t3.boundingBox[1], t3.boundingBox[2] - t3.boundingBox[0], t3.boundingBox[3] - t3.boundingBox[1], t3.matrix);\n  }, y2.endTilingPattern = function(t3, e3) {\n    q2(\"endTilingPattern()\"), e3.stream = ot2[$2].join(\"\\n\"), Jt2(t3, e3), Tt2.publish(\"endTilingPattern\", e3), Wt2.pop().restore();\n  };\n  var Xt2 = y2.__private__.newObject = function() {\n    var t3 = Kt2();\n    return Zt2(t3, true), t3;\n  }, Kt2 = y2.__private__.newObjectDeferred = function() {\n    return et2++, rt2[et2] = function() {\n      return it2;\n    }, et2;\n  }, Zt2 = function(t3, e3) {\n    return e3 = typeof e3 == \"boolean\" && e3, rt2[t3] = it2, e3 && lt2(t3 + \" 0 obj\"), t3;\n  }, $t2 = y2.__private__.newAdditionalObject = function() {\n    var t3 = { objId: Kt2(), content: \"\" };\n    return at2.push(t3), t3;\n  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t3) {\n    var e3 = t3.split(\" \");\n    if (e3.length !== 2 || e3[1] !== \"g\" && e3[1] !== \"G\") {\n      if (e3.length === 5 && (e3[4] === \"k\" || e3[4] === \"K\")) {\n        e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), \"r\"];\n      }\n    } else {\n      var r3 = parseFloat(e3[0]);\n      e3 = [r3, r3, r3, \"r\"];\n    }\n    for (var n2 = \"#\", i3 = 0; i3 < 3; i3++)\n      n2 += (\"0\" + Math.floor(255 * parseFloat(e3[i3])).toString(16)).slice(-2);\n    return n2;\n  }, re2 = y2.__private__.encodeColorString = function(e3) {\n    var r3;\n    typeof e3 == \"string\" && (e3 = { ch1: e3 });\n    var n2 = e3.ch1, i3 = e3.ch2, a2 = e3.ch3, o3 = e3.ch4, s3 = e3.pdfColorType === \"draw\" ? [\"G\", \"RG\", \"K\"] : [\"g\", \"rg\", \"k\"];\n    if (typeof n2 == \"string\" && n2.charAt(0) !== \"#\") {\n      var c3 = new f$2(n2);\n      if (c3.ok)\n        n2 = c3.toHex();\n      else if (!/^\\d*\\.?\\d*$/.test(n2))\n        throw new Error('Invalid color \"' + n2 + '\" passed to jsPDF.encodeColorString.');\n    }\n    if (typeof n2 == \"string\" && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = \"#\" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), typeof n2 == \"string\" && /^#[0-9A-Fa-f]{6}$/.test(n2)) {\n      var u3 = parseInt(n2.substr(1), 16);\n      n2 = u3 >> 16 & 255, i3 = u3 >> 8 & 255, a2 = 255 & u3;\n    }\n    if (i3 === void 0 || o3 === void 0 && n2 === i3 && i3 === a2)\n      if (typeof n2 == \"string\")\n        r3 = n2 + \" \" + s3[0];\n      else\n        switch (e3.precision) {\n          case 2:\n            r3 = R2(n2 / 255) + \" \" + s3[0];\n            break;\n          case 3:\n          default:\n            r3 = T2(n2 / 255) + \" \" + s3[0];\n        }\n    else if (o3 === void 0 || _typeof$2(o3) === \"object\") {\n      if (o3 && !isNaN(o3.a) && o3.a === 0)\n        return r3 = [\"1.\", \"1.\", \"1.\", s3[1]].join(\" \");\n      if (typeof n2 == \"string\")\n        r3 = [n2, i3, a2, s3[1]].join(\" \");\n      else\n        switch (e3.precision) {\n          case 2:\n            r3 = [R2(n2 / 255), R2(i3 / 255), R2(a2 / 255), s3[1]].join(\" \");\n            break;\n          default:\n          case 3:\n            r3 = [T2(n2 / 255), T2(i3 / 255), T2(a2 / 255), s3[1]].join(\" \");\n        }\n    } else if (typeof n2 == \"string\")\n      r3 = [n2, i3, a2, o3, s3[2]].join(\" \");\n    else\n      switch (e3.precision) {\n        case 2:\n          r3 = [R2(n2), R2(i3), R2(a2), R2(o3), s3[2]].join(\" \");\n          break;\n        case 3:\n        default:\n          r3 = [T2(n2), T2(i3), T2(a2), T2(o3), s3[2]].join(\" \");\n      }\n    return r3;\n  }, ne2 = y2.__private__.getFilters = function() {\n    return u2;\n  }, ie2 = y2.__private__.putStream = function(t3) {\n    var e3 = (t3 = t3 || {}).data || \"\", r3 = t3.filters || ne2(), n2 = t3.alreadyAppliedFilters || [], i3 = t3.addLength1 || false, a2 = e3.length, o3 = t3.objectId, s3 = function(t4) {\n      return t4;\n    };\n    if (m2 !== null && o3 === void 0)\n      throw new Error(\"ObjectId must be passed to putStream for file encryption\");\n    m2 !== null && (s3 = Ye.encryptor(o3, 0));\n    var c3 = {};\n    r3 === true && (r3 = [\"FlateEncode\"]);\n    var u3 = t3.additionalKeyValues || [], h2 = (c3 = E$1.API.processDataByFilters !== void 0 ? E$1.API.processDataByFilters(e3, r3) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(\" \") : n2.toString());\n    if (c3.data.length !== 0 && (u3.push({ key: \"Length\", value: c3.data.length }), i3 === true && u3.push({ key: \"Length1\", value: a2 })), h2.length != 0)\n      if (h2.split(\"/\").length - 1 == 1)\n        u3.push({ key: \"Filter\", value: h2 });\n      else {\n        u3.push({ key: \"Filter\", value: \"[\" + h2 + \"]\" });\n        for (var l2 = 0; l2 < u3.length; l2 += 1)\n          if (u3[l2].key === \"DecodeParms\") {\n            for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split(\"/\").length - 1; d3 += 1)\n              f2.push(\"null\");\n            f2.push(u3[l2].value), u3[l2].value = \"[\" + f2.join(\" \") + \"]\";\n          }\n      }\n    lt2(\"<<\");\n    for (var p6 = 0; p6 < u3.length; p6++)\n      lt2(\"/\" + u3[p6].key + \" \" + u3[p6].value);\n    lt2(\">>\"), c3.data.length !== 0 && (lt2(\"stream\"), lt2(s3(c3.data)), lt2(\"endstream\"));\n  }, ae2 = y2.__private__.putPage = function(t3) {\n    var e3 = t3.number, r3 = t3.data, n2 = t3.objId, i3 = t3.contentsObjId;\n    Zt2(n2, true), lt2(\"<</Type /Page\"), lt2(\"/Parent \" + t3.rootDictionaryObjId + \" 0 R\"), lt2(\"/Resources \" + t3.resourceDictionaryObjId + \" 0 R\"), lt2(\"/MediaBox [\" + parseFloat(O2(t3.mediaBox.bottomLeftX)) + \" \" + parseFloat(O2(t3.mediaBox.bottomLeftY)) + \" \" + O2(t3.mediaBox.topRightX) + \" \" + O2(t3.mediaBox.topRightY) + \"]\"), t3.cropBox !== null && lt2(\"/CropBox [\" + O2(t3.cropBox.bottomLeftX) + \" \" + O2(t3.cropBox.bottomLeftY) + \" \" + O2(t3.cropBox.topRightX) + \" \" + O2(t3.cropBox.topRightY) + \"]\"), t3.bleedBox !== null && lt2(\"/BleedBox [\" + O2(t3.bleedBox.bottomLeftX) + \" \" + O2(t3.bleedBox.bottomLeftY) + \" \" + O2(t3.bleedBox.topRightX) + \" \" + O2(t3.bleedBox.topRightY) + \"]\"), t3.trimBox !== null && lt2(\"/TrimBox [\" + O2(t3.trimBox.bottomLeftX) + \" \" + O2(t3.trimBox.bottomLeftY) + \" \" + O2(t3.trimBox.topRightX) + \" \" + O2(t3.trimBox.topRightY) + \"]\"), t3.artBox !== null && lt2(\"/ArtBox [\" + O2(t3.artBox.bottomLeftX) + \" \" + O2(t3.artBox.bottomLeftY) + \" \" + O2(t3.artBox.topRightX) + \" \" + O2(t3.artBox.topRightY) + \"]\"), typeof t3.userUnit == \"number\" && t3.userUnit !== 1 && lt2(\"/UserUnit \" + t3.userUnit), Tt2.publish(\"putPage\", { objId: n2, pageContext: Rt2[e3], pageNumber: e3, page: r3 }), lt2(\"/Contents \" + i3 + \" 0 R\"), lt2(\">>\"), lt2(\"endobj\");\n    var a2 = r3.join(\"\\n\");\n    return S2 === x2.ADVANCED && (a2 += \"\\nQ\"), Zt2(i3, true), ie2({ data: a2, filters: ne2(), objectId: i3 }), lt2(\"endobj\"), n2;\n  }, oe2 = y2.__private__.putPages = function() {\n    var t3, e3, r3 = [];\n    for (t3 = 1; t3 <= Dt2; t3++)\n      Rt2[t3].objId = Kt2(), Rt2[t3].contentsObjId = Kt2();\n    for (t3 = 1; t3 <= Dt2; t3++)\n      r3.push(ae2({ number: t3, data: ot2[t3], objId: Rt2[t3].objId, contentsObjId: Rt2[t3].contentsObjId, mediaBox: Rt2[t3].mediaBox, cropBox: Rt2[t3].cropBox, bleedBox: Rt2[t3].bleedBox, trimBox: Rt2[t3].trimBox, artBox: Rt2[t3].artBox, userUnit: Rt2[t3].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));\n    Zt2(Qt2, true), lt2(\"<</Type /Pages\");\n    var n2 = \"/Kids [\";\n    for (e3 = 0; e3 < Dt2; e3++)\n      n2 += r3[e3] + \" 0 R \";\n    lt2(n2 + \"]\"), lt2(\"/Count \" + Dt2), lt2(\">>\"), lt2(\"endobj\"), Tt2.publish(\"postPutPages\");\n  }, se2 = function(t3) {\n    Tt2.publish(\"putFont\", { font: t3, out: lt2, newObject: Xt2, putStream: ie2 }), t3.isAlreadyPutted !== true && (t3.objectNumber = Xt2(), lt2(\"<<\"), lt2(\"/Type /Font\"), lt2(\"/BaseFont /\" + F$1(t3.postScriptName)), lt2(\"/Subtype /Type1\"), typeof t3.encoding == \"string\" && lt2(\"/Encoding /\" + t3.encoding), lt2(\"/FirstChar 32\"), lt2(\"/LastChar 255\"), lt2(\">>\"), lt2(\"endobj\"));\n  }, ce2 = function() {\n    for (var t3 in Ft2)\n      Ft2.hasOwnProperty(t3) && (v2 === false || v2 === true && b2.hasOwnProperty(t3)) && se2(Ft2[t3]);\n  }, ue2 = function(t3) {\n    t3.objectNumber = Xt2();\n    var e3 = [];\n    e3.push({ key: \"Type\", value: \"/XObject\" }), e3.push({ key: \"Subtype\", value: \"/Form\" }), e3.push({ key: \"BBox\", value: \"[\" + [O2(t3.x), O2(t3.y), O2(t3.x + t3.width), O2(t3.y + t3.height)].join(\" \") + \"]\" }), e3.push({ key: \"Matrix\", value: \"[\" + t3.matrix.toString() + \"]\" });\n    var r3 = t3.pages[1].join(\"\\n\");\n    ie2({ data: r3, additionalKeyValues: e3, objectId: t3.objectNumber }), lt2(\"endobj\");\n  }, he2 = function() {\n    for (var t3 in Ut2)\n      Ut2.hasOwnProperty(t3) && ue2(Ut2[t3]);\n  }, le2 = function(t3, e3) {\n    var r3, n2 = [], i3 = 1 / (e3 - 1);\n    for (r3 = 0; r3 < 1; r3 += i3)\n      n2.push(r3);\n    if (n2.push(1), t3[0].offset != 0) {\n      var a2 = { offset: 0, color: t3[0].color };\n      t3.unshift(a2);\n    }\n    if (t3[t3.length - 1].offset != 1) {\n      var o3 = { offset: 1, color: t3[t3.length - 1].color };\n      t3.push(o3);\n    }\n    for (var s3 = \"\", c3 = 0, u3 = 0; u3 < n2.length; u3++) {\n      for (r3 = n2[u3]; r3 > t3[c3 + 1].offset; )\n        c3++;\n      var h2 = t3[c3].offset, l2 = (r3 - h2) / (t3[c3 + 1].offset - h2), f2 = t3[c3].color, d3 = t3[c3 + 1].color;\n      s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));\n    }\n    return s3.trim();\n  }, fe2 = function(t3, e3) {\n    e3 || (e3 = 21);\n    var r3 = Xt2(), n2 = le2(t3.colors, e3), i3 = [];\n    i3.push({ key: \"FunctionType\", value: \"0\" }), i3.push({ key: \"Domain\", value: \"[0.0 1.0]\" }), i3.push({ key: \"Size\", value: \"[\" + e3 + \"]\" }), i3.push({ key: \"BitsPerSample\", value: \"8\" }), i3.push({ key: \"Range\", value: \"[0.0 1.0 0.0 1.0 0.0 1.0]\" }), i3.push({ key: \"Decode\", value: \"[0.0 1.0 0.0 1.0 0.0 1.0]\" }), ie2({ data: n2, additionalKeyValues: i3, alreadyAppliedFilters: [\"/ASCIIHexDecode\"], objectId: r3 }), lt2(\"endobj\"), t3.objectNumber = Xt2(), lt2(\"<< /ShadingType \" + t3.type), lt2(\"/ColorSpace /DeviceRGB\");\n    var a2 = \"/Coords [\" + O2(parseFloat(t3.coords[0])) + \" \" + O2(parseFloat(t3.coords[1])) + \" \";\n    t3.type === 2 ? a2 += O2(parseFloat(t3.coords[2])) + \" \" + O2(parseFloat(t3.coords[3])) : a2 += O2(parseFloat(t3.coords[2])) + \" \" + O2(parseFloat(t3.coords[3])) + \" \" + O2(parseFloat(t3.coords[4])) + \" \" + O2(parseFloat(t3.coords[5])), lt2(a2 += \"]\"), t3.matrix && lt2(\"/Matrix [\" + t3.matrix.toString() + \"]\"), lt2(\"/Function \" + r3 + \" 0 R\"), lt2(\"/Extend [true true]\"), lt2(\">>\"), lt2(\"endobj\");\n  }, de2 = function(t3, e3) {\n    var r3 = Kt2(), n2 = Xt2();\n    e3.push({ resourcesOid: r3, objectOid: n2 }), t3.objectNumber = n2;\n    var i3 = [];\n    i3.push({ key: \"Type\", value: \"/Pattern\" }), i3.push({ key: \"PatternType\", value: \"1\" }), i3.push({ key: \"PaintType\", value: \"1\" }), i3.push({ key: \"TilingType\", value: \"1\" }), i3.push({ key: \"BBox\", value: \"[\" + t3.boundingBox.map(O2).join(\" \") + \"]\" }), i3.push({ key: \"XStep\", value: O2(t3.xStep) }), i3.push({ key: \"YStep\", value: O2(t3.yStep) }), i3.push({ key: \"Resources\", value: r3 + \" 0 R\" }), t3.matrix && i3.push({ key: \"Matrix\", value: \"[\" + t3.matrix.toString() + \"]\" }), ie2({ data: t3.stream, additionalKeyValues: i3, objectId: t3.objectNumber }), lt2(\"endobj\");\n  }, pe2 = function(t3) {\n    var e3;\n    for (e3 in Ot2)\n      Ot2.hasOwnProperty(e3) && (Ot2[e3] instanceof B ? fe2(Ot2[e3]) : Ot2[e3] instanceof M$1 && de2(Ot2[e3], t3));\n  }, ge2 = function(t3) {\n    for (var e3 in t3.objectNumber = Xt2(), lt2(\"<<\"), t3)\n      switch (e3) {\n        case \"opacity\":\n          lt2(\"/ca \" + R2(t3[e3]));\n          break;\n        case \"stroke-opacity\":\n          lt2(\"/CA \" + R2(t3[e3]));\n      }\n    lt2(\">>\"), lt2(\"endobj\");\n  }, me2 = function() {\n    var t3;\n    for (t3 in Mt2)\n      Mt2.hasOwnProperty(t3) && ge2(Mt2[t3]);\n  }, ve2 = function() {\n    for (var t3 in lt2(\"/XObject <<\"), Ut2)\n      Ut2.hasOwnProperty(t3) && Ut2[t3].objectNumber >= 0 && lt2(\"/\" + t3 + \" \" + Ut2[t3].objectNumber + \" 0 R\");\n    Tt2.publish(\"putXobjectDict\"), lt2(\">>\");\n  }, be2 = function() {\n    Ye.oid = Xt2(), lt2(\"<<\"), lt2(\"/Filter /Standard\"), lt2(\"/V \" + Ye.v), lt2(\"/R \" + Ye.r), lt2(\"/U <\" + Ye.toHexString(Ye.U) + \">\"), lt2(\"/O <\" + Ye.toHexString(Ye.O) + \">\"), lt2(\"/P \" + Ye.P), lt2(\">>\"), lt2(\"endobj\");\n  }, ye2 = function() {\n    for (var t3 in lt2(\"/Font <<\"), Ft2)\n      Ft2.hasOwnProperty(t3) && (v2 === false || v2 === true && b2.hasOwnProperty(t3)) && lt2(\"/\" + t3 + \" \" + Ft2[t3].objectNumber + \" 0 R\");\n    lt2(\">>\");\n  }, we2 = function() {\n    if (Object.keys(Ot2).length > 0) {\n      for (var t3 in lt2(\"/Shading <<\"), Ot2)\n        Ot2.hasOwnProperty(t3) && Ot2[t3] instanceof B && Ot2[t3].objectNumber >= 0 && lt2(\"/\" + t3 + \" \" + Ot2[t3].objectNumber + \" 0 R\");\n      Tt2.publish(\"putShadingPatternDict\"), lt2(\">>\");\n    }\n  }, Ne2 = function(t3) {\n    if (Object.keys(Ot2).length > 0) {\n      for (var e3 in lt2(\"/Pattern <<\"), Ot2)\n        Ot2.hasOwnProperty(e3) && Ot2[e3] instanceof y2.TilingPattern && Ot2[e3].objectNumber >= 0 && Ot2[e3].objectNumber < t3 && lt2(\"/\" + e3 + \" \" + Ot2[e3].objectNumber + \" 0 R\");\n      Tt2.publish(\"putTilingPatternDict\"), lt2(\">>\");\n    }\n  }, Le2 = function() {\n    if (Object.keys(Mt2).length > 0) {\n      var t3;\n      for (t3 in lt2(\"/ExtGState <<\"), Mt2)\n        Mt2.hasOwnProperty(t3) && Mt2[t3].objectNumber >= 0 && lt2(\"/\" + t3 + \" \" + Mt2[t3].objectNumber + \" 0 R\");\n      Tt2.publish(\"putGStateDict\"), lt2(\">>\");\n    }\n  }, Ae = function(t3) {\n    Zt2(t3.resourcesOid, true), lt2(\"<<\"), lt2(\"/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]\"), ye2(), we2(), Ne2(t3.objectOid), Le2(), ve2(), lt2(\">>\"), lt2(\"endobj\");\n  }, xe = function() {\n    var t3 = [];\n    ce2(), me2(), he2(), pe2(t3), Tt2.publish(\"putResources\"), t3.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish(\"postPutResources\");\n  }, Se = function() {\n    Tt2.publish(\"putAdditionalObjects\");\n    for (var t3 = 0; t3 < at2.length; t3++) {\n      var e3 = at2[t3];\n      Zt2(e3.objId, true), lt2(e3.content), lt2(\"endobj\");\n    }\n    Tt2.publish(\"postPutAdditionalObjects\");\n  }, _e = function(t3) {\n    Ct2[t3.fontName] = Ct2[t3.fontName] || {}, Ct2[t3.fontName][t3.fontStyle] = t3.id;\n  }, Pe = function(t3, e3, r3, n2, i3) {\n    var a2 = { id: \"F\" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t3, fontName: e3, fontStyle: r3, encoding: n2, isStandardFont: i3 || false, metadata: {} };\n    return Tt2.publish(\"addFont\", { font: a2, instance: this }), Ft2[a2.id] = a2, _e(a2), a2.id;\n  }, ke = function(t3) {\n    for (var e3 = 0, r3 = pt2.length; e3 < r3; e3++) {\n      var n2 = Pe.call(this, t3[e3][0], t3[e3][1], t3[e3][2], pt2[e3][3], true);\n      v2 === false && (b2[n2] = true);\n      var i3 = t3[e3][0].split(\"-\");\n      _e({ id: n2, fontName: i3[0], fontStyle: i3[1] || \"\" });\n    }\n    Tt2.publish(\"addFonts\", { fonts: Ft2, dictionary: Ct2 });\n  }, Ie = function(t3) {\n    return t3.foo = function() {\n      try {\n        return t3.apply(this, arguments);\n      } catch (t4) {\n        var e3 = t4.stack || \"\";\n        ~e3.indexOf(\" at \") && (e3 = e3.split(\" at \")[1]);\n        var r3 = \"Error in function \" + e3.split(\"\\n\")[0].split(\"<\")[0] + \": \" + t4.message;\n        if (!n$1.console)\n          throw new Error(r3);\n        n$1.console.error(r3, t4), n$1.alert && alert(r3);\n      }\n    }, t3.foo.bar = t3, t3.foo;\n  }, Fe = function(t3, e3) {\n    var r3, n2, i3, a2, o3, s3, c3, u3, h2;\n    if (i3 = (e3 = e3 || {}).sourceEncoding || \"Unicode\", o3 = e3.outputEncoding, (e3.autoencode || o3) && Ft2[St].metadata && Ft2[St].metadata[i3] && Ft2[St].metadata[i3].encoding && (a2 = Ft2[St].metadata[i3].encoding, !o3 && Ft2[St].encoding && (o3 = Ft2[St].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), typeof o3 == \"string\" && (o3 = a2[o3]), o3)) {\n      for (c3 = false, s3 = [], r3 = 0, n2 = t3.length; r3 < n2; r3++)\n        (u3 = o3[t3.charCodeAt(r3)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t3[r3]), s3[r3].charCodeAt(0) >> 8 && (c3 = true);\n      t3 = s3.join(\"\");\n    }\n    for (r3 = t3.length; c3 === void 0 && r3 !== 0; )\n      t3.charCodeAt(r3 - 1) >> 8 && (c3 = true), r3--;\n    if (!c3)\n      return t3;\n    for (s3 = e3.noBOM ? [] : [254, 255], r3 = 0, n2 = t3.length; r3 < n2; r3++) {\n      if ((h2 = (u3 = t3.charCodeAt(r3)) >> 8) >> 8)\n        throw new Error(\"Character at position \" + r3 + \" of string '\" + t3 + \"' exceeds 16bits. Cannot be encoded into UCS-2 BE\");\n      s3.push(h2), s3.push(u3 - (h2 << 8));\n    }\n    return String.fromCharCode.apply(void 0, s3);\n  }, Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t3, e3) {\n    return Fe(t3, e3).replace(/\\\\/g, \"\\\\\\\\\").replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\");\n  }, je = y2.__private__.beginPage = function(t3) {\n    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t3[0]), topRightY: Number(t3[1]) } }, Me(Dt2), ht2(ot2[$2]);\n  }, Oe = function(t3, e3) {\n    var r3, n2, o3;\n    switch (i2 = e3 || i2, typeof t3 == \"string\" && (r3 = A2(t3.toLowerCase()), Array.isArray(r3) && (n2 = r3[0], o3 = r3[1])), Array.isArray(t3) && (n2 = t3[0] * _t2, o3 = t3[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a$2.warn(\"A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400\"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i2.substr(0, 1)) {\n      case \"l\":\n        o3 > n2 && (s2 = [o3, n2]);\n        break;\n      case \"p\":\n        n2 > o3 && (s2 = [o3, n2]);\n    }\n    je(s2), pr(fr), lt2(Lr), kr !== 0 && lt2(kr + \" J\"), Ir !== 0 && lt2(Ir + \" j\"), Tt2.publish(\"addPage\", { pageNumber: Dt2 });\n  }, Be = function(t3) {\n    t3 > 0 && t3 <= Dt2 && (ot2.splice(t3, 1), Rt2.splice(t3, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));\n  }, Me = function(t3) {\n    t3 > 0 && t3 <= Dt2 && ($2 = t3);\n  }, Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {\n    return ot2.length - 1;\n  }, qe = function(t3, e3, r3) {\n    var n2, i3 = void 0;\n    return r3 = r3 || {}, t3 = t3 !== void 0 ? t3 : Ft2[St].fontName, e3 = e3 !== void 0 ? e3 : Ft2[St].fontStyle, n2 = t3.toLowerCase(), Ct2[n2] !== void 0 && Ct2[n2][e3] !== void 0 ? i3 = Ct2[n2][e3] : Ct2[t3] !== void 0 && Ct2[t3][e3] !== void 0 ? i3 = Ct2[t3][e3] : r3.disableWarning === false && a$2.warn(\"Unable to look up font label for font '\" + t3 + \"', '\" + e3 + \"'. Refer to getFontList() for available fonts.\"), i3 || r3.noFallback || (i3 = Ct2.times[e3]) == null && (i3 = Ct2.times.normal), i3;\n  }, De = y2.__private__.putInfo = function() {\n    var t3 = Xt2(), e3 = function(t4) {\n      return t4;\n    };\n    for (var r3 in m2 !== null && (e3 = Ye.encryptor(t3, 0)), lt2(\"<<\"), lt2(\"/Producer (\" + Ce(e3(\"jsPDF \" + E$1.version)) + \")\"), xt2)\n      xt2.hasOwnProperty(r3) && xt2[r3] && lt2(\"/\" + r3.substr(0, 1).toUpperCase() + r3.substr(1) + \" (\" + Ce(e3(xt2[r3])) + \")\");\n    lt2(\"/CreationDate (\" + Ce(e3(W2)) + \")\"), lt2(\">>\"), lt2(\"endobj\");\n  }, Re = y2.__private__.putCatalog = function(t3) {\n    var e3 = (t3 = t3 || {}).rootDictionaryObjId || Qt2;\n    switch (Xt2(), lt2(\"<<\"), lt2(\"/Type /Catalog\"), lt2(\"/Pages \" + e3 + \" 0 R\"), mt2 || (mt2 = \"fullwidth\"), mt2) {\n      case \"fullwidth\":\n        lt2(\"/OpenAction [3 0 R /FitH null]\");\n        break;\n      case \"fullheight\":\n        lt2(\"/OpenAction [3 0 R /FitV null]\");\n        break;\n      case \"fullpage\":\n        lt2(\"/OpenAction [3 0 R /Fit]\");\n        break;\n      case \"original\":\n        lt2(\"/OpenAction [3 0 R /XYZ null null 1]\");\n        break;\n      default:\n        var r3 = \"\" + mt2;\n        r3.substr(r3.length - 1) === \"%\" && (mt2 = parseInt(mt2) / 100), typeof mt2 == \"number\" && lt2(\"/OpenAction [3 0 R /XYZ null null \" + R2(mt2) + \"]\");\n    }\n    switch (Nt2 || (Nt2 = \"continuous\"), Nt2) {\n      case \"continuous\":\n        lt2(\"/PageLayout /OneColumn\");\n        break;\n      case \"single\":\n        lt2(\"/PageLayout /SinglePage\");\n        break;\n      case \"two\":\n      case \"twoleft\":\n        lt2(\"/PageLayout /TwoColumnLeft\");\n        break;\n      case \"tworight\":\n        lt2(\"/PageLayout /TwoColumnRight\");\n    }\n    yt2 && lt2(\"/PageMode /\" + yt2), Tt2.publish(\"putCatalog\"), lt2(\">>\"), lt2(\"endobj\");\n  }, Te = y2.__private__.putTrailer = function() {\n    lt2(\"trailer\"), lt2(\"<<\"), lt2(\"/Size \" + (et2 + 1)), lt2(\"/Root \" + et2 + \" 0 R\"), lt2(\"/Info \" + (et2 - 1) + \" 0 R\"), m2 !== null && lt2(\"/Encrypt \" + Ye.oid + \" 0 R\"), lt2(\"/ID [ <\" + V2 + \"> <\" + V2 + \"> ]\"), lt2(\">>\");\n  }, ze = y2.__private__.putHeader = function() {\n    lt2(\"%PDF-\" + w2), lt2(\"%\\xBA\\xDF\\xAC\\xE0\");\n  }, Ue = y2.__private__.putXRef = function() {\n    var t3 = \"0000000000\";\n    lt2(\"xref\"), lt2(\"0 \" + (et2 + 1)), lt2(\"0000000000 65535 f \");\n    for (var e3 = 1; e3 <= et2; e3++) {\n      typeof rt2[e3] == \"function\" ? lt2((t3 + rt2[e3]()).slice(-10) + \" 00000 n \") : rt2[e3] !== void 0 ? lt2((t3 + rt2[e3]).slice(-10) + \" 00000 n \") : lt2(\"0000000000 00000 n \");\n    }\n  }, He = y2.__private__.buildDocument = function() {\n    ut2(), ht2(nt2), Tt2.publish(\"buildDocument\"), ze(), oe2(), Se(), xe(), m2 !== null && be2(), De(), Re();\n    var t3 = it2;\n    return Ue(), Te(), lt2(\"startxref\"), lt2(\"\" + t3), lt2(\"%%EOF\"), ht2(ot2[$2]), nt2.join(\"\\n\");\n  }, We = y2.__private__.getBlob = function(t3) {\n    return new Blob([dt2(t3)], { type: \"application/pdf\" });\n  }, Ve = y2.output = y2.__private__.output = Ie(function(t3, e3) {\n    switch (typeof (e3 = e3 || {}) == \"string\" ? e3 = { filename: e3 } : e3.filename = e3.filename || \"generated.pdf\", t3) {\n      case void 0:\n        return He();\n      case \"save\":\n        y2.save(e3.filename);\n        break;\n      case \"arraybuffer\":\n        return dt2(He());\n      case \"blob\":\n        return We(He());\n      case \"bloburi\":\n      case \"bloburl\":\n        if (n$1.URL !== void 0 && typeof n$1.URL.createObjectURL == \"function\")\n          return n$1.URL && n$1.URL.createObjectURL(We(He())) || void 0;\n        a$2.warn(\"bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.\");\n        break;\n      case \"datauristring\":\n      case \"dataurlstring\":\n        var r3 = \"\", i3 = He();\n        try {\n          r3 = h$1(i3);\n        } catch (t4) {\n          r3 = h$1(unescape(encodeURIComponent(i3)));\n        }\n        return \"data:application/pdf;filename=\" + e3.filename + \";base64,\" + r3;\n      case \"pdfobjectnewwindow\":\n        if (Object.prototype.toString.call(n$1) === \"[object Window]\") {\n          var o3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src=\"' + (e3.pdfObjectUrl || \"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js\") + '\"><\\/script><script >PDFObject.embed(\"' + this.output(\"dataurlstring\") + '\", ' + JSON.stringify(e3) + \");<\\/script></body></html>\", s3 = n$1.open();\n          return s3 !== null && s3.document.write(o3), s3;\n        }\n        throw new Error(\"The option pdfobjectnewwindow just works in a browser-environment.\");\n      case \"pdfjsnewwindow\":\n        if (Object.prototype.toString.call(n$1) === \"[object Window]\") {\n          var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id=\"pdfViewer\" src=\"' + (e3.pdfJsUrl || \"examples/PDF.js/web/viewer.html\") + \"?file=&downloadName=\" + e3.filename + '\" width=\"500px\" height=\"400px\" /></body></html>', u3 = n$1.open();\n          if (u3 !== null) {\n            u3.document.write(c3);\n            var l2 = this;\n            u3.document.documentElement.querySelector(\"#pdfViewer\").onload = function() {\n              u3.document.title = e3.filename, u3.document.documentElement.querySelector(\"#pdfViewer\").contentWindow.PDFViewerApplication.open(l2.output(\"bloburl\"));\n            };\n          }\n          return u3;\n        }\n        throw new Error(\"The option pdfjsnewwindow just works in a browser-environment.\");\n      case \"dataurlnewwindow\":\n        if (Object.prototype.toString.call(n$1) !== \"[object Window]\")\n          throw new Error(\"The option dataurlnewwindow just works in a browser-environment.\");\n        var f2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src=\"' + this.output(\"datauristring\", e3) + '\"></iframe></body></html>', d3 = n$1.open();\n        if (d3 !== null && (d3.document.write(f2), d3.document.title = e3.filename), d3 || typeof safari == \"undefined\")\n          return d3;\n        break;\n      case \"datauri\":\n      case \"dataurl\":\n        return n$1.document.location.href = this.output(\"datauristring\", e3);\n      default:\n        return null;\n    }\n  }), Ge = function(t3) {\n    return Array.isArray(zt2) === true && zt2.indexOf(t3) > -1;\n  };\n  switch (o2) {\n    case \"pt\":\n      _t2 = 1;\n      break;\n    case \"mm\":\n      _t2 = 72 / 25.4;\n      break;\n    case \"cm\":\n      _t2 = 72 / 2.54;\n      break;\n    case \"in\":\n      _t2 = 72;\n      break;\n    case \"px\":\n      _t2 = Ge(\"px_scaling\") == 1 ? 0.75 : 96 / 72;\n      break;\n    case \"pc\":\n    case \"em\":\n      _t2 = 12;\n      break;\n    case \"ex\":\n      _t2 = 6;\n      break;\n    default:\n      if (typeof o2 != \"number\")\n        throw new Error(\"Invalid unit: \" + o2);\n      _t2 = o2;\n  }\n  var Ye = null;\n  K2(), Y2();\n  var Je = function(t3) {\n    return m2 !== null ? Ye.encryptor(t3, 0) : function(t4) {\n      return t4;\n    };\n  }, Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t3) {\n    if (isNaN(t3) || t3 % 1 != 0)\n      throw new Error(\"Invalid argument passed to jsPDF.getPageInfo\");\n    return { objId: Rt2[t3].objId, pageNumber: t3, pageContext: Rt2[t3] };\n  }, Ke = y2.__private__.getPageInfoByObjId = function(t3) {\n    if (isNaN(t3) || t3 % 1 != 0)\n      throw new Error(\"Invalid argument passed to jsPDF.getPageInfoByObjId\");\n    for (var e3 in Rt2)\n      if (Rt2[e3].objId === t3)\n        break;\n    return Xe(e3);\n  }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {\n    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };\n  };\n  y2.addPage = function() {\n    return Oe.apply(this, arguments), this;\n  }, y2.setPage = function() {\n    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;\n  }, y2.insertPage = function(t3) {\n    return this.addPage(), this.movePage($2, t3), this;\n  }, y2.movePage = function(t3, e3) {\n    var r3, n2;\n    if (t3 > e3) {\n      r3 = ot2[t3], n2 = Rt2[t3];\n      for (var i3 = t3; i3 > e3; i3--)\n        ot2[i3] = ot2[i3 - 1], Rt2[i3] = Rt2[i3 - 1];\n      ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);\n    } else if (t3 < e3) {\n      r3 = ot2[t3], n2 = Rt2[t3];\n      for (var a2 = t3; a2 < e3; a2++)\n        ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];\n      ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);\n    }\n    return this;\n  }, y2.deletePage = function() {\n    return Be.apply(this, arguments), this;\n  }, y2.__private__.text = y2.text = function(e3, r3, n2, i3, a2) {\n    var o3, s3, c3, u3, h2, l2, f2, d3, p6, g3 = (i3 = i3 || {}).scope || this;\n    if (typeof e3 == \"number\" && typeof r3 == \"number\" && (typeof n2 == \"string\" || Array.isArray(n2))) {\n      var m3 = n2;\n      n2 = r3, r3 = e3, e3 = m3;\n    }\n    if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], _typeof$2(f2 = arguments[3]) === \"object\" && f2 !== null || (typeof c3 == \"string\" && (u3 = c3, c3 = null), typeof f2 == \"string\" && (u3 = f2, f2 = null), typeof f2 == \"number\" && (c3 = f2, f2 = null), i3 = { flags: f2, angle: c3, align: u3 })) : (q2(\"The transform parameter of text() with a Matrix value\"), p6 = a2), isNaN(r3) || isNaN(n2) || e3 == null)\n      throw new Error(\"Invalid arguments passed to jsPDF.text\");\n    if (e3.length === 0)\n      return g3;\n    var v3 = \"\", y3 = false, w3 = typeof i3.lineHeightFactor == \"number\" ? i3.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;\n    function L3(t3) {\n      return t3 = t3.split(\"\t\").join(Array(i3.TabLen || 9).join(\" \")), Ce(t3, f2);\n    }\n    function A3(t3) {\n      for (var e4, r4 = t3.concat(), n3 = [], i4 = r4.length; i4--; )\n        typeof (e4 = r4.shift()) == \"string\" ? n3.push(e4) : Array.isArray(t3) && (e4.length === 1 || e4[1] === void 0 && e4[2] === void 0) ? n3.push(e4[0]) : n3.push([e4[0], e4[1], e4[2]]);\n      return n3;\n    }\n    function _3(t3, e4) {\n      var r4;\n      if (typeof t3 == \"string\")\n        r4 = e4(t3)[0];\n      else if (Array.isArray(t3)) {\n        for (var n3, i4, a3 = t3.concat(), o4 = [], s4 = a3.length; s4--; )\n          typeof (n3 = a3.shift()) == \"string\" ? o4.push(e4(n3)[0]) : Array.isArray(n3) && typeof n3[0] == \"string\" && (i4 = e4(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));\n        r4 = o4;\n      }\n      return r4;\n    }\n    var P3 = false, k3 = true;\n    if (typeof e3 == \"string\")\n      P3 = true;\n    else if (Array.isArray(e3)) {\n      var I2 = e3.concat();\n      s3 = [];\n      for (var F2, C2 = I2.length; C2--; )\n        (typeof (F2 = I2.shift()) != \"string\" || Array.isArray(F2) && typeof F2[0] != \"string\") && (k3 = false);\n      P3 = k3;\n    }\n    if (P3 === false)\n      throw new Error('Type of text must be string or Array. \"' + e3 + '\" is not recognized.');\n    typeof e3 == \"string\" && (e3 = e3.match(/[\\r?\\n]/) ? e3.split(/\\r\\n|\\r|\\n/g) : [e3]);\n    var j2 = gt2 / g3.internal.scaleFactor, B3 = j2 * (w3 - 1);\n    switch (i3.baseline) {\n      case \"bottom\":\n        n2 -= B3;\n        break;\n      case \"top\":\n        n2 += j2 - B3;\n        break;\n      case \"hanging\":\n        n2 += j2 - 2 * B3;\n        break;\n      case \"middle\":\n        n2 += j2 / 2 - B3;\n    }\n    if ((l2 = i3.maxWidth || 0) > 0 && (typeof e3 == \"string\" ? e3 = g3.splitTextToSize(e3, l2) : Object.prototype.toString.call(e3) === \"[object Array]\" && (e3 = e3.reduce(function(t3, e4) {\n      return t3.concat(g3.splitTextToSize(e4, l2));\n    }, []))), o3 = { text: e3, x: r3, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish(\"preProcessText\", o3), e3 = o3.text, c3 = (i3 = o3.options).angle, p6 instanceof Vt2 == false && c3 && typeof c3 == \"number\") {\n      c3 *= Math.PI / 180, i3.rotationDirection === 0 && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);\n      var M2 = Math.cos(c3), E2 = Math.sin(c3);\n      p6 = new Vt2(M2, E2, -E2, M2, 0, 0);\n    } else\n      c3 && c3 instanceof Vt2 && (p6 = c3);\n    S2 !== x2.ADVANCED || p6 || (p6 = Yt2), (h2 = i3.charSpace || _r) !== void 0 && (v3 += O2(z2(h2)) + \" Tc\\n\", this.setCharSpace(this.getCharSpace() || 0)), (d3 = i3.horizontalScale) !== void 0 && (v3 += O2(100 * d3) + \" Tz\\n\");\n    i3.lang;\n    var D3 = -1, R3 = i3.renderingMode !== void 0 ? i3.renderingMode : i3.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;\n    switch (R3) {\n      case 0:\n      case false:\n      case \"fill\":\n        D3 = 0;\n        break;\n      case 1:\n      case true:\n      case \"stroke\":\n        D3 = 1;\n        break;\n      case 2:\n      case \"fillThenStroke\":\n        D3 = 2;\n        break;\n      case 3:\n      case \"invisible\":\n        D3 = 3;\n        break;\n      case 4:\n      case \"fillAndAddForClipping\":\n        D3 = 4;\n        break;\n      case 5:\n      case \"strokeAndAddPathForClipping\":\n        D3 = 5;\n        break;\n      case 6:\n      case \"fillThenStrokeAndAddToPathForClipping\":\n        D3 = 6;\n        break;\n      case 7:\n      case \"addToPathForClipping\":\n        D3 = 7;\n    }\n    var U3 = T3.usedRenderingMode !== void 0 ? T3.usedRenderingMode : -1;\n    D3 !== -1 ? v3 += D3 + \" Tr\\n\" : U3 !== -1 && (v3 += \"0 Tr\\n\"), D3 !== -1 && (T3.usedRenderingMode = D3), u3 = i3.align || \"left\";\n    var H5, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St];\n    h2 = i3.charSpace || _r, l2 = i3.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i3.flags);\n    var Y3 = [];\n    if (Object.prototype.toString.call(e3) === \"[object Array]\") {\n      var J3;\n      s3 = A3(e3), u3 !== \"left\" && (H5 = s3.map(function(t3) {\n        return g3.getStringUnitWidth(t3, { font: G3, charSpace: h2, fontSize: gt2, doKerning: false }) * gt2 / N3;\n      }));\n      var X3, K3 = 0;\n      if (u3 === \"right\") {\n        r3 -= H5[0], e3 = [], C2 = s3.length;\n        for (var Z3 = 0; Z3 < C2; Z3++)\n          Z3 === 0 ? (X3 = br(r3), J3 = yr(n2)) : (X3 = z2(K3 - H5[Z3]), J3 = -W3), e3.push([s3[Z3], X3, J3]), K3 = H5[Z3];\n      } else if (u3 === \"center\") {\n        r3 -= H5[0] / 2, e3 = [], C2 = s3.length;\n        for (var $3 = 0; $3 < C2; $3++)\n          $3 === 0 ? (X3 = br(r3), J3 = yr(n2)) : (X3 = z2((K3 - H5[$3]) / 2), J3 = -W3), e3.push([s3[$3], X3, J3]), K3 = H5[$3];\n      } else if (u3 === \"left\") {\n        e3 = [], C2 = s3.length;\n        for (var Q3 = 0; Q3 < C2; Q3++)\n          e3.push(s3[Q3]);\n      } else {\n        if (u3 !== \"justify\")\n          throw new Error('Unrecognized alignment option, use \"left\", \"center\", \"right\" or \"justify\".');\n        e3 = [], C2 = s3.length, l2 = l2 !== 0 ? l2 : V3;\n        for (var tt3 = 0; tt3 < C2; tt3++)\n          J3 = tt3 === 0 ? yr(n2) : -W3, X3 = tt3 === 0 ? br(r3) : 0, tt3 < C2 - 1 ? Y3.push(O2(z2((l2 - H5[tt3]) / (s3[tt3].split(\" \").length - 1)))) : Y3.push(0), e3.push([s3[tt3], X3, J3]);\n      }\n    }\n    var et3 = typeof i3.R2L == \"boolean\" ? i3.R2L : bt2;\n    et3 === true && (e3 = _3(e3, function(t3, e4, r4) {\n      return [t3.split(\"\").reverse().join(\"\"), e4, r4];\n    })), o3 = { text: e3, x: r3, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish(\"postProcessText\", o3), e3 = o3.text, y3 = o3.mutex.isHex || false;\n    var rt3 = Ft2[St].encoding;\n    rt3 !== \"WinAnsiEncoding\" && rt3 !== \"StandardEncoding\" || (e3 = _3(e3, function(t3, e4, r4) {\n      return [L3(t3), e4, r4];\n    })), s3 = A3(e3), e3 = [];\n    for (var nt3, it3, at3, ot3 = 0, st3 = 1, ct3 = Array.isArray(s3[0]) ? st3 : ot3, ut3 = \"\", ht3 = function(t3, e4, r4) {\n      var n3 = \"\";\n      return r4 instanceof Vt2 ? (r4 = typeof i3.angle == \"number\" ? Gt2(r4, new Vt2(1, 0, 0, 1, t3, e4)) : Gt2(new Vt2(1, 0, 0, 1, t3, e4), r4), S2 === x2.ADVANCED && (r4 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r4)), n3 = r4.join(\" \") + \" Tm\\n\") : n3 = O2(t3) + \" \" + O2(e4) + \" Td\\n\", n3;\n    }, ft3 = 0; ft3 < s3.length; ft3++) {\n      switch (ut3 = \"\", ct3) {\n        case st3:\n          at3 = (y3 ? \"<\" : \"(\") + s3[ft3][0] + (y3 ? \">\" : \")\"), nt3 = parseFloat(s3[ft3][1]), it3 = parseFloat(s3[ft3][2]);\n          break;\n        case ot3:\n          at3 = (y3 ? \"<\" : \"(\") + s3[ft3] + (y3 ? \">\" : \")\"), nt3 = br(r3), it3 = yr(n2);\n      }\n      Y3 !== void 0 && Y3[ft3] !== void 0 && (ut3 = Y3[ft3] + \" Tw\\n\"), ft3 === 0 ? e3.push(ut3 + ht3(nt3, it3, p6) + at3) : ct3 === ot3 ? e3.push(ut3 + at3) : ct3 === st3 && e3.push(ut3 + ht3(nt3, it3, p6) + at3);\n    }\n    e3 = ct3 === ot3 ? e3.join(\" Tj\\nT* \") : e3.join(\" Tj\\n\"), e3 += \" Tj\\n\";\n    var dt3 = \"BT\\n/\";\n    return dt3 += St + \" \" + gt2 + \" Tf\\n\", dt3 += O2(gt2 * w3) + \" TL\\n\", dt3 += xr + \"\\n\", dt3 += v3, dt3 += e3, lt2(dt3 += \"ET\"), b2[St] = true, g3;\n  };\n  var $e = y2.__private__.clip = y2.clip = function(t3) {\n    return lt2(t3 === \"evenodd\" ? \"W*\" : \"W\"), this;\n  };\n  y2.clipEvenOdd = function() {\n    return $e(\"evenodd\");\n  }, y2.__private__.discardPath = y2.discardPath = function() {\n    return lt2(\"n\"), this;\n  };\n  var Qe = y2.__private__.isValidStyle = function(t3) {\n    var e3 = false;\n    return [void 0, null, \"S\", \"D\", \"F\", \"DF\", \"FD\", \"f\", \"f*\", \"B\", \"B*\", \"n\"].indexOf(t3) !== -1 && (e3 = true), e3;\n  };\n  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t3) {\n    return Qe(t3) && (g2 = t3), this;\n  };\n  var tr = y2.__private__.getStyle = y2.getStyle = function(t3) {\n    var e3 = g2;\n    switch (t3) {\n      case \"D\":\n      case \"S\":\n        e3 = \"S\";\n        break;\n      case \"F\":\n        e3 = \"f\";\n        break;\n      case \"FD\":\n      case \"DF\":\n        e3 = \"B\";\n        break;\n      case \"f\":\n      case \"f*\":\n      case \"B\":\n      case \"B*\":\n        e3 = t3;\n    }\n    return e3;\n  }, er = y2.close = function() {\n    return lt2(\"h\"), this;\n  };\n  y2.stroke = function() {\n    return lt2(\"S\"), this;\n  }, y2.fill = function(t3) {\n    return rr(\"f\", t3), this;\n  }, y2.fillEvenOdd = function(t3) {\n    return rr(\"f*\", t3), this;\n  }, y2.fillStroke = function(t3) {\n    return rr(\"B\", t3), this;\n  }, y2.fillStrokeEvenOdd = function(t3) {\n    return rr(\"B*\", t3), this;\n  };\n  var rr = function(e3, r3) {\n    _typeof$2(r3) === \"object\" ? ar(r3, e3) : lt2(e3);\n  }, nr = function(t3) {\n    t3 === null || S2 === x2.ADVANCED && t3 === void 0 || (t3 = tr(t3), lt2(t3));\n  };\n  function ir(t3, e3, r3, n2, i3) {\n    var a2 = new M$1(e3 || this.boundingBox, r3 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);\n    a2.stream = this.stream;\n    var o3 = t3 + \"$$\" + this.cloneIndex++ + \"$$\";\n    return Jt2(o3, a2), a2;\n  }\n  var ar = function(t3, e3) {\n    var r3 = Bt2[t3.key], n2 = Ot2[r3];\n    if (n2 instanceof B)\n      lt2(\"q\"), lt2(or(e3)), n2.gState && y2.setGState(n2.gState), lt2(t3.matrix.toString() + \" cm\"), lt2(\"/\" + r3 + \" sh\"), lt2(\"Q\");\n    else if (n2 instanceof M$1) {\n      var i3 = new Vt2(1, 0, 0, -1, 0, Rr());\n      t3.matrix && (i3 = i3.multiply(t3.matrix || Yt2), r3 = ir.call(n2, t3.key, t3.boundingBox, t3.xStep, t3.yStep, i3).id), lt2(\"q\"), lt2(\"/Pattern cs\"), lt2(\"/\" + r3 + \" scn\"), n2.gState && y2.setGState(n2.gState), lt2(e3), lt2(\"Q\");\n    }\n  }, or = function(t3) {\n    switch (t3) {\n      case \"f\":\n      case \"F\":\n        return \"W n\";\n      case \"f*\":\n        return \"W* n\";\n      case \"B\":\n        return \"W S\";\n      case \"B*\":\n        return \"W* S\";\n      case \"S\":\n        return \"W S\";\n      case \"n\":\n        return \"W n\";\n    }\n  }, sr = y2.moveTo = function(t3, e3) {\n    return lt2(O2(z2(t3)) + \" \" + O2(H4(e3)) + \" m\"), this;\n  }, cr = y2.lineTo = function(t3, e3) {\n    return lt2(O2(z2(t3)) + \" \" + O2(H4(e3)) + \" l\"), this;\n  }, ur = y2.curveTo = function(t3, e3, r3, n2, i3, a2) {\n    return lt2([O2(z2(t3)), O2(H4(e3)), O2(z2(r3)), O2(H4(n2)), O2(z2(i3)), O2(H4(a2)), \"c\"].join(\" \")), this;\n  };\n  y2.__private__.line = y2.line = function(t3, e3, r3, n2, i3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))\n      throw new Error(\"Invalid arguments passed to jsPDF.line\");\n    return S2 === x2.COMPAT ? this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1], i3 || \"S\") : this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1]).stroke();\n  }, y2.__private__.lines = y2.lines = function(t3, e3, r3, n2, i3, a2) {\n    var o3, s3, c3, u3, h2, l2, f2, d3, p6, g3, m3, v3;\n    if (typeof t3 == \"number\" && (v3 = r3, r3 = e3, e3 = t3, t3 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e3) || isNaN(r3) || !Array.isArray(t3) || !Array.isArray(n2) || !Qe(i3) || typeof a2 != \"boolean\")\n      throw new Error(\"Invalid arguments passed to jsPDF.lines\");\n    for (sr(e3, r3), o3 = n2[0], s3 = n2[1], u3 = t3.length, g3 = e3, m3 = r3, c3 = 0; c3 < u3; c3++)\n      (h2 = t3[c3]).length === 2 ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d3 = h2[2] * o3 + g3, p6 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d3, p6, g3, m3));\n    return a2 && er(), nr(i3), this;\n  }, y2.path = function(t3) {\n    for (var e3 = 0; e3 < t3.length; e3++) {\n      var r3 = t3[e3], n2 = r3.c;\n      switch (r3.op) {\n        case \"m\":\n          sr(n2[0], n2[1]);\n          break;\n        case \"l\":\n          cr(n2[0], n2[1]);\n          break;\n        case \"c\":\n          ur.apply(this, n2);\n          break;\n        case \"h\":\n          er();\n      }\n    }\n    return this;\n  }, y2.__private__.rect = y2.rect = function(t3, e3, r3, n2, i3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))\n      throw new Error(\"Invalid arguments passed to jsPDF.rect\");\n    return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(z2(t3)), O2(H4(e3)), O2(z2(r3)), O2(z2(n2)), \"re\"].join(\" \")), nr(i3), this;\n  }, y2.__private__.triangle = y2.triangle = function(t3, e3, r3, n2, i3, a2, o3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))\n      throw new Error(\"Invalid arguments passed to jsPDF.triangle\");\n    return this.lines([[r3 - t3, n2 - e3], [i3 - r3, a2 - n2], [t3 - i3, e3 - a2]], t3, e3, [1, 1], o3, true), this;\n  }, y2.__private__.roundedRect = y2.roundedRect = function(t3, e3, r3, n2, i3, a2, o3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))\n      throw new Error(\"Invalid arguments passed to jsPDF.roundedRect\");\n    var s3 = 4 / 3 * (Math.SQRT2 - 1);\n    return i3 = Math.min(i3, 0.5 * r3), a2 = Math.min(a2, 0.5 * n2), this.lines([[r3 - 2 * i3, 0], [i3 * s3, 0, i3, a2 - a2 * s3, i3, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i3 * s3, a2, -i3, a2], [2 * i3 - r3, 0], [-i3 * s3, 0, -i3, -a2 * s3, -i3, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i3 * s3, -a2, i3, -a2]], t3 + i3, e3, [1, 1], o3, true), this;\n  }, y2.__private__.ellipse = y2.ellipse = function(t3, e3, r3, n2, i3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe(i3))\n      throw new Error(\"Invalid arguments passed to jsPDF.ellipse\");\n    var a2 = 4 / 3 * (Math.SQRT2 - 1) * r3, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;\n    return sr(t3 + r3, e3), ur(t3 + r3, e3 - o3, t3 + a2, e3 - n2, t3, e3 - n2), ur(t3 - a2, e3 - n2, t3 - r3, e3 - o3, t3 - r3, e3), ur(t3 - r3, e3 + o3, t3 - a2, e3 + n2, t3, e3 + n2), ur(t3 + a2, e3 + n2, t3 + r3, e3 + o3, t3 + r3, e3), nr(i3), this;\n  }, y2.__private__.circle = y2.circle = function(t3, e3, r3, n2) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || !Qe(n2))\n      throw new Error(\"Invalid arguments passed to jsPDF.circle\");\n    return this.ellipse(t3, e3, r3, r3, n2);\n  }, y2.setFont = function(t3, e3, r3) {\n    return r3 && (e3 = k2(e3, r3)), St = qe(t3, e3, { disableWarning: false }), this;\n  };\n  var hr = y2.__private__.getFont = y2.getFont = function() {\n    return Ft2[qe.apply(y2, arguments)];\n  };\n  y2.__private__.getFontList = y2.getFontList = function() {\n    var t3, e3, r3 = {};\n    for (t3 in Ct2)\n      if (Ct2.hasOwnProperty(t3))\n        for (e3 in r3[t3] = [], Ct2[t3])\n          Ct2[t3].hasOwnProperty(e3) && r3[t3].push(e3);\n    return r3;\n  }, y2.addFont = function(t3, e3, r3, n2, i3) {\n    var a2 = [\"StandardEncoding\", \"MacRomanEncoding\", \"Identity-H\", \"WinAnsiEncoding\"];\n    return arguments[3] && a2.indexOf(arguments[3]) !== -1 ? i3 = arguments[3] : arguments[3] && a2.indexOf(arguments[3]) == -1 && (r3 = k2(r3, n2)), i3 = i3 || \"Identity-H\", Pe.call(this, t3, e3, r3, i3);\n  };\n  var lr, fr = e2.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {\n    return fr;\n  }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t3) {\n    return fr = t3, lt2(O2(z2(t3)) + \" w\"), this;\n  };\n  y2.__private__.setLineDash = E$1.API.setLineDash = E$1.API.setLineDashPattern = function(t3, e3) {\n    if (t3 = t3 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t3))\n      throw new Error(\"Invalid arguments passed to jsPDF.setLineDash\");\n    return t3 = t3.map(function(t4) {\n      return O2(z2(t4));\n    }).join(\" \"), e3 = O2(z2(e3)), lt2(\"[\" + t3 + \"] \" + e3 + \" d\"), this;\n  };\n  var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {\n    return gt2 * lr;\n  };\n  y2.__private__.getLineHeight = y2.getLineHeight = function() {\n    return gt2 * lr;\n  };\n  var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t3) {\n    return typeof (t3 = t3 || 1.15) == \"number\" && (lr = t3), this;\n  }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {\n    return lr;\n  };\n  mr(e2.lineHeight);\n  var br = y2.__private__.getHorizontalCoordinate = function(t3) {\n    return z2(t3);\n  }, yr = y2.__private__.getVerticalCoordinate = function(t3) {\n    return S2 === x2.ADVANCED ? t3 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - z2(t3);\n  }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t3) {\n    return O2(br(t3));\n  }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t3) {\n    return O2(yr(t3));\n  }, Lr = e2.strokeColor || \"0 G\";\n  y2.__private__.getStrokeColor = y2.getDrawColor = function() {\n    return ee2(Lr);\n  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t3, e3, r3, n2) {\n    return Lr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: \"draw\", precision: 2 }), lt2(Lr), this;\n  };\n  var Ar = e2.fillColor || \"0 g\";\n  y2.__private__.getFillColor = y2.getFillColor = function() {\n    return ee2(Ar);\n  }, y2.__private__.setFillColor = y2.setFillColor = function(t3, e3, r3, n2) {\n    return Ar = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: \"fill\", precision: 2 }), lt2(Ar), this;\n  };\n  var xr = e2.textColor || \"0 g\", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {\n    return ee2(xr);\n  };\n  y2.__private__.setTextColor = y2.setTextColor = function(t3, e3, r3, n2) {\n    return xr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: \"text\", precision: 3 }), this;\n  };\n  var _r = e2.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {\n    return parseFloat(_r || 0);\n  };\n  y2.__private__.setCharSpace = y2.setCharSpace = function(t3) {\n    if (isNaN(t3))\n      throw new Error(\"Invalid argument passed to jsPDF.setCharSpace\");\n    return _r = t3, this;\n  };\n  var kr = 0;\n  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t3) {\n    var e3 = y2.CapJoinStyles[t3];\n    if (e3 === void 0)\n      throw new Error(\"Line cap style of '\" + t3 + \"' is not recognized. See or extend .CapJoinStyles property for valid styles\");\n    return kr = e3, lt2(e3 + \" J\"), this;\n  };\n  var Ir = 0;\n  y2.__private__.setLineJoin = y2.setLineJoin = function(t3) {\n    var e3 = y2.CapJoinStyles[t3];\n    if (e3 === void 0)\n      throw new Error(\"Line join style of '\" + t3 + \"' is not recognized. See or extend .CapJoinStyles property for valid styles\");\n    return Ir = e3, lt2(e3 + \" j\"), this;\n  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t3) {\n    if (t3 = t3 || 0, isNaN(t3))\n      throw new Error(\"Invalid argument passed to jsPDF.setLineMiterLimit\");\n    return lt2(O2(z2(t3)) + \" M\"), this;\n  }, y2.GState = j, y2.setGState = function(t3) {\n    (t3 = typeof t3 == \"string\" ? Mt2[Et2[t3]] : Fr(null, t3)).equals(qt2) || (lt2(\"/\" + t3.id + \" gs\"), qt2 = t3);\n  };\n  var Fr = function(t3, e3) {\n    if (!t3 || !Et2[t3]) {\n      var r3 = false;\n      for (var n2 in Mt2)\n        if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e3)) {\n          r3 = true;\n          break;\n        }\n      if (r3)\n        e3 = Mt2[n2];\n      else {\n        var i3 = \"GS\" + (Object.keys(Mt2).length + 1).toString(10);\n        Mt2[i3] = e3, e3.id = i3;\n      }\n      return t3 && (Et2[t3] = e3.id), Tt2.publish(\"addGState\", e3), e3;\n    }\n  };\n  y2.addGState = function(t3, e3) {\n    return Fr(t3, e3), this;\n  }, y2.saveGraphicsState = function() {\n    return lt2(\"q\"), jt2.push({ key: St, size: gt2, color: xr }), this;\n  }, y2.restoreGraphicsState = function() {\n    lt2(\"Q\");\n    var t3 = jt2.pop();\n    return St = t3.key, gt2 = t3.size, xr = t3.color, qt2 = null, this;\n  }, y2.setCurrentTransformationMatrix = function(t3) {\n    return lt2(t3.toString() + \" cm\"), this;\n  }, y2.comment = function(t3) {\n    return lt2(\"#\" + t3), this;\n  };\n  var Cr = function(t3, e3) {\n    var r3 = t3 || 0;\n    Object.defineProperty(this, \"x\", { enumerable: true, get: function() {\n      return r3;\n    }, set: function(t4) {\n      isNaN(t4) || (r3 = parseFloat(t4));\n    } });\n    var n2 = e3 || 0;\n    Object.defineProperty(this, \"y\", { enumerable: true, get: function() {\n      return n2;\n    }, set: function(t4) {\n      isNaN(t4) || (n2 = parseFloat(t4));\n    } });\n    var i3 = \"pt\";\n    return Object.defineProperty(this, \"type\", { enumerable: true, get: function() {\n      return i3;\n    }, set: function(t4) {\n      i3 = t4.toString();\n    } }), this;\n  }, jr = function(t3, e3, r3, n2) {\n    Cr.call(this, t3, e3), this.type = \"rect\";\n    var i3 = r3 || 0;\n    Object.defineProperty(this, \"w\", { enumerable: true, get: function() {\n      return i3;\n    }, set: function(t4) {\n      isNaN(t4) || (i3 = parseFloat(t4));\n    } });\n    var a2 = n2 || 0;\n    return Object.defineProperty(this, \"h\", { enumerable: true, get: function() {\n      return a2;\n    }, set: function(t4) {\n      isNaN(t4) || (a2 = parseFloat(t4));\n    } }), this;\n  }, Or = function() {\n    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = \"\", this.objectNumber = -1;\n  };\n  Or.prototype.restore = function() {\n    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;\n  };\n  var Br = function(t3, e3, r3, n2, i3) {\n    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t3, kt2 = e3, It2 = i3, je([r3, n2]);\n  }, Mr = function(t3) {\n    if (Ht2[t3])\n      Wt2.pop().restore();\n    else {\n      var e3 = new Or(), r3 = \"Xo\" + (Object.keys(Ut2).length + 1).toString(10);\n      e3.id = r3, Ht2[t3] = r3, Ut2[r3] = e3, Tt2.publish(\"addFormObject\", e3), Wt2.pop().restore();\n    }\n  };\n  for (var Er in y2.beginFormObject = function(t3, e3, r3, n2, i3) {\n    return Br(t3, e3, r3, n2, i3), this;\n  }, y2.endFormObject = function(t3) {\n    return Mr(t3), this;\n  }, y2.doFormObject = function(t3, e3) {\n    var r3 = Ut2[Ht2[t3]];\n    return lt2(\"q\"), lt2(e3.toString() + \" cm\"), lt2(\"/\" + r3.id + \" Do\"), lt2(\"Q\"), this;\n  }, y2.getFormObject = function(t3) {\n    var e3 = Ut2[Ht2[t3]];\n    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };\n  }, y2.save = function(t3, e3) {\n    return t3 = t3 || \"generated.pdf\", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, e3.returnPromise === false ? (l$1(We(He()), t3), typeof l$1.unload == \"function\" && n$1.setTimeout && setTimeout(l$1.unload, 911), this) : new Promise(function(e4, r3) {\n      try {\n        var i3 = l$1(We(He()), t3);\n        typeof l$1.unload == \"function\" && n$1.setTimeout && setTimeout(l$1.unload, 911), e4(i3);\n      } catch (t4) {\n        r3(t4.message);\n      }\n    });\n  }, E$1.API)\n    E$1.API.hasOwnProperty(Er) && (Er === \"events\" && E$1.API.events.length ? function(t3, e3) {\n      var r3, n2, i3;\n      for (i3 = e3.length - 1; i3 !== -1; i3--)\n        r3 = e3[i3][0], n2 = e3[i3][1], t3.subscribe.apply(t3, [r3].concat(typeof n2 == \"function\" ? [n2] : n2));\n    }(Tt2, E$1.API.events) : y2[Er] = E$1.API[Er]);\n  var qr = y2.getPageWidth = function(t3) {\n    return (Rt2[t3 = t3 || $2].mediaBox.topRightX - Rt2[t3].mediaBox.bottomLeftX) / _t2;\n  }, Dr = y2.setPageWidth = function(t3, e3) {\n    Rt2[t3].mediaBox.topRightX = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftX;\n  }, Rr = y2.getPageHeight = function(t3) {\n    return (Rt2[t3 = t3 || $2].mediaBox.topRightY - Rt2[t3].mediaBox.bottomLeftY) / _t2;\n  }, Tr = y2.setPageHeight = function(t3, e3) {\n    Rt2[t3].mediaBox.topRightY = e3 * _t2 + Rt2[t3].mediaBox.bottomLeftY;\n  };\n  return y2.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {\n    return qr($2);\n  }, setWidth: function(t3) {\n    Dr($2, t3);\n  }, getHeight: function() {\n    return Rr($2);\n  }, setHeight: function(t3) {\n    Tr($2, t3);\n  } }, encryptionOptions: m2, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y2.internal.pageSize, \"width\", { get: function() {\n    return qr($2);\n  }, set: function(t3) {\n    Dr($2, t3);\n  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, \"height\", { get: function() {\n    return Rr($2);\n  }, set: function(t3) {\n    Tr($2, t3);\n  }, enumerable: true, configurable: true }), ke.call(y2, pt2), St = \"F1\", Oe(s2, i2), Tt2.publish(\"initialized\"), y2;\n}\nI.prototype.lsbFirstWord = function(t3) {\n  return String.fromCharCode(t3 >> 0 & 255, t3 >> 8 & 255, t3 >> 16 & 255, t3 >> 24 & 255);\n}, I.prototype.toHexString = function(t3) {\n  return t3.split(\"\").map(function(t4) {\n    return (\"0\" + (255 & t4.charCodeAt(0)).toString(16)).slice(-2);\n  }).join(\"\");\n}, I.prototype.hexToBytes = function(t3) {\n  for (var e2 = [], r2 = 0; r2 < t3.length; r2 += 2)\n    e2.push(String.fromCharCode(parseInt(t3.substr(r2, 2), 16)));\n  return e2.join(\"\");\n}, I.prototype.processOwnerPassword = function(t3, e2) {\n  return P(x(e2).substr(0, 5), t3);\n}, I.prototype.encryptor = function(t3, e2) {\n  var r2 = x(this.encryptionKey + String.fromCharCode(255 & t3, t3 >> 8 & 255, t3 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);\n  return function(t4) {\n    return P(r2, t4);\n  };\n}, j.prototype.equals = function(e2) {\n  var r2, n2 = \"id,objectNumber,equals\";\n  if (!e2 || _typeof$2(e2) !== _typeof$2(this))\n    return false;\n  var i2 = 0;\n  for (r2 in this)\n    if (!(n2.indexOf(r2) >= 0)) {\n      if (this.hasOwnProperty(r2) && !e2.hasOwnProperty(r2))\n        return false;\n      if (this[r2] !== e2[r2])\n        return false;\n      i2++;\n    }\n  for (r2 in e2)\n    e2.hasOwnProperty(r2) && n2.indexOf(r2) < 0 && i2--;\n  return i2 === 0;\n}, E$1.API = { events: [] }, E$1.version = \"2.5.0\";\nvar q = E$1.API, D = 1, R = function(t3) {\n  return t3.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\");\n}, T$2 = function(t3) {\n  return t3.replace(/\\\\\\\\/g, \"\\\\\").replace(/\\\\\\(/g, \"(\").replace(/\\\\\\)/g, \")\");\n}, z$1 = function(t3) {\n  return t3.toFixed(2);\n}, U$1 = function(t3) {\n  return t3.toFixed(5);\n};\nq.__acroform__ = {};\nvar H = function(t3, e2) {\n  t3.prototype = Object.create(e2.prototype), t3.prototype.constructor = t3;\n}, W = function(t3) {\n  return t3 * D;\n}, V$1 = function(t3) {\n  var e2 = new ut(), r2 = At.internal.getHeight(t3) || 0, n2 = At.internal.getWidth(t3) || 0;\n  return e2.BBox = [0, 0, Number(z$1(n2)), Number(z$1(r2))], e2;\n}, G = q.__acroform__.setBit = function(t3, e2) {\n  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))\n    throw new Error(\"Invalid arguments passed to jsPDF.API.__acroform__.setBit\");\n  return t3 |= 1 << e2;\n}, Y = q.__acroform__.clearBit = function(t3, e2) {\n  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))\n    throw new Error(\"Invalid arguments passed to jsPDF.API.__acroform__.clearBit\");\n  return t3 &= ~(1 << e2);\n}, J = q.__acroform__.getBit = function(t3, e2) {\n  if (isNaN(t3) || isNaN(e2))\n    throw new Error(\"Invalid arguments passed to jsPDF.API.__acroform__.getBit\");\n  return (t3 & 1 << e2) == 0 ? 0 : 1;\n}, X = q.__acroform__.getBitForPdf = function(t3, e2) {\n  if (isNaN(t3) || isNaN(e2))\n    throw new Error(\"Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf\");\n  return J(t3, e2 - 1);\n}, K = q.__acroform__.setBitForPdf = function(t3, e2) {\n  if (isNaN(t3) || isNaN(e2))\n    throw new Error(\"Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf\");\n  return G(t3, e2 - 1);\n}, Z$2 = q.__acroform__.clearBitForPdf = function(t3, e2) {\n  if (isNaN(t3) || isNaN(e2))\n    throw new Error(\"Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf\");\n  return Y(t3, e2 - 1);\n}, $$a = q.__acroform__.calculateCoordinates = function(t3, e2) {\n  var r2 = e2.internal.getHorizontalCoordinate, n2 = e2.internal.getVerticalCoordinate, i2 = t3[0], a2 = t3[1], o2 = t3[2], s2 = t3[3], c2 = {};\n  return c2.lowerLeft_X = r2(i2) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r2(i2 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(z$1(c2.lowerLeft_X)), Number(z$1(c2.lowerLeft_Y)), Number(z$1(c2.upperRight_X)), Number(z$1(c2.upperRight_Y))];\n}, Q = function(t3) {\n  if (t3.appearanceStreamContent)\n    return t3.appearanceStreamContent;\n  if (t3.V || t3.DV) {\n    var e2 = [], r2 = t3._V || t3.DV, n2 = tt(t3, r2), i2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id;\n    e2.push(\"/Tx BMC\"), e2.push(\"q\"), e2.push(\"BT\"), e2.push(t3.scope.__private__.encodeColorString(t3.color)), e2.push(\"/\" + i2 + \" \" + z$1(n2.fontSize) + \" Tf\"), e2.push(\"1 0 0 1 0 0 Tm\"), e2.push(n2.text), e2.push(\"ET\"), e2.push(\"Q\"), e2.push(\"EMC\");\n    var a2 = V$1(t3);\n    return a2.scope = t3.scope, a2.stream = e2.join(\"\\n\"), a2;\n  }\n}, tt = function(t3, e2) {\n  var r2 = t3.fontSize === 0 ? t3.maxFontSize : t3.fontSize, n2 = { text: \"\", fontSize: \"\" }, i2 = (e2 = (e2 = e2.substr(0, 1) == \"(\" ? e2.substr(1) : e2).substr(e2.length - 1) == \")\" ? e2.substr(0, e2.length - 1) : e2).split(\" \");\n  i2 = t3.multiline ? i2.map(function(t4) {\n    return t4.split(\"\\n\");\n  }) : i2.map(function(t4) {\n    return [t4];\n  });\n  var a2 = r2, o2 = At.internal.getHeight(t3) || 0;\n  o2 = o2 < 0 ? -o2 : o2;\n  var s2 = At.internal.getWidth(t3) || 0;\n  s2 = s2 < 0 ? -s2 : s2;\n  var c2 = function(e3, r3, n3) {\n    if (e3 + 1 < i2.length) {\n      var a3 = r3 + \" \" + i2[e3 + 1][0];\n      return et(a3, t3, n3).width <= s2 - 4;\n    }\n    return false;\n  };\n  a2++;\n  t:\n    for (; a2 > 0; ) {\n      e2 = \"\", a2--;\n      var u2, h2, l2 = et(\"3\", t3, a2).height, f2 = t3.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p5 = 0, g2 = 0, m2 = 0;\n      if (a2 <= 0) {\n        e2 = \"(...) Tj\\n\", e2 += \"% Width of Text: \" + et(e2, t3, a2 = 12).width + \", FieldWidth:\" + s2 + \"\\n\";\n        break;\n      }\n      for (var v2 = \"\", b2 = 0, y2 = 0; y2 < i2.length; y2++)\n        if (i2.hasOwnProperty(y2)) {\n          var w2 = false;\n          if (i2[y2].length !== 1 && m2 !== i2[y2].length - 1) {\n            if ((l2 + 2) * (b2 + 2) + 2 > o2)\n              continue t;\n            v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;\n          } else {\n            v2 = (v2 += i2[y2][m2] + \" \").substr(v2.length - 1) == \" \" ? v2.substr(0, v2.length - 1) : v2;\n            var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i2.length - 1;\n            if (L2 && !A2) {\n              v2 += \" \", m2 = 0;\n              continue;\n            }\n            if (L2 || A2) {\n              if (A2)\n                g2 = N2;\n              else if (t3.multiline && (l2 + 2) * (b2 + 2) + 2 > o2)\n                continue t;\n            } else {\n              if (!t3.multiline)\n                continue t;\n              if ((l2 + 2) * (b2 + 2) + 2 > o2)\n                continue t;\n              g2 = N2;\n            }\n          }\n          for (var x2 = \"\", S2 = p5; S2 <= g2; S2++) {\n            var _2 = i2[S2];\n            if (t3.multiline) {\n              if (S2 === g2) {\n                x2 += _2[m2] + \" \", m2 = (m2 + 1) % _2.length;\n                continue;\n              }\n              if (S2 === p5) {\n                x2 += _2[_2.length - 1] + \" \";\n                continue;\n              }\n            }\n            x2 += _2[0] + \" \";\n          }\n          switch (x2 = x2.substr(x2.length - 1) == \" \" ? x2.substr(0, x2.length - 1) : x2, h2 = et(x2, t3, a2).width, t3.textAlign) {\n            case \"right\":\n              u2 = s2 - h2 - 2;\n              break;\n            case \"center\":\n              u2 = (s2 - h2) / 2;\n              break;\n            case \"left\":\n            default:\n              u2 = 2;\n          }\n          e2 += z$1(u2) + \" \" + z$1(d2) + \" Td\\n\", e2 += \"(\" + R(x2) + \") Tj\\n\", e2 += -z$1(u2) + \" 0 Td\\n\", d2 = -(a2 + 2), h2 = 0, p5 = w2 ? g2 : g2 + 1, b2++, v2 = \"\";\n        }\n      break;\n    }\n  return n2.text = e2, n2.fontSize = a2, n2;\n}, et = function(t3, e2, r2) {\n  var n2 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i2 = e2.scope.getStringUnitWidth(t3, { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2);\n  return { height: e2.scope.getStringUnitWidth(\"3\", { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2) * 1.5, width: i2 };\n}, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, nt = function(t3, e2) {\n  var r2 = { type: \"reference\", object: t3 };\n  e2.internal.getPageInfo(t3.page).pageContext.annotations.find(function(t4) {\n    return t4.type === r2.type && t4.object === r2.object;\n  }) === void 0 && e2.internal.getPageInfo(t3.page).pageContext.annotations.push(r2);\n}, it = function(e2, r2) {\n  for (var n2 in e2)\n    if (e2.hasOwnProperty(n2)) {\n      var i2 = n2, a2 = e2[n2];\n      r2.internal.newObjectDeferredBegin(a2.objId, true), _typeof$2(a2) === \"object\" && typeof a2.putStream == \"function\" && a2.putStream(), delete e2[i2];\n    }\n}, at = function(e2, r2) {\n  if (r2.scope = e2, e2.internal !== void 0 && (e2.internal.acroformPlugin === void 0 || e2.internal.acroformPlugin.isInitialized === false)) {\n    if (lt.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot)\n      throw new Error(\"Exception while creating AcroformDictionary\");\n    D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe(\"postPutResources\", function() {\n      !function(t3) {\n        t3.internal.events.unsubscribe(t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t3.internal.acroformPlugin.printedOut = true;\n      }(e2);\n    }), e2.internal.events.subscribe(\"buildDocument\", function() {\n      !function(t3) {\n        t3.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;\n        var e3 = t3.internal.acroformPlugin.acroFormDictionaryRoot.Fields;\n        for (var r3 in e3)\n          if (e3.hasOwnProperty(r3)) {\n            var n2 = e3[r3];\n            n2.objId = void 0, n2.hasAnnotation && nt(n2, t3);\n          }\n      }(e2);\n    }), e2.internal.events.subscribe(\"putCatalog\", function() {\n      !function(t3) {\n        if (t3.internal.acroformPlugin.acroFormDictionaryRoot === void 0)\n          throw new Error(\"putCatalogCallback: Root missing.\");\n        t3.internal.write(\"/AcroForm \" + t3.internal.acroformPlugin.acroFormDictionaryRoot.objId + \" 0 R\");\n      }(e2);\n    }), e2.internal.events.subscribe(\"postPutPages\", function(r3) {\n      !function(e3, r4) {\n        var n2 = !e3;\n        for (var i2 in e3 || (r4.internal.newObjectDeferredBegin(r4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r4.internal.acroformPlugin.acroFormDictionaryRoot.Kids)\n          if (e3.hasOwnProperty(i2)) {\n            var a2 = e3[i2], o2 = [], s2 = a2.Rect;\n            if (a2.Rect && (a2.Rect = $$a(a2.Rect, r4)), r4.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), _typeof$2(a2) === \"object\" && typeof a2.getKeyValueListForStream == \"function\" && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {\n              var c2 = Q(a2);\n              o2.push({ key: \"AP\", value: \"<</N \" + c2 + \">>\" }), r4.internal.acroformPlugin.xForms.push(c2);\n            }\n            if (a2.appearanceStreamContent) {\n              var u2 = \"\";\n              for (var h2 in a2.appearanceStreamContent)\n                if (a2.appearanceStreamContent.hasOwnProperty(h2)) {\n                  var l2 = a2.appearanceStreamContent[h2];\n                  if (u2 += \"/\" + h2 + \" \", u2 += \"<<\", Object.keys(l2).length >= 1 || Array.isArray(l2)) {\n                    for (var i2 in l2)\n                      if (l2.hasOwnProperty(i2)) {\n                        var f2 = l2[i2];\n                        typeof f2 == \"function\" && (f2 = f2.call(r4, a2)), u2 += \"/\" + i2 + \" \" + f2 + \" \", r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);\n                      }\n                  } else\n                    typeof (f2 = l2) == \"function\" && (f2 = f2.call(r4, a2)), u2 += \"/\" + i2 + \" \" + f2, r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);\n                  u2 += \">>\";\n                }\n              o2.push({ key: \"AP\", value: \"<<\\n\" + u2 + \">>\" });\n            }\n            r4.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r4.internal.out(\"endobj\");\n          }\n        n2 && it(r4.internal.acroformPlugin.xForms, r4);\n      }(r3, e2);\n    }), e2.internal.acroformPlugin.isInitialized = true;\n  }\n}, ot = q.__acroform__.arrayToPdfArray = function(e2, r2, n2) {\n  var i2 = function(t3) {\n    return t3;\n  };\n  if (Array.isArray(e2)) {\n    for (var a2 = \"[\", o2 = 0; o2 < e2.length; o2++)\n      switch (o2 !== 0 && (a2 += \" \"), _typeof$2(e2[o2])) {\n        case \"boolean\":\n        case \"number\":\n        case \"object\":\n          a2 += e2[o2].toString();\n          break;\n        case \"string\":\n          e2[o2].substr(0, 1) !== \"/\" ? (r2 !== void 0 && n2 && (i2 = n2.internal.getEncryptor(r2)), a2 += \"(\" + R(i2(e2[o2].toString())) + \")\") : a2 += e2[o2].toString();\n      }\n    return a2 += \"]\";\n  }\n  throw new Error(\"Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray\");\n};\nvar st = function(t3, e2, r2) {\n  var n2 = function(t4) {\n    return t4;\n  };\n  return e2 !== void 0 && r2 && (n2 = r2.internal.getEncryptor(e2)), (t3 = t3 || \"\").toString(), t3 = \"(\" + R(n2(t3)) + \")\";\n}, ct = function() {\n  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, \"objId\", { get: function() {\n    if (this._objId === void 0) {\n      if (this.scope === void 0)\n        return;\n      this._objId = this.scope.internal.newObjectDeferred();\n    }\n    return this._objId;\n  }, set: function(t3) {\n    this._objId = t3;\n  } }), Object.defineProperty(this, \"scope\", { value: this._scope, writable: true });\n};\nct.prototype.toString = function() {\n  return this.objId + \" 0 R\";\n}, ct.prototype.putStream = function() {\n  var t3 = this.getKeyValueListForStream();\n  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t3, objectId: this.objId }), this.scope.internal.out(\"endobj\");\n}, ct.prototype.getKeyValueListForStream = function() {\n  var t3 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t4) {\n    return t4 != \"content\" && t4 != \"appearanceStreamContent\" && t4 != \"scope\" && t4 != \"objId\" && t4.substring(0, 1) != \"_\";\n  });\n  for (var r2 in e2)\n    if (Object.getOwnPropertyDescriptor(this, e2[r2]).configurable === false) {\n      var n2 = e2[r2], i2 = this[n2];\n      i2 && (Array.isArray(i2) ? t3.push({ key: n2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ct ? (i2.scope = this.scope, t3.push({ key: n2, value: i2.objId + \" 0 R\" })) : typeof i2 != \"function\" && t3.push({ key: n2, value: i2 }));\n    }\n  return t3;\n};\nvar ut = function() {\n  ct.call(this), Object.defineProperty(this, \"Type\", { value: \"/XObject\", configurable: false, writable: true }), Object.defineProperty(this, \"Subtype\", { value: \"/Form\", configurable: false, writable: true }), Object.defineProperty(this, \"FormType\", { value: 1, configurable: false, writable: true });\n  var t3, e2 = [];\n  Object.defineProperty(this, \"BBox\", { configurable: false, get: function() {\n    return e2;\n  }, set: function(t4) {\n    e2 = t4;\n  } }), Object.defineProperty(this, \"Resources\", { value: \"2 0 R\", configurable: false, writable: true }), Object.defineProperty(this, \"stream\", { enumerable: false, configurable: true, set: function(e3) {\n    t3 = e3.trim();\n  }, get: function() {\n    return t3 || null;\n  } });\n};\nH(ut, ct);\nvar ht = function() {\n  ct.call(this);\n  var t3, e2 = [];\n  Object.defineProperty(this, \"Kids\", { enumerable: false, configurable: true, get: function() {\n    return e2.length > 0 ? e2 : void 0;\n  } }), Object.defineProperty(this, \"Fields\", { enumerable: false, configurable: false, get: function() {\n    return e2;\n  } }), Object.defineProperty(this, \"DA\", { enumerable: false, configurable: false, get: function() {\n    if (t3) {\n      var e3 = function(t4) {\n        return t4;\n      };\n      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), \"(\" + R(e3(t3)) + \")\";\n    }\n  }, set: function(e3) {\n    t3 = e3;\n  } });\n};\nH(ht, ct);\nvar lt = function t() {\n  ct.call(this);\n  var e2 = 4;\n  Object.defineProperty(this, \"F\", { enumerable: false, configurable: false, get: function() {\n    return e2;\n  }, set: function(t3) {\n    if (isNaN(t3))\n      throw new Error('Invalid value \"' + t3 + '\" for attribute F supplied.');\n    e2 = t3;\n  } }), Object.defineProperty(this, \"showWhenPrinted\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(e2, 3));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.F = K(e2, 3) : this.F = Z$2(e2, 3);\n  } });\n  var r2 = 0;\n  Object.defineProperty(this, \"Ff\", { enumerable: false, configurable: false, get: function() {\n    return r2;\n  }, set: function(t3) {\n    if (isNaN(t3))\n      throw new Error('Invalid value \"' + t3 + '\" for attribute Ff supplied.');\n    r2 = t3;\n  } });\n  var n2 = [];\n  Object.defineProperty(this, \"Rect\", { enumerable: false, configurable: false, get: function() {\n    if (n2.length !== 0)\n      return n2;\n  }, set: function(t3) {\n    n2 = t3 !== void 0 ? t3 : [];\n  } }), Object.defineProperty(this, \"x\", { enumerable: true, configurable: true, get: function() {\n    return !n2 || isNaN(n2[0]) ? 0 : n2[0];\n  }, set: function(t3) {\n    n2[0] = t3;\n  } }), Object.defineProperty(this, \"y\", { enumerable: true, configurable: true, get: function() {\n    return !n2 || isNaN(n2[1]) ? 0 : n2[1];\n  }, set: function(t3) {\n    n2[1] = t3;\n  } }), Object.defineProperty(this, \"width\", { enumerable: true, configurable: true, get: function() {\n    return !n2 || isNaN(n2[2]) ? 0 : n2[2];\n  }, set: function(t3) {\n    n2[2] = t3;\n  } }), Object.defineProperty(this, \"height\", { enumerable: true, configurable: true, get: function() {\n    return !n2 || isNaN(n2[3]) ? 0 : n2[3];\n  }, set: function(t3) {\n    n2[3] = t3;\n  } });\n  var i2 = \"\";\n  Object.defineProperty(this, \"FT\", { enumerable: true, configurable: false, get: function() {\n    return i2;\n  }, set: function(t3) {\n    switch (t3) {\n      case \"/Btn\":\n      case \"/Tx\":\n      case \"/Ch\":\n      case \"/Sig\":\n        i2 = t3;\n        break;\n      default:\n        throw new Error('Invalid value \"' + t3 + '\" for attribute FT supplied.');\n    }\n  } });\n  var a2 = null;\n  Object.defineProperty(this, \"T\", { enumerable: true, configurable: false, get: function() {\n    if (!a2 || a2.length < 1) {\n      if (this instanceof yt)\n        return;\n      a2 = \"FieldObject\" + t.FieldNum++;\n    }\n    var e3 = function(t3) {\n      return t3;\n    };\n    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), \"(\" + R(e3(a2)) + \")\";\n  }, set: function(t3) {\n    a2 = t3.toString();\n  } }), Object.defineProperty(this, \"fieldName\", { configurable: true, enumerable: true, get: function() {\n    return a2;\n  }, set: function(t3) {\n    a2 = t3;\n  } });\n  var o2 = \"helvetica\";\n  Object.defineProperty(this, \"fontName\", { enumerable: true, configurable: true, get: function() {\n    return o2;\n  }, set: function(t3) {\n    o2 = t3;\n  } });\n  var s2 = \"normal\";\n  Object.defineProperty(this, \"fontStyle\", { enumerable: true, configurable: true, get: function() {\n    return s2;\n  }, set: function(t3) {\n    s2 = t3;\n  } });\n  var c2 = 0;\n  Object.defineProperty(this, \"fontSize\", { enumerable: true, configurable: true, get: function() {\n    return c2;\n  }, set: function(t3) {\n    c2 = t3;\n  } });\n  var u2 = void 0;\n  Object.defineProperty(this, \"maxFontSize\", { enumerable: true, configurable: true, get: function() {\n    return u2 === void 0 ? 50 / D : u2;\n  }, set: function(t3) {\n    u2 = t3;\n  } });\n  var h2 = \"black\";\n  Object.defineProperty(this, \"color\", { enumerable: true, configurable: true, get: function() {\n    return h2;\n  }, set: function(t3) {\n    h2 = t3;\n  } });\n  var l2 = \"/F1 0 Tf 0 g\";\n  Object.defineProperty(this, \"DA\", { enumerable: true, configurable: false, get: function() {\n    if (!(!l2 || this instanceof yt || this instanceof Nt))\n      return st(l2, this.objId, this.scope);\n  }, set: function(t3) {\n    t3 = t3.toString(), l2 = t3;\n  } });\n  var f2 = null;\n  Object.defineProperty(this, \"DV\", { enumerable: false, configurable: false, get: function() {\n    if (f2)\n      return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;\n  }, set: function(t3) {\n    t3 = t3.toString(), f2 = this instanceof mt == false ? t3.substr(0, 1) === \"(\" ? T$2(t3.substr(1, t3.length - 2)) : T$2(t3) : t3;\n  } }), Object.defineProperty(this, \"defaultValue\", { enumerable: true, configurable: true, get: function() {\n    return this instanceof mt == true ? T$2(f2.substr(1, f2.length - 1)) : f2;\n  }, set: function(t3) {\n    t3 = t3.toString(), f2 = this instanceof mt == true ? \"/\" + t3 : t3;\n  } });\n  var d2 = null;\n  Object.defineProperty(this, \"_V\", { enumerable: false, configurable: false, get: function() {\n    if (d2)\n      return d2;\n  }, set: function(t3) {\n    this.V = t3;\n  } }), Object.defineProperty(this, \"V\", { enumerable: false, configurable: false, get: function() {\n    if (d2)\n      return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;\n  }, set: function(t3) {\n    t3 = t3.toString(), d2 = this instanceof mt == false ? t3.substr(0, 1) === \"(\" ? T$2(t3.substr(1, t3.length - 2)) : T$2(t3) : t3;\n  } }), Object.defineProperty(this, \"value\", { enumerable: true, configurable: true, get: function() {\n    return this instanceof mt == true ? T$2(d2.substr(1, d2.length - 1)) : d2;\n  }, set: function(t3) {\n    t3 = t3.toString(), d2 = this instanceof mt == true ? \"/\" + t3 : t3;\n  } }), Object.defineProperty(this, \"hasAnnotation\", { enumerable: true, configurable: true, get: function() {\n    return this.Rect;\n  } }), Object.defineProperty(this, \"Type\", { enumerable: true, configurable: false, get: function() {\n    return this.hasAnnotation ? \"/Annot\" : null;\n  } }), Object.defineProperty(this, \"Subtype\", { enumerable: true, configurable: false, get: function() {\n    return this.hasAnnotation ? \"/Widget\" : null;\n  } });\n  var p5, g2 = false;\n  Object.defineProperty(this, \"hasAppearanceStream\", { enumerable: true, configurable: true, get: function() {\n    return g2;\n  }, set: function(t3) {\n    t3 = Boolean(t3), g2 = t3;\n  } }), Object.defineProperty(this, \"page\", { enumerable: true, configurable: true, get: function() {\n    if (p5)\n      return p5;\n  }, set: function(t3) {\n    p5 = t3;\n  } }), Object.defineProperty(this, \"readOnly\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 1));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.Ff = K(this.Ff, 1) : this.Ff = Z$2(this.Ff, 1);\n  } }), Object.defineProperty(this, \"required\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 2));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.Ff = K(this.Ff, 2) : this.Ff = Z$2(this.Ff, 2);\n  } }), Object.defineProperty(this, \"noExport\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 3));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.Ff = K(this.Ff, 3) : this.Ff = Z$2(this.Ff, 3);\n  } });\n  var m2 = null;\n  Object.defineProperty(this, \"Q\", { enumerable: true, configurable: false, get: function() {\n    if (m2 !== null)\n      return m2;\n  }, set: function(t3) {\n    if ([0, 1, 2].indexOf(t3) === -1)\n      throw new Error('Invalid value \"' + t3 + '\" for attribute Q supplied.');\n    m2 = t3;\n  } }), Object.defineProperty(this, \"textAlign\", { get: function() {\n    var t3;\n    switch (m2) {\n      case 0:\n      default:\n        t3 = \"left\";\n        break;\n      case 1:\n        t3 = \"center\";\n        break;\n      case 2:\n        t3 = \"right\";\n    }\n    return t3;\n  }, configurable: true, enumerable: true, set: function(t3) {\n    switch (t3) {\n      case \"right\":\n      case 2:\n        m2 = 2;\n        break;\n      case \"center\":\n      case 1:\n        m2 = 1;\n        break;\n      case \"left\":\n      case 0:\n      default:\n        m2 = 0;\n    }\n  } });\n};\nH(lt, ct);\nvar ft = function() {\n  lt.call(this), this.FT = \"/Ch\", this.V = \"()\", this.fontName = \"zapfdingbats\";\n  var t3 = 0;\n  Object.defineProperty(this, \"TI\", { enumerable: true, configurable: false, get: function() {\n    return t3;\n  }, set: function(e3) {\n    t3 = e3;\n  } }), Object.defineProperty(this, \"topIndex\", { enumerable: true, configurable: true, get: function() {\n    return t3;\n  }, set: function(e3) {\n    t3 = e3;\n  } });\n  var e2 = [];\n  Object.defineProperty(this, \"Opt\", { enumerable: true, configurable: false, get: function() {\n    return ot(e2, this.objId, this.scope);\n  }, set: function(t4) {\n    var r2, n2;\n    n2 = [], typeof (r2 = t4) == \"string\" && (n2 = function(t5, e3, r3) {\n      r3 || (r3 = 1);\n      for (var n3, i2 = []; n3 = e3.exec(t5); )\n        i2.push(n3[r3]);\n      return i2;\n    }(r2, /\\((.*?)\\)/g)), e2 = n2;\n  } }), this.getOptions = function() {\n    return e2;\n  }, this.setOptions = function(t4) {\n    e2 = t4, this.sort && e2.sort();\n  }, this.addOption = function(t4) {\n    t4 = (t4 = t4 || \"\").toString(), e2.push(t4), this.sort && e2.sort();\n  }, this.removeOption = function(t4, r2) {\n    for (r2 = r2 || false, t4 = (t4 = t4 || \"\").toString(); e2.indexOf(t4) !== -1 && (e2.splice(e2.indexOf(t4), 1), r2 !== false); )\n      ;\n  }, Object.defineProperty(this, \"combo\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 18));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 18) : this.Ff = Z$2(this.Ff, 18);\n  } }), Object.defineProperty(this, \"edit\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 19));\n  }, set: function(t4) {\n    this.combo === true && (Boolean(t4) === true ? this.Ff = K(this.Ff, 19) : this.Ff = Z$2(this.Ff, 19));\n  } }), Object.defineProperty(this, \"sort\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 20));\n  }, set: function(t4) {\n    Boolean(t4) === true ? (this.Ff = K(this.Ff, 20), e2.sort()) : this.Ff = Z$2(this.Ff, 20);\n  } }), Object.defineProperty(this, \"multiSelect\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 22));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 22) : this.Ff = Z$2(this.Ff, 22);\n  } }), Object.defineProperty(this, \"doNotSpellCheck\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 23));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z$2(this.Ff, 23);\n  } }), Object.defineProperty(this, \"commitOnSelChange\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 27));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 27) : this.Ff = Z$2(this.Ff, 27);\n  } }), this.hasAppearanceStream = false;\n};\nH(ft, lt);\nvar dt = function() {\n  ft.call(this), this.fontName = \"helvetica\", this.combo = false;\n};\nH(dt, ft);\nvar pt = function() {\n  dt.call(this), this.combo = true;\n};\nH(pt, dt);\nvar gt = function() {\n  pt.call(this), this.edit = true;\n};\nH(gt, pt);\nvar mt = function() {\n  lt.call(this), this.FT = \"/Btn\", Object.defineProperty(this, \"noToggleToOff\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 15));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.Ff = K(this.Ff, 15) : this.Ff = Z$2(this.Ff, 15);\n  } }), Object.defineProperty(this, \"radio\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 16));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.Ff = K(this.Ff, 16) : this.Ff = Z$2(this.Ff, 16);\n  } }), Object.defineProperty(this, \"pushButton\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 17));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.Ff = K(this.Ff, 17) : this.Ff = Z$2(this.Ff, 17);\n  } }), Object.defineProperty(this, \"radioIsUnison\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 26));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z$2(this.Ff, 26);\n  } });\n  var e2, r2 = {};\n  Object.defineProperty(this, \"MK\", { enumerable: false, configurable: false, get: function() {\n    var t3 = function(t4) {\n      return t4;\n    };\n    if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), Object.keys(r2).length !== 0) {\n      var e3, n2 = [];\n      for (e3 in n2.push(\"<<\"), r2)\n        n2.push(\"/\" + e3 + \" (\" + R(t3(r2[e3])) + \")\");\n      return n2.push(\">>\"), n2.join(\"\\n\");\n    }\n  }, set: function(e3) {\n    _typeof$2(e3) === \"object\" && (r2 = e3);\n  } }), Object.defineProperty(this, \"caption\", { enumerable: true, configurable: true, get: function() {\n    return r2.CA || \"\";\n  }, set: function(t3) {\n    typeof t3 == \"string\" && (r2.CA = t3);\n  } }), Object.defineProperty(this, \"AS\", { enumerable: false, configurable: false, get: function() {\n    return e2;\n  }, set: function(t3) {\n    e2 = t3;\n  } }), Object.defineProperty(this, \"appearanceState\", { enumerable: true, configurable: true, get: function() {\n    return e2.substr(1, e2.length - 1);\n  }, set: function(t3) {\n    e2 = \"/\" + t3;\n  } });\n};\nH(mt, lt);\nvar vt = function() {\n  mt.call(this), this.pushButton = true;\n};\nH(vt, mt);\nvar bt = function() {\n  mt.call(this), this.radio = true, this.pushButton = false;\n  var t3 = [];\n  Object.defineProperty(this, \"Kids\", { enumerable: true, configurable: false, get: function() {\n    return t3;\n  }, set: function(e2) {\n    t3 = e2 !== void 0 ? e2 : [];\n  } });\n};\nH(bt, mt);\nvar yt = function() {\n  var e2, r2;\n  lt.call(this), Object.defineProperty(this, \"Parent\", { enumerable: false, configurable: false, get: function() {\n    return e2;\n  }, set: function(t3) {\n    e2 = t3;\n  } }), Object.defineProperty(this, \"optionName\", { enumerable: false, configurable: true, get: function() {\n    return r2;\n  }, set: function(t3) {\n    r2 = t3;\n  } });\n  var n2, i2 = {};\n  Object.defineProperty(this, \"MK\", { enumerable: false, configurable: false, get: function() {\n    var t3 = function(t4) {\n      return t4;\n    };\n    this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));\n    var e3, r3 = [];\n    for (e3 in r3.push(\"<<\"), i2)\n      r3.push(\"/\" + e3 + \" (\" + R(t3(i2[e3])) + \")\");\n    return r3.push(\">>\"), r3.join(\"\\n\");\n  }, set: function(e3) {\n    _typeof$2(e3) === \"object\" && (i2 = e3);\n  } }), Object.defineProperty(this, \"caption\", { enumerable: true, configurable: true, get: function() {\n    return i2.CA || \"\";\n  }, set: function(t3) {\n    typeof t3 == \"string\" && (i2.CA = t3);\n  } }), Object.defineProperty(this, \"AS\", { enumerable: false, configurable: false, get: function() {\n    return n2;\n  }, set: function(t3) {\n    n2 = t3;\n  } }), Object.defineProperty(this, \"appearanceState\", { enumerable: true, configurable: true, get: function() {\n    return n2.substr(1, n2.length - 1);\n  }, set: function(t3) {\n    n2 = \"/\" + t3;\n  } }), this.caption = \"l\", this.appearanceState = \"Off\", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);\n};\nH(yt, lt), bt.prototype.setAppearance = function(t3) {\n  if (!(\"createAppearanceStream\" in t3) || !(\"getCA\" in t3))\n    throw new Error(\"Couldn't assign Appearance to RadioButton. Appearance was Invalid!\");\n  for (var e2 in this.Kids)\n    if (this.Kids.hasOwnProperty(e2)) {\n      var r2 = this.Kids[e2];\n      r2.appearanceStreamContent = t3.createAppearanceStream(r2.optionName), r2.caption = t3.getCA();\n    }\n}, bt.prototype.createOption = function(t3) {\n  var e2 = new yt();\n  return e2.Parent = this, e2.optionName = t3, this.Kids.push(e2), xt.call(this.scope, e2), e2;\n};\nvar wt = function() {\n  mt.call(this), this.fontName = \"zapfdingbats\", this.caption = \"3\", this.appearanceState = \"On\", this.value = \"On\", this.textAlign = \"center\", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();\n};\nH(wt, mt);\nvar Nt = function() {\n  lt.call(this), this.FT = \"/Tx\", Object.defineProperty(this, \"multiline\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 13));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 13) : this.Ff = Z$2(this.Ff, 13);\n  } }), Object.defineProperty(this, \"fileSelect\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 21));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 21) : this.Ff = Z$2(this.Ff, 21);\n  } }), Object.defineProperty(this, \"doNotSpellCheck\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 23));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z$2(this.Ff, 23);\n  } }), Object.defineProperty(this, \"doNotScroll\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 24));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 24) : this.Ff = Z$2(this.Ff, 24);\n  } }), Object.defineProperty(this, \"comb\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 25));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 25) : this.Ff = Z$2(this.Ff, 25);\n  } }), Object.defineProperty(this, \"richText\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 26));\n  }, set: function(t4) {\n    Boolean(t4) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z$2(this.Ff, 26);\n  } });\n  var t3 = null;\n  Object.defineProperty(this, \"MaxLen\", { enumerable: true, configurable: false, get: function() {\n    return t3;\n  }, set: function(e2) {\n    t3 = e2;\n  } }), Object.defineProperty(this, \"maxLength\", { enumerable: true, configurable: true, get: function() {\n    return t3;\n  }, set: function(e2) {\n    Number.isInteger(e2) && (t3 = e2);\n  } }), Object.defineProperty(this, \"hasAppearanceStream\", { enumerable: true, configurable: true, get: function() {\n    return this.V || this.DV;\n  } });\n};\nH(Nt, lt);\nvar Lt = function() {\n  Nt.call(this), Object.defineProperty(this, \"password\", { enumerable: true, configurable: true, get: function() {\n    return Boolean(X(this.Ff, 14));\n  }, set: function(t3) {\n    Boolean(t3) === true ? this.Ff = K(this.Ff, 14) : this.Ff = Z$2(this.Ff, 14);\n  } }), this.password = true;\n};\nH(Lt, Nt);\nvar At = { CheckBox: { createAppearanceStream: function() {\n  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };\n}, YesPushDown: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = [], n2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, i2 = t3.scope.__private__.encodeColorString(t3.color), a2 = tt(t3, t3.caption);\n  return r2.push(\"0.749023 g\"), r2.push(\"0 0 \" + z$1(At.internal.getWidth(t3)) + \" \" + z$1(At.internal.getHeight(t3)) + \" re\"), r2.push(\"f\"), r2.push(\"BMC\"), r2.push(\"q\"), r2.push(\"0 0 1 rg\"), r2.push(\"/\" + n2 + \" \" + z$1(a2.fontSize) + \" Tf \" + i2), r2.push(\"BT\"), r2.push(a2.text), r2.push(\"ET\"), r2.push(\"Q\"), r2.push(\"EMC\"), e2.stream = r2.join(\"\\n\"), e2;\n}, YesNormal: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, n2 = t3.scope.__private__.encodeColorString(t3.color), i2 = [], a2 = At.internal.getHeight(t3), o2 = At.internal.getWidth(t3), s2 = tt(t3, t3.caption);\n  return i2.push(\"1 g\"), i2.push(\"0 0 \" + z$1(o2) + \" \" + z$1(a2) + \" re\"), i2.push(\"f\"), i2.push(\"q\"), i2.push(\"0 0 1 rg\"), i2.push(\"0 0 \" + z$1(o2 - 1) + \" \" + z$1(a2 - 1) + \" re\"), i2.push(\"W\"), i2.push(\"n\"), i2.push(\"0 g\"), i2.push(\"BT\"), i2.push(\"/\" + r2 + \" \" + z$1(s2.fontSize) + \" Tf \" + n2), i2.push(s2.text), i2.push(\"ET\"), i2.push(\"Q\"), e2.stream = i2.join(\"\\n\"), e2;\n}, OffPushDown: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = [];\n  return r2.push(\"0.749023 g\"), r2.push(\"0 0 \" + z$1(At.internal.getWidth(t3)) + \" \" + z$1(At.internal.getHeight(t3)) + \" re\"), r2.push(\"f\"), e2.stream = r2.join(\"\\n\"), e2;\n} }, RadioButton: { Circle: { createAppearanceStream: function(t3) {\n  var e2 = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };\n  return e2.N[t3] = At.RadioButton.Circle.YesNormal, e2.D[t3] = At.RadioButton.Circle.YesPushDown, e2;\n}, getCA: function() {\n  return \"l\";\n}, YesNormal: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;\n  n2 = Number((0.9 * n2).toFixed(5));\n  var i2 = At.internal.Bezier_C, a2 = Number((n2 * i2).toFixed(5));\n  return r2.push(\"q\"), r2.push(\"1 0 0 1 \" + U$1(At.internal.getWidth(t3) / 2) + \" \" + U$1(At.internal.getHeight(t3) / 2) + \" cm\"), r2.push(n2 + \" 0 m\"), r2.push(n2 + \" \" + a2 + \" \" + a2 + \" \" + n2 + \" 0 \" + n2 + \" c\"), r2.push(\"-\" + a2 + \" \" + n2 + \" -\" + n2 + \" \" + a2 + \" -\" + n2 + \" 0 c\"), r2.push(\"-\" + n2 + \" -\" + a2 + \" -\" + a2 + \" -\" + n2 + \" 0 -\" + n2 + \" c\"), r2.push(a2 + \" -\" + n2 + \" \" + n2 + \" -\" + a2 + \" \" + n2 + \" 0 c\"), r2.push(\"f\"), r2.push(\"Q\"), e2.stream = r2.join(\"\\n\"), e2;\n}, YesPushDown: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;\n  n2 = Number((0.9 * n2).toFixed(5));\n  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));\n  return r2.push(\"0.749023 g\"), r2.push(\"q\"), r2.push(\"1 0 0 1 \" + U$1(At.internal.getWidth(t3) / 2) + \" \" + U$1(At.internal.getHeight(t3) / 2) + \" cm\"), r2.push(i2 + \" 0 m\"), r2.push(i2 + \" \" + a2 + \" \" + a2 + \" \" + i2 + \" 0 \" + i2 + \" c\"), r2.push(\"-\" + a2 + \" \" + i2 + \" -\" + i2 + \" \" + a2 + \" -\" + i2 + \" 0 c\"), r2.push(\"-\" + i2 + \" -\" + a2 + \" -\" + a2 + \" -\" + i2 + \" 0 -\" + i2 + \" c\"), r2.push(a2 + \" -\" + i2 + \" \" + i2 + \" -\" + a2 + \" \" + i2 + \" 0 c\"), r2.push(\"f\"), r2.push(\"Q\"), r2.push(\"0 g\"), r2.push(\"q\"), r2.push(\"1 0 0 1 \" + U$1(At.internal.getWidth(t3) / 2) + \" \" + U$1(At.internal.getHeight(t3) / 2) + \" cm\"), r2.push(n2 + \" 0 m\"), r2.push(n2 + \" \" + o2 + \" \" + o2 + \" \" + n2 + \" 0 \" + n2 + \" c\"), r2.push(\"-\" + o2 + \" \" + n2 + \" -\" + n2 + \" \" + o2 + \" -\" + n2 + \" 0 c\"), r2.push(\"-\" + n2 + \" -\" + o2 + \" -\" + o2 + \" -\" + n2 + \" 0 -\" + n2 + \" c\"), r2.push(o2 + \" -\" + n2 + \" \" + n2 + \" -\" + o2 + \" \" + n2 + \" 0 c\"), r2.push(\"f\"), r2.push(\"Q\"), e2.stream = r2.join(\"\\n\"), e2;\n}, OffPushDown: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;\n  n2 = Number((0.9 * n2).toFixed(5));\n  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5));\n  return r2.push(\"0.749023 g\"), r2.push(\"q\"), r2.push(\"1 0 0 1 \" + U$1(At.internal.getWidth(t3) / 2) + \" \" + U$1(At.internal.getHeight(t3) / 2) + \" cm\"), r2.push(i2 + \" 0 m\"), r2.push(i2 + \" \" + a2 + \" \" + a2 + \" \" + i2 + \" 0 \" + i2 + \" c\"), r2.push(\"-\" + a2 + \" \" + i2 + \" -\" + i2 + \" \" + a2 + \" -\" + i2 + \" 0 c\"), r2.push(\"-\" + i2 + \" -\" + a2 + \" -\" + a2 + \" -\" + i2 + \" 0 -\" + i2 + \" c\"), r2.push(a2 + \" -\" + i2 + \" \" + i2 + \" -\" + a2 + \" \" + i2 + \" 0 c\"), r2.push(\"f\"), r2.push(\"Q\"), e2.stream = r2.join(\"\\n\"), e2;\n} }, Cross: { createAppearanceStream: function(t3) {\n  var e2 = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };\n  return e2.N[t3] = At.RadioButton.Cross.YesNormal, e2.D[t3] = At.RadioButton.Cross.YesPushDown, e2;\n}, getCA: function() {\n  return \"8\";\n}, YesNormal: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = [], n2 = At.internal.calculateCross(t3);\n  return r2.push(\"q\"), r2.push(\"1 1 \" + z$1(At.internal.getWidth(t3) - 2) + \" \" + z$1(At.internal.getHeight(t3) - 2) + \" re\"), r2.push(\"W\"), r2.push(\"n\"), r2.push(z$1(n2.x1.x) + \" \" + z$1(n2.x1.y) + \" m\"), r2.push(z$1(n2.x2.x) + \" \" + z$1(n2.x2.y) + \" l\"), r2.push(z$1(n2.x4.x) + \" \" + z$1(n2.x4.y) + \" m\"), r2.push(z$1(n2.x3.x) + \" \" + z$1(n2.x3.y) + \" l\"), r2.push(\"s\"), r2.push(\"Q\"), e2.stream = r2.join(\"\\n\"), e2;\n}, YesPushDown: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = At.internal.calculateCross(t3), n2 = [];\n  return n2.push(\"0.749023 g\"), n2.push(\"0 0 \" + z$1(At.internal.getWidth(t3)) + \" \" + z$1(At.internal.getHeight(t3)) + \" re\"), n2.push(\"f\"), n2.push(\"q\"), n2.push(\"1 1 \" + z$1(At.internal.getWidth(t3) - 2) + \" \" + z$1(At.internal.getHeight(t3) - 2) + \" re\"), n2.push(\"W\"), n2.push(\"n\"), n2.push(z$1(r2.x1.x) + \" \" + z$1(r2.x1.y) + \" m\"), n2.push(z$1(r2.x2.x) + \" \" + z$1(r2.x2.y) + \" l\"), n2.push(z$1(r2.x4.x) + \" \" + z$1(r2.x4.y) + \" m\"), n2.push(z$1(r2.x3.x) + \" \" + z$1(r2.x3.y) + \" l\"), n2.push(\"s\"), n2.push(\"Q\"), e2.stream = n2.join(\"\\n\"), e2;\n}, OffPushDown: function(t3) {\n  var e2 = V$1(t3);\n  e2.scope = t3.scope;\n  var r2 = [];\n  return r2.push(\"0.749023 g\"), r2.push(\"0 0 \" + z$1(At.internal.getWidth(t3)) + \" \" + z$1(At.internal.getHeight(t3)) + \" re\"), r2.push(\"f\"), e2.stream = r2.join(\"\\n\"), e2;\n} } }, createDefaultAppearanceStream: function(t3) {\n  var e2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, r2 = t3.scope.__private__.encodeColorString(t3.color);\n  return \"/\" + e2 + \" \" + t3.fontSize + \" Tf \" + r2;\n} };\nAt.internal = { Bezier_C: 0.551915024494, calculateCross: function(t3) {\n  var e2 = At.internal.getWidth(t3), r2 = At.internal.getHeight(t3), n2 = Math.min(e2, r2);\n  return { x1: { x: (e2 - n2) / 2, y: (r2 - n2) / 2 + n2 }, x2: { x: (e2 - n2) / 2 + n2, y: (r2 - n2) / 2 }, x3: { x: (e2 - n2) / 2, y: (r2 - n2) / 2 }, x4: { x: (e2 - n2) / 2 + n2, y: (r2 - n2) / 2 + n2 } };\n} }, At.internal.getWidth = function(e2) {\n  var r2 = 0;\n  return _typeof$2(e2) === \"object\" && (r2 = W(e2.Rect[2])), r2;\n}, At.internal.getHeight = function(e2) {\n  var r2 = 0;\n  return _typeof$2(e2) === \"object\" && (r2 = W(e2.Rect[3])), r2;\n};\nvar xt = q.addField = function(t3) {\n  if (at(this, t3), !(t3 instanceof lt))\n    throw new Error(\"Invalid argument passed to jsPDF.addField.\");\n  var e2;\n  return (e2 = t3).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t3.page = t3.scope.internal.getCurrentPageInfo().pageNumber, this;\n};\nq.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E$1.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };\nE$1.AcroForm;\nfunction _t(t3) {\n  return t3.reduce(function(t4, e2, r2) {\n    return t4[e2] = r2, t4;\n  }, {});\n}\n!function(e2) {\n  e2.__addimage__ = {};\n  var r2 = \"UNKNOWN\", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i2 = e2.__addimage__.getImageFileTypeByImageData = function(t3, e3) {\n    var i3, a3, o3, s3, c3, u2 = r2;\n    if ((e3 = e3 || r2) === \"RGBA\" || t3.data !== void 0 && t3.data instanceof Uint8ClampedArray && \"height\" in t3 && \"width\" in t3)\n      return \"RGBA\";\n    if (x2(t3))\n      for (c3 in n2)\n        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {\n          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)\n            if (o3[i3][a3] !== void 0 && o3[i3][a3] !== t3[a3]) {\n              s3 = false;\n              break;\n            }\n          if (s3 === true) {\n            u2 = c3;\n            break;\n          }\n        }\n    else\n      for (c3 in n2)\n        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {\n          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)\n            if (o3[i3][a3] !== void 0 && o3[i3][a3] !== t3.charCodeAt(a3)) {\n              s3 = false;\n              break;\n            }\n          if (s3 === true) {\n            u2 = c3;\n            break;\n          }\n        }\n    return u2 === r2 && e3 !== r2 && (u2 = e3), u2;\n  }, a2 = function t3(e3) {\n    for (var r3 = this.internal.write, n3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); i3.indexOf(\"FlateEncode\") !== -1; )\n      i3.splice(i3.indexOf(\"FlateEncode\"), 1);\n    e3.objectId = this.internal.newObject();\n    var a3 = [];\n    if (a3.push({ key: \"Type\", value: \"/XObject\" }), a3.push({ key: \"Subtype\", value: \"/Image\" }), a3.push({ key: \"Width\", value: e3.width }), a3.push({ key: \"Height\", value: e3.height }), e3.colorSpace === b2.INDEXED ? a3.push({ key: \"ColorSpace\", value: \"[/Indexed /DeviceRGB \" + (e3.palette.length / 3 - 1) + \" \" + (\"sMask\" in e3 && e3.sMask !== void 0 ? e3.objectId + 2 : e3.objectId + 1) + \" 0 R]\" }) : (a3.push({ key: \"ColorSpace\", value: \"/\" + e3.colorSpace }), e3.colorSpace === b2.DEVICE_CMYK && a3.push({ key: \"Decode\", value: \"[1 0 1 0 1 0 1 0]\" })), a3.push({ key: \"BitsPerComponent\", value: e3.bitsPerComponent }), \"decodeParameters\" in e3 && e3.decodeParameters !== void 0 && a3.push({ key: \"DecodeParms\", value: \"<<\" + e3.decodeParameters + \">>\" }), \"transparency\" in e3 && Array.isArray(e3.transparency)) {\n      for (var o3 = \"\", s3 = 0, c3 = e3.transparency.length; s3 < c3; s3++)\n        o3 += e3.transparency[s3] + \" \" + e3.transparency[s3] + \" \";\n      a3.push({ key: \"Mask\", value: \"[\" + o3 + \"]\" });\n    }\n    e3.sMask !== void 0 && a3.push({ key: \"SMask\", value: e3.objectId + 1 + \" 0 R\" });\n    var u2 = e3.filter !== void 0 ? [\"/\" + e3.filter] : void 0;\n    if (n3({ data: e3.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e3.objectId }), r3(\"endobj\"), \"sMask\" in e3 && e3.sMask !== void 0) {\n      var h3 = \"/Predictor \" + e3.predictor + \" /Colors 1 /BitsPerComponent \" + e3.bitsPerComponent + \" /Columns \" + e3.width, l3 = { width: e3.width, height: e3.height, colorSpace: \"DeviceGray\", bitsPerComponent: e3.bitsPerComponent, decodeParameters: h3, data: e3.sMask };\n      \"filter\" in e3 && (l3.filter = e3.filter), t3.call(this, l3);\n    }\n    if (e3.colorSpace === b2.INDEXED) {\n      var f3 = this.internal.newObject();\n      n3({ data: _2(new Uint8Array(e3.palette)), objectId: f3 }), r3(\"endobj\");\n    }\n  }, o2 = function() {\n    var t3 = this.internal.collections.addImage_images;\n    for (var e3 in t3)\n      a2.call(this, t3[e3]);\n  }, s2 = function() {\n    var t3, e3 = this.internal.collections.addImage_images, r3 = this.internal.write;\n    for (var n3 in e3)\n      r3(\"/I\" + (t3 = e3[n3]).index, t3.objectId, \"0\", \"R\");\n  }, c2 = function() {\n    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe(\"putResources\", o2), this.internal.events.subscribe(\"putXobjectDict\", s2));\n  }, h2 = function() {\n    var t3 = this.internal.collections.addImage_images;\n    return c2.call(this), t3;\n  }, l2 = function() {\n    return Object.keys(this.internal.collections.addImage_images).length;\n  }, f2 = function(t3) {\n    return typeof e2[\"process\" + t3.toUpperCase()] == \"function\";\n  }, d2 = function(e3) {\n    return _typeof$2(e3) === \"object\" && e3.nodeType === 1;\n  }, p5 = function(t3, r3) {\n    if (t3.nodeName === \"IMG\" && t3.hasAttribute(\"src\")) {\n      var n3 = \"\" + t3.getAttribute(\"src\");\n      if (n3.indexOf(\"data:image/\") === 0)\n        return u$2(unescape(n3).split(\"base64,\").pop());\n      var i3 = e2.loadFile(n3, true);\n      if (i3 !== void 0)\n        return i3;\n    }\n    if (t3.nodeName === \"CANVAS\") {\n      if (t3.width === 0 || t3.height === 0)\n        throw new Error(\"Given canvas must have data. Canvas width: \" + t3.width + \", height: \" + t3.height);\n      var a3;\n      switch (r3) {\n        case \"PNG\":\n          a3 = \"image/png\";\n          break;\n        case \"WEBP\":\n          a3 = \"image/webp\";\n          break;\n        case \"JPEG\":\n        case \"JPG\":\n        default:\n          a3 = \"image/jpeg\";\n      }\n      return u$2(t3.toDataURL(a3, 1).split(\"base64,\").pop());\n    }\n  }, g2 = function(t3) {\n    var e3 = this.internal.collections.addImage_images;\n    if (e3) {\n      for (var r3 in e3)\n        if (t3 === e3[r3].alias)\n          return e3[r3];\n    }\n  }, m2 = function(t3, e3, r3) {\n    return t3 || e3 || (t3 = -96, e3 = -96), t3 < 0 && (t3 = -1 * r3.width * 72 / t3 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r3.height * 72 / e3 / this.internal.scaleFactor), t3 === 0 && (t3 = e3 * r3.width / r3.height), e3 === 0 && (e3 = t3 * r3.height / r3.width), [t3, e3];\n  }, v2 = function(t3, e3, r3, n3, i3, a3) {\n    var o3 = m2.call(this, r3, n3, i3), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);\n    if (r3 = o3[0], n3 = o3[1], u2[i3.index] = i3, a3) {\n      a3 *= Math.PI / 180;\n      var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = function(t4) {\n        return t4.toFixed(4);\n      }, p6 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, \"cm\"];\n    }\n    this.internal.write(\"q\"), a3 ? (this.internal.write([1, \"0\", \"0\", 1, s3(t3), c3(e3 + n3), \"cm\"].join(\" \")), this.internal.write(p6.join(\" \")), this.internal.write([s3(r3), \"0\", \"0\", s3(n3), \"0\", \"0\", \"cm\"].join(\" \"))) : this.internal.write([s3(r3), \"0\", \"0\", s3(n3), s3(t3), c3(e3 + n3), \"cm\"].join(\" \")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, \"cm\"].join(\" \")), this.internal.write(\"/I\" + i3.index + \" Do\"), this.internal.write(\"Q\");\n  }, b2 = e2.color_spaces = { DEVICE_RGB: \"DeviceRGB\", DEVICE_GRAY: \"DeviceGray\", DEVICE_CMYK: \"DeviceCMYK\", CAL_GREY: \"CalGray\", CAL_RGB: \"CalRGB\", LAB: \"Lab\", ICC_BASED: \"ICCBased\", INDEXED: \"Indexed\", PATTERN: \"Pattern\", SEPARATION: \"Separation\", DEVICE_N: \"DeviceN\" };\n  e2.decode = { DCT_DECODE: \"DCTDecode\", FLATE_DECODE: \"FlateDecode\", LZW_DECODE: \"LZWDecode\", JPX_DECODE: \"JPXDecode\", JBIG2_DECODE: \"JBIG2Decode\", ASCII85_DECODE: \"ASCII85Decode\", ASCII_HEX_DECODE: \"ASCIIHexDecode\", RUN_LENGTH_DECODE: \"RunLengthDecode\", CCITT_FAX_DECODE: \"CCITTFaxDecode\" };\n  var y2 = e2.image_compression = { NONE: \"NONE\", FAST: \"FAST\", MEDIUM: \"MEDIUM\", SLOW: \"SLOW\" }, w2 = e2.__addimage__.sHashCode = function(t3) {\n    var e3, r3, n3 = 0;\n    if (typeof t3 == \"string\")\n      for (r3 = t3.length, e3 = 0; e3 < r3; e3++)\n        n3 = (n3 << 5) - n3 + t3.charCodeAt(e3), n3 |= 0;\n    else if (x2(t3))\n      for (r3 = t3.byteLength / 2, e3 = 0; e3 < r3; e3++)\n        n3 = (n3 << 5) - n3 + t3[e3], n3 |= 0;\n    return n3;\n  }, N2 = e2.__addimage__.validateStringAsBase64 = function(t3) {\n    (t3 = t3 || \"\").toString().trim();\n    var e3 = true;\n    return t3.length === 0 && (e3 = false), t3.length % 4 != 0 && (e3 = false), /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) === false && (e3 = false), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) === false && (e3 = false), e3;\n  }, L2 = e2.__addimage__.extractImageFromDataUrl = function(t3) {\n    var e3 = (t3 = t3 || \"\").split(\"base64,\"), r3 = null;\n    if (e3.length === 2) {\n      var n3 = /^data:(\\w*\\/\\w*);*(charset=(?!charset=)[\\w=-]*)*;*$/.exec(e3[0]);\n      Array.isArray(n3) && (r3 = { mimeType: n3[1], charset: n3[2], data: e3[1] });\n    }\n    return r3;\n  }, A2 = e2.__addimage__.supportsArrayBuffer = function() {\n    return typeof ArrayBuffer != \"undefined\" && typeof Uint8Array != \"undefined\";\n  };\n  e2.__addimage__.isArrayBuffer = function(t3) {\n    return A2() && t3 instanceof ArrayBuffer;\n  };\n  var x2 = e2.__addimage__.isArrayBufferView = function(t3) {\n    return A2() && typeof Uint32Array != \"undefined\" && (t3 instanceof Int8Array || t3 instanceof Uint8Array || typeof Uint8ClampedArray != \"undefined\" && t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array);\n  }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t3) {\n    for (var e3 = t3.length, r3 = new Uint8Array(e3), n3 = 0; n3 < e3; n3++)\n      r3[n3] = t3.charCodeAt(n3);\n    return r3;\n  }, _2 = e2.__addimage__.arrayBufferToBinaryString = function(t3) {\n    for (var e3 = \"\", r3 = x2(t3) ? t3 : new Uint8Array(t3), n3 = 0; n3 < r3.length; n3 += 8192)\n      e3 += String.fromCharCode.apply(null, r3.subarray(n3, n3 + 8192));\n    return e3;\n  };\n  e2.addImage = function() {\n    var e3, n3, i3, a3, o3, s3, u2, h3, l3;\n    if (typeof arguments[1] == \"number\" ? (n3 = r2, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), _typeof$2(e3 = arguments[0]) === \"object\" && !d2(e3) && \"imageData\" in e3) {\n      var f3 = e3;\n      e3 = f3.imageData, n3 = f3.format || n3 || r2, i3 = f3.x || i3 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;\n    }\n    var p6 = this.internal.getFilters();\n    if (h3 === void 0 && p6.indexOf(\"FlateEncode\") !== -1 && (h3 = \"SLOW\"), isNaN(i3) || isNaN(a3))\n      throw new Error(\"Invalid coordinates passed to jsPDF.addImage\");\n    c2.call(this);\n    var g3 = P2.call(this, e3, n3, u2, h3);\n    return v2.call(this, i3, a3, o3, s3, g3, l3), this;\n  };\n  var P2 = function(t3, n3, a3, o3) {\n    var s3, c3, u2;\n    if (typeof t3 == \"string\" && i2(t3) === r2) {\n      t3 = unescape(t3);\n      var h3 = k2(t3, false);\n      (h3 !== \"\" || (h3 = e2.loadFile(t3, true)) !== void 0) && (t3 = h3);\n    }\n    if (d2(t3) && (t3 = p5(t3, n3)), n3 = i2(t3, n3), !f2(n3))\n      throw new Error(\"addImage does not support files of type '\" + n3 + \"', please ensure that a plugin for '\" + n3 + \"' support is added.\");\n    if (((u2 = a3) == null || u2.length === 0) && (a3 = function(t4) {\n      return typeof t4 == \"string\" || x2(t4) ? w2(t4) : x2(t4.data) ? w2(t4.data) : null;\n    }(t3)), (s3 = g2.call(this, a3)) || (A2() && (t3 instanceof Uint8Array || n3 === \"RGBA\" || (c3 = t3, t3 = S2(t3))), s3 = this[\"process\" + n3.toUpperCase()](t3, l2.call(this), a3, function(t4) {\n      return t4 && typeof t4 == \"string\" && (t4 = t4.toUpperCase()), t4 in e2.image_compression ? t4 : y2.NONE;\n    }(o3), c3)), !s3)\n      throw new Error(\"An unknown error occurred whilst processing the image.\");\n    return s3;\n  }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t3, e3) {\n    var r3;\n    e3 = typeof e3 != \"boolean\" || e3;\n    var n3, i3 = \"\";\n    if (typeof t3 == \"string\") {\n      n3 = (r3 = L2(t3)) !== null ? r3.data : t3;\n      try {\n        i3 = u$2(n3);\n      } catch (t4) {\n        if (e3)\n          throw N2(n3) ? new Error(\"atob-Error in jsPDF.convertBase64ToBinaryString \" + t4.message) : new Error(\"Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString \");\n      }\n    }\n    return i3;\n  };\n  e2.getImageProperties = function(t3) {\n    var n3, a3, o3 = \"\";\n    if (d2(t3) && (t3 = p5(t3)), typeof t3 == \"string\" && i2(t3) === r2 && ((o3 = k2(t3, false)) === \"\" && (o3 = e2.loadFile(t3) || \"\"), t3 = o3), a3 = i2(t3), !f2(a3))\n      throw new Error(\"addImage does not support files of type '\" + a3 + \"', please ensure that a plugin for '\" + a3 + \"' support is added.\");\n    if (!A2() || t3 instanceof Uint8Array || (t3 = S2(t3)), !(n3 = this[\"process\" + a3.toUpperCase()](t3)))\n      throw new Error(\"An unknown error occurred whilst processing the image\");\n    return n3.fileType = a3, n3;\n  };\n}(E$1.API), function(t3) {\n  var e2 = function(t4) {\n    if (t4 !== void 0 && t4 != \"\")\n      return true;\n  };\n  E$1.API.events.push([\"addPage\", function(t4) {\n    this.internal.getPageInfo(t4.pageNumber).pageContext.annotations = [];\n  }]), t3.events.push([\"putPage\", function(t4) {\n    for (var r2, n2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t4.objId), c2 = t4.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++)\n      switch ((r2 = c2[h2]).type) {\n        case \"link\":\n          (e2(r2.options.url) || e2(r2.options.pageNumber)) && (u2 = true);\n          break;\n        case \"reference\":\n        case \"text\":\n        case \"freetext\":\n          u2 = true;\n      }\n    if (u2 != 0) {\n      this.internal.write(\"/Annots [\");\n      for (var l2 = 0; l2 < c2.length; l2++) {\n        r2 = c2[l2];\n        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t4.objId);\n        switch (r2.type) {\n          case \"reference\":\n            this.internal.write(\" \" + r2.object.objId + \" 0 R \");\n            break;\n          case \"text\":\n            var p5 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p5.objId), v2 = r2.title || \"Note\";\n            i2 = \"<</Type /Annot /Subtype /Text \" + (n2 = \"/Rect [\" + a2(r2.bounds.x) + \" \" + o2(r2.bounds.y + r2.bounds.h) + \" \" + a2(r2.bounds.x + r2.bounds.w) + \" \" + o2(r2.bounds.y) + \"] \") + \"/Contents (\" + f2(m2(r2.contents)) + \")\", i2 += \" /Popup \" + g2.objId + \" 0 R\", i2 += \" /P \" + s2.objId + \" 0 R\", i2 += \" /T (\" + f2(m2(v2)) + \") >>\", p5.content = i2;\n            var b2 = p5.objId + \" 0 R\";\n            i2 = \"<</Type /Annot /Subtype /Popup \" + (n2 = \"/Rect [\" + a2(r2.bounds.x + 30) + \" \" + o2(r2.bounds.y + r2.bounds.h) + \" \" + a2(r2.bounds.x + r2.bounds.w + 30) + \" \" + o2(r2.bounds.y) + \"] \") + \" /Parent \" + b2, r2.open && (i2 += \" /Open true\"), i2 += \" >>\", g2.content = i2, this.internal.write(p5.objId, \"0 R\", g2.objId, \"0 R\");\n            break;\n          case \"freetext\":\n            n2 = \"/Rect [\" + a2(r2.bounds.x) + \" \" + o2(r2.bounds.y) + \" \" + a2(r2.bounds.x + r2.bounds.w) + \" \" + o2(r2.bounds.y + r2.bounds.h) + \"] \";\n            var y2 = r2.color || \"#000000\";\n            i2 = \"<</Type /Annot /Subtype /FreeText \" + n2 + \"/Contents (\" + f2(d2(r2.contents)) + \")\", i2 += \" /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#\" + y2 + \")\", i2 += \" /Border [0 0 0]\", i2 += \" >>\", this.internal.write(i2);\n            break;\n          case \"link\":\n            if (r2.options.name) {\n              var w2 = this.annotations._nameMap[r2.options.name];\n              r2.options.pageNumber = w2.page, r2.options.top = w2.y;\n            } else\n              r2.options.top || (r2.options.top = 0);\n            if (n2 = \"/Rect [\" + r2.finalBounds.x + \" \" + r2.finalBounds.y + \" \" + r2.finalBounds.w + \" \" + r2.finalBounds.h + \"] \", i2 = \"\", r2.options.url)\n              i2 = \"<</Type /Annot /Subtype /Link \" + n2 + \"/Border [0 0 0] /A <</S /URI /URI (\" + f2(d2(r2.options.url)) + \") >>\";\n            else if (r2.options.pageNumber) {\n              switch (i2 = \"<</Type /Annot /Subtype /Link \" + n2 + \"/Border [0 0 0] /Dest [\" + this.internal.getPageInfo(r2.options.pageNumber).objId + \" 0 R\", r2.options.magFactor = r2.options.magFactor || \"XYZ\", r2.options.magFactor) {\n                case \"Fit\":\n                  i2 += \" /Fit]\";\n                  break;\n                case \"FitH\":\n                  i2 += \" /FitH \" + r2.options.top + \"]\";\n                  break;\n                case \"FitV\":\n                  r2.options.left = r2.options.left || 0, i2 += \" /FitV \" + r2.options.left + \"]\";\n                  break;\n                case \"XYZ\":\n                default:\n                  var N2 = o2(r2.options.top);\n                  r2.options.left = r2.options.left || 0, r2.options.zoom === void 0 && (r2.options.zoom = 0), i2 += \" /XYZ \" + r2.options.left + \" \" + N2 + \" \" + r2.options.zoom + \"]\";\n              }\n            }\n            i2 != \"\" && (i2 += \" >>\", this.internal.write(i2));\n        }\n      }\n      this.internal.write(\"]\");\n    }\n  }]), t3.createAnnotation = function(t4) {\n    var e3 = this.internal.getCurrentPageInfo();\n    switch (t4.type) {\n      case \"link\":\n        this.link(t4.bounds.x, t4.bounds.y, t4.bounds.w, t4.bounds.h, t4);\n        break;\n      case \"text\":\n      case \"freetext\":\n        e3.pageContext.annotations.push(t4);\n    }\n  }, t3.link = function(t4, e3, r2, n2, i2) {\n    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;\n    a2.pageContext.annotations.push({ finalBounds: { x: o2(t4), y: s2(e3), w: o2(t4 + r2), h: s2(e3 + n2) }, options: i2, type: \"link\" });\n  }, t3.textWithLink = function(t4, e3, r2, n2) {\n    var i2, a2, o2 = this.getTextWidth(t4), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;\n    if (n2.maxWidth !== void 0) {\n      a2 = n2.maxWidth;\n      var c2 = this.splitTextToSize(t4, a2).length;\n      i2 = Math.ceil(s2 * c2);\n    } else\n      a2 = o2, i2 = s2;\n    return this.text(t4, e3, r2, n2), r2 += 0.2 * s2, n2.align === \"center\" && (e3 -= o2 / 2), n2.align === \"right\" && (e3 -= o2), this.link(e3, r2 - s2, a2, i2, n2), o2;\n  }, t3.getTextWidth = function(t4) {\n    var e3 = this.internal.getFontSize();\n    return this.getStringUnitWidth(t4) * e3 / this.internal.scaleFactor;\n  };\n}(E$1.API), function(t3) {\n  var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];\n  t3.__arabicParser__ = {};\n  var a2 = t3.__arabicParser__.isInArabicSubstitutionA = function(t4) {\n    return e2[t4.charCodeAt(0)] !== void 0;\n  }, o2 = t3.__arabicParser__.isArabicLetter = function(t4) {\n    return typeof t4 == \"string\" && /^[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]+$/.test(t4);\n  }, s2 = t3.__arabicParser__.isArabicEndLetter = function(t4) {\n    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length <= 2;\n  }, c2 = t3.__arabicParser__.isArabicAlfLetter = function(t4) {\n    return o2(t4) && i2.indexOf(t4.charCodeAt(0)) >= 0;\n  };\n  t3.__arabicParser__.arabicLetterHasIsolatedForm = function(t4) {\n    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 1;\n  };\n  var u2 = t3.__arabicParser__.arabicLetterHasFinalForm = function(t4) {\n    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 2;\n  };\n  t3.__arabicParser__.arabicLetterHasInitialForm = function(t4) {\n    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 3;\n  };\n  var h2 = t3.__arabicParser__.arabicLetterHasMedialForm = function(t4) {\n    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length == 4;\n  }, l2 = t3.__arabicParser__.resolveLigatures = function(t4) {\n    var e3 = 0, n3 = r2, i3 = \"\", a3 = 0;\n    for (e3 = 0; e3 < t4.length; e3 += 1)\n      n3[t4.charCodeAt(e3)] !== void 0 ? (a3++, typeof (n3 = n3[t4.charCodeAt(e3)]) == \"number\" && (i3 += String.fromCharCode(n3), n3 = r2, a3 = 0), e3 === t4.length - 1 && (n3 = r2, i3 += t4.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (n3 = r2, i3 += t4.charAt(e3 - a3), e3 -= a3, a3 = 0);\n    return i3;\n  };\n  t3.__arabicParser__.isArabicDiacritic = function(t4) {\n    return t4 !== void 0 && n2[t4.charCodeAt(0)] !== void 0;\n  };\n  var f2 = t3.__arabicParser__.getCorrectForm = function(t4, e3, r3) {\n    return o2(t4) ? a2(t4) === false ? -1 : !u2(t4) || !o2(e3) && !o2(r3) || !o2(r3) && s2(e3) || s2(t4) && !o2(e3) || s2(t4) && c2(e3) || s2(t4) && s2(e3) ? 0 : h2(t4) && o2(e3) && !s2(e3) && o2(r3) && u2(r3) ? 3 : s2(t4) || !o2(r3) ? 1 : 2 : -1;\n  }, d2 = function(t4) {\n    var r3 = 0, n3 = 0, i3 = 0, a3 = \"\", s3 = \"\", c3 = \"\", u3 = (t4 = t4 || \"\").split(\"\\\\s+\"), h3 = [];\n    for (r3 = 0; r3 < u3.length; r3 += 1) {\n      for (h3.push(\"\"), n3 = 0; n3 < u3[r3].length; n3 += 1)\n        a3 = u3[r3][n3], s3 = u3[r3][n3 - 1], c3 = u3[r3][n3 + 1], o2(a3) ? (i3 = f2(a3, s3, c3), h3[r3] += i3 !== -1 ? String.fromCharCode(e2[a3.charCodeAt(0)][i3]) : a3) : h3[r3] += a3;\n      h3[r3] = l2(h3[r3]);\n    }\n    return h3.join(\" \");\n  }, p5 = t3.__arabicParser__.processArabic = t3.processArabic = function() {\n    var t4, e3 = typeof arguments[0] == \"string\" ? arguments[0] : arguments[0].text, r3 = [];\n    if (Array.isArray(e3)) {\n      var n3 = 0;\n      for (r3 = [], n3 = 0; n3 < e3.length; n3 += 1)\n        Array.isArray(e3[n3]) ? r3.push([d2(e3[n3][0]), e3[n3][1], e3[n3][2]]) : r3.push([d2(e3[n3])]);\n      t4 = r3;\n    } else\n      t4 = d2(e3);\n    return typeof arguments[0] == \"string\" ? t4 : (arguments[0].text = t4, arguments[0]);\n  };\n  t3.events.push([\"preProcessText\", p5]);\n}(E$1.API), E$1.API.autoPrint = function(t3) {\n  var e2;\n  switch ((t3 = t3 || {}).variant = t3.variant || \"non-conform\", t3.variant) {\n    case \"javascript\":\n      this.addJS(\"print({});\");\n      break;\n    case \"non-conform\":\n    default:\n      this.internal.events.subscribe(\"postPutResources\", function() {\n        e2 = this.internal.newObject(), this.internal.out(\"<<\"), this.internal.out(\"/S /Named\"), this.internal.out(\"/Type /Action\"), this.internal.out(\"/N /Print\"), this.internal.out(\">>\"), this.internal.out(\"endobj\");\n      }), this.internal.events.subscribe(\"putCatalog\", function() {\n        this.internal.out(\"/OpenAction \" + e2 + \" 0 R\");\n      });\n  }\n  return this;\n}, function(t3) {\n  var e2 = function() {\n    var t4 = void 0;\n    Object.defineProperty(this, \"pdf\", { get: function() {\n      return t4;\n    }, set: function(e4) {\n      t4 = e4;\n    } });\n    var e3 = 150;\n    Object.defineProperty(this, \"width\", { get: function() {\n      return e3;\n    }, set: function(t5) {\n      e3 = isNaN(t5) || Number.isInteger(t5) === false || t5 < 0 ? 150 : t5, this.getContext(\"2d\").pageWrapXEnabled && (this.getContext(\"2d\").pageWrapX = e3 + 1);\n    } });\n    var r2 = 300;\n    Object.defineProperty(this, \"height\", { get: function() {\n      return r2;\n    }, set: function(t5) {\n      r2 = isNaN(t5) || Number.isInteger(t5) === false || t5 < 0 ? 300 : t5, this.getContext(\"2d\").pageWrapYEnabled && (this.getContext(\"2d\").pageWrapY = r2 + 1);\n    } });\n    var n2 = [];\n    Object.defineProperty(this, \"childNodes\", { get: function() {\n      return n2;\n    }, set: function(t5) {\n      n2 = t5;\n    } });\n    var i2 = {};\n    Object.defineProperty(this, \"style\", { get: function() {\n      return i2;\n    }, set: function(t5) {\n      i2 = t5;\n    } }), Object.defineProperty(this, \"parentNode\", {});\n  };\n  e2.prototype.getContext = function(t4, e3) {\n    var r2;\n    if ((t4 = t4 || \"2d\") !== \"2d\")\n      return null;\n    for (r2 in e3)\n      this.pdf.context2d.hasOwnProperty(r2) && (this.pdf.context2d[r2] = e3[r2]);\n    return this.pdf.context2d._canvas = this, this.pdf.context2d;\n  }, e2.prototype.toDataURL = function() {\n    throw new Error(\"toDataURL is not implemented.\");\n  }, t3.events.push([\"initialized\", function() {\n    this.canvas = new e2(), this.canvas.pdf = this;\n  }]);\n}(E$1.API), function(e2) {\n  var r2 = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i2 = function() {\n    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r2), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));\n  }, a2 = function() {\n    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;\n  }, o2 = function() {\n    var t3 = arguments[0];\n    Object.defineProperty(this, \"x\", { enumerable: true, get: function() {\n      return t3;\n    }, set: function(e4) {\n      t3 = e4;\n    } });\n    var e3 = arguments[1];\n    Object.defineProperty(this, \"y\", { enumerable: true, get: function() {\n      return e3;\n    }, set: function(t4) {\n      e3 = t4;\n    } });\n    var r3 = arguments[2];\n    Object.defineProperty(this, \"width\", { enumerable: true, get: function() {\n      return r3;\n    }, set: function(t4) {\n      r3 = t4;\n    } });\n    var n3 = arguments[3];\n    Object.defineProperty(this, \"height\", { enumerable: true, get: function() {\n      return n3;\n    }, set: function(t4) {\n      n3 = t4;\n    } });\n    var i3 = arguments[4];\n    Object.defineProperty(this, \"text\", { enumerable: true, get: function() {\n      return i3;\n    }, set: function(t4) {\n      i3 = t4;\n    } });\n    var a3 = arguments[5];\n    Object.defineProperty(this, \"lineNumber\", { enumerable: true, get: function() {\n      return a3;\n    }, set: function(t4) {\n      a3 = t4;\n    } });\n    var o3 = arguments[6];\n    return Object.defineProperty(this, \"align\", { enumerable: true, get: function() {\n      return o3;\n    }, set: function(t4) {\n      o3 = t4;\n    } }), this;\n  };\n  o2.prototype.clone = function() {\n    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);\n  }, o2.prototype.toArray = function() {\n    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];\n  }, e2.setHeaderFunction = function(t3) {\n    return i2.call(this), this.internal.__cell__.headerFunction = typeof t3 == \"function\" ? t3 : void 0, this;\n  }, e2.getTextDimensions = function(t3, e3) {\n    i2.call(this);\n    var r3 = (e3 = e3 || {}).fontSize || this.getFontSize(), n3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;\n    if (!Array.isArray(t3) && typeof t3 != \"string\") {\n      if (typeof t3 != \"number\")\n        throw new Error(\"getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.\");\n      t3 = String(t3);\n    }\n    var h2 = e3.maxWidth;\n    h2 > 0 ? typeof t3 == \"string\" ? t3 = this.splitTextToSize(t3, h2) : Object.prototype.toString.call(t3) === \"[object Array]\" && (t3 = t3.reduce(function(t4, e4) {\n      return t4.concat(u2.splitTextToSize(e4, h2));\n    }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];\n    for (var l2 = 0; l2 < t3.length; l2++)\n      o3 < (c3 = this.getStringUnitWidth(t3[l2], { font: n3 }) * r3) && (o3 = c3);\n    return o3 !== 0 && (s3 = t3.length), { w: o3 /= a3, h: Math.max((s3 * r3 * this.getLineHeightFactor() - r3 * (this.getLineHeightFactor() - 1)) / a3, 0) };\n  }, e2.cellAddPage = function() {\n    i2.call(this), this.addPage();\n    var t3 = this.internal.__cell__.margins || r2;\n    return this.internal.__cell__.lastCell = new o2(t3.left, t3.top, void 0, void 0), this.internal.__cell__.pages += 1, this;\n  };\n  var s2 = e2.cell = function() {\n    var t3;\n    t3 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);\n    var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r2, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;\n    return e3.lineNumber !== void 0 && (e3.lineNumber === t3.lineNumber ? (t3.x = (e3.x || 0) + (e3.width || 0), t3.y = e3.y || 0) : e3.y + e3.height + t3.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s3.top, u2 && c3 && (this.printHeaderRow(t3.lineNumber, true), t3.y += c3[0].height)) : t3.y = e3.y + e3.height || t3.y), t3.text[0] !== void 0 && (this.rect(t3.x, t3.y, t3.width, t3.height, n2 === true ? \"FD\" : void 0), t3.align === \"right\" ? this.text(t3.text, t3.x + t3.width - a3, t3.y + a3, { align: \"right\", baseline: \"top\" }) : t3.align === \"center\" ? this.text(t3.text, t3.x + t3.width / 2, t3.y + a3, { align: \"center\", baseline: \"top\", maxWidth: t3.width - a3 - a3 }) : this.text(t3.text, t3.x + a3, t3.y + a3, { align: \"left\", baseline: \"top\", maxWidth: t3.width - a3 - a3 })), this.internal.__cell__.lastCell = t3, this;\n  };\n  e2.table = function(e3, n3, u2, h2, l2) {\n    if (i2.call(this), !u2)\n      throw new Error(\"No data for PDF table.\");\n    var f2, d2, p5, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = l2.printHeaders !== false, S2 = l2.css && l2.css[\"font-size\"] !== void 0 ? 16 * l2.css[\"font-size\"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r2), P2 = typeof l2.padding == \"number\" ? l2.padding : 3, k2 = l2.headerBackgroundColor || \"#c8c8c8\", I2 = l2.headerTextColor || \"#000\";\n    if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), h2 == null)\n      v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {\n        return \"left\";\n      });\n    else if (Array.isArray(h2) && _typeof$2(h2[0]) === \"object\")\n      for (m2 = h2.map(function(t3) {\n        return t3.name;\n      }), v2 = h2.map(function(t3) {\n        return t3.prompt || t3.name || \"\";\n      }), b2 = h2.map(function(t3) {\n        return t3.align || \"left\";\n      }), f2 = 0; f2 < h2.length; f2 += 1)\n        w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);\n    else\n      Array.isArray(h2) && typeof h2[0] == \"string\" && (v2 = m2 = h2, b2 = m2.map(function() {\n        return \"left\";\n      }));\n    if (A2 || Array.isArray(h2) && typeof h2[0] == \"string\")\n      for (f2 = 0; f2 < m2.length; f2 += 1) {\n        for (y2[g2 = m2[f2]] = u2.map(function(t3) {\n          return t3[g2];\n        }), this.setFont(void 0, \"bold\"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, \"normal\"), p5 = 0; p5 < d2.length; p5 += 1)\n          N2.push(this.getTextDimensions(d2[p5], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);\n        w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];\n      }\n    if (x2) {\n      var F2 = {};\n      for (f2 = 0; f2 < m2.length; f2 += 1)\n        F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];\n      var C2 = c2.call(this, F2, w2);\n      L2 = m2.map(function(t3) {\n        return new o2(e3, n3, w2[t3], C2, F2[t3].text, void 0, F2[t3].align);\n      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);\n    }\n    var j2 = h2.reduce(function(t3, e4) {\n      return t3[e4.name] = e4.align, t3;\n    }, {});\n    for (f2 = 0; f2 < u2.length; f2 += 1) {\n      \"rowStart\" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);\n      var O2 = c2.call(this, u2[f2], w2);\n      for (p5 = 0; p5 < m2.length; p5 += 1) {\n        var B3 = u2[f2][m2[p5]];\n        \"cellStart\" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p5, data: B3 }, this), s2.call(this, new o2(e3, n3, w2[m2[p5]], O2, B3, f2 + 2, j2[m2[p5]]));\n      }\n    }\n    return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n3, this;\n  };\n  var c2 = function(t3, e3) {\n    var r3 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;\n    return Object.keys(t3).map(function(n4) {\n      var i4 = t3[n4];\n      return this.splitTextToSize(i4.hasOwnProperty(\"text\") ? i4.text : i4, e3[n4] - r3 - r3);\n    }, this).map(function(t4) {\n      return this.getLineHeightFactor() * t4.length * n3 / i3 + r3 + r3;\n    }, this).reduce(function(t4, e4) {\n      return Math.max(t4, e4);\n    }, 0);\n  };\n  e2.setTableHeaderRow = function(t3) {\n    i2.call(this), this.internal.__cell__.tableHeaderRow = t3;\n  }, e2.printHeaderRow = function(t3, e3) {\n    if (i2.call(this), !this.internal.__cell__.tableHeaderRow)\n      throw new Error(\"Property tableHeaderRow does not exist.\");\n    var r3;\n    if (n2 = true, typeof this.internal.__cell__.headerFunction == \"function\") {\n      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);\n      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);\n    }\n    this.setFont(void 0, \"bold\");\n    for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {\n      r3 = this.internal.__cell__.tableHeaderRow[u2].clone(), e3 && (r3.y = this.internal.__cell__.margins.top || 0, c3.push(r3)), r3.lineNumber = t3;\n      var h2 = this.getTextColor();\n      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r3), this.setTextColor(h2);\n    }\n    c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, \"normal\"), n2 = false;\n  };\n}(E$1.API);\nvar Pt = { italic: [\"italic\", \"oblique\", \"normal\"], oblique: [\"oblique\", \"italic\", \"normal\"], normal: [\"normal\", \"oblique\", \"italic\"] }, kt = [\"ultra-condensed\", \"extra-condensed\", \"condensed\", \"semi-condensed\", \"normal\", \"semi-expanded\", \"expanded\", \"extra-expanded\", \"ultra-expanded\"], It = _t(kt), Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ct = _t(Ft);\nfunction jt(t3) {\n  var e2 = t3.family.replace(/\"|'/g, \"\").toLowerCase(), r2 = function(t4) {\n    return Pt[t4 = t4 || \"normal\"] ? t4 : \"normal\";\n  }(t3.style), n2 = function(t4) {\n    if (!t4)\n      return 400;\n    if (typeof t4 == \"number\")\n      return t4 >= 100 && t4 <= 900 && t4 % 100 == 0 ? t4 : 400;\n    if (/^\\d00$/.test(t4))\n      return parseInt(t4);\n    switch (t4) {\n      case \"bold\":\n        return 700;\n      case \"normal\":\n      default:\n        return 400;\n    }\n  }(t3.weight), i2 = function(t4) {\n    return typeof It[t4 = t4 || \"normal\"] == \"number\" ? t4 : \"normal\";\n  }(t3.stretch);\n  return { family: e2, style: r2, weight: n2, stretch: i2, src: t3.src || [], ref: t3.ref || { name: e2, style: [i2, r2, n2].join(\" \") } };\n}\nfunction Ot(t3, e2, r2, n2) {\n  var i2;\n  for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 += n2)\n    if (t3[e2[i2]])\n      return t3[e2[i2]];\n  for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 -= n2)\n    if (t3[e2[i2]])\n      return t3[e2[i2]];\n}\nvar Bt = { \"sans-serif\": \"helvetica\", fixed: \"courier\", monospace: \"courier\", terminal: \"courier\", cursive: \"times\", fantasy: \"times\", serif: \"times\" }, Mt = { caption: \"times\", icon: \"times\", menu: \"times\", \"message-box\": \"times\", \"small-caption\": \"times\", \"status-bar\": \"times\" };\nfunction Et(t3) {\n  return [t3.stretch, t3.style, t3.weight, t3.family].join(\" \");\n}\nfunction qt(t3, e2, r2) {\n  for (var n2 = (r2 = r2 || {}).defaultFontFamily || \"times\", i2 = Object.assign({}, Bt, r2.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e2.length; ++s2)\n    if (i2[(a2 = jt(e2[s2])).family] && (a2.family = i2[a2.family]), t3.hasOwnProperty(a2.family)) {\n      o2 = t3[a2.family];\n      break;\n    }\n  if (!(o2 = o2 || t3[n2]))\n    throw new Error(\"Could not find a font-family for the rule '\" + Et(a2) + \"' and default family '\" + n2 + \"'.\");\n  if (o2 = function(t4, e3) {\n    if (e3[t4])\n      return e3[t4];\n    var r3 = It[t4], n3 = r3 <= It.normal ? -1 : 1, i3 = Ot(e3, kt, r3, n3);\n    if (!i3)\n      throw new Error(\"Could not find a matching font-stretch value for \" + t4);\n    return i3;\n  }(a2.stretch, o2), o2 = function(t4, e3) {\n    if (e3[t4])\n      return e3[t4];\n    for (var r3 = Pt[t4], n3 = 0; n3 < r3.length; ++n3)\n      if (e3[r3[n3]])\n        return e3[r3[n3]];\n    throw new Error(\"Could not find a matching font-style for \" + t4);\n  }(a2.style, o2), !(o2 = function(t4, e3) {\n    if (e3[t4])\n      return e3[t4];\n    if (t4 === 400 && e3[500])\n      return e3[500];\n    if (t4 === 500 && e3[400])\n      return e3[400];\n    var r3 = Ct[t4], n3 = Ot(e3, Ft, r3, t4 < 400 ? -1 : 1);\n    if (!n3)\n      throw new Error(\"Could not find a matching font-weight for value \" + t4);\n    return n3;\n  }(a2.weight, o2)))\n    throw new Error(\"Failed to resolve a font for the rule '\" + Et(a2) + \"'.\");\n  return o2;\n}\nfunction Dt(t3) {\n  return t3.trimLeft();\n}\nfunction Rt(t3, e2) {\n  for (var r2 = 0; r2 < t3.length; ) {\n    if (t3.charAt(r2) === e2)\n      return [t3.substring(0, r2), t3.substring(r2 + 1)];\n    r2 += 1;\n  }\n  return null;\n}\nfunction Tt(t3) {\n  var e2 = t3.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);\n  return e2 === null ? null : [e2[0], t3.substring(e2[0].length)];\n}\nvar zt, Ut, Ht, Wt = [\"times\"];\n!function(e2) {\n  var r2, n2, i2, o2, s2, c2, u2, h2, l2, d2 = function(t3) {\n    return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || \"#000000\", this.fillStyle = t3.fillStyle || \"#000000\", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || \"10px sans-serif\", this.textBaseline = t3.textBaseline || \"alphabetic\", this.textAlign = t3.textAlign || \"left\", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || \"miter\", this.lineCap = t3.lineCap || \"butt\", this.path = t3.path || [], this.transform = t3.transform !== void 0 ? t3.transform.clone() : new h2(), this.globalCompositeOperation = t3.globalCompositeOperation || \"normal\", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new c2(), this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new c2(), this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof t3.ignoreClearRect != \"boolean\" || t3.ignoreClearRect, this;\n  };\n  e2.events.push([\"initialized\", function() {\n    this.context2d = new p5(this), r2 = this.internal.f2, n2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();\n  }]);\n  var p5 = function(t3) {\n    Object.defineProperty(this, \"canvas\", { get: function() {\n      return { parentNode: false, style: false };\n    } });\n    var e3 = t3;\n    Object.defineProperty(this, \"pdf\", { get: function() {\n      return e3;\n    } });\n    var r3 = false;\n    Object.defineProperty(this, \"pageWrapXEnabled\", { get: function() {\n      return r3;\n    }, set: function(t4) {\n      r3 = Boolean(t4);\n    } });\n    var n3 = false;\n    Object.defineProperty(this, \"pageWrapYEnabled\", { get: function() {\n      return n3;\n    }, set: function(t4) {\n      n3 = Boolean(t4);\n    } });\n    var i3 = 0;\n    Object.defineProperty(this, \"posX\", { get: function() {\n      return i3;\n    }, set: function(t4) {\n      isNaN(t4) || (i3 = t4);\n    } });\n    var a2 = 0;\n    Object.defineProperty(this, \"posY\", { get: function() {\n      return a2;\n    }, set: function(t4) {\n      isNaN(t4) || (a2 = t4);\n    } }), Object.defineProperty(this, \"margin\", { get: function() {\n      return l2.margin;\n    }, set: function(t4) {\n      var e4;\n      typeof t4 == \"number\" ? e4 = [t4, t4, t4, t4] : ((e4 = new Array(4))[0] = t4[0], e4[1] = t4.length >= 2 ? t4[1] : e4[0], e4[2] = t4.length >= 3 ? t4[2] : e4[0], e4[3] = t4.length >= 4 ? t4[3] : e4[1]), l2.margin = e4;\n    } });\n    var o3 = false;\n    Object.defineProperty(this, \"autoPaging\", { get: function() {\n      return o3;\n    }, set: function(t4) {\n      o3 = t4;\n    } });\n    var s3 = 0;\n    Object.defineProperty(this, \"lastBreak\", { get: function() {\n      return s3;\n    }, set: function(t4) {\n      s3 = t4;\n    } });\n    var c3 = [];\n    Object.defineProperty(this, \"pageBreaks\", { get: function() {\n      return c3;\n    }, set: function(t4) {\n      c3 = t4;\n    } }), Object.defineProperty(this, \"ctx\", { get: function() {\n      return l2;\n    }, set: function(t4) {\n      t4 instanceof d2 && (l2 = t4);\n    } }), Object.defineProperty(this, \"path\", { get: function() {\n      return l2.path;\n    }, set: function(t4) {\n      l2.path = t4;\n    } });\n    var u3 = [];\n    Object.defineProperty(this, \"ctxStack\", { get: function() {\n      return u3;\n    }, set: function(t4) {\n      u3 = t4;\n    } }), Object.defineProperty(this, \"fillStyle\", { get: function() {\n      return this.ctx.fillStyle;\n    }, set: function(t4) {\n      var e4;\n      e4 = g2(t4), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = e4.a === 0, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });\n    } }), Object.defineProperty(this, \"strokeStyle\", { get: function() {\n      return this.ctx.strokeStyle;\n    }, set: function(t4) {\n      var e4 = g2(t4);\n      this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = e4.a === 0, this.ctx.strokeOpacity = e4.a, e4.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));\n    } }), Object.defineProperty(this, \"lineCap\", { get: function() {\n      return this.ctx.lineCap;\n    }, set: function(t4) {\n      [\"butt\", \"round\", \"square\"].indexOf(t4) !== -1 && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));\n    } }), Object.defineProperty(this, \"lineWidth\", { get: function() {\n      return this.ctx.lineWidth;\n    }, set: function(t4) {\n      isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));\n    } }), Object.defineProperty(this, \"lineJoin\", { get: function() {\n      return this.ctx.lineJoin;\n    }, set: function(t4) {\n      [\"bevel\", \"round\", \"miter\"].indexOf(t4) !== -1 && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));\n    } }), Object.defineProperty(this, \"miterLimit\", { get: function() {\n      return this.ctx.miterLimit;\n    }, set: function(t4) {\n      isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));\n    } }), Object.defineProperty(this, \"textBaseline\", { get: function() {\n      return this.ctx.textBaseline;\n    }, set: function(t4) {\n      this.ctx.textBaseline = t4;\n    } }), Object.defineProperty(this, \"textAlign\", { get: function() {\n      return this.ctx.textAlign;\n    }, set: function(t4) {\n      [\"right\", \"end\", \"center\", \"left\", \"start\"].indexOf(t4) !== -1 && (this.ctx.textAlign = t4);\n    } });\n    var h3 = null;\n    function f2(t4, e4) {\n      if (h3 === null) {\n        var r4 = function(t5) {\n          var e5 = [];\n          return Object.keys(t5).forEach(function(r5) {\n            t5[r5].forEach(function(t6) {\n              var n4 = null;\n              switch (t6) {\n                case \"bold\":\n                  n4 = { family: r5, weight: \"bold\" };\n                  break;\n                case \"italic\":\n                  n4 = { family: r5, style: \"italic\" };\n                  break;\n                case \"bolditalic\":\n                  n4 = { family: r5, weight: \"bold\", style: \"italic\" };\n                  break;\n                case \"\":\n                case \"normal\":\n                  n4 = { family: r5 };\n              }\n              n4 !== null && (n4.ref = { name: r5, style: t6 }, e5.push(n4));\n            });\n          }), e5;\n        }(t4.getFontList());\n        h3 = function(t5) {\n          for (var e5 = {}, r5 = 0; r5 < t5.length; ++r5) {\n            var n4 = jt(t5[r5]), i4 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;\n            e5[i4] = e5[i4] || {}, e5[i4][a3] = e5[i4][a3] || {}, e5[i4][a3][o4] = e5[i4][a3][o4] || {}, e5[i4][a3][o4][s4] = n4;\n          }\n          return e5;\n        }(r4.concat(e4));\n      }\n      return h3;\n    }\n    var p6 = null;\n    Object.defineProperty(this, \"fontFaces\", { get: function() {\n      return p6;\n    }, set: function(t4) {\n      h3 = null, p6 = t4;\n    } }), Object.defineProperty(this, \"font\", { get: function() {\n      return this.ctx.font;\n    }, set: function(t4) {\n      var e4;\n      if (this.ctx.font = t4, (e4 = /^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))(?:\\s*\\/\\s*(normal|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])))?\\s*([-_,\\\"\\'\\sa-z]+?)\\s*$/i.exec(t4)) !== null) {\n        var r4 = e4[1], n4 = (e4[2], e4[3]), i4 = e4[4], a3 = (e4[5], e4[6]), o4 = /^([.\\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];\n        i4 = o4 === \"px\" ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : o4 === \"em\" ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);\n        var s4 = function(t5) {\n          var e5, r5, n5 = [], i5 = t5.trim();\n          if (i5 === \"\")\n            return Wt;\n          if (i5 in Mt)\n            return [Mt[i5]];\n          for (; i5 !== \"\"; ) {\n            switch (r5 = null, e5 = (i5 = Dt(i5)).charAt(0)) {\n              case '\"':\n              case \"'\":\n                r5 = Rt(i5.substring(1), e5);\n                break;\n              default:\n                r5 = Tt(i5);\n            }\n            if (r5 === null)\n              return Wt;\n            if (n5.push(r5[0]), (i5 = Dt(r5[1])) !== \"\" && i5.charAt(0) !== \",\")\n              return Wt;\n            i5 = i5.replace(/^,/, \"\");\n          }\n          return n5;\n        }(a3);\n        if (this.fontFaces) {\n          var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t5) {\n            return { family: t5, stretch: \"normal\", weight: n4, style: r4 };\n          }));\n          this.pdf.setFont(c4.ref.name, c4.ref.style);\n        } else {\n          var u4 = \"\";\n          (n4 === \"bold\" || parseInt(n4, 10) >= 700 || r4 === \"bold\") && (u4 = \"bold\"), r4 === \"italic\" && (u4 += \"italic\"), u4.length === 0 && (u4 = \"normal\");\n          for (var h4 = \"\", l3 = { arial: \"Helvetica\", Arial: \"Helvetica\", verdana: \"Helvetica\", Verdana: \"Helvetica\", helvetica: \"Helvetica\", Helvetica: \"Helvetica\", \"sans-serif\": \"Helvetica\", fixed: \"Courier\", monospace: \"Courier\", terminal: \"Courier\", cursive: \"Times\", fantasy: \"Times\", serif: \"Times\" }, d3 = 0; d3 < s4.length; d3++) {\n            if (this.pdf.internal.getFont(s4[d3], u4, { noFallback: true, disableWarning: true }) !== void 0) {\n              h4 = s4[d3];\n              break;\n            }\n            if (u4 === \"bolditalic\" && this.pdf.internal.getFont(s4[d3], \"bold\", { noFallback: true, disableWarning: true }) !== void 0)\n              h4 = s4[d3], u4 = \"bold\";\n            else if (this.pdf.internal.getFont(s4[d3], \"normal\", { noFallback: true, disableWarning: true }) !== void 0) {\n              h4 = s4[d3], u4 = \"normal\";\n              break;\n            }\n          }\n          if (h4 === \"\") {\n            for (var p7 = 0; p7 < s4.length; p7++)\n              if (l3[s4[p7]]) {\n                h4 = l3[s4[p7]];\n                break;\n              }\n          }\n          h4 = h4 === \"\" ? \"Times\" : h4, this.pdf.setFont(h4, u4);\n        }\n      }\n    } }), Object.defineProperty(this, \"globalCompositeOperation\", { get: function() {\n      return this.ctx.globalCompositeOperation;\n    }, set: function(t4) {\n      this.ctx.globalCompositeOperation = t4;\n    } }), Object.defineProperty(this, \"globalAlpha\", { get: function() {\n      return this.ctx.globalAlpha;\n    }, set: function(t4) {\n      this.ctx.globalAlpha = t4;\n    } }), Object.defineProperty(this, \"lineDashOffset\", { get: function() {\n      return this.ctx.lineDashOffset;\n    }, set: function(t4) {\n      this.ctx.lineDashOffset = t4, T2.call(this);\n    } }), Object.defineProperty(this, \"lineDash\", { get: function() {\n      return this.ctx.lineDash;\n    }, set: function(t4) {\n      this.ctx.lineDash = t4, T2.call(this);\n    } }), Object.defineProperty(this, \"ignoreClearRect\", { get: function() {\n      return this.ctx.ignoreClearRect;\n    }, set: function(t4) {\n      this.ctx.ignoreClearRect = Boolean(t4);\n    } });\n  };\n  p5.prototype.setLineDash = function(t3) {\n    this.lineDash = t3;\n  }, p5.prototype.getLineDash = function() {\n    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();\n  }, p5.prototype.fill = function() {\n    A2.call(this, \"fill\", false);\n  }, p5.prototype.stroke = function() {\n    A2.call(this, \"stroke\", false);\n  }, p5.prototype.beginPath = function() {\n    this.path = [{ type: \"begin\" }];\n  }, p5.prototype.moveTo = function(t3, e3) {\n    if (isNaN(t3) || isNaN(e3))\n      throw a$2.error(\"jsPDF.context2d.moveTo: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.moveTo\");\n    var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));\n    this.path.push({ type: \"mt\", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(t3, e3);\n  }, p5.prototype.closePath = function() {\n    var e3 = new c2(0, 0), r3 = 0;\n    for (r3 = this.path.length - 1; r3 !== -1; r3--)\n      if (this.path[r3].type === \"begin\" && _typeof$2(this.path[r3 + 1]) === \"object\" && typeof this.path[r3 + 1].x == \"number\") {\n        e3 = new c2(this.path[r3 + 1].x, this.path[r3 + 1].y);\n        break;\n      }\n    this.path.push({ type: \"close\" }), this.ctx.lastPoint = new c2(e3.x, e3.y);\n  }, p5.prototype.lineTo = function(t3, e3) {\n    if (isNaN(t3) || isNaN(e3))\n      throw a$2.error(\"jsPDF.context2d.lineTo: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.lineTo\");\n    var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));\n    this.path.push({ type: \"lt\", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(r3.x, r3.y);\n  }, p5.prototype.clip = function() {\n    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);\n  }, p5.prototype.quadraticCurveTo = function(t3, e3, r3, n3) {\n    if (isNaN(r3) || isNaN(n3) || isNaN(t3) || isNaN(e3))\n      throw a$2.error(\"jsPDF.context2d.quadraticCurveTo: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.quadraticCurveTo\");\n    var i3 = this.ctx.transform.applyToPoint(new c2(r3, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t3, e3));\n    this.path.push({ type: \"qct\", x1: o3.x, y1: o3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new c2(i3.x, i3.y);\n  }, p5.prototype.bezierCurveTo = function(t3, e3, r3, n3, i3, o3) {\n    if (isNaN(i3) || isNaN(o3) || isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))\n      throw a$2.error(\"jsPDF.context2d.bezierCurveTo: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.bezierCurveTo\");\n    var s3 = this.ctx.transform.applyToPoint(new c2(i3, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t3, e3)), h3 = this.ctx.transform.applyToPoint(new c2(r3, n3));\n    this.path.push({ type: \"bct\", x1: u3.x, y1: u3.y, x2: h3.x, y2: h3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);\n  }, p5.prototype.arc = function(t3, e3, r3, n3, i3, o3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3))\n      throw a$2.error(\"jsPDF.context2d.arc: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.arc\");\n    if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {\n      var s3 = this.ctx.transform.applyToPoint(new c2(t3, e3));\n      t3 = s3.x, e3 = s3.y;\n      var u3 = this.ctx.transform.applyToPoint(new c2(0, r3)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));\n      r3 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));\n    }\n    Math.abs(i3 - n3) >= 2 * Math.PI && (n3 = 0, i3 = 2 * Math.PI), this.path.push({ type: \"arc\", x: t3, y: e3, radius: r3, startAngle: n3, endAngle: i3, counterclockwise: o3 });\n  }, p5.prototype.arcTo = function(t3, e3, r3, n3, i3) {\n    throw new Error(\"arcTo not implemented.\");\n  }, p5.prototype.rect = function(t3, e3, r3, n3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))\n      throw a$2.error(\"jsPDF.context2d.rect: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.rect\");\n    this.moveTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3 + r3, e3 + n3), this.lineTo(t3, e3 + n3), this.lineTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3, e3);\n  }, p5.prototype.fillRect = function(t3, e3, r3, n3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))\n      throw a$2.error(\"jsPDF.context2d.fillRect: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.fillRect\");\n    if (!m2.call(this)) {\n      var i3 = {};\n      this.lineCap !== \"butt\" && (i3.lineCap = this.lineCap, this.lineCap = \"butt\"), this.lineJoin !== \"miter\" && (i3.lineJoin = this.lineJoin, this.lineJoin = \"miter\"), this.beginPath(), this.rect(t3, e3, r3, n3), this.fill(), i3.hasOwnProperty(\"lineCap\") && (this.lineCap = i3.lineCap), i3.hasOwnProperty(\"lineJoin\") && (this.lineJoin = i3.lineJoin);\n    }\n  }, p5.prototype.strokeRect = function(t3, e3, r3, n3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))\n      throw a$2.error(\"jsPDF.context2d.strokeRect: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.strokeRect\");\n    v2.call(this) || (this.beginPath(), this.rect(t3, e3, r3, n3), this.stroke());\n  }, p5.prototype.clearRect = function(t3, e3, r3, n3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))\n      throw a$2.error(\"jsPDF.context2d.clearRect: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.clearRect\");\n    this.ignoreClearRect || (this.fillStyle = \"#ffffff\", this.fillRect(t3, e3, r3, n3));\n  }, p5.prototype.save = function(t3) {\n    t3 = typeof t3 != \"boolean\" || t3;\n    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)\n      this.pdf.setPage(r3 + 1), this.pdf.internal.out(\"q\");\n    if (this.pdf.setPage(e3), t3) {\n      this.ctx.fontSize = this.pdf.internal.getFontSize();\n      var n3 = new d2(this.ctx);\n      this.ctxStack.push(this.ctx), this.ctx = n3;\n    }\n  }, p5.prototype.restore = function(t3) {\n    t3 = typeof t3 != \"boolean\" || t3;\n    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)\n      this.pdf.setPage(r3 + 1), this.pdf.internal.out(\"Q\");\n    this.pdf.setPage(e3), t3 && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);\n  }, p5.prototype.toDataURL = function() {\n    throw new Error(\"toDataUrl not implemented.\");\n  };\n  var g2 = function(t3) {\n    var e3, r3, n3, i3;\n    if (t3.isCanvasGradient === true && (t3 = t3.getColor()), !t3)\n      return { r: 0, g: 0, b: 0, a: 0, style: t3 };\n    if (/transparent|rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*0+\\s*\\)/.test(t3))\n      e3 = 0, r3 = 0, n3 = 0, i3 = 0;\n    else {\n      var a2 = /rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/.exec(t3);\n      if (a2 !== null)\n        e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = 1;\n      else if ((a2 = /rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d.]+)\\s*\\)/.exec(t3)) !== null)\n        e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = parseFloat(a2[4]);\n      else {\n        if (i3 = 1, typeof t3 == \"string\" && t3.charAt(0) !== \"#\") {\n          var o3 = new f$2(t3);\n          t3 = o3.ok ? o3.toHex() : \"#000000\";\n        }\n        t3.length === 4 ? (e3 = t3.substring(1, 2), e3 += e3, r3 = t3.substring(2, 3), r3 += r3, n3 = t3.substring(3, 4), n3 += n3) : (e3 = t3.substring(1, 3), r3 = t3.substring(3, 5), n3 = t3.substring(5, 7)), e3 = parseInt(e3, 16), r3 = parseInt(r3, 16), n3 = parseInt(n3, 16);\n      }\n    }\n    return { r: e3, g: r3, b: n3, a: i3, style: t3 };\n  }, m2 = function() {\n    return this.ctx.isFillTransparent || this.globalAlpha == 0;\n  }, v2 = function() {\n    return Boolean(this.ctx.isStrokeTransparent || this.globalAlpha == 0);\n  };\n  p5.prototype.fillText = function(t3, e3, r3, n3) {\n    if (isNaN(e3) || isNaN(r3) || typeof t3 != \"string\")\n      throw a$2.error(\"jsPDF.context2d.fillText: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.fillText\");\n    if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {\n      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;\n      C2.call(this, { text: t3, x: e3, y: r3, scale: o3, angle: i3, align: this.textAlign, maxWidth: n3 });\n    }\n  }, p5.prototype.strokeText = function(t3, e3, r3, n3) {\n    if (isNaN(e3) || isNaN(r3) || typeof t3 != \"string\")\n      throw a$2.error(\"jsPDF.context2d.strokeText: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.strokeText\");\n    if (!v2.call(this)) {\n      n3 = isNaN(n3) ? void 0 : n3;\n      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;\n      C2.call(this, { text: t3, x: e3, y: r3, scale: o3, renderingMode: \"stroke\", angle: i3, align: this.textAlign, maxWidth: n3 });\n    }\n  }, p5.prototype.measureText = function(t3) {\n    if (typeof t3 != \"string\")\n      throw a$2.error(\"jsPDF.context2d.measureText: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.measureText\");\n    var e3 = this.pdf, r3 = this.pdf.internal.scaleFactor, n3 = e3.internal.getFontSize(), i3 = e3.getStringUnitWidth(t3) * n3 / e3.internal.scaleFactor, o3 = function(t4) {\n      var e4 = (t4 = t4 || {}).width || 0;\n      return Object.defineProperty(this, \"width\", { get: function() {\n        return e4;\n      } }), this;\n    };\n    return new o3({ width: i3 *= Math.round(96 * r3 / 72 * 1e4) / 1e4 });\n  }, p5.prototype.scale = function(t3, e3) {\n    if (isNaN(t3) || isNaN(e3))\n      throw a$2.error(\"jsPDF.context2d.scale: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.scale\");\n    var r3 = new h2(t3, 0, 0, e3, 0, 0);\n    this.ctx.transform = this.ctx.transform.multiply(r3);\n  }, p5.prototype.rotate = function(t3) {\n    if (isNaN(t3))\n      throw a$2.error(\"jsPDF.context2d.rotate: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.rotate\");\n    var e3 = new h2(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);\n    this.ctx.transform = this.ctx.transform.multiply(e3);\n  }, p5.prototype.translate = function(t3, e3) {\n    if (isNaN(t3) || isNaN(e3))\n      throw a$2.error(\"jsPDF.context2d.translate: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.translate\");\n    var r3 = new h2(1, 0, 0, 1, t3, e3);\n    this.ctx.transform = this.ctx.transform.multiply(r3);\n  }, p5.prototype.transform = function(t3, e3, r3, n3, i3, o3) {\n    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3) || isNaN(o3))\n      throw a$2.error(\"jsPDF.context2d.transform: Invalid arguments\", arguments), new Error(\"Invalid arguments passed to jsPDF.context2d.transform\");\n    var s3 = new h2(t3, e3, r3, n3, i3, o3);\n    this.ctx.transform = this.ctx.transform.multiply(s3);\n  }, p5.prototype.setTransform = function(t3, e3, r3, n3, i3, a2) {\n    t3 = isNaN(t3) ? 1 : t3, e3 = isNaN(e3) ? 0 : e3, r3 = isNaN(r3) ? 0 : r3, n3 = isNaN(n3) ? 1 : n3, i3 = isNaN(i3) ? 0 : i3, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t3, e3, r3, n3, i3, a2);\n  };\n  var b2 = function() {\n    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;\n  };\n  p5.prototype.drawImage = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {\n    var l3 = this.pdf.getImageProperties(t3), f2 = 1, d3 = 1, p6 = 1, g3 = 1;\n    n3 !== void 0 && s3 !== void 0 && (p6 = s3 / n3, g3 = c3 / i3, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i3 * c3 / i3), a2 === void 0 && (a2 = e3, o3 = r3, e3 = 0, r3 = 0), n3 !== void 0 && s3 === void 0 && (s3 = n3, c3 = i3), n3 === void 0 && s3 === void 0 && (s3 = l3.width, c3 = l3.height);\n    for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e3 * p6, o3 - r3 * g3, n3 * f2, i3 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1)\n      P3.indexOf(_3[k3]) === -1 && P3.push(_3[k3]);\n    if (L2(P3), this.autoPaging)\n      for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {\n        this.pdf.setPage(C3);\n        var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = C3 === 1 ? this.posY + this.margin[0] : this.margin[0], B4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = C3 === 1 ? 0 : B4 + (C3 - 2) * M3;\n        if (this.ctx.clip_path.length !== 0) {\n          var D3 = this.path;\n          m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, \"fill\", true), this.path = D3;\n        }\n        var R3 = JSON.parse(JSON.stringify(S3));\n        R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];\n        var T3 = (C3 > I3 || C3 < F3) && b2.call(this);\n        T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t3, \"JPEG\", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();\n      }\n    else\n      this.pdf.addImage(t3, \"JPEG\", S3.x, S3.y, S3.w, S3.h, null, null, w3);\n  };\n  var y2 = function(t3, e3, r3) {\n    var n3 = [];\n    e3 = e3 || this.pdf.internal.pageSize.width, r3 = r3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];\n    var i3 = this.posY + this.ctx.prevPageLastElemOffset;\n    switch (t3.type) {\n      default:\n      case \"mt\":\n      case \"lt\":\n        n3.push(Math.floor((t3.y + i3) / r3) + 1);\n        break;\n      case \"arc\":\n        n3.push(Math.floor((t3.y + i3 - t3.radius) / r3) + 1), n3.push(Math.floor((t3.y + i3 + t3.radius) / r3) + 1);\n        break;\n      case \"qct\":\n        var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);\n        n3.push(Math.floor((a2.y + i3) / r3) + 1), n3.push(Math.floor((a2.y + a2.h + i3) / r3) + 1);\n        break;\n      case \"bct\":\n        var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);\n        n3.push(Math.floor((o3.y + i3) / r3) + 1), n3.push(Math.floor((o3.y + o3.h + i3) / r3) + 1);\n        break;\n      case \"rect\":\n        n3.push(Math.floor((t3.y + i3) / r3) + 1), n3.push(Math.floor((t3.y + t3.h + i3) / r3) + 1);\n    }\n    for (var s3 = 0; s3 < n3.length; s3 += 1)\n      for (; this.pdf.internal.getNumberOfPages() < n3[s3]; )\n        w2.call(this);\n    return n3;\n  }, w2 = function() {\n    var t3 = this.fillStyle, e3 = this.strokeStyle, r3 = this.font, n3 = this.lineCap, i3 = this.lineWidth, a2 = this.lineJoin;\n    this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e3, this.font = r3, this.lineCap = n3, this.lineWidth = i3, this.lineJoin = a2;\n  }, N2 = function(t3, e3, r3) {\n    for (var n3 = 0; n3 < t3.length; n3++)\n      switch (t3[n3].type) {\n        case \"bct\":\n          t3[n3].x2 += e3, t3[n3].y2 += r3;\n        case \"qct\":\n          t3[n3].x1 += e3, t3[n3].y1 += r3;\n        case \"mt\":\n        case \"lt\":\n        case \"arc\":\n        default:\n          t3[n3].x += e3, t3[n3].y += r3;\n      }\n    return t3;\n  }, L2 = function(t3) {\n    return t3.sort(function(t4, e3) {\n      return t4 - e3;\n    });\n  }, A2 = function(t3, e3) {\n    for (var r3, n3, i3 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++)\n      if (l3[d3].x !== void 0)\n        for (var p6 = y2.call(this, l3[d3]), g3 = 0; g3 < p6.length; g3 += 1)\n          f2.indexOf(p6[g3]) === -1 && f2.push(p6[g3]);\n    for (var m3 = 0; m3 < f2.length; m3++)\n      for (; this.pdf.internal.getNumberOfPages() < f2[m3]; )\n        w2.call(this);\n    if (L2(f2), this.autoPaging)\n      for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {\n        this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;\n        var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = S3 === 1 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = S3 === 1 ? 0 : k3 + (S3 - 2) * I3;\n        if (this.ctx.clip_path.length !== 0) {\n          var C3 = this.path;\n          r3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t3, true), this.path = C3;\n        }\n        if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), e3 === false || S3 === 0) {\n          var j3 = (S3 > v3 || S3 < A3) && b2.call(this);\n          j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t3, e3), j3 && this.pdf.restoreGraphicsState();\n        }\n        this.lineWidth = s3;\n      }\n    else\n      this.lineWidth = c3, x2.call(this, t3, e3), this.lineWidth = s3;\n    this.path = h3;\n  }, x2 = function(t3, e3) {\n    if ((t3 !== \"stroke\" || e3 || !v2.call(this)) && (t3 === \"stroke\" || e3 || !m2.call(this))) {\n      for (var r3, n3, i3 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {\n        var s3 = a2[o3];\n        switch (s3.type) {\n          case \"begin\":\n            i3.push({ begin: true });\n            break;\n          case \"close\":\n            i3.push({ close: true });\n            break;\n          case \"mt\":\n            i3.push({ start: s3, deltas: [], abs: [] });\n            break;\n          case \"lt\":\n            var c3 = i3.length;\n            if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r3 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {\n              for (; c3 >= 0; c3--)\n                if (i3[c3 - 1].close !== true && i3[c3 - 1].begin !== true) {\n                  i3[c3 - 1].deltas.push(r3), i3[c3 - 1].abs.push(s3);\n                  break;\n                }\n            }\n            break;\n          case \"bct\":\n            r3 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);\n            break;\n          case \"qct\":\n            var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p6 = s3.y;\n            r3 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p6 - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);\n            break;\n          case \"arc\":\n            i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);\n        }\n      }\n      n3 = e3 ? null : t3 === \"stroke\" ? \"stroke\" : \"fill\";\n      for (var g3 = false, b3 = 0; b3 < i3.length; b3++)\n        if (i3[b3].arc)\n          for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {\n            var N3 = y3[w3];\n            N3.type === \"arc\" ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : j2.call(this, N3.x, N3.y), g3 = true;\n          }\n        else if (i3[b3].close === true)\n          this.pdf.internal.out(\"h\"), g3 = false;\n        else if (i3[b3].begin !== true) {\n          var L3 = i3[b3].start.x, A3 = i3[b3].start.y;\n          O2.call(this, i3[b3].deltas, L3, A3), g3 = true;\n        }\n      n3 && k2.call(this, n3), e3 && I2.call(this);\n    }\n  }, S2 = function(t3) {\n    var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);\n    switch (this.ctx.textBaseline) {\n      case \"bottom\":\n        return t3 - r3;\n      case \"top\":\n        return t3 + e3 - r3;\n      case \"hanging\":\n        return t3 + e3 - 2 * r3;\n      case \"middle\":\n        return t3 + e3 / 2 - r3;\n      case \"ideographic\":\n        return t3;\n      case \"alphabetic\":\n      default:\n        return t3;\n    }\n  }, _2 = function(t3) {\n    return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);\n  };\n  p5.prototype.createLinearGradient = function() {\n    var t3 = function() {\n    };\n    return t3.colorStops = [], t3.addColorStop = function(t4, e3) {\n      this.colorStops.push([t4, e3]);\n    }, t3.getColor = function() {\n      return this.colorStops.length === 0 ? \"#000000\" : this.colorStops[0][1];\n    }, t3.isCanvasGradient = true, t3;\n  }, p5.prototype.createPattern = function() {\n    return this.createLinearGradient();\n  }, p5.prototype.createRadialGradient = function() {\n    return this.createLinearGradient();\n  };\n  var P2 = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {\n    for (var u3 = M2.call(this, r3, n3, i3, a2), h3 = 0; h3 < u3.length; h3++) {\n      var l3 = u3[h3];\n      h3 === 0 && (c3 ? F2.call(this, l3.x1 + t3, l3.y1 + e3) : j2.call(this, l3.x1 + t3, l3.y1 + e3)), B3.call(this, t3, e3, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);\n    }\n    s3 ? I2.call(this) : k2.call(this, o3);\n  }, k2 = function(t3) {\n    switch (t3) {\n      case \"stroke\":\n        this.pdf.internal.out(\"S\");\n        break;\n      case \"fill\":\n        this.pdf.internal.out(\"f\");\n    }\n  }, I2 = function() {\n    this.pdf.clip(), this.pdf.discardPath();\n  }, F2 = function(t3, e3) {\n    this.pdf.internal.out(n2(t3) + \" \" + i2(e3) + \" m\");\n  }, C2 = function(t3) {\n    var e3;\n    switch (t3.align) {\n      case \"right\":\n      case \"end\":\n        e3 = \"right\";\n        break;\n      case \"center\":\n        e3 = \"center\";\n        break;\n      case \"left\":\n      case \"start\":\n      default:\n        e3 = \"left\";\n    }\n    var r3 = this.pdf.getTextDimensions(t3.text), n3 = S2.call(this, t3.y), i3 = _2.call(this, n3) - r3.h, a2 = this.ctx.transform.applyToPoint(new c2(t3.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();\n    s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);\n    for (var l3, f2, d3, p6 = this.ctx.transform.applyToRectangle(new u2(t3.x, n3, r3.w, r3.h)), g3 = s3.applyToRectangle(new u2(t3.x, i3, r3.w, r3.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1)\n      v3.indexOf(m3[w3]) === -1 && v3.push(m3[w3]);\n    if (L2(v3), this.autoPaging)\n      for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {\n        this.pdf.setPage(k3);\n        var I3 = k3 === 1 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B4 = O3 - this.margin[3], M3 = k3 === 1 ? 0 : F3 + (k3 - 2) * j3;\n        if (this.ctx.clip_path.length !== 0) {\n          var E3 = this.path;\n          l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, \"fill\", true), this.path = E3;\n        }\n        var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];\n        t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale);\n        var D3 = this.autoPaging !== \"text\";\n        if (D3 || q3.y + q3.h <= C3) {\n          if (D3 || q3.y >= I3 && q3.x <= O3) {\n            var R3 = D3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p6))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], z2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);\n            z2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B4, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode }), z2 && this.pdf.restoreGraphicsState();\n          }\n        } else\n          q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);\n        t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);\n      }\n    else\n      t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale), this.pdf.text(t3.text, a2.x + this.posX, a2.y + this.posY, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode, maxWidth: t3.maxWidth }), t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);\n  }, j2 = function(t3, e3, r3, a2) {\n    r3 = r3 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t3 + r3) + \" \" + i2(e3 + a2) + \" l\");\n  }, O2 = function(t3, e3, r3) {\n    return this.pdf.lines(t3, e3, r3, null, null);\n  }, B3 = function(t3, e3, n3, i3, a2, c3, u3, h3) {\n    this.pdf.internal.out([r2(o2(n3 + t3)), r2(s2(i3 + e3)), r2(o2(a2 + t3)), r2(s2(c3 + e3)), r2(o2(u3 + t3)), r2(s2(h3 + e3)), \"c\"].join(\" \"));\n  }, M2 = function(t3, e3, r3, n3) {\n    for (var i3 = 2 * Math.PI, a2 = Math.PI / 2; e3 > r3; )\n      e3 -= i3;\n    var o3 = Math.abs(r3 - e3);\n    o3 < i3 && n3 && (o3 = i3 - o3);\n    for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e3; o3 > 1e-5; ) {\n      var h3 = u3 + c3 * Math.min(o3, a2);\n      s3.push(E2.call(this, t3, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;\n    }\n    return s3;\n  }, E2 = function(t3, e3, r3) {\n    var n3 = (r3 - e3) / 2, i3 = t3 * Math.cos(n3), a2 = t3 * Math.sin(n3), o3 = i3, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i3 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i3), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d3 = l3, p6 = -f2, g3 = n3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);\n    return { x1: t3 * Math.cos(e3), y1: t3 * Math.sin(e3), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d3 * m3 - p6 * v3, y3: d3 * v3 + p6 * m3, x4: t3 * Math.cos(r3), y4: t3 * Math.sin(r3) };\n  }, q2 = function(t3) {\n    return 180 * t3 / Math.PI;\n  }, D2 = function(t3, e3, r3, n3, i3, a2) {\n    var o3 = t3 + 0.5 * (r3 - t3), s3 = e3 + 0.5 * (n3 - e3), c3 = i3 + 0.5 * (r3 - i3), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t3, i3, o3, c3), f2 = Math.max(t3, i3, o3, c3), d3 = Math.min(e3, a2, s3, h3), p6 = Math.max(e3, a2, s3, h3);\n    return new u2(l3, d3, f2 - l3, p6 - d3);\n  }, R2 = function(t3, e3, r3, n3, i3, a2, o3, s3) {\n    var c3, h3, l3, f2, d3, p6, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r3 - t3, x3 = n3 - e3, S3 = i3 - r3, _3 = a2 - n3, P3 = o3 - i3, k3 = s3 - a2;\n    for (h3 = 0; h3 < 41; h3++)\n      v3 = (g3 = (l3 = t3 + (c3 = h3 / 40) * A3) + c3 * ((d3 = r3 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i3 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e3 + c3 * x3) + c3 * ((p6 = n3 + c3 * _3) - f2)) + c3 * (p6 + c3 * (a2 + c3 * k3 - p6) - m3), h3 == 0 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));\n    return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));\n  }, T2 = function() {\n    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {\n      var t3, e3, r3 = (t3 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t3, lineDashOffset: e3 }));\n      this.prevLineDash !== r3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r3);\n    }\n  };\n}(E$1.API), function(t3) {\n  var r2 = function(t4) {\n    var e2, r3, n3, i3, a3, o2, s2, c2, u2, h2;\n    for (/[^\\x00-\\xFF]/.test(t4), r3 = [], n3 = 0, i3 = (t4 += e2 = \"\\0\\0\\0\\0\".slice(t4.length % 4 || 4)).length; i3 > n3; n3 += 4)\n      (a3 = (t4.charCodeAt(n3) << 24) + (t4.charCodeAt(n3 + 1) << 16) + (t4.charCodeAt(n3 + 2) << 8) + t4.charCodeAt(n3 + 3)) !== 0 ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r3.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r3.push(122);\n    return function(t5, e3) {\n      for (var r4 = e3; r4 > 0; r4--)\n        t5.pop();\n    }(r3, e2.length), String.fromCharCode.apply(String, r3) + \"~>\";\n  }, n2 = function(t4) {\n    var e2, r3, n3, i3, a3, o2 = String, s2 = \"length\", c2 = 255, u2 = \"charCodeAt\", h2 = \"slice\", l2 = \"replace\";\n    for (t4[h2](-2), t4 = t4[h2](0, -2)[l2](/\\s/g, \"\")[l2](\"z\", \"!!!!!\"), n3 = [], i3 = 0, a3 = (t4 += e2 = \"uuuuu\"[h2](t4[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5)\n      r3 = 52200625 * (t4[u2](i3) - 33) + 614125 * (t4[u2](i3 + 1) - 33) + 7225 * (t4[u2](i3 + 2) - 33) + 85 * (t4[u2](i3 + 3) - 33) + (t4[u2](i3 + 4) - 33), n3.push(c2 & r3 >> 24, c2 & r3 >> 16, c2 & r3 >> 8, c2 & r3);\n    return function(t5, e3) {\n      for (var r4 = e3; r4 > 0; r4--)\n        t5.pop();\n    }(n3, e2[s2]), o2.fromCharCode.apply(o2, n3);\n  }, i2 = function(t4) {\n    var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);\n    if ((t4 = t4.replace(/\\s/g, \"\")).indexOf(\">\") !== -1 && (t4 = t4.substr(0, t4.indexOf(\">\"))), t4.length % 2 && (t4 += \"0\"), e2.test(t4) === false)\n      return \"\";\n    for (var r3 = \"\", n3 = 0; n3 < t4.length; n3 += 2)\n      r3 += String.fromCharCode(\"0x\" + (t4[n3] + t4[n3 + 1]));\n    return r3;\n  }, a2 = function(t4) {\n    for (var r3 = new Uint8Array(t4.length), n3 = t4.length; n3--; )\n      r3[n3] = t4.charCodeAt(n3);\n    return t4 = (r3 = zlibSync(r3)).reduce(function(t5, e2) {\n      return t5 + String.fromCharCode(e2);\n    }, \"\");\n  };\n  t3.processDataByFilters = function(t4, e2) {\n    var o2 = 0, s2 = t4 || \"\", c2 = [];\n    for (typeof (e2 = e2 || []) == \"string\" && (e2 = [e2]), o2 = 0; o2 < e2.length; o2 += 1)\n      switch (e2[o2]) {\n        case \"ASCII85Decode\":\n        case \"/ASCII85Decode\":\n          s2 = n2(s2), c2.push(\"/ASCII85Encode\");\n          break;\n        case \"ASCII85Encode\":\n        case \"/ASCII85Encode\":\n          s2 = r2(s2), c2.push(\"/ASCII85Decode\");\n          break;\n        case \"ASCIIHexDecode\":\n        case \"/ASCIIHexDecode\":\n          s2 = i2(s2), c2.push(\"/ASCIIHexEncode\");\n          break;\n        case \"ASCIIHexEncode\":\n        case \"/ASCIIHexEncode\":\n          s2 = s2.split(\"\").map(function(t5) {\n            return (\"0\" + t5.charCodeAt().toString(16)).slice(-2);\n          }).join(\"\") + \">\", c2.push(\"/ASCIIHexDecode\");\n          break;\n        case \"FlateEncode\":\n        case \"/FlateEncode\":\n          s2 = a2(s2), c2.push(\"/FlateDecode\");\n          break;\n        default:\n          throw new Error('The filter: \"' + e2[o2] + '\" is not implemented');\n      }\n    return { data: s2, reverseChain: c2.reverse().join(\" \") };\n  };\n}(E$1.API), function(t3) {\n  t3.loadFile = function(t4, e2, r2) {\n    return function(t5, e3, r3) {\n      e3 = e3 !== false, r3 = typeof r3 == \"function\" ? r3 : function() {\n      };\n      var n2 = void 0;\n      try {\n        n2 = function(t6, e4, r4) {\n          var n3 = new XMLHttpRequest(), i2 = 0, a2 = function(t7) {\n            var e5 = t7.length, r5 = [], n4 = String.fromCharCode;\n            for (i2 = 0; i2 < e5; i2 += 1)\n              r5.push(n4(255 & t7.charCodeAt(i2)));\n            return r5.join(\"\");\n          };\n          if (n3.open(\"GET\", t6, !e4), n3.overrideMimeType(\"text/plain; charset=x-user-defined\"), e4 === false && (n3.onload = function() {\n            n3.status === 200 ? r4(a2(this.responseText)) : r4(void 0);\n          }), n3.send(null), e4 && n3.status === 200)\n            return a2(n3.responseText);\n        }(t5, e3, r3);\n      } catch (t6) {\n      }\n      return n2;\n    }(t4, e2, r2);\n  }, t3.loadImageFile = t3.loadFile;\n}(E$1.API), function(e2) {\n  function r2() {\n    return (n$1.html2canvas ? Promise.resolve(n$1.html2canvas) : Promise.resolve().then(function() {\n      return html2canvas_esm;\n    })).catch(function(t3) {\n      return Promise.reject(new Error(\"Could not load html2canvas: \" + t3));\n    }).then(function(t3) {\n      return t3.default ? t3.default : t3;\n    });\n  }\n  function i2() {\n    return (n$1.DOMPurify ? Promise.resolve(n$1.DOMPurify) : Promise.resolve().then(function() {\n      return purify_es;\n    })).catch(function(t3) {\n      return Promise.reject(new Error(\"Could not load dompurify: \" + t3));\n    }).then(function(t3) {\n      return t3.default ? t3.default : t3;\n    });\n  }\n  var a2 = function(e3) {\n    var r3 = _typeof$2(e3);\n    return r3 === \"undefined\" ? \"undefined\" : r3 === \"string\" || e3 instanceof String ? \"string\" : r3 === \"number\" || e3 instanceof Number ? \"number\" : r3 === \"function\" || e3 instanceof Function ? \"function\" : e3 && e3.constructor === Array ? \"array\" : e3 && e3.nodeType === 1 ? \"element\" : r3 === \"object\" ? \"object\" : \"unknown\";\n  }, o2 = function(t3, e3) {\n    var r3 = document.createElement(t3);\n    for (var n2 in e3.className && (r3.className = e3.className), e3.innerHTML && e3.dompurify && (r3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style)\n      r3.style[n2] = e3.style[n2];\n    return r3;\n  }, s2 = function t3(e3) {\n    var r3 = Object.assign(t3.convert(Promise.resolve()), JSON.parse(JSON.stringify(t3.template))), n2 = t3.convert(Promise.resolve(), r3);\n    return n2 = (n2 = n2.setProgress(1, t3, 1, [t3])).set(e3);\n  };\n  (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t3, e3) {\n    return t3.__proto__ = e3 || s2.prototype, t3;\n  }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {\n  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: \"file.pdf\", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: \"transparent\" } }, s2.prototype.from = function(t3, e3) {\n    return this.then(function() {\n      switch (e3 = e3 || function(t4) {\n        switch (a2(t4)) {\n          case \"string\":\n            return \"string\";\n          case \"element\":\n            return t4.nodeName.toLowerCase() === \"canvas\" ? \"canvas\" : \"element\";\n          default:\n            return \"unknown\";\n        }\n      }(t3)) {\n        case \"string\":\n          return this.then(i2).then(function(e4) {\n            return this.set({ src: o2(\"div\", { innerHTML: t3, dompurify: e4 }) });\n          });\n        case \"element\":\n          return this.set({ src: t3 });\n        case \"canvas\":\n          return this.set({ canvas: t3 });\n        case \"img\":\n          return this.set({ img: t3 });\n        default:\n          return this.error(\"Unknown source type.\");\n      }\n    });\n  }, s2.prototype.to = function(t3) {\n    switch (t3) {\n      case \"container\":\n        return this.toContainer();\n      case \"canvas\":\n        return this.toCanvas();\n      case \"img\":\n        return this.toImg();\n      case \"pdf\":\n        return this.toPdf();\n      default:\n        return this.error(\"Invalid target.\");\n    }\n  }, s2.prototype.toContainer = function() {\n    return this.thenList([function() {\n      return this.prop.src || this.error(\"Cannot duplicate - no source HTML.\");\n    }, function() {\n      return this.prop.pageSize || this.setPageSize();\n    }]).then(function() {\n      var t3 = { position: \"relative\", display: \"inline-block\", width: (typeof this.opt.width != \"number\" || isNaN(this.opt.width) || typeof this.opt.windowWidth != \"number\" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + \"px\", left: 0, right: 0, top: 0, margin: \"auto\", backgroundColor: this.opt.backgroundColor }, e3 = function t4(e4, r3) {\n        for (var n2 = e4.nodeType === 3 ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i3 = e4.firstChild; i3; i3 = i3.nextSibling)\n          r3 !== true && i3.nodeType === 1 && i3.nodeName === \"SCRIPT\" || n2.appendChild(t4(i3, r3));\n        return e4.nodeType === 1 && (e4.nodeName === \"CANVAS\" ? (n2.width = e4.width, n2.height = e4.height, n2.getContext(\"2d\").drawImage(e4, 0, 0)) : e4.nodeName !== \"TEXTAREA\" && e4.nodeName !== \"SELECT\" || (n2.value = e4.value), n2.addEventListener(\"load\", function() {\n          n2.scrollTop = e4.scrollTop, n2.scrollLeft = e4.scrollLeft;\n        }, true)), n2;\n      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);\n      e3.tagName === \"BODY\" && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + \"px\"), this.prop.overlay = o2(\"div\", { className: \"html2pdf__overlay\", style: { position: \"fixed\", overflow: \"hidden\", zIndex: 1e3, left: \"-100000px\", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2(\"div\", { className: \"html2pdf__container\", style: t3 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2(\"div\", { style: { clear: \"both\", border: \"0 none transparent\", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = \"none\", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = \"relative\", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + \"px\";\n    });\n  }, s2.prototype.toCanvas = function() {\n    var t3 = [function() {\n      return document.body.contains(this.prop.container) || this.toContainer();\n    }];\n    return this.thenList(t3).then(r2).then(function(t4) {\n      var e3 = Object.assign({}, this.opt.html2canvas);\n      return delete e3.onrendered, t4(this.prop.container, e3);\n    }).then(function(t4) {\n      (this.opt.html2canvas.onrendered || function() {\n      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);\n    });\n  }, s2.prototype.toContext2d = function() {\n    var t3 = [function() {\n      return document.body.contains(this.prop.container) || this.toContainer();\n    }];\n    return this.thenList(t3).then(r2).then(function(t4) {\n      var e3 = this.opt.jsPDF, r3 = this.opt.fontFaces, n2 = typeof this.opt.width != \"number\" || isNaN(this.opt.width) || typeof this.opt.windowWidth != \"number\" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: \"#ffffff\", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);\n      if (delete i3.onrendered, e3.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r3, r3)\n        for (var a3 = 0; a3 < r3.length; ++a3) {\n          var o3 = r3[a3], s3 = o3.src.find(function(t5) {\n            return t5.format === \"truetype\";\n          });\n          s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);\n        }\n      return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = i3.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e3.context2d.save(true), t4(this.prop.container, i3);\n    }).then(function(t4) {\n      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {\n      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);\n    });\n  }, s2.prototype.toImg = function() {\n    return this.thenList([function() {\n      return this.prop.canvas || this.toCanvas();\n    }]).then(function() {\n      var t3 = this.prop.canvas.toDataURL(\"image/\" + this.opt.image.type, this.opt.image.quality);\n      this.prop.img = document.createElement(\"img\"), this.prop.img.src = t3;\n    });\n  }, s2.prototype.toPdf = function() {\n    return this.thenList([function() {\n      return this.toContext2d();\n    }]).then(function() {\n      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;\n    });\n  }, s2.prototype.output = function(t3, e3, r3) {\n    return (r3 = r3 || \"pdf\").toLowerCase() === \"img\" || r3.toLowerCase() === \"image\" ? this.outputImg(t3, e3) : this.outputPdf(t3, e3);\n  }, s2.prototype.outputPdf = function(t3, e3) {\n    return this.thenList([function() {\n      return this.prop.pdf || this.toPdf();\n    }]).then(function() {\n      return this.prop.pdf.output(t3, e3);\n    });\n  }, s2.prototype.outputImg = function(t3) {\n    return this.thenList([function() {\n      return this.prop.img || this.toImg();\n    }]).then(function() {\n      switch (t3) {\n        case void 0:\n        case \"img\":\n          return this.prop.img;\n        case \"datauristring\":\n        case \"dataurlstring\":\n          return this.prop.img.src;\n        case \"datauri\":\n        case \"dataurl\":\n          return document.location.href = this.prop.img.src;\n        default:\n          throw 'Image output type \"' + t3 + '\" is not supported.';\n      }\n    });\n  }, s2.prototype.save = function(t3) {\n    return this.thenList([function() {\n      return this.prop.pdf || this.toPdf();\n    }]).set(t3 ? { filename: t3 } : null).then(function() {\n      this.prop.pdf.save(this.opt.filename);\n    });\n  }, s2.prototype.doCallback = function() {\n    return this.thenList([function() {\n      return this.prop.pdf || this.toPdf();\n    }]).then(function() {\n      this.prop.callback(this.prop.pdf);\n    });\n  }, s2.prototype.set = function(t3) {\n    if (a2(t3) !== \"object\")\n      return this;\n    var e3 = Object.keys(t3 || {}).map(function(e4) {\n      if (e4 in s2.template.prop)\n        return function() {\n          this.prop[e4] = t3[e4];\n        };\n      switch (e4) {\n        case \"margin\":\n          return this.setMargin.bind(this, t3.margin);\n        case \"jsPDF\":\n          return function() {\n            return this.opt.jsPDF = t3.jsPDF, this.setPageSize();\n          };\n        case \"pageSize\":\n          return this.setPageSize.bind(this, t3.pageSize);\n        default:\n          return function() {\n            this.opt[e4] = t3[e4];\n          };\n      }\n    }, this);\n    return this.then(function() {\n      return this.thenList(e3);\n    });\n  }, s2.prototype.get = function(t3, e3) {\n    return this.then(function() {\n      var r3 = t3 in s2.template.prop ? this.prop[t3] : this.opt[t3];\n      return e3 ? e3(r3) : r3;\n    });\n  }, s2.prototype.setMargin = function(t3) {\n    return this.then(function() {\n      switch (a2(t3)) {\n        case \"number\":\n          t3 = [t3, t3, t3, t3];\n        case \"array\":\n          if (t3.length === 2 && (t3 = [t3[0], t3[1], t3[0], t3[1]]), t3.length === 4)\n            break;\n        default:\n          return this.error(\"Invalid margin array.\");\n      }\n      this.opt.margin = t3;\n    }).then(this.setPageSize);\n  }, s2.prototype.setPageSize = function(t3) {\n    function e3(t4, e4) {\n      return Math.floor(t4 * e4 / 72 * 96);\n    }\n    return this.then(function() {\n      (t3 = t3 || E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty(\"inner\") || (t3.inner = { width: t3.width - this.opt.margin[1] - this.opt.margin[3], height: t3.height - this.opt.margin[0] - this.opt.margin[2] }, t3.inner.px = { width: e3(t3.inner.width, t3.k), height: e3(t3.inner.height, t3.k) }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;\n    });\n  }, s2.prototype.setProgress = function(t3, e3, r3, n2) {\n    return t3 != null && (this.progress.val = t3), e3 != null && (this.progress.state = e3), r3 != null && (this.progress.n = r3), n2 != null && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;\n  }, s2.prototype.updateProgress = function(t3, e3, r3, n2) {\n    return this.setProgress(t3 ? this.progress.val + t3 : null, e3 || null, r3 ? this.progress.n + r3 : null, n2 ? this.progress.stack.concat(n2) : null);\n  }, s2.prototype.then = function(t3, e3) {\n    var r3 = this;\n    return this.thenCore(t3, e3, function(t4, e4) {\n      return r3.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e5) {\n        return r3.updateProgress(null, t4), e5;\n      }).then(t4, e4).then(function(t5) {\n        return r3.updateProgress(1), t5;\n      });\n    });\n  }, s2.prototype.thenCore = function(t3, e3, r3) {\n    r3 = r3 || Promise.prototype.then;\n    t3 && (t3 = t3.bind(this)), e3 && (e3 = e3.bind(this));\n    var n2 = Promise.toString().indexOf(\"[native code]\") !== -1 && Promise.name === \"Promise\" ? this : s2.convert(Object.assign({}, this), Promise.prototype), i3 = r3.call(n2, t3, e3);\n    return s2.convert(i3, this.__proto__);\n  }, s2.prototype.thenExternal = function(t3, e3) {\n    return Promise.prototype.then.call(this, t3, e3);\n  }, s2.prototype.thenList = function(t3) {\n    var e3 = this;\n    return t3.forEach(function(t4) {\n      e3 = e3.thenCore(t4);\n    }), e3;\n  }, s2.prototype.catch = function(t3) {\n    t3 && (t3 = t3.bind(this));\n    var e3 = Promise.prototype.catch.call(this, t3);\n    return s2.convert(e3, this);\n  }, s2.prototype.catchExternal = function(t3) {\n    return Promise.prototype.catch.call(this, t3);\n  }, s2.prototype.error = function(t3) {\n    return this.then(function() {\n      throw new Error(t3);\n    });\n  }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E$1.getPageSize = function(e3, r3, n2) {\n    if (_typeof$2(e3) === \"object\") {\n      var i3 = e3;\n      e3 = i3.orientation, r3 = i3.unit || r3, n2 = i3.format || n2;\n    }\n    r3 = r3 || \"mm\", n2 = n2 || \"a4\", e3 = (\"\" + (e3 || \"P\")).toLowerCase();\n    var a3, o3 = (\"\" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], \"government-letter\": [576, 756], legal: [612, 1008], \"junior-legal\": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], \"credit-card\": [153, 243] };\n    switch (r3) {\n      case \"pt\":\n        a3 = 1;\n        break;\n      case \"mm\":\n        a3 = 72 / 25.4;\n        break;\n      case \"cm\":\n        a3 = 72 / 2.54;\n        break;\n      case \"in\":\n        a3 = 72;\n        break;\n      case \"px\":\n        a3 = 0.75;\n        break;\n      case \"pc\":\n      case \"em\":\n        a3 = 12;\n        break;\n      case \"ex\":\n        a3 = 6;\n        break;\n      default:\n        throw \"Invalid unit: \" + r3;\n    }\n    var c2, u2 = 0, h2 = 0;\n    if (s3.hasOwnProperty(o3))\n      u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;\n    else\n      try {\n        u2 = n2[1], h2 = n2[0];\n      } catch (t3) {\n        throw new Error(\"Invalid format: \" + n2);\n      }\n    if (e3 === \"p\" || e3 === \"portrait\")\n      e3 = \"p\", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);\n    else {\n      if (e3 !== \"l\" && e3 !== \"landscape\")\n        throw \"Invalid orientation: \" + e3;\n      e3 = \"l\", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);\n    }\n    return { width: h2, height: u2, unit: r3, k: a3, orientation: e3 };\n  }, e2.html = function(t3, e3) {\n    (e3 = e3 || {}).callback = e3.callback || function() {\n    }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt) : null;\n    var r3 = new s2(e3);\n    return e3.worker ? r3 : r3.from(t3).doCallback();\n  };\n}(E$1.API), E$1.API.addJS = function(t3) {\n  return Ht = t3, this.internal.events.subscribe(\"postPutResources\", function() {\n    zt = this.internal.newObject(), this.internal.out(\"<<\"), this.internal.out(\"/Names [(EmbeddedJS) \" + (zt + 1) + \" 0 R]\"), this.internal.out(\">>\"), this.internal.out(\"endobj\"), Ut = this.internal.newObject(), this.internal.out(\"<<\"), this.internal.out(\"/S /JavaScript\"), this.internal.out(\"/JS (\" + Ht + \")\"), this.internal.out(\">>\"), this.internal.out(\"endobj\");\n  }), this.internal.events.subscribe(\"putCatalog\", function() {\n    zt !== void 0 && Ut !== void 0 && this.internal.out(\"/Names <</JavaScript \" + zt + \" 0 R>>\");\n  }), this;\n}, function(t3) {\n  var e2;\n  t3.events.push([\"postPutResources\", function() {\n    var t4 = this, r2 = /^(\\d+) 0 obj$/;\n    if (this.outline.root.children.length > 0)\n      for (var n2 = t4.outline.render().split(/\\r\\n/), i2 = 0; i2 < n2.length; i2++) {\n        var a2 = n2[i2], o2 = r2.exec(a2);\n        if (o2 != null) {\n          var s2 = o2[1];\n          t4.internal.newObjectDeferredBegin(s2, false);\n        }\n        t4.internal.write(a2);\n      }\n    if (this.outline.createNamedDestinations) {\n      var c2 = this.internal.pages.length, u2 = [];\n      for (i2 = 0; i2 < c2; i2++) {\n        var h2 = t4.internal.newObject();\n        u2.push(h2);\n        var l2 = t4.internal.getPageInfo(i2 + 1);\n        t4.internal.write(\"<< /D[\" + l2.objId + \" 0 R /XYZ null null null]>> endobj\");\n      }\n      var f2 = t4.internal.newObject();\n      t4.internal.write(\"<< /Names [ \");\n      for (i2 = 0; i2 < u2.length; i2++)\n        t4.internal.write(\"(page_\" + (i2 + 1) + \")\" + u2[i2] + \" 0 R\");\n      t4.internal.write(\" ] >>\", \"endobj\"), e2 = t4.internal.newObject(), t4.internal.write(\"<< /Dests \" + f2 + \" 0 R\"), t4.internal.write(\">>\", \"endobj\");\n    }\n  }]), t3.events.push([\"putCatalog\", function() {\n    this.outline.root.children.length > 0 && (this.internal.write(\"/Outlines\", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write(\"/Names \" + e2 + \" 0 R\"));\n  }]), t3.events.push([\"initialized\", function() {\n    var t4 = this;\n    t4.outline = { createNamedDestinations: false, root: { children: [] } }, t4.outline.add = function(t5, e3, r2) {\n      var n2 = { title: e3, options: r2, children: [] };\n      return t5 == null && (t5 = this.root), t5.children.push(n2), n2;\n    }, t4.outline.render = function() {\n      return this.ctx = {}, this.ctx.val = \"\", this.ctx.pdf = t4, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;\n    }, t4.outline.genIds_r = function(e3) {\n      e3.id = t4.internal.newObjectDeferred();\n      for (var r2 = 0; r2 < e3.children.length; r2++)\n        this.genIds_r(e3.children[r2]);\n    }, t4.outline.renderRoot = function(t5) {\n      this.objStart(t5), this.line(\"/Type /Outlines\"), t5.children.length > 0 && (this.line(\"/First \" + this.makeRef(t5.children[0])), this.line(\"/Last \" + this.makeRef(t5.children[t5.children.length - 1]))), this.line(\"/Count \" + this.count_r({ count: 0 }, t5)), this.objEnd();\n    }, t4.outline.renderItems = function(e3) {\n      for (var r2 = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e3.children.length; n2++) {\n        var i2 = e3.children[n2];\n        this.objStart(i2), this.line(\"/Title \" + this.makeString(i2.title)), this.line(\"/Parent \" + this.makeRef(e3)), n2 > 0 && this.line(\"/Prev \" + this.makeRef(e3.children[n2 - 1])), n2 < e3.children.length - 1 && this.line(\"/Next \" + this.makeRef(e3.children[n2 + 1])), i2.children.length > 0 && (this.line(\"/First \" + this.makeRef(i2.children[0])), this.line(\"/Last \" + this.makeRef(i2.children[i2.children.length - 1])));\n        var a2 = this.count = this.count_r({ count: 0 }, i2);\n        if (a2 > 0 && this.line(\"/Count \" + a2), i2.options && i2.options.pageNumber) {\n          var o2 = t4.internal.getPageInfo(i2.options.pageNumber);\n          this.line(\"/Dest [\" + o2.objId + \" 0 R /XYZ 0 \" + r2(0) + \" 0]\");\n        }\n        this.objEnd();\n      }\n      for (var s2 = 0; s2 < e3.children.length; s2++)\n        this.renderItems(e3.children[s2]);\n    }, t4.outline.line = function(t5) {\n      this.ctx.val += t5 + \"\\r\\n\";\n    }, t4.outline.makeRef = function(t5) {\n      return t5.id + \" 0 R\";\n    }, t4.outline.makeString = function(e3) {\n      return \"(\" + t4.internal.pdfEscape(e3) + \")\";\n    }, t4.outline.objStart = function(t5) {\n      this.ctx.val += \"\\r\\n\" + t5.id + \" 0 obj\\r\\n<<\\r\\n\";\n    }, t4.outline.objEnd = function() {\n      this.ctx.val += \">> \\r\\nendobj\\r\\n\";\n    }, t4.outline.count_r = function(t5, e3) {\n      for (var r2 = 0; r2 < e3.children.length; r2++)\n        t5.count++, this.count_r(t5, e3.children[r2]);\n      return t5.count;\n    };\n  }]);\n}(E$1.API), function(t3) {\n  var e2 = [192, 193, 194, 195, 196, 197, 198, 199];\n  t3.processJPEG = function(t4, r2, n2, i2, a2, o2) {\n    var s2, c2 = this.decode.DCT_DECODE, u2 = null;\n    if (typeof t4 == \"string\" || this.__addimage__.isArrayBuffer(t4) || this.__addimage__.isArrayBufferView(t4)) {\n      switch (t4 = a2 || t4, t4 = this.__addimage__.isArrayBuffer(t4) ? new Uint8Array(t4) : t4, (s2 = function(t5) {\n        for (var r3, n3 = 256 * t5.charCodeAt(4) + t5.charCodeAt(5), i3 = t5.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {\n          if (o3 += n3, e2.indexOf(t5.charCodeAt(o3 + 1)) !== -1) {\n            r3 = 256 * t5.charCodeAt(o3 + 5) + t5.charCodeAt(o3 + 6), a3 = { width: 256 * t5.charCodeAt(o3 + 7) + t5.charCodeAt(o3 + 8), height: r3, numcomponents: t5.charCodeAt(o3 + 9) };\n            break;\n          }\n          n3 = 256 * t5.charCodeAt(o3 + 2) + t5.charCodeAt(o3 + 3);\n        }\n        return a3;\n      }(t4 = this.__addimage__.isArrayBufferView(t4) ? this.__addimage__.arrayBufferToBinaryString(t4) : t4)).numcomponents) {\n        case 1:\n          o2 = this.color_spaces.DEVICE_GRAY;\n          break;\n        case 4:\n          o2 = this.color_spaces.DEVICE_CMYK;\n          break;\n        case 3:\n          o2 = this.color_spaces.DEVICE_RGB;\n      }\n      u2 = { data: t4, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r2, alias: n2 };\n    }\n    return u2;\n  };\n}(E$1.API);\nvar Vt, Gt, Yt, Jt, Xt, Kt = function() {\n  var t3, e2, i2;\n  function a2(t4) {\n    var e3, r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2, d2, p5;\n    for (this.data = t4, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {\n      switch (e3 = this.readUInt32(), u2 = function() {\n        var t5, e4;\n        for (e4 = [], t5 = 0; t5 < 4; ++t5)\n          e4.push(String.fromCharCode(this.data[this.pos++]));\n        return e4;\n      }.call(this).join(\"\")) {\n        case \"IHDR\":\n          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];\n          break;\n        case \"acTL\":\n          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };\n          break;\n        case \"PLTE\":\n          this.palette = this.read(e3);\n          break;\n        case \"fcTL\":\n          o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i3 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i3, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];\n          break;\n        case \"IDAT\":\n        case \"fdAT\":\n          for (u2 === \"fdAT\" && (this.pos += 4, e3 -= 4), t4 = (o3 != null ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e3 ? f2 < e3 : f2 > e3; 0 <= e3 ? ++f2 : --f2)\n            t4.push(this.data[this.pos++]);\n          break;\n        case \"tRNS\":\n          switch (this.transparency = {}, this.colorType) {\n            case 3:\n              if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n2)\n                throw new Error(\"More transparent colors than palette size\");\n              if ((h2 = n2 - this.transparency.indexed.length) > 0)\n                for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2)\n                  this.transparency.indexed.push(255);\n              break;\n            case 0:\n              this.transparency.grayscale = this.read(e3)[0];\n              break;\n            case 2:\n              this.transparency.rgb = this.read(e3);\n          }\n          break;\n        case \"tEXt\":\n          s2 = (l2 = this.read(e3)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));\n          break;\n        case \"IEND\":\n          return o3 && this.animation.frames.push(o3), this.colors = function() {\n            switch (this.colorType) {\n              case 0:\n              case 3:\n              case 4:\n                return 1;\n              case 2:\n              case 6:\n                return 3;\n            }\n          }.call(this), this.hasAlphaChannel = (p5 = this.colorType) === 4 || p5 === 6, r2 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r2, this.colorSpace = function() {\n            switch (this.colors) {\n              case 1:\n                return \"DeviceGray\";\n              case 3:\n                return \"DeviceRGB\";\n            }\n          }.call(this), void (this.imgData = new Uint8Array(this.imgData));\n        default:\n          this.pos += e3;\n      }\n      if (this.pos += 4, this.pos > this.data.length)\n        throw new Error(\"Incomplete or corrupt PNG file\");\n    }\n  }\n  a2.prototype.read = function(t4) {\n    var e3, r2;\n    for (r2 = [], e3 = 0; 0 <= t4 ? e3 < t4 : e3 > t4; 0 <= t4 ? ++e3 : --e3)\n      r2.push(this.data[this.pos++]);\n    return r2;\n  }, a2.prototype.readUInt32 = function() {\n    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];\n  }, a2.prototype.readUInt16 = function() {\n    return this.data[this.pos++] << 8 | this.data[this.pos++];\n  }, a2.prototype.decodePixels = function(t4) {\n    var e3 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e3), i3 = 0, a3 = this;\n    if (t4 == null && (t4 = this.imgData), t4.length === 0)\n      return new Uint8Array(0);\n    function o3(r2, o4, s2, c2) {\n      var u2, h2, l2, f2, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r2) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;\n      for (L2 = e3 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p5 = t4.length, N2 = 0, h2 = 0; N2 < C2 && i3 < p5; ) {\n        switch (t4[i3++]) {\n          case 0:\n            for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1)\n              w2[h2++] = t4[i3++];\n            break;\n          case 1:\n            for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1)\n              u2 = t4[i3++], d2 = f2 < e3 ? 0 : w2[h2 - e3], w2[h2++] = (u2 + d2) % 256;\n            break;\n          case 2:\n            for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1)\n              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (A2 + u2) % 256;\n            break;\n          case 3:\n            for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1)\n              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;\n            break;\n          case 4:\n            for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1)\n              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], N2 === 0 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e3 + f2 % e3]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;\n            break;\n          default:\n            throw new Error(\"Invalid filter algorithm: \" + t4[i3 - 1]);\n        }\n        if (!j2) {\n          var O2 = ((o4 + N2 * c2) * a3.width + r2) * e3, B3 = N2 * L2;\n          for (f2 = 0; f2 < F2; f2 += 1) {\n            for (var M2 = 0; M2 < e3; M2 += 1)\n              n2[O2++] = w2[B3++];\n            O2 += (s2 - 1) * e3;\n          }\n        }\n        N2++;\n      }\n    }\n    return t4 = unzlibSync(t4), a3.interlaceMethod == 1 ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;\n  }, a2.prototype.decodePalette = function() {\n    var t4, e3, r2, n2, i3, a3, o3, s2, c2;\n    for (r2 = this.palette, a3 = this.transparency.indexed || [], i3 = new Uint8Array((a3.length || 0) + r2.length), n2 = 0, t4 = 0, e3 = o3 = 0, s2 = r2.length; o3 < s2; e3 = o3 += 3)\n      i3[n2++] = r2[e3], i3[n2++] = r2[e3 + 1], i3[n2++] = r2[e3 + 2], i3[n2++] = (c2 = a3[t4++]) != null ? c2 : 255;\n    return i3;\n  }, a2.prototype.copyToImageData = function(t4, e3) {\n    var r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2;\n    if (n2 = this.colors, h2 = null, r2 = this.hasAlphaChannel, this.palette.length && (h2 = (f2 = this._decodedPalette) != null ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r2 = true), u2 = (i3 = t4.data || t4).length, o3 = h2 || e3, a3 = s2 = 0, n2 === 1)\n      for (; a3 < u2; )\n        c2 = h2 ? 4 * e3[a3 / 4] : s2, l2 = o3[c2++], i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;\n    else\n      for (; a3 < u2; )\n        c2 = h2 ? 4 * e3[a3 / 4] : s2, i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;\n  }, a2.prototype.decode = function() {\n    var t4;\n    return t4 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t4, this.decodePixels()), t4;\n  };\n  var o2 = function() {\n    if (Object.prototype.toString.call(n$1) === \"[object Window]\") {\n      try {\n        e2 = n$1.document.createElement(\"canvas\"), i2 = e2.getContext(\"2d\");\n      } catch (t4) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  };\n  return o2(), t3 = function(t4) {\n    var r2;\n    if (o2() === true)\n      return i2.width = t4.width, i2.height = t4.height, i2.clearRect(0, 0, t4.width, t4.height), i2.putImageData(t4, 0, 0), (r2 = new Image()).src = e2.toDataURL(), r2;\n    throw new Error(\"This method requires a Browser with Canvas-capability.\");\n  }, a2.prototype.decodeFrames = function(e3) {\n    var r2, n2, i3, a3, o3, s2, c2, u2;\n    if (this.animation) {\n      for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3)\n        r2 = c2[n2], i3 = e3.createImageData(r2.width, r2.height), a3 = this.decodePixels(new Uint8Array(r2.data)), this.copyToImageData(i3, a3), r2.imageData = i3, u2.push(r2.image = t3(i3));\n      return u2;\n    }\n  }, a2.prototype.renderFrame = function(t4, e3) {\n    var r2, n2, i3;\n    return r2 = (n2 = this.animation.frames)[e3], i3 = n2[e3 - 1], e3 === 0 && t4.clearRect(0, 0, this.width, this.height), (i3 != null ? i3.disposeOp : void 0) === 1 ? t4.clearRect(i3.xOffset, i3.yOffset, i3.width, i3.height) : (i3 != null ? i3.disposeOp : void 0) === 2 && t4.putImageData(i3.imageData, i3.xOffset, i3.yOffset), r2.blendOp === 0 && t4.clearRect(r2.xOffset, r2.yOffset, r2.width, r2.height), t4.drawImage(r2.image, r2.xOffset, r2.yOffset);\n  }, a2.prototype.animate = function(t4) {\n    var e3, r2, n2, i3, a3, o3, s2 = this;\n    return r2 = 0, o3 = this.animation, i3 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e3 = function() {\n      var o4, c2;\n      if (o4 = r2++ % i3, c2 = n2[o4], s2.renderFrame(t4, o4), i3 > 1 && r2 / i3 < a3)\n        return s2.animation._timeout = setTimeout(e3, c2.delay);\n    })();\n  }, a2.prototype.stopAnimation = function() {\n    var t4;\n    return clearTimeout((t4 = this.animation) != null ? t4._timeout : void 0);\n  }, a2.prototype.render = function(t4) {\n    var e3, r2;\n    return t4._png && t4._png.stopAnimation(), t4._png = this, t4.width = this.width, t4.height = this.height, e3 = t4.getContext(\"2d\"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r2 = e3.createImageData(this.width, this.height), this.copyToImageData(r2, this.decodePixels()), e3.putImageData(r2, 0, 0));\n  }, a2;\n}();\n/**\n * @license\n *\n * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n * ====================================================================\n */\n/**\n * @license\n * (c) Dean McNamee <dean@gmail.com>, 2013.\n *\n * https://github.com/deanm/omggif\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n * including animation and compression.  It does not rely on any specific\n * underlying system, so should run in the browser, Node, or Plask.\n */\nfunction Zt(t3) {\n  var e2 = 0;\n  if (t3[e2++] !== 71 || t3[e2++] !== 73 || t3[e2++] !== 70 || t3[e2++] !== 56 || (t3[e2++] + 1 & 253) != 56 || t3[e2++] !== 97)\n    throw new Error(\"Invalid GIF 87a/89a header.\");\n  var r2 = t3[e2++] | t3[e2++] << 8, n2 = t3[e2++] | t3[e2++] << 8, i2 = t3[e2++], a2 = i2 >> 7, o2 = 1 << (7 & i2) + 1;\n  t3[e2++];\n  t3[e2++];\n  var s2 = null, c2 = null;\n  a2 && (s2 = e2, c2 = o2, e2 += 3 * o2);\n  var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p5 = null;\n  for (this.width = r2, this.height = n2; u2 && e2 < t3.length; )\n    switch (t3[e2++]) {\n      case 33:\n        switch (t3[e2++]) {\n          case 255:\n            if (t3[e2] !== 11 || t3[e2 + 1] == 78 && t3[e2 + 2] == 69 && t3[e2 + 3] == 84 && t3[e2 + 4] == 83 && t3[e2 + 5] == 67 && t3[e2 + 6] == 65 && t3[e2 + 7] == 80 && t3[e2 + 8] == 69 && t3[e2 + 9] == 50 && t3[e2 + 10] == 46 && t3[e2 + 11] == 48 && t3[e2 + 12] == 3 && t3[e2 + 13] == 1 && t3[e2 + 16] == 0)\n              e2 += 14, p5 = t3[e2++] | t3[e2++] << 8, e2++;\n            else\n              for (e2 += 12; ; ) {\n                if (!((P2 = t3[e2++]) >= 0))\n                  throw Error(\"Invalid block size\");\n                if (P2 === 0)\n                  break;\n                e2 += P2;\n              }\n            break;\n          case 249:\n            if (t3[e2++] !== 4 || t3[e2 + 4] !== 0)\n              throw new Error(\"Invalid graphics extension block.\");\n            var g2 = t3[e2++];\n            l2 = t3[e2++] | t3[e2++] << 8, f2 = t3[e2++], (1 & g2) == 0 && (f2 = null), d2 = g2 >> 2 & 7, e2++;\n            break;\n          case 254:\n            for (; ; ) {\n              if (!((P2 = t3[e2++]) >= 0))\n                throw Error(\"Invalid block size\");\n              if (P2 === 0)\n                break;\n              e2 += P2;\n            }\n            break;\n          default:\n            throw new Error(\"Unknown graphic control label: 0x\" + t3[e2 - 1].toString(16));\n        }\n        break;\n      case 44:\n        var m2 = t3[e2++] | t3[e2++] << 8, v2 = t3[e2++] | t3[e2++] << 8, b2 = t3[e2++] | t3[e2++] << 8, y2 = t3[e2++] | t3[e2++] << 8, w2 = t3[e2++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;\n        if (w2 >> 7) {\n          S2 = true;\n          A2 = e2, x2 = L2, e2 += 3 * L2;\n        }\n        var _2 = e2;\n        for (e2++; ; ) {\n          var P2;\n          if (!((P2 = t3[e2++]) >= 0))\n            throw Error(\"Invalid block size\");\n          if (P2 === 0)\n            break;\n          e2 += P2;\n        }\n        h2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e2 - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });\n        break;\n      case 59:\n        u2 = false;\n        break;\n      default:\n        throw new Error(\"Unknown gif block: 0x\" + t3[e2 - 1].toString(16));\n    }\n  this.numFrames = function() {\n    return h2.length;\n  }, this.loopCount = function() {\n    return p5;\n  }, this.frameInfo = function(t4) {\n    if (t4 < 0 || t4 >= h2.length)\n      throw new Error(\"Frame index out of range.\");\n    return h2[t4];\n  }, this.decodeAndBlitFrameBGRA = function(e3, n3) {\n    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);\n    $t(t3, i3.data_offset, o3, a3);\n    var s3 = i3.palette_offset, c3 = i3.transparent_index;\n    c3 === null && (c3 = 256);\n    var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p6 = f3, g3 = 4 * h3;\n    i3.interlaced === true && (g3 += 4 * r2 * 7);\n    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {\n      var y3 = o3[v3];\n      if (l3 === 0 && (l3 = u3, (p6 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p6 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)\n        p6 += 4;\n      else {\n        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];\n        n3[p6++] = L3, n3[p6++] = N3, n3[p6++] = w3, n3[p6++] = 255;\n      }\n      --l3;\n    }\n  }, this.decodeAndBlitFrameRGBA = function(e3, n3) {\n    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);\n    $t(t3, i3.data_offset, o3, a3);\n    var s3 = i3.palette_offset, c3 = i3.transparent_index;\n    c3 === null && (c3 = 256);\n    var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p6 = f3, g3 = 4 * h3;\n    i3.interlaced === true && (g3 += 4 * r2 * 7);\n    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {\n      var y3 = o3[v3];\n      if (l3 === 0 && (l3 = u3, (p6 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p6 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)\n        p6 += 4;\n      else {\n        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];\n        n3[p6++] = w3, n3[p6++] = N3, n3[p6++] = L3, n3[p6++] = 255;\n      }\n      --l3;\n    }\n  };\n}\nfunction $t(t3, e2, r2, n2) {\n  for (var i2 = t3[e2++], o2 = 1 << i2, s2 = o2 + 1, c2 = s2 + 1, u2 = i2 + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p5 = t3[e2++], g2 = new Int32Array(4096), m2 = null; ; ) {\n    for (; l2 < 16 && p5 !== 0; )\n      f2 |= t3[e2++] << l2, l2 += 8, p5 === 1 ? p5 = t3[e2++] : --p5;\n    if (l2 < u2)\n      break;\n    var v2 = f2 & h2;\n    if (f2 >>= u2, l2 -= u2, v2 !== o2) {\n      if (v2 === s2)\n        break;\n      for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; )\n        w2 = g2[w2] >> 8, ++y2;\n      var N2 = w2;\n      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2)\n        return void a$2.log(\"Warning, gif stream longer than expected.\");\n      r2[d2++] = N2;\n      var L2 = d2 += y2;\n      for (b2 !== v2 && (r2[d2++] = N2), w2 = b2; y2--; )\n        w2 = g2[w2], r2[--L2] = 255 & w2, w2 >>= 8;\n      m2 !== null && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;\n    } else\n      c2 = s2 + 1, h2 = (1 << (u2 = i2 + 1)) - 1, m2 = null;\n  }\n  return d2 !== n2 && a$2.log(\"Warning, gif stream shorter than expected.\"), r2;\n}\n/**\n * @license\n  Copyright (c) 2008, Adobe Systems Incorporated\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without \n  modification, are permitted provided that the following conditions are\n  met:\n\n  * Redistributions of source code must retain the above copyright notice, \n    this list of conditions and the following disclaimer.\n  \n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the \n    documentation and/or other materials provided with the distribution.\n  \n  * Neither the name of Adobe Systems Incorporated nor the names of its \n    contributors may be used to endorse or promote products derived from \n    this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR \n  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nfunction Qt(t3) {\n  var e2, r2, n2, i2, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p5 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];\n  function j2(t4, e3) {\n    for (var r3 = 0, n3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {\n      for (var o3 = 1; o3 <= t4[a3]; o3++)\n        i3[e3[n3]] = [], i3[e3[n3]][0] = r3, i3[e3[n3]][1] = a3, n3++, r3++;\n      r3 *= 2;\n    }\n    return i3;\n  }\n  function O2(t4) {\n    for (var e3 = t4[0], r3 = t4[1] - 1; r3 >= 0; )\n      e3 & 1 << r3 && (m2 |= 1 << v2), r3--, --v2 < 0 && (m2 == 255 ? (B3(255), B3(0)) : B3(m2), v2 = 7, m2 = 0);\n  }\n  function B3(t4) {\n    g2.push(t4);\n  }\n  function M2(t4) {\n    B3(t4 >> 8 & 255), B3(255 & t4);\n  }\n  function E2(t4, e3, r3, n3, i3) {\n    for (var a3, o3 = i3[0], s3 = i3[240], c3 = function(t5, e4) {\n      var r4, n4, i4, a4, o4, s4, c4, u4, h4, l3, f3 = 0;\n      for (h4 = 0; h4 < 8; ++h4) {\n        r4 = t5[f3], n4 = t5[f3 + 1], i4 = t5[f3 + 2], a4 = t5[f3 + 3], o4 = t5[f3 + 4], s4 = t5[f3 + 5], c4 = t5[f3 + 6];\n        var p6 = r4 + (u4 = t5[f3 + 7]), g4 = r4 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p6 + w4, A3 = p6 - w4, x3 = m4 + b4, S3 = m4 - b4;\n        t5[f3] = L3 + x3, t5[f3 + 4] = L3 - x3;\n        var _3 = 0.707106781 * (S3 + A3);\n        t5[f3 + 2] = A3 + _3, t5[f3 + 6] = A3 - _3;\n        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;\n        t5[f3 + 5] = j3 + k3, t5[f3 + 3] = j3 - k3, t5[f3 + 1] = C3 + I3, t5[f3 + 7] = C3 - I3, f3 += 8;\n      }\n      for (f3 = 0, h4 = 0; h4 < 8; ++h4) {\n        r4 = t5[f3], n4 = t5[f3 + 8], i4 = t5[f3 + 16], a4 = t5[f3 + 24], o4 = t5[f3 + 32], s4 = t5[f3 + 40], c4 = t5[f3 + 48];\n        var O3 = r4 + (u4 = t5[f3 + 56]), B4 = r4 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i4 + s4, D2 = i4 - s4, R2 = a4 + o4, T2 = a4 - o4, z2 = O3 + R2, U2 = O3 - R2, H4 = M3 + q3, W2 = M3 - q3;\n        t5[f3] = z2 + H4, t5[f3 + 32] = z2 - H4;\n        var V2 = 0.707106781 * (W2 + U2);\n        t5[f3 + 16] = U2 + V2, t5[f3 + 48] = U2 - V2;\n        var G2 = 0.382683433 * ((z2 = T2 + D2) - (W2 = E3 + B4)), Y2 = 0.5411961 * z2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H4 = D2 + E3), K2 = B4 + X2, Z2 = B4 - X2;\n        t5[f3 + 40] = Z2 + Y2, t5[f3 + 24] = Z2 - Y2, t5[f3 + 8] = K2 + J2, t5[f3 + 56] = K2 - J2, f3++;\n      }\n      for (h4 = 0; h4 < 64; ++h4)\n        l3 = t5[h4] * e4[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;\n      return d2;\n    }(t4, e3), u3 = 0; u3 < 64; ++u3)\n      p5[A2[u3]] = c3[u3];\n    var h3 = p5[0] - r3;\n    r3 = p5[0], h3 == 0 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));\n    for (var g3 = 63; g3 > 0 && p5[g3] == 0; )\n      g3--;\n    if (g3 == 0)\n      return O2(o3), r3;\n    for (var m3, v3 = 1; v3 <= g3; ) {\n      for (var b3 = v3; p5[v3] == 0 && v3 <= g3; )\n        ++v3;\n      var y3 = v3 - b3;\n      if (y3 >= 16) {\n        m3 = y3 >> 4;\n        for (var w3 = 1; w3 <= m3; ++w3)\n          O2(s3);\n        y3 &= 15;\n      }\n      a3 = 32767 + p5[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;\n    }\n    return g3 != 63 && O2(o3), r3;\n  }\n  function q2(t4) {\n    (t4 = Math.min(Math.max(t4, 1), 100), a2 != t4) && (!function(t5) {\n      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0; r3 < 64; r3++) {\n        var n3 = o2((e3[r3] * t5 + 50) / 100);\n        n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r3]] = n3;\n      }\n      for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {\n        var l3 = o2((i3[a3] * t5 + 50) / 100);\n        l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;\n      }\n      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p6 = 0; p6 < 8; p6++)\n        for (var g3 = 0; g3 < 8; g3++)\n          u2[d3] = 1 / (s2[A2[d3]] * f3[p6] * f3[g3] * 8), h2[d3] = 1 / (c2[A2[d3]] * f3[p6] * f3[g3] * 8), d3++;\n    }(t4 < 50 ? Math.floor(5e3 / t4) : Math.floor(200 - 2 * t4)), a2 = t4);\n  }\n  this.encode = function(t4, a3) {\n    a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B3(74), B3(70), B3(73), B3(70), B3(0), B3(1), B3(1), B3(0), M2(1), M2(1), B3(0), B3(0), function() {\n      M2(65499), M2(132), B3(0);\n      for (var t5 = 0; t5 < 64; t5++)\n        B3(s2[t5]);\n      B3(1);\n      for (var e3 = 0; e3 < 64; e3++)\n        B3(c2[e3]);\n    }(), function(t5, e3) {\n      M2(65472), M2(17), B3(8), M2(e3), M2(t5), B3(3), B3(1), B3(17), B3(0), B3(2), B3(17), B3(1), B3(3), B3(17), B3(1);\n    }(t4.width, t4.height), function() {\n      M2(65476), M2(418), B3(0);\n      for (var t5 = 0; t5 < 16; t5++)\n        B3(x2[t5 + 1]);\n      for (var e3 = 0; e3 <= 11; e3++)\n        B3(S2[e3]);\n      B3(16);\n      for (var r3 = 0; r3 < 16; r3++)\n        B3(_2[r3 + 1]);\n      for (var n3 = 0; n3 <= 161; n3++)\n        B3(P2[n3]);\n      B3(1);\n      for (var i3 = 0; i3 < 16; i3++)\n        B3(k2[i3 + 1]);\n      for (var a4 = 0; a4 <= 11; a4++)\n        B3(I2[a4]);\n      B3(17);\n      for (var o4 = 0; o4 < 16; o4++)\n        B3(F2[o4 + 1]);\n      for (var s3 = 0; s3 <= 161; s3++)\n        B3(C2[s3]);\n    }(), M2(65498), M2(12), B3(3), B3(1), B3(0), B3(2), B3(17), B3(3), B3(17), B3(0), B3(63), B3(0);\n    var o3 = 0, l3 = 0, f3 = 0;\n    m2 = 0, v2 = 7, this.encode.displayName = \"_encode_\";\n    for (var d3, p6, N3, A3, j3, D2, R2, T2, z2, U2 = t4.data, H4 = t4.width, W2 = t4.height, V2 = 4 * H4, G2 = 0; G2 < W2; ) {\n      for (d3 = 0; d3 < V2; ) {\n        for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, z2 = 0; z2 < 64; z2++)\n          D2 = j3 + (T2 = z2 >> 3) * V2 + (R2 = 4 * (7 & z2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p6 = U2[D2++], N3 = U2[D2++], A3 = U2[D2++], b2[z2] = (L2[p6] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[z2] = (L2[p6 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[z2] = (L2[p6 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;\n        o3 = E2(b2, u2, o3, e2, n2), l3 = E2(y2, h2, l3, r2, i2), f3 = E2(w2, h2, f3, r2, i2), d3 += 32;\n      }\n      G2 += 8;\n    }\n    if (v2 >= 0) {\n      var Y2 = [];\n      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);\n    }\n    return M2(65497), new Uint8Array(g2);\n  }, t3 = t3 || 50, function() {\n    for (var t4 = String.fromCharCode, e3 = 0; e3 < 256; e3++)\n      N2[e3] = t4(e3);\n  }(), e2 = j2(x2, S2), r2 = j2(k2, I2), n2 = j2(_2, P2), i2 = j2(F2, C2), function() {\n    for (var t4 = 1, e3 = 2, r3 = 1; r3 <= 15; r3++) {\n      for (var n3 = t4; n3 < e3; n3++)\n        f2[32767 + n3] = r3, l2[32767 + n3] = [], l2[32767 + n3][1] = r3, l2[32767 + n3][0] = n3;\n      for (var i3 = -(e3 - 1); i3 <= -t4; i3++)\n        f2[32767 + i3] = r3, l2[32767 + i3] = [], l2[32767 + i3][1] = r3, l2[32767 + i3][0] = e3 - 1 + i3;\n      t4 <<= 1, e3 <<= 1;\n    }\n  }(), function() {\n    for (var t4 = 0; t4 < 256; t4++)\n      L2[t4] = 19595 * t4, L2[t4 + 256 >> 0] = 38470 * t4, L2[t4 + 512 >> 0] = 7471 * t4 + 32768, L2[t4 + 768 >> 0] = -11059 * t4, L2[t4 + 1024 >> 0] = -21709 * t4, L2[t4 + 1280 >> 0] = 32768 * t4 + 8421375, L2[t4 + 1536 >> 0] = -27439 * t4, L2[t4 + 1792 >> 0] = -5329 * t4;\n  }(), q2(t3);\n}\n/**\n * @license\n * Copyright (c) 2017 Aras Abbasi\n *\n * Licensed under the MIT License.\n * http://opensource.org/licenses/mit-license\n */\nfunction te(t3, e2) {\n  if (this.pos = 0, this.buffer = t3, this.datav = new DataView(t3.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, [\"BM\", \"BA\", \"CI\", \"CP\", \"IC\", \"PT\"].indexOf(this.flag) === -1)\n    throw new Error(\"Invalid BMP File\");\n  this.parseHeader(), this.parseBGR();\n}\nfunction ee(t3) {\n  function e2(t4) {\n    if (!t4)\n      throw Error(\"assert :P\");\n  }\n  function r2(t4, e3, r3) {\n    for (var n3 = 0; 4 > n3; n3++)\n      if (t4[e3 + n3] != r3.charCodeAt(n3))\n        return true;\n    return false;\n  }\n  function n2(t4, e3, r3, n3, i3) {\n    for (var a3 = 0; a3 < i3; a3++)\n      t4[e3 + a3] = r3[n3 + a3];\n  }\n  function i2(t4, e3, r3, n3) {\n    for (var i3 = 0; i3 < n3; i3++)\n      t4[e3 + i3] = r3;\n  }\n  function a2(t4) {\n    return new Int32Array(t4);\n  }\n  function o2(t4, e3) {\n    for (var r3 = [], n3 = 0; n3 < t4; n3++)\n      r3.push(new e3());\n    return r3;\n  }\n  function s2(t4, e3) {\n    var r3 = [];\n    return function t5(r4, n3, i3) {\n      for (var a3 = i3[n3], o3 = 0; o3 < a3 && (r4.push(i3.length > n3 + 1 ? [] : new e3()), !(i3.length < n3 + 1)); o3++)\n        t5(r4[o3], n3 + 1, i3);\n    }(r3, 0, t4), r3;\n  }\n  var c2 = function() {\n    var t4 = this;\n    function c3(t5, e3) {\n      for (var r3 = 1 << e3 - 1 >>> 0; t5 & r3; )\n        r3 >>>= 1;\n      return r3 ? (t5 & r3 - 1) + r3 : t5;\n    }\n    function u3(t5, r3, n3, i3, a3) {\n      e2(!(i3 % n3));\n      do {\n        t5[r3 + (i3 -= n3)] = a3;\n      } while (0 < i3);\n    }\n    function h3(t5, r3, n3, i3, o3) {\n      if (e2(2328 >= o3), 512 >= o3)\n        var s3 = a2(512);\n      else if ((s3 = a2(o3)) == null)\n        return 0;\n      return function(t6, r4, n4, i4, o4, s4) {\n        var h4, f4, d4 = r4, p7 = 1 << n4, g4 = a2(16), m4 = a2(16);\n        for (e2(o4 != 0), e2(i4 != null), e2(t6 != null), e2(0 < n4), f4 = 0; f4 < o4; ++f4) {\n          if (15 < i4[f4])\n            return 0;\n          ++g4[i4[f4]];\n        }\n        if (g4[0] == o4)\n          return 0;\n        for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {\n          if (g4[h4] > 1 << h4)\n            return 0;\n          m4[h4 + 1] = m4[h4] + g4[h4];\n        }\n        for (f4 = 0; f4 < o4; ++f4)\n          h4 = i4[f4], 0 < i4[f4] && (s4[m4[h4]++] = f4);\n        if (m4[15] == 1)\n          return (i4 = new l3()).g = 0, i4.value = s4[0], u3(t6, d4, 1, p7, i4), p7;\n        var v4, b4 = -1, y4 = p7 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;\n        for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {\n          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))\n            return 0;\n          for (; 0 < g4[h4]; --g4[h4])\n            (i4 = new l3()).g = h4, i4.value = s4[f4++], u3(t6, d4 + w4, o4, A4, i4), w4 = c3(w4, h4);\n        }\n        for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {\n          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))\n            return 0;\n          for (; 0 < g4[h4]; --g4[h4]) {\n            if (i4 = new l3(), (w4 & y4) != b4) {\n              for (d4 += A4, v4 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); )\n                ++b4, v4 <<= 1;\n              p7 += A4 = 1 << (v4 = b4 - n4), t6[r4 + (b4 = w4 & y4)].g = v4 + n4, t6[r4 + b4].value = d4 - r4 - b4;\n            }\n            i4.g = h4 - n4, i4.value = s4[f4++], u3(t6, d4 + (w4 >> n4), o4, A4, i4), w4 = c3(w4, h4);\n          }\n        }\n        return N4 != 2 * m4[15] - 1 ? 0 : p7;\n      }(t5, r3, n3, i3, o3, s3);\n    }\n    function l3() {\n      this.value = this.g = 0;\n    }\n    function f3() {\n      this.value = this.g = 0;\n    }\n    function d3() {\n      this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);\n    }\n    function p6(t5, r3, n3, i3) {\n      e2(t5 != null), e2(r3 != null), e2(2147483648 > i3), t5.Ca = 254, t5.I = 0, t5.b = -8, t5.Ka = 0, t5.oa = r3, t5.pa = n3, t5.Jd = r3, t5.Yc = n3 + i3, t5.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t5);\n    }\n    function g3(t5, e3) {\n      for (var r3 = 0; 0 < e3--; )\n        r3 |= k2(t5, 128) << e3;\n      return r3;\n    }\n    function m3(t5, e3) {\n      var r3 = g3(t5, e3);\n      return P2(t5) ? -r3 : r3;\n    }\n    function v3(t5, r3, n3, i3) {\n      var a3, o3 = 0;\n      for (e2(t5 != null), e2(r3 != null), e2(4294967288 > i3), t5.Sb = i3, t5.Ra = 0, t5.u = 0, t5.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3)\n        o3 += r3[n3 + a3] << 8 * a3;\n      t5.Ra = o3, t5.bb = i3, t5.oa = r3, t5.pa = n3;\n    }\n    function b3(t5) {\n      for (; 8 <= t5.u && t5.bb < t5.Sb; )\n        t5.Ra >>>= 8, t5.Ra += t5.oa[t5.pa + t5.bb] << zr - 8 >>> 0, ++t5.bb, t5.u -= 8;\n      A3(t5) && (t5.h = 1, t5.u = 0);\n    }\n    function y3(t5, r3) {\n      if (e2(0 <= r3), !t5.h && r3 <= Tr) {\n        var n3 = L3(t5) & Rr[r3];\n        return t5.u += r3, b3(t5), n3;\n      }\n      return t5.h = 1, t5.u = 0;\n    }\n    function w3() {\n      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;\n    }\n    function N3() {\n      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;\n    }\n    function L3(t5) {\n      return t5.Ra >>> (t5.u & zr - 1) >>> 0;\n    }\n    function A3(t5) {\n      return e2(t5.bb <= t5.Sb), t5.h || t5.bb == t5.Sb && t5.u > zr;\n    }\n    function x2(t5, e3) {\n      t5.u = e3, t5.h = A3(t5);\n    }\n    function S2(t5) {\n      t5.u >= Ur && (e2(t5.u >= Ur), b3(t5));\n    }\n    function _2(t5) {\n      e2(t5 != null && t5.oa != null), t5.pa < t5.Zc ? (t5.I = (t5.oa[t5.pa++] | t5.I << 8) >>> 0, t5.b += 8) : (e2(t5 != null && t5.oa != null), t5.pa < t5.Yc ? (t5.b += 8, t5.I = t5.oa[t5.pa++] | t5.I << 8) : t5.Ka ? t5.b = 0 : (t5.I <<= 8, t5.b += 8, t5.Ka = 1));\n    }\n    function P2(t5) {\n      return g3(t5, 1);\n    }\n    function k2(t5, e3) {\n      var r3 = t5.Ca;\n      0 > t5.b && _2(t5);\n      var n3 = t5.b, i3 = r3 * e3 >>> 8, a3 = (t5.I >>> n3 > i3) + 0;\n      for (a3 ? (r3 -= i3, t5.I -= i3 + 1 << n3 >>> 0) : r3 = i3 + 1, n3 = r3, i3 = 0; 256 <= n3; )\n        i3 += 8, n3 >>= 8;\n      return n3 = 7 ^ i3 + Hr[n3], t5.b -= n3, t5.Ca = (r3 << n3) - 1, a3;\n    }\n    function I2(t5, e3, r3) {\n      t5[e3 + 0] = r3 >> 24 & 255, t5[e3 + 1] = r3 >> 16 & 255, t5[e3 + 2] = r3 >> 8 & 255, t5[e3 + 3] = r3 >> 0 & 255;\n    }\n    function F2(t5, e3) {\n      return t5[e3 + 0] << 0 | t5[e3 + 1] << 8;\n    }\n    function C2(t5, e3) {\n      return F2(t5, e3) | t5[e3 + 2] << 16;\n    }\n    function j2(t5, e3) {\n      return F2(t5, e3) | F2(t5, e3 + 2) << 16;\n    }\n    function O2(t5, r3) {\n      var n3 = 1 << r3;\n      return e2(t5 != null), e2(0 < r3), t5.X = a2(n3), t5.X == null ? 0 : (t5.Mb = 32 - r3, t5.Xa = r3, 1);\n    }\n    function B3(t5, r3) {\n      e2(t5 != null), e2(r3 != null), e2(t5.Xa == r3.Xa), n2(r3.X, 0, t5.X, 0, 1 << r3.Xa);\n    }\n    function M2() {\n      this.X = [], this.Xa = this.Mb = 0;\n    }\n    function E2(t5, r3, n3, i3) {\n      e2(n3 != null), e2(i3 != null);\n      var a3 = n3[0], o3 = i3[0];\n      return a3 == 0 && (a3 = (t5 * o3 + r3 / 2) / r3), o3 == 0 && (o3 = (r3 * a3 + t5 / 2) / t5), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i3[0] = o3, 1);\n    }\n    function q2(t5, e3) {\n      return t5 + (1 << e3) - 1 >>> e3;\n    }\n    function D2(t5, e3) {\n      return ((4278255360 & t5) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t5) + (16711935 & e3) >>> 0 & 16711935) >>> 0;\n    }\n    function R2(e3, r3) {\n      t4[r3] = function(r4, n3, i3, a3, o3, s3, c4) {\n        var u4;\n        for (u4 = 0; u4 < o3; ++u4) {\n          var h4 = t4[e3](s3[c4 + u4 - 1], i3, a3 + u4);\n          s3[c4 + u4] = D2(r4[n3 + u4], h4);\n        }\n      };\n    }\n    function T2() {\n      this.ud = this.hd = this.jd = 0;\n    }\n    function z2(t5, e3) {\n      return ((4278124286 & (t5 ^ e3)) >>> 1) + (t5 & e3) >>> 0;\n    }\n    function U2(t5) {\n      return 0 <= t5 && 256 > t5 ? t5 : 0 > t5 ? 0 : 255 < t5 ? 255 : void 0;\n    }\n    function H4(t5, e3) {\n      return U2(t5 + (t5 - e3 + 0.5 >> 1));\n    }\n    function W2(t5, e3, r3) {\n      return Math.abs(e3 - r3) - Math.abs(t5 - r3);\n    }\n    function V2(t5, e3, r3, n3, i3, a3, o3) {\n      for (n3 = a3[o3 - 1], r3 = 0; r3 < i3; ++r3)\n        a3[o3 + r3] = n3 = D2(t5[e3 + r3], n3);\n    }\n    function G2(t5, e3, r3, n3, i3) {\n      var a3;\n      for (a3 = 0; a3 < r3; ++a3) {\n        var o3 = t5[e3 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));\n        n3[i3 + a3] = (4278255360 & o3) + c4 >>> 0;\n      }\n    }\n    function Y2(t5, e3) {\n      e3.jd = t5 >> 0 & 255, e3.hd = t5 >> 8 & 255, e3.ud = t5 >> 16 & 255;\n    }\n    function J2(t5, e3, r3, n3, i3, a3) {\n      var o3;\n      for (o3 = 0; o3 < n3; ++o3) {\n        var s3 = e3[r3 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t5.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));\n        u4 = 255 & (u4 = (u4 = u4 + ((t5.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t5.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));\n        i3[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;\n      }\n    }\n    function X2(e3, r3, n3, i3, a3) {\n      t4[r3] = function(t5, e4, r4, n4, o3, s3, c4, u4, h4) {\n        for (n4 = c4; n4 < u4; ++n4)\n          for (c4 = 0; c4 < h4; ++c4)\n            o3[s3++] = a3(r4[i3(t5[e4++])]);\n      }, t4[e3] = function(e4, r4, o3, s3, c4, u4, h4) {\n        var l4 = 8 >> e4.b, f4 = e4.Ea, d4 = e4.K[0], p7 = e4.w;\n        if (8 > l4)\n          for (e4 = (1 << e4.b) - 1, p7 = (1 << l4) - 1; r4 < o3; ++r4) {\n            var g4, m4 = 0;\n            for (g4 = 0; g4 < f4; ++g4)\n              g4 & e4 || (m4 = i3(s3[c4++])), u4[h4++] = a3(d4[m4 & p7]), m4 >>= l4;\n          }\n        else\n          t4[\"VP8LMapColor\" + n3](s3, c4, d4, p7, u4, h4, r4, o3, f4);\n      };\n    }\n    function K2(t5, e3, r3, n3, i3) {\n      for (r3 = e3 + r3; e3 < r3; ) {\n        var a3 = t5[e3++];\n        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255;\n      }\n    }\n    function Z2(t5, e3, r3, n3, i3) {\n      for (r3 = e3 + r3; e3 < r3; ) {\n        var a3 = t5[e3++];\n        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 24 & 255;\n      }\n    }\n    function $2(t5, e3, r3, n3, i3) {\n      for (r3 = e3 + r3; e3 < r3; ) {\n        var a3 = (o3 = t5[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;\n        n3[i3++] = a3, n3[i3++] = o3;\n      }\n    }\n    function Q2(t5, e3, r3, n3, i3) {\n      for (r3 = e3 + r3; e3 < r3; ) {\n        var a3 = (o3 = t5[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;\n        n3[i3++] = a3, n3[i3++] = o3;\n      }\n    }\n    function tt2(t5, e3, r3, n3, i3) {\n      for (r3 = e3 + r3; e3 < r3; ) {\n        var a3 = t5[e3++];\n        n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 16 & 255;\n      }\n    }\n    function et2(t5, e3, r3, i3, a3, o3) {\n      if (o3 == 0)\n        for (r3 = e3 + r3; e3 < r3; )\n          I2(i3, ((o3 = t5[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;\n      else\n        n2(i3, a3, t5, e3, r3);\n    }\n    function rt2(e3, r3) {\n      t4[r3][0] = t4[e3 + \"0\"], t4[r3][1] = t4[e3 + \"1\"], t4[r3][2] = t4[e3 + \"2\"], t4[r3][3] = t4[e3 + \"3\"], t4[r3][4] = t4[e3 + \"4\"], t4[r3][5] = t4[e3 + \"5\"], t4[r3][6] = t4[e3 + \"6\"], t4[r3][7] = t4[e3 + \"7\"], t4[r3][8] = t4[e3 + \"8\"], t4[r3][9] = t4[e3 + \"9\"], t4[r3][10] = t4[e3 + \"10\"], t4[r3][11] = t4[e3 + \"11\"], t4[r3][12] = t4[e3 + \"12\"], t4[r3][13] = t4[e3 + \"13\"], t4[r3][14] = t4[e3 + \"0\"], t4[r3][15] = t4[e3 + \"0\"];\n    }\n    function nt2(t5) {\n      return t5 == Hn || t5 == Wn || t5 == Vn || t5 == Gn;\n    }\n    function it2() {\n      this.eb = [], this.size = this.A = this.fb = 0;\n    }\n    function at2() {\n      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;\n    }\n    function ot2() {\n      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;\n    }\n    function st2() {\n      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];\n    }\n    function ct2() {\n      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;\n    }\n    function ut2(t5) {\n      return alert(\"todo:WebPSamplerProcessPlane\"), t5.T;\n    }\n    function ht2(t5, e3) {\n      var r3 = t5.T, i3 = e3.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t5.ka * i3.A, s3 = vi[e3.ba.S], c4 = t5.y, u4 = t5.O, h4 = t5.f, l4 = t5.N, f4 = t5.ea, d4 = t5.W, p7 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v4 = e3.Nc, b4 = t5.ka, y4 = t5.ka + t5.T, w4 = t5.U, N4 = w4 + 1 >> 1;\n      for (b4 == 0 ? s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, c4, u4, p7, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++r3); b4 + 2 < y4; b4 += 2)\n        p7 = h4, g4 = l4, m4 = f4, v4 = d4, l4 += t5.Rc, d4 += t5.Rc, o3 += 2 * i3.A, s3(c4, (u4 += 2 * t5.fa) - t5.fa, c4, u4, p7, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4);\n      return u4 += t5.fa, t5.j + y4 < t5.o ? (n2(e3.ec, e3.fc, c4, u4, w4), n2(e3.cc, e3.dc, h4, l4, N4), n2(e3.Mc, e3.Nc, f4, d4, N4), r3--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3 + i3.A, null, null, w4), r3;\n    }\n    function lt2(t5, r3, n3) {\n      var i3 = t5.F, a3 = [t5.J];\n      if (i3 != null) {\n        var o3 = t5.U, s3 = r3.ba.S, c4 = s3 == Tn || s3 == Vn;\n        r3 = r3.ba.f.RGBA;\n        var u4 = [0], h4 = t5.ka;\n        u4[0] = t5.T, t5.Kb && (h4 == 0 ? --u4[0] : (--h4, a3[0] -= t5.width), t5.j + t5.ka + t5.T == t5.o && (u4[0] = t5.o - t5.j - h4));\n        var l4 = r3.eb;\n        h4 = r3.fb + h4 * r3.A;\n        t5 = Sn(i3, a3[0], t5.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r3.A), e2(n3 == u4), t5 && nt2(s3) && An(l4, h4, c4, o3, u4, r3.A);\n      }\n      return 0;\n    }\n    function ft2(t5) {\n      var e3 = t5.ma, r3 = e3.ba.S, n3 = 11 > r3, i3 = r3 == qn || r3 == Rn || r3 == Tn || r3 == zn || r3 == 12 || nt2(r3);\n      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t5, i3 ? 11 : 12))\n        return 0;\n      if (i3 && nt2(r3) && br(), t5.da)\n        alert(\"todo:use_scaling\");\n      else {\n        if (n3) {\n          if (e3.Ib = ut2, t5.Kb) {\n            if (r3 = t5.U + 1 >> 1, e3.memory = a2(t5.U + 2 * r3), e3.memory == null)\n              return 0;\n            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t5.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r3, e3.Ib = ht2, br();\n          }\n        } else\n          alert(\"todo:EmitYUV\");\n        i3 && (e3.Jb = lt2, n3 && mr());\n      }\n      if (n3 && !Ci) {\n        for (t5 = 0; 256 > t5; ++t5)\n          ji[t5] = 89858 * (t5 - 128) + _i >> Si, Mi[t5] = -22014 * (t5 - 128) + _i, Bi[t5] = -45773 * (t5 - 128), Oi[t5] = 113618 * (t5 - 128) + _i >> Si;\n        for (t5 = Pi; t5 < ki; ++t5)\n          e3 = 76283 * (t5 - 16) + _i >> Si, Ei[t5 - Pi] = Vt2(e3, 255), qi[t5 - Pi] = Vt2(e3 + 8 >> 4, 15);\n        Ci = 1;\n      }\n      return 1;\n    }\n    function dt2(t5) {\n      var r3 = t5.ma, n3 = t5.U, i3 = t5.T;\n      return e2(!(1 & t5.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r3.Ib(t5, r3), r3.Jb != null && r3.Jb(t5, r3, n3), r3.Dc += n3, 1);\n    }\n    function pt2(t5) {\n      t5.ma.memory = null;\n    }\n    function gt2(t5, e3, r3, n3) {\n      return y3(t5, 8) != 47 ? 0 : (e3[0] = y3(t5, 14) + 1, r3[0] = y3(t5, 14) + 1, n3[0] = y3(t5, 1), y3(t5, 3) != 0 ? 0 : !t5.h);\n    }\n    function mt2(t5, e3) {\n      if (4 > t5)\n        return t5 + 1;\n      var r3 = t5 - 2 >> 1;\n      return (2 + (1 & t5) << r3) + y3(e3, r3) + 1;\n    }\n    function vt2(t5, e3) {\n      return 120 < e3 ? e3 - 120 : 1 <= (r3 = ((r3 = $n[e3 - 1]) >> 4) * t5 + (8 - (15 & r3))) ? r3 : 1;\n      var r3;\n    }\n    function bt2(t5, e3, r3) {\n      var n3 = L3(r3), i3 = t5[e3 += 255 & n3].g - 8;\n      return 0 < i3 && (x2(r3, r3.u + 8), n3 = L3(r3), e3 += t5[e3].value, e3 += n3 & (1 << i3) - 1), x2(r3, r3.u + t5[e3].g), t5[e3].value;\n    }\n    function yt2(t5, r3, n3) {\n      return n3.g += t5.g, n3.value += t5.value << r3 >>> 0, e2(8 >= n3.g), t5.g;\n    }\n    function wt2(t5, r3, n3) {\n      var i3 = t5.xc;\n      return e2((r3 = i3 == 0 ? 0 : t5.vc[t5.md * (n3 >> i3) + (r3 >> i3)]) < t5.Wb), t5.Ya[r3];\n    }\n    function Nt2(t5, r3, i3, a3) {\n      var o3 = t5.ab, s3 = t5.c * r3, c4 = t5.C;\n      r3 = c4 + r3;\n      var u4 = i3, h4 = a3;\n      for (a3 = t5.Ta, i3 = t5.Ua; 0 < o3--; ) {\n        var l4 = t5.gc[o3], f4 = c4, d4 = r3, p7 = u4, g4 = h4, m4 = (h4 = a3, u4 = i3, l4.Ea);\n        switch (e2(f4 < d4), e2(d4 <= l4.nc), l4.hc) {\n          case 2:\n            Gr(p7, g4, (d4 - f4) * m4, h4, u4);\n            break;\n          case 0:\n            var v4 = f4, b4 = d4, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;\n            v4 == 0 && (Wr(p7, g4, null, null, 1, y4, w4), V2(p7, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);\n            for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {\n              var P3 = S3, k3 = _3, I3 = 1;\n              for (Vr(p7, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {\n                var F3 = (I3 & ~A4) + L4;\n                F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p7, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;\n              }\n              g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);\n            }\n            d4 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d4 - f4 - 1) * m4, m4);\n            break;\n          case 1:\n            for (m4 = p7, b4 = g4, N4 = (p7 = l4.Ea) - (w4 = p7 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p7, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {\n              for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p7; b4 < _3; )\n                Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;\n              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);\n            }\n            break;\n          case 3:\n            if (p7 == h4 && g4 == u4 && 0 < l4.b) {\n              for (b4 = h4, p7 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4)\n                v4[w4] = g4[y4 + w4];\n              for (w4 = N4 - 1; 0 <= w4; --w4)\n                b4[p7 + w4] = v4[w4];\n              Yr(l4, f4, d4, h4, m4, h4, u4);\n            } else\n              Yr(l4, f4, d4, p7, g4, h4, u4);\n        }\n        u4 = a3, h4 = i3;\n      }\n      h4 != i3 && n2(a3, i3, u4, h4, s3);\n    }\n    function Lt2(t5, r3) {\n      var n3 = t5.V, i3 = t5.Ba + t5.c * t5.C, a3 = r3 - t5.C;\n      if (e2(r3 <= t5.l.o), e2(16 >= a3), 0 < a3) {\n        var o3 = t5.l, s3 = t5.Ta, c4 = t5.Ua, u4 = o3.width;\n        if (Nt2(t5, a3, n3, i3), a3 = c4 = [c4], e2((n3 = t5.C) < (i3 = r3)), e2(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {\n          var h4 = o3.j - n3;\n          n3 = o3.j;\n          a3[0] += h4 * u4;\n        }\n        if (n3 >= i3 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {\n          if (c4 = c4[0], 11 > (n3 = t5.ca).S) {\n            var l4 = n3.f.RGBA, f4 = (i3 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d4 = o3;\n            for (l4 = l4.fb + t5.Ma * l4.A; 0 < d4--; ) {\n              var p7 = s3, g4 = c4, m4 = a3, v4 = h4, b4 = l4;\n              switch (i3) {\n                case En:\n                  Qr(p7, g4, m4, v4, b4);\n                  break;\n                case qn:\n                  tn(p7, g4, m4, v4, b4);\n                  break;\n                case Hn:\n                  tn(p7, g4, m4, v4, b4), An(v4, b4, 0, m4, 1, 0);\n                  break;\n                case Dn:\n                  nn(p7, g4, m4, v4, b4);\n                  break;\n                case Rn:\n                  et2(p7, g4, m4, v4, b4, 1);\n                  break;\n                case Wn:\n                  et2(p7, g4, m4, v4, b4, 1), An(v4, b4, 0, m4, 1, 0);\n                  break;\n                case Tn:\n                  et2(p7, g4, m4, v4, b4, 0);\n                  break;\n                case Vn:\n                  et2(p7, g4, m4, v4, b4, 0), An(v4, b4, 1, m4, 1, 0);\n                  break;\n                case zn:\n                  en(p7, g4, m4, v4, b4);\n                  break;\n                case Gn:\n                  en(p7, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);\n                  break;\n                case Un:\n                  rn(p7, g4, m4, v4, b4);\n                  break;\n                default:\n                  e2(0);\n              }\n              c4 += u4, l4 += f4;\n            }\n            t5.Ma += o3;\n          } else\n            alert(\"todo:EmitRescaledRowsYUVA\");\n          e2(t5.Ma <= n3.height);\n        }\n      }\n      t5.C = r3, e2(t5.C <= t5.i);\n    }\n    function At2(t5) {\n      var e3;\n      if (0 < t5.ua)\n        return 0;\n      for (e3 = 0; e3 < t5.Wb; ++e3) {\n        var r3 = t5.Ya[e3].G, n3 = t5.Ya[e3].H;\n        if (0 < r3[1][n3[1] + 0].g || 0 < r3[2][n3[2] + 0].g || 0 < r3[3][n3[3] + 0].g)\n          return 0;\n      }\n      return 1;\n    }\n    function xt2(t5, r3, n3, i3, a3, o3) {\n      if (t5.Z != 0) {\n        var s3 = t5.qd, c4 = t5.rd;\n        for (e2(mi[t5.Z] != null); r3 < n3; ++r3)\n          mi[t5.Z](s3, c4, i3, a3, i3, a3, o3), s3 = i3, c4 = a3, a3 += o3;\n        t5.qd = s3, t5.rd = c4;\n      }\n    }\n    function St(t5, r3) {\n      var n3 = t5.l.ma, i3 = n3.Z == 0 || n3.Z == 1 ? t5.l.j : t5.C;\n      i3 = t5.C < i3 ? i3 : t5.C;\n      if (e2(r3 <= t5.l.o), r3 > i3) {\n        var a3 = t5.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i3, c4 = t5.V, u4 = t5.Ba + t5.c * i3, h4 = t5.gc;\n        e2(t5.ab == 1), e2(h4[0].hc == 3), Xr(h4[0], i3, r3, c4, u4, o3, s3), xt2(n3, i3, r3, o3, s3, a3);\n      }\n      t5.C = t5.Ma = r3;\n    }\n    function _t2(t5, r3, n3, i3, a3, o3, s3) {\n      var c4 = t5.$ / i3, u4 = t5.$ % i3, h4 = t5.m, l4 = t5.s, f4 = n3 + t5.$, d4 = f4;\n      a3 = n3 + i3 * a3;\n      var p7 = n3 + i3 * o3, g4 = 280 + l4.ua, m4 = t5.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p7 ? wt2(l4, u4, c4) : null;\n      e2(t5.C < o3), e2(p7 <= a3);\n      var w4 = false;\n      t:\n        for (; ; ) {\n          for (; w4 || f4 < p7; ) {\n            var N4 = 0;\n            if (c4 >= m4) {\n              var _3 = f4 - n3;\n              e2((m4 = t5).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B3(m4.s.Wa, m4.s.vb), m4 = c4 + ti;\n            }\n            if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e2(y4 != null), y4.Qb && (r3[f4] = y4.qb, w4 = true), !w4)\n              if (S2(h4), y4.jc) {\n                N4 = h4, _3 = r3;\n                var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];\n                e2(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e2(256 <= k3.value), N4 = k3.value), N4 == 0 && (w4 = true);\n              } else\n                N4 = bt2(y4.G[0], y4.H[0], h4);\n            if (h4.h)\n              break;\n            if (w4 || 256 > N4) {\n              if (!w4)\n                if (y4.nd)\n                  r3[f4] = (y4.qb | N4 << 8) >>> 0;\n                else {\n                  if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h)\n                    break;\n                  r3[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;\n                }\n              if (w4 = false, ++f4, ++u4 >= i3 && (u4 = 0, ++c4, s3 != null && c4 <= o3 && !(c4 % 16) && s3(t5, c4), v4 != null))\n                for (; d4 < f4; )\n                  N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;\n            } else if (280 > N4) {\n              if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i3, _3 = mt2(_3, h4)), h4.h)\n                break;\n              if (f4 - n3 < _3 || a3 - f4 < N4)\n                break t;\n              for (P3 = 0; P3 < N4; ++P3)\n                r3[f4 + P3] = r3[f4 + P3 - _3];\n              for (f4 += N4, u4 += N4; u4 >= i3; )\n                u4 -= i3, ++c4, s3 != null && c4 <= o3 && !(c4 % 16) && s3(t5, c4);\n              if (e2(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), v4 != null)\n                for (; d4 < f4; )\n                  N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;\n            } else {\n              if (!(N4 < g4))\n                break t;\n              for (w4 = N4 - 280, e2(v4 != null); d4 < f4; )\n                N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;\n              N4 = f4, e2(!(w4 >>> (_3 = v4).Xa)), r3[N4] = _3.X[w4], w4 = true;\n            }\n            w4 || e2(h4.h == A3(h4));\n          }\n          if (t5.Pb && h4.h && f4 < a3)\n            e2(t5.m.h), t5.a = 5, t5.m = t5.wd, t5.$ = t5.xd, 0 < t5.s.ua && B3(t5.s.vb, t5.s.Wa);\n          else {\n            if (h4.h)\n              break t;\n            s3 != null && s3(t5, c4 > o3 ? o3 : c4), t5.a = 0, t5.$ = f4 - n3;\n          }\n          return 1;\n        }\n      return t5.a = 3, 0;\n    }\n    function Pt2(t5) {\n      e2(t5 != null), t5.vc = null, t5.yc = null, t5.Ya = null;\n      var r3 = t5.Wa;\n      r3 != null && (r3.X = null), t5.vb = null, e2(t5 != null);\n    }\n    function kt2() {\n      var e3 = new or();\n      return e3 == null ? null : (e3.a = 0, e3.xb = gi, rt2(\"Predictor\", \"VP8LPredictors\"), rt2(\"Predictor\", \"VP8LPredictors_C\"), rt2(\"PredictorAdd\", \"VP8LPredictorsAdd\"), rt2(\"PredictorAdd\", \"VP8LPredictorsAdd_C\"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t4.VP8LMapColor32b = Jr, t4.VP8LMapColor8b = Kr, e3);\n    }\n    function It2(t5, r3, n3, s3, c4) {\n      var u4 = 1, f4 = [t5], p7 = [r3], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;\n      t:\n        for (; ; ) {\n          if (n3)\n            for (; u4 && y3(g4, 1); ) {\n              var w4 = f4, N4 = p7, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);\n              if (A4.Oc & 1 << I3)\n                u4 = 0;\n              else {\n                switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e2(4 >= A4.ab), I3) {\n                  case 0:\n                  case 1:\n                    k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];\n                    break;\n                  case 3:\n                    var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;\n                    if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {\n                      var B4, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);\n                      if (T3 == null)\n                        F3 = 0;\n                      else {\n                        var z3 = E3.K[0], U3 = E3.w;\n                        for (T3[0] = E3.K[0][0], B4 = 1; B4 < 1 * M3; ++B4)\n                          T3[B4] = D2(z3[U3 + B4], T3[B4 - 1]);\n                        for (; B4 < 4 * R3; ++B4)\n                          T3[B4] = 0;\n                        E3.K[0] = null, E3.K[0] = T3, F3 = 1;\n                      }\n                    }\n                    _3 = F3;\n                    break;\n                  case 2:\n                    break;\n                  default:\n                    e2(0);\n                }\n                u4 = _3;\n              }\n            }\n          if (f4 = f4[0], p7 = p7[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {\n            s3.a = 3;\n            break t;\n          }\n          var H5;\n          if (H5 = u4)\n            e: {\n              var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p7, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn[K3];\n              r:\n                for (; ; ) {\n                  if (Z3 && y3($3, 1)) {\n                    var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;\n                    if (!It2(at3, ot3, 0, Y3, tt3))\n                      break r;\n                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {\n                      var ct3 = tt3[W3] >> 8 & 65535;\n                      tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);\n                    }\n                  }\n                  if ($3.h)\n                    break r;\n                  for (V3 = 0; 5 > V3; ++V3) {\n                    var ut3 = Xn[V3];\n                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);\n                  }\n                  var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d3);\n                  if (ft3 == null)\n                    var dt3 = null;\n                  else\n                    e2(65536 >= lt3), dt3 = ft3;\n                  var pt3 = a2(rt3);\n                  if (dt3 == null || pt3 == null || ht3 == null) {\n                    Y3.a = 1;\n                    break r;\n                  }\n                  var gt3 = ht3;\n                  for (W3 = G3 = 0; W3 < et3; ++W3) {\n                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;\n                    for (V3 = 0; 5 > V3; ++V3) {\n                      ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);\n                      n: {\n                        var At3, xt3 = ut3, St2 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St2.m, Bt3 = y3(Ot3, 1);\n                        if (i2(kt3, 0, 0, xt3), Bt3) {\n                          var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, Et3 == 0 ? 1 : 8);\n                          kt3[qt3] = 1, Mt3 == 2 && (kt3[qt3 = y3(Ot3, 8)] = 1);\n                          var Dt3 = 1;\n                        } else {\n                          var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;\n                          if (19 < Tt3) {\n                            St2.a = 3;\n                            var zt3 = 0;\n                            break n;\n                          }\n                          for (At3 = 0; At3 < Tt3; ++At3)\n                            Rt3[Zn[At3]] = y3(Ot3, 3);\n                          var Ut3 = void 0, Ht3 = void 0, Wt3 = St2, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);\n                          i:\n                            for (; h3(Zt3, 0, 7, Vt3, 19); ) {\n                              if (y3(Xt3, 1)) {\n                                var $t3 = 2 + 2 * y3(Xt3, 3);\n                                if ((Ut3 = 2 + y3(Xt3, $t3)) > Gt3)\n                                  break i;\n                              } else\n                                Ut3 = Gt3;\n                              for (Ht3 = 0; Ht3 < Gt3 && Ut3--; ) {\n                                S2(Xt3);\n                                var Qt3 = Zt3[0 + (127 & L3(Xt3))];\n                                x2(Xt3, Xt3.u + Qt3.g);\n                                var te3 = Qt3.value;\n                                if (16 > te3)\n                                  Yt3[Ht3++] = te3, te3 != 0 && (Kt3 = te3);\n                                else {\n                                  var ee3 = te3 == 16, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt3, Yn[re3]) + ne3;\n                                  if (Ht3 + ie3 > Gt3)\n                                    break i;\n                                  for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )\n                                    Yt3[Ht3++] = ae3;\n                                }\n                              }\n                              Jt3 = 1;\n                              break i;\n                            }\n                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;\n                        }\n                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft3, Ct3, 8, kt3, xt3)), Dt3 && jt3 != 0 ? zt3 = jt3 : (St2.a = 3, zt3 = 0);\n                      }\n                      if (zt3 == 0)\n                        break r;\n                      if (Nt3 && Kn[V3] == 1 && (Nt3 = gt3[G3].g == 0), wt3 += gt3[G3].g, G3 += zt3, 3 >= V3) {\n                        var oe3, se3 = pt3[0];\n                        for (oe3 = 1; oe3 < ut3; ++oe3)\n                          pt3[oe3] > se3 && (se3 = pt3[oe3]);\n                        Lt3 += se3;\n                      }\n                    }\n                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, wt3 == 0 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {\n                      var ce3, ue3 = mt3;\n                      for (ce3 = 0; ce3 < Dr; ++ce3) {\n                        var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];\n                        256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));\n                      }\n                    }\n                  }\n                  Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H5 = 1;\n                  break e;\n                }\n              H5 = 0;\n            }\n          if (!(u4 = H5)) {\n            s3.a = 3;\n            break t;\n          }\n          if (0 < b4) {\n            if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {\n              s3.a = 1, u4 = 0;\n              break t;\n            }\n          } else\n            m4.ua = 0;\n          var de3 = s3, pe3 = f4, ge3 = p7, me3 = de3.s, ve3 = me3.xc;\n          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = ve3 == 0 ? -1 : (1 << ve3) - 1, n3) {\n            s3.xb = pi;\n            break t;\n          }\n          if ((v4 = a2(f4 * p7)) == null) {\n            s3.a = 1, u4 = 0;\n            break t;\n          }\n          u4 = (u4 = _t2(s3, v4, 0, f4, p7, p7, null)) && !g4.h;\n          break t;\n        }\n      return u4 ? (c4 != null ? c4[0] = v4 : (e2(v4 == null), e2(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;\n    }\n    function Ft2(t5, r3) {\n      var n3 = t5.c * t5.i, i3 = n3 + r3 + 16 * r3;\n      return e2(t5.c <= r3), t5.V = a2(i3), t5.V == null ? (t5.Ta = null, t5.Ua = 0, t5.a = 1, 0) : (t5.Ta = t5.V, t5.Ua = t5.Ba + n3 + r3, 1);\n    }\n    function Ct2(t5, r3) {\n      var n3 = t5.C, i3 = r3 - n3, a3 = t5.V, o3 = t5.Ba + t5.c * n3;\n      for (e2(r3 <= t5.l.o); 0 < i3; ) {\n        var s3 = 16 < i3 ? 16 : i3, c4 = t5.l.ma, u4 = t5.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t5.Ta, p7 = t5.Ua;\n        Nt2(t5, s3, a3, o3), _n(d4, p7, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i3 -= s3, a3 += s3 * t5.c, n3 += s3;\n      }\n      e2(n3 == r3), t5.C = t5.Ma = r3;\n    }\n    function jt2() {\n      this.ub = this.yd = this.td = this.Rb = 0;\n    }\n    function Ot2() {\n      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;\n    }\n    function Bt2() {\n      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);\n    }\n    function Mt2() {\n      this.Yb = function() {\n        var t5 = [];\n        return function t6(e3, r3, n3) {\n          for (var i3 = n3[r3], a3 = 0; a3 < i3 && (e3.push(n3.length > r3 + 1 ? [] : 0), !(n3.length < r3 + 1)); a3++)\n            t6(e3[a3], r3 + 1, n3);\n        }(t5, 0, [3, 11]), t5;\n      }();\n    }\n    function Et2() {\n      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);\n    }\n    function qt2() {\n      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);\n    }\n    function Dt2() {\n      this.ld = this.La = this.dd = this.tc = 0;\n    }\n    function Rt2() {\n      this.Na = this.la = 0;\n    }\n    function Tt2() {\n      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;\n    }\n    function zt2() {\n      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;\n    }\n    function Ut2() {\n      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new zt2()), this.aa = 0, this.l = new Gt2();\n    }\n    function Ht2() {\n      this.y = a2(16), this.f = a2(8), this.ea = a2(8);\n    }\n    function Wt2() {\n      this.cb = this.a = 0, this.sc = \"\", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new Ut2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zt2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;\n    }\n    function Vt2(t5, e3) {\n      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;\n    }\n    function Gt2() {\n      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = \"void\", this.put = \"VP8IoPutHook\", this.ac = \"VP8IoSetupHook\", this.bc = \"VP8IoTeardownHook\", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;\n    }\n    function Yt2() {\n      var t5 = new Wt2();\n      return t5 != null && (t5.a = 0, t5.sc = \"OK\", t5.cb = 0, t5.Xb = 0, ni || (ni = Zt2)), t5;\n    }\n    function Jt2(t5, e3, r3) {\n      return t5.a == 0 && (t5.a = e3, t5.sc = r3, t5.cb = 0), 0;\n    }\n    function Xt2(t5, e3, r3) {\n      return 3 <= r3 && t5[e3 + 0] == 157 && t5[e3 + 1] == 1 && t5[e3 + 2] == 42;\n    }\n    function Kt2(t5, r3) {\n      if (t5 == null)\n        return 0;\n      if (t5.a = 0, t5.sc = \"OK\", r3 == null)\n        return Jt2(t5, 2, \"null VP8Io passed to VP8GetHeaders()\");\n      var n3 = r3.data, a3 = r3.w, o3 = r3.ha;\n      if (4 > o3)\n        return Jt2(t5, 7, \"Truncated header.\");\n      var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t5.Od;\n      if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td)\n        return Jt2(t5, 3, \"Incorrect keyframe parameters.\");\n      if (!c4.yd)\n        return Jt2(t5, 4, \"Frame not displayable.\");\n      a3 += 3, o3 -= 3;\n      var u4 = t5.Kc;\n      if (c4.Rb) {\n        if (7 > o3)\n          return Jt2(t5, 7, \"cannot parse picture header\");\n        if (!Xt2(n3, a3, o3))\n          return Jt2(t5, 3, \"Bad code word\");\n        u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t5.za = u4.c + 15 >> 4, t5.Ub = u4.i + 15 >> 4, r3.width = u4.c, r3.height = u4.i, r3.Da = 0, r3.j = 0, r3.v = 0, r3.va = r3.width, r3.o = r3.height, r3.da = 0, r3.ib = r3.width, r3.hb = r3.height, r3.U = r3.width, r3.T = r3.height, i2((s3 = t5.Pa).jb, 0, 255, s3.jb.length), e2((s3 = t5.Qa) != null), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);\n      }\n      if (c4.ub > o3)\n        return Jt2(t5, 7, \"bad partition length\");\n      p6(s3 = t5.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t5.Qa;\n      var h4, l4 = t5.Pa;\n      if (e2(s3 != null), e2(u4 != null), u4.Cb = P2(s3), u4.Cb) {\n        if (u4.Bb = P2(s3), P2(s3)) {\n          for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4)\n            u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;\n          for (h4 = 0; 4 > h4; ++h4)\n            u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;\n        }\n        if (u4.Bb)\n          for (h4 = 0; 3 > h4; ++h4)\n            l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;\n      } else\n        u4.Bb = 0;\n      if (s3.Ka)\n        return Jt2(t5, 3, \"cannot parse segment header\");\n      if ((u4 = t5.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {\n        for (l4 = 0; 4 > l4; ++l4)\n          P2(s3) && (u4.vd[l4] = m3(s3, 6));\n        for (l4 = 0; 4 > l4; ++l4)\n          P2(s3) && (u4.od[l4] = m3(s3, 6));\n      }\n      if (t5.L = u4.Tb == 0 ? 0 : u4.zd ? 1 : 2, s3.Ka)\n        return Jt2(t5, 3, \"cannot parse filter header\");\n      var f4 = o3;\n      if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t5.Xb = (1 << g3(t5.m, 2)) - 1, f4 < 3 * (l4 = t5.Xb))\n        n3 = 7;\n      else {\n        for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {\n          var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;\n          d4 > u4 && (d4 = u4), p6(t5.Jc[+f4], n3, h4, d4), h4 += d4, u4 -= d4, o3 += 3;\n        }\n        p6(t5.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;\n      }\n      if (n3 != 0)\n        return Jt2(t5, n3, \"cannot parse partitions\");\n      for (n3 = g3(h4 = t5.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t5.Qa, d4 = 0; 4 > d4; ++d4) {\n        if (f4.Cb) {\n          var v4 = f4.Zb[d4];\n          f4.Fb || (v4 += n3);\n        } else {\n          if (0 < d4) {\n            t5.pb[d4] = t5.pb[0];\n            continue;\n          }\n          v4 = n3;\n        }\n        var b4 = t5.pb[d4];\n        b4.Sc[0] = ei[Vt2(v4 + o3, 127)], b4.Sc[1] = ri[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v4 + l4, 117)], b4.Qc[1] = ri[Vt2(v4 + h4, 127)], b4.lc = v4 + h4;\n      }\n      if (!c4.Rb)\n        return Jt2(t5, 4, \"Not a key frame.\");\n      for (P2(s3), c4 = t5.Pa, n3 = 0; 4 > n3; ++n3) {\n        for (o3 = 0; 8 > o3; ++o3)\n          for (a3 = 0; 3 > a3; ++a3)\n            for (u4 = 0; 11 > u4; ++u4)\n              l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;\n        for (o3 = 0; 17 > o3; ++o3)\n          c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];\n      }\n      return t5.kc = P2(s3), t5.kc && (t5.Bd = g3(s3, 8)), t5.cb = 1;\n    }\n    function Zt2(t5, e3, r3, n3, i3, a3, o3) {\n      var s3 = e3[i3].Yb[r3];\n      for (r3 = 0; 16 > i3; ++i3) {\n        if (!k2(t5, s3[r3 + 0]))\n          return i3;\n        for (; !k2(t5, s3[r3 + 1]); )\n          if (s3 = e3[++i3].Yb[0], r3 = 0, i3 == 16)\n            return 16;\n        var c4 = e3[i3 + 1].Yb;\n        if (k2(t5, s3[r3 + 2])) {\n          var u4 = t5, h4 = 0;\n          if (k2(u4, (f4 = s3)[(l4 = r3) + 3]))\n            if (k2(u4, f4[l4 + 6])) {\n              for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii[l4]; f4[s3]; ++s3)\n                h4 += h4 + k2(u4, f4[s3]);\n              h4 += 3 + (8 << l4);\n            } else\n              k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);\n          else\n            h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;\n          s3 = c4[2];\n        } else\n          h4 = 1, s3 = c4[1];\n        c4 = o3 + ai[i3], 0 > (u4 = t5).b && _2(u4);\n        var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;\n        --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h4 ^ d4) - d4) * n3[(0 < i3) + 0];\n      }\n      return 16;\n    }\n    function $t2(t5) {\n      var e3 = t5.rb[t5.sb - 1];\n      e3.la = 0, e3.Na = 0, i2(t5.zc, 0, 0, t5.zc.length), t5.ja = 0;\n    }\n    function Qt2(t5, r3) {\n      if (t5 == null)\n        return 0;\n      if (r3 == null)\n        return Jt2(t5, 2, \"NULL VP8Io parameter in VP8Decode().\");\n      if (!t5.cb && !Kt2(t5, r3))\n        return 0;\n      if (e2(t5.cb), r3.ac == null || r3.ac(r3)) {\n        r3.ob && (t5.L = 0);\n        var s3 = Ri[t5.L];\n        if (t5.L == 2 ? (t5.yb = 0, t5.zb = 0) : (t5.yb = r3.v - s3 >> 4, t5.zb = r3.j - s3 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = r3.o + 15 + s3 >> 4, t5.Hb = r3.va + 15 + s3 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {\n          var c4 = t5.ed;\n          for (s3 = 0; 4 > s3; ++s3) {\n            var u4;\n            if (t5.Qa.Cb) {\n              var h4 = t5.Qa.Lb[s3];\n              t5.Qa.Fb || (h4 += c4.Tb);\n            } else\n              h4 = c4.Tb;\n            for (u4 = 0; 1 >= u4; ++u4) {\n              var l4 = t5.gd[s3][u4], f4 = h4;\n              if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {\n                var d4 = f4;\n                0 < c4.wb && ((d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb)), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;\n              } else\n                l4.tc = 0;\n              l4.La = u4;\n            }\n          }\n        }\n        s3 = 0;\n      } else\n        Jt2(t5, 6, \"Frame setup failed\"), s3 = t5.a;\n      if (s3 = s3 == 0) {\n        if (s3) {\n          t5.$c = 0, 0 < t5.Aa || (t5.Ic = zi);\n          t: {\n            s3 = t5.Ic;\n            c4 = 4 * (d4 = t5.za);\n            var p7 = 32 * d4, g4 = d4 + 1, m4 = 0 < t5.L ? d4 * (0 < t5.Aa ? 2 : 1) : 0, v4 = (t5.Aa == 2 ? 2 : 1) * d4;\n            if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t5.L]) / 2 * p7) + (h4 = t5.Fa != null && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != l4)\n              s3 = 0;\n            else {\n              if (l4 > t5.Vb) {\n                if (t5.Vb = 0, t5.Ec = a2(l4), t5.Fc = 0, t5.Ec == null) {\n                  s3 = Jt2(t5, 1, \"no memory during frame initialization.\");\n                  break t;\n                }\n                t5.Vb = l4;\n              }\n              l4 = t5.Ec, f4 = t5.Fc, t5.Ac = l4, t5.Bc = f4, f4 += c4, t5.Gd = o2(p7, Ht2), t5.Hd = 0, t5.rb = o2(g4 + 1, Rt2), t5.sb = 1, t5.wa = m4 ? o2(m4, Dt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d4), e2(true), t5.oc = l4, t5.pc = f4, f4 += 832, t5.ya = o2(v4, zt2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, t5.Aa == 2 && (t5.D.aa += d4), t5.R = 16 * d4, t5.B = 8 * d4, d4 = (p7 = Ri[t5.L]) * t5.R, p7 = p7 / 2 * t5.B, t5.sa = l4, t5.ta = f4 + d4, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s3 * t5.R + p7, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s3 * t5.B + p7, t5.$c = 0, f4 += u4, t5.mb = h4 ? l4 : null, t5.nb = h4 ? f4 : null, e2(f4 + h4 <= t5.Fc + t5.Vb), $t2(t5), i2(t5.Ac, t5.Bc, 0, c4), s3 = 1;\n            }\n          }\n          if (s3) {\n            if (r3.ka = 0, r3.y = t5.sa, r3.O = t5.ta, r3.f = t5.qa, r3.N = t5.ra, r3.ea = t5.Ha, r3.Vd = t5.Ia, r3.fa = t5.R, r3.Rc = t5.B, r3.F = null, r3.J = 0, !Cn) {\n              for (s3 = -255; 255 >= s3; ++s3)\n                Pn[255 + s3] = 0 > s3 ? -s3 : s3;\n              for (s3 = -1020; 1020 >= s3; ++s3)\n                kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;\n              for (s3 = -112; 112 >= s3; ++s3)\n                In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;\n              for (s3 = -255; 510 >= s3; ++s3)\n                Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;\n              Cn = 1;\n            }\n            an = ue2, on = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = Ue, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s3 = 1;\n          } else\n            s3 = 0;\n        }\n        s3 && (s3 = function(t6, r4) {\n          for (t6.M = 0; t6.M < t6.Va; ++t6.M) {\n            var o3, s4 = t6.Jc[t6.M & t6.Xb], c5 = t6.m, u5 = t6;\n            for (o3 = 0; o3 < u5.za; ++o3) {\n              var h5 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p8 = l5.zc, g5 = l5.ya[l5.aa + o3];\n              if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {\n                var m5 = g5.Ob, v5 = 0;\n                for (l5 = 0; 4 > l5; ++l5) {\n                  var b4, y4 = p8[0 + l5];\n                  for (b4 = 0; 4 > b4; ++b4) {\n                    y4 = ci[f5[d5 + b4]][y4];\n                    for (var w4 = oi[k2(h5, y4[0])]; 0 < w4; )\n                      w4 = oi[2 * w4 + k2(h5, y4[w4])];\n                    y4 = -w4, f5[d5 + b4] = y4;\n                  }\n                  n2(m5, v5, f5, d5, 4), v5 += 4, p8[0 + l5] = y4;\n                }\n              } else\n                y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i2(f5, d5, y4, 4), i2(p8, 0, y4, 4);\n              g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;\n            }\n            if (u5.m.Ka)\n              return Jt2(t6, 7, \"Premature end-of-partition0 encountered.\");\n            for (; t6.ja < t6.za; ++t6.ja) {\n              if (u5 = s4, h5 = (c5 = t6).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0)\n                h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;\n              else {\n                var N4, L4;\n                h5 = f5, f5 = u5, d5 = c5.Pa.Xc, p8 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p8.$b];\n                if (l5 = p8.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i2(l5, m5, 0, 384), p8.Za)\n                  var A4 = 0, x3 = d5[3];\n                else {\n                  w4 = a2(16);\n                  var S3 = h5.Na + v5.Na;\n                  if (S3 = ni(f5, d5[1], S3, g5.Eb, 0, w4, 0), h5.Na = v5.Na = (0 < S3) + 0, 1 < S3)\n                    an(w4, 0, l5, m5);\n                  else {\n                    var _3 = w4[0] + 3 >> 3;\n                    for (w4 = 0; 256 > w4; w4 += 16)\n                      l5[m5 + w4] = _3;\n                  }\n                  A4 = 1, x3 = d5[0];\n                }\n                var P3 = 15 & h5.la, I3 = 15 & v5.la;\n                for (w4 = 0; 4 > w4; ++w4) {\n                  var F3 = 1 & I3;\n                  for (_3 = L4 = 0; 4 > _3; ++_3)\n                    P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l5[m5 + 0] != 0), m5 += 16;\n                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;\n                }\n                for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {\n                  for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {\n                    for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3)\n                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l5[m5 + 0] != 0), m5 += 16;\n                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;\n                  }\n                  y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;\n                }\n                h5.la = x3, v5.la = A4, p8.Hc = b4, p8.Gc = y4, p8.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);\n              }\n              if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka)\n                return Jt2(t6, 7, \"Premature end-of-file encountered.\");\n            }\n            if ($t2(t6), c5 = r4, u5 = 1, o3 = (s4 = t6).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, s4.Aa == 0)\n              t: {\n                if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p8 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = (P3 = L4.M) == 0, b4 = P3 >= s4.Va - 1, s4.Aa == 2 && Or(s4, L4), L4.uc)\n                  for (F3 = (S3 = s4).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {\n                    A4 = L4, x3 = F3;\n                    var C3 = (j3 = (z3 = S3).D).Nb;\n                    N4 = z3.R;\n                    var j3 = j3.wa[j3.Y + A4], O3 = z3.sa, B4 = z3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;\n                    if (E3 != 0)\n                      if (e2(3 <= E3), z3.L == 1)\n                        0 < A4 && wn(O3, B4, N4, E3 + 4), j3.La && Ln(O3, B4, N4, E3), 0 < x3 && yn(O3, B4, N4, E3 + 4), j3.La && Nn(O3, B4, N4, E3);\n                      else {\n                        var q3 = z3.B, D3 = z3.qa, R3 = z3.ra + 8 * C3 * q3 + 8 * A4, T3 = z3.Ha, z3 = z3.Ia + 8 * C3 * q3 + 8 * A4;\n                        C3 = j3.ld;\n                        0 < A4 && (fn(O3, B4, N4, E3 + 4, M3, C3), pn(D3, R3, T3, z3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B4, N4, E3, M3, C3), bn(D3, R3, T3, z3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B4, N4, E3 + 4, M3, C3), dn(D3, R3, T3, z3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B4, N4, E3, M3, C3), vn(D3, R3, T3, z3, q3, E3, M3, C3));\n                      }\n                  }\n                if (s4.ia && alert(\"todo:DitherRow\"), c5.put != null) {\n                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p8, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, s4.Fa != null && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, c5.F == null && c5.F.length == 0)) {\n                    u5 = Jt2(s4, 3, \"Could not decode alpha data.\");\n                    break t;\n                  }\n                  L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e2(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), c5.F != null && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, c5.F != null && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));\n                }\n                o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d5, p8 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));\n              }\n            if (!u5)\n              return Jt2(t6, 6, \"Output aborted.\");\n          }\n          return 1;\n        }(t5, r3)), r3.bc != null && r3.bc(r3), s3 &= 1;\n      }\n      return s3 ? (t5.cb = 0, s3) : 0;\n    }\n    function te2(t5, e3, r3, n3, i3) {\n      i3 = t5[e3 + r3 + 32 * n3] + (i3 >> 3), t5[e3 + r3 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;\n    }\n    function ee2(t5, e3, r3, n3, i3, a3) {\n      te2(t5, e3, 0, r3, n3 + i3), te2(t5, e3, 1, r3, n3 + a3), te2(t5, e3, 2, r3, n3 - a3), te2(t5, e3, 3, r3, n3 - i3);\n    }\n    function re2(t5) {\n      return (20091 * t5 >> 16) + t5;\n    }\n    function ne2(t5, e3, r3, n3) {\n      var i3, o3 = 0, s3 = a2(16);\n      for (i3 = 0; 4 > i3; ++i3) {\n        var c4 = t5[e3 + 0] + t5[e3 + 8], u4 = t5[e3 + 0] - t5[e3 + 8], h4 = (35468 * t5[e3 + 4] >> 16) - re2(t5[e3 + 12]), l4 = re2(t5[e3 + 4]) + (35468 * t5[e3 + 12] >> 16);\n        s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e3++;\n      }\n      for (i3 = o3 = 0; 4 > i3; ++i3)\n        c4 = (t5 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t5 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r3, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r3, n3, 1, 0, u4 + h4), te2(r3, n3, 2, 0, u4 - h4), te2(r3, n3, 3, 0, c4 - l4), o3++, n3 += 32;\n    }\n    function ie2(t5, e3, r3, n3) {\n      var i3 = t5[e3 + 0] + 4, a3 = 35468 * t5[e3 + 4] >> 16, o3 = re2(t5[e3 + 4]), s3 = 35468 * t5[e3 + 1] >> 16;\n      ee2(r3, n3, 0, i3 + o3, t5 = re2(t5[e3 + 1]), s3), ee2(r3, n3, 1, i3 + a3, t5, s3), ee2(r3, n3, 2, i3 - a3, t5, s3), ee2(r3, n3, 3, i3 - o3, t5, s3);\n    }\n    function ae2(t5, e3, r3, n3, i3) {\n      ne2(t5, e3, r3, n3), i3 && ne2(t5, e3 + 16, r3, n3 + 4);\n    }\n    function oe2(t5, e3, r3, n3) {\n      on(t5, e3 + 0, r3, n3, 1), on(t5, e3 + 32, r3, n3 + 128, 1);\n    }\n    function se2(t5, e3, r3, n3) {\n      var i3;\n      for (t5 = t5[e3 + 0] + 4, i3 = 0; 4 > i3; ++i3)\n        for (e3 = 0; 4 > e3; ++e3)\n          te2(r3, n3, e3, i3, t5);\n    }\n    function ce2(t5, e3, r3, n3) {\n      t5[e3 + 0] && un(t5, e3 + 0, r3, n3), t5[e3 + 16] && un(t5, e3 + 16, r3, n3 + 4), t5[e3 + 32] && un(t5, e3 + 32, r3, n3 + 128), t5[e3 + 48] && un(t5, e3 + 48, r3, n3 + 128 + 4);\n    }\n    function ue2(t5, e3, r3, n3) {\n      var i3, o3 = a2(16);\n      for (i3 = 0; 4 > i3; ++i3) {\n        var s3 = t5[e3 + 0 + i3] + t5[e3 + 12 + i3], c4 = t5[e3 + 4 + i3] + t5[e3 + 8 + i3], u4 = t5[e3 + 4 + i3] - t5[e3 + 8 + i3], h4 = t5[e3 + 0 + i3] - t5[e3 + 12 + i3];\n        o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = h4 + u4, o3[12 + i3] = h4 - u4;\n      }\n      for (i3 = 0; 4 > i3; ++i3)\n        s3 = (t5 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], h4 = t5 - o3[3 + 4 * i3], r3[n3 + 0] = s3 + c4 >> 3, r3[n3 + 16] = h4 + u4 >> 3, r3[n3 + 32] = s3 - c4 >> 3, r3[n3 + 48] = h4 - u4 >> 3, n3 += 64;\n    }\n    function he2(t5, e3, r3) {\n      var n3, i3 = e3 - 32, a3 = Bn, o3 = 255 - t5[i3 - 1];\n      for (n3 = 0; n3 < r3; ++n3) {\n        var s3, c4 = a3, u4 = o3 + t5[e3 - 1];\n        for (s3 = 0; s3 < r3; ++s3)\n          t5[e3 + s3] = c4[u4 + t5[i3 + s3]];\n        e3 += 32;\n      }\n    }\n    function le2(t5, e3) {\n      he2(t5, e3, 4);\n    }\n    function fe2(t5, e3) {\n      he2(t5, e3, 8);\n    }\n    function de2(t5, e3) {\n      he2(t5, e3, 16);\n    }\n    function pe2(t5, e3) {\n      var r3;\n      for (r3 = 0; 16 > r3; ++r3)\n        n2(t5, e3 + 32 * r3, t5, e3 - 32, 16);\n    }\n    function ge2(t5, e3) {\n      var r3;\n      for (r3 = 16; 0 < r3; --r3)\n        i2(t5, e3, t5[e3 - 1], 16), e3 += 32;\n    }\n    function me2(t5, e3, r3) {\n      var n3;\n      for (n3 = 0; 16 > n3; ++n3)\n        i2(e3, r3 + 32 * n3, t5, 16);\n    }\n    function ve2(t5, e3) {\n      var r3, n3 = 16;\n      for (r3 = 0; 16 > r3; ++r3)\n        n3 += t5[e3 - 1 + 32 * r3] + t5[e3 + r3 - 32];\n      me2(n3 >> 5, t5, e3);\n    }\n    function be2(t5, e3) {\n      var r3, n3 = 8;\n      for (r3 = 0; 16 > r3; ++r3)\n        n3 += t5[e3 - 1 + 32 * r3];\n      me2(n3 >> 4, t5, e3);\n    }\n    function ye2(t5, e3) {\n      var r3, n3 = 8;\n      for (r3 = 0; 16 > r3; ++r3)\n        n3 += t5[e3 + r3 - 32];\n      me2(n3 >> 4, t5, e3);\n    }\n    function we2(t5, e3) {\n      me2(128, t5, e3);\n    }\n    function Ne2(t5, e3, r3) {\n      return t5 + 2 * e3 + r3 + 2 >> 2;\n    }\n    function Le2(t5, e3) {\n      var r3, i3 = e3 - 32;\n      i3 = new Uint8Array([Ne2(t5[i3 - 1], t5[i3 + 0], t5[i3 + 1]), Ne2(t5[i3 + 0], t5[i3 + 1], t5[i3 + 2]), Ne2(t5[i3 + 1], t5[i3 + 2], t5[i3 + 3]), Ne2(t5[i3 + 2], t5[i3 + 3], t5[i3 + 4])]);\n      for (r3 = 0; 4 > r3; ++r3)\n        n2(t5, e3 + 32 * r3, i3, 0, i3.length);\n    }\n    function Ae(t5, e3) {\n      var r3 = t5[e3 - 1], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];\n      I2(t5, e3 + 0, 16843009 * Ne2(t5[e3 - 1 - 32], r3, n3)), I2(t5, e3 + 32, 16843009 * Ne2(r3, n3, i3)), I2(t5, e3 + 64, 16843009 * Ne2(n3, i3, a3)), I2(t5, e3 + 96, 16843009 * Ne2(i3, a3, a3));\n    }\n    function xe(t5, e3) {\n      var r3, n3 = 4;\n      for (r3 = 0; 4 > r3; ++r3)\n        n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];\n      for (n3 >>= 3, r3 = 0; 4 > r3; ++r3)\n        i2(t5, e3 + 32 * r3, n3, 4);\n    }\n    function Se(t5, e3) {\n      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];\n      t5[e3 + 0 + 96] = Ne2(n3, i3, t5[e3 - 1 + 96]), t5[e3 + 1 + 96] = t5[e3 + 0 + 64] = Ne2(r3, n3, i3), t5[e3 + 2 + 96] = t5[e3 + 1 + 64] = t5[e3 + 0 + 32] = Ne2(a3, r3, n3), t5[e3 + 3 + 96] = t5[e3 + 2 + 64] = t5[e3 + 1 + 32] = t5[e3 + 0 + 0] = Ne2(o3, a3, r3), t5[e3 + 3 + 64] = t5[e3 + 2 + 32] = t5[e3 + 1 + 0] = Ne2(s3, o3, a3), t5[e3 + 3 + 32] = t5[e3 + 2 + 0] = Ne2(c4, s3, o3), t5[e3 + 3 + 0] = Ne2(u4, c4, s3);\n    }\n    function _e(t5, e3) {\n      var r3 = t5[e3 + 1 - 32], n3 = t5[e3 + 2 - 32], i3 = t5[e3 + 3 - 32], a3 = t5[e3 + 4 - 32], o3 = t5[e3 + 5 - 32], s3 = t5[e3 + 6 - 32], c4 = t5[e3 + 7 - 32];\n      t5[e3 + 0 + 0] = Ne2(t5[e3 + 0 - 32], r3, n3), t5[e3 + 1 + 0] = t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 2 + 0] = t5[e3 + 1 + 32] = t5[e3 + 0 + 64] = Ne2(n3, i3, a3), t5[e3 + 3 + 0] = t5[e3 + 2 + 32] = t5[e3 + 1 + 64] = t5[e3 + 0 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 64] = t5[e3 + 1 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = t5[e3 + 2 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, c4);\n    }\n    function Pe(t5, e3) {\n      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];\n      t5[e3 + 0 + 0] = t5[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 3 + 64] = s3 + c4 + 1 >> 1, t5[e3 + 3 + 0] = c4 + u4 + 1 >> 1, t5[e3 + 0 + 96] = Ne2(i3, n3, r3), t5[e3 + 0 + 64] = Ne2(n3, r3, a3), t5[e3 + 0 + 32] = t5[e3 + 1 + 96] = Ne2(r3, a3, o3), t5[e3 + 1 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 2 + 32] = t5[e3 + 3 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 32] = Ne2(s3, c4, u4);\n    }\n    function ke(t5, e3) {\n      var r3 = t5[e3 + 0 - 32], n3 = t5[e3 + 1 - 32], i3 = t5[e3 + 2 - 32], a3 = t5[e3 + 3 - 32], o3 = t5[e3 + 4 - 32], s3 = t5[e3 + 5 - 32], c4 = t5[e3 + 6 - 32], u4 = t5[e3 + 7 - 32];\n      t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 0 + 64] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 1 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 3 + 0] = t5[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 1 + 32] = t5[e3 + 0 + 96] = Ne2(n3, i3, a3), t5[e3 + 2 + 32] = t5[e3 + 1 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, u4);\n    }\n    function Ie(t5, e3) {\n      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];\n      t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 0 + 32] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 32] = t5[e3 + 0 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 1 + 0] = Ne2(r3, n3, i3), t5[e3 + 3 + 0] = t5[e3 + 1 + 32] = Ne2(n3, i3, a3), t5[e3 + 3 + 32] = t5[e3 + 1 + 64] = Ne2(i3, a3, a3), t5[e3 + 3 + 64] = t5[e3 + 2 + 64] = t5[e3 + 0 + 96] = t5[e3 + 1 + 96] = t5[e3 + 2 + 96] = t5[e3 + 3 + 96] = a3;\n    }\n    function Fe(t5, e3) {\n      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96], o3 = t5[e3 - 1 - 32], s3 = t5[e3 + 0 - 32], c4 = t5[e3 + 1 - 32], u4 = t5[e3 + 2 - 32];\n      t5[e3 + 0 + 0] = t5[e3 + 2 + 32] = r3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = t5[e3 + 2 + 64] = n3 + r3 + 1 >> 1, t5[e3 + 0 + 64] = t5[e3 + 2 + 96] = i3 + n3 + 1 >> 1, t5[e3 + 0 + 96] = a3 + i3 + 1 >> 1, t5[e3 + 3 + 0] = Ne2(s3, c4, u4), t5[e3 + 2 + 0] = Ne2(o3, s3, c4), t5[e3 + 1 + 0] = t5[e3 + 3 + 32] = Ne2(r3, o3, s3), t5[e3 + 1 + 32] = t5[e3 + 3 + 64] = Ne2(n3, r3, o3), t5[e3 + 1 + 64] = t5[e3 + 3 + 96] = Ne2(i3, n3, r3), t5[e3 + 1 + 96] = Ne2(a3, i3, n3);\n    }\n    function Ce(t5, e3) {\n      var r3;\n      for (r3 = 0; 8 > r3; ++r3)\n        n2(t5, e3 + 32 * r3, t5, e3 - 32, 8);\n    }\n    function je(t5, e3) {\n      var r3;\n      for (r3 = 0; 8 > r3; ++r3)\n        i2(t5, e3, t5[e3 - 1], 8), e3 += 32;\n    }\n    function Oe(t5, e3, r3) {\n      var n3;\n      for (n3 = 0; 8 > n3; ++n3)\n        i2(e3, r3 + 32 * n3, t5, 8);\n    }\n    function Be(t5, e3) {\n      var r3, n3 = 8;\n      for (r3 = 0; 8 > r3; ++r3)\n        n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];\n      Oe(n3 >> 4, t5, e3);\n    }\n    function Me(t5, e3) {\n      var r3, n3 = 4;\n      for (r3 = 0; 8 > r3; ++r3)\n        n3 += t5[e3 + r3 - 32];\n      Oe(n3 >> 3, t5, e3);\n    }\n    function Ee(t5, e3) {\n      var r3, n3 = 4;\n      for (r3 = 0; 8 > r3; ++r3)\n        n3 += t5[e3 - 1 + 32 * r3];\n      Oe(n3 >> 3, t5, e3);\n    }\n    function qe(t5, e3) {\n      Oe(128, t5, e3);\n    }\n    function De(t5, e3, r3) {\n      var n3 = t5[e3 - r3], i3 = t5[e3 + 0], a3 = 3 * (i3 - n3) + jn[1020 + t5[e3 - 2 * r3] - t5[e3 + r3]], o3 = On[112 + (a3 + 4 >> 3)];\n      t5[e3 - r3] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t5[e3 + 0] = Bn[255 + i3 - o3];\n    }\n    function Re(t5, e3, r3, n3) {\n      var i3 = t5[e3 + 0], a3 = t5[e3 + r3];\n      return Mn[255 + t5[e3 - 2 * r3] - t5[e3 - r3]] > n3 || Mn[255 + a3 - i3] > n3;\n    }\n    function Te(t5, e3, r3, n3) {\n      return 4 * Mn[255 + t5[e3 - r3] - t5[e3 + 0]] + Mn[255 + t5[e3 - 2 * r3] - t5[e3 + r3]] <= n3;\n    }\n    function ze(t5, e3, r3, n3, i3) {\n      var a3 = t5[e3 - 3 * r3], o3 = t5[e3 - 2 * r3], s3 = t5[e3 - r3], c4 = t5[e3 + 0], u4 = t5[e3 + r3], h4 = t5[e3 + 2 * r3], l4 = t5[e3 + 3 * r3];\n      return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t5[e3 - 4 * r3] - a3] <= i3 && Mn[255 + a3 - o3] <= i3 && Mn[255 + o3 - s3] <= i3 && Mn[255 + l4 - h4] <= i3 && Mn[255 + h4 - u4] <= i3 && Mn[255 + u4 - c4] <= i3;\n    }\n    function Ue(t5, e3, r3, n3) {\n      var i3 = 2 * n3 + 1;\n      for (n3 = 0; 16 > n3; ++n3)\n        Te(t5, e3 + n3, r3, i3) && De(t5, e3 + n3, r3);\n    }\n    function He(t5, e3, r3, n3) {\n      var i3 = 2 * n3 + 1;\n      for (n3 = 0; 16 > n3; ++n3)\n        Te(t5, e3 + n3 * r3, 1, i3) && De(t5, e3 + n3 * r3, 1);\n    }\n    function We(t5, e3, r3, n3) {\n      var i3;\n      for (i3 = 3; 0 < i3; --i3)\n        Ue(t5, e3 += 4 * r3, r3, n3);\n    }\n    function Ve(t5, e3, r3, n3) {\n      var i3;\n      for (i3 = 3; 0 < i3; --i3)\n        He(t5, e3 += 4, r3, n3);\n    }\n    function Ge(t5, e3, r3, n3, i3, a3, o3, s3) {\n      for (a3 = 2 * a3 + 1; 0 < i3--; ) {\n        if (ze(t5, e3, r3, a3, o3))\n          if (Re(t5, e3, r3, s3))\n            De(t5, e3, r3);\n          else {\n            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d4 = c4[u4 + 0], p7 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f4) + jn[1020 + l4 - p7]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;\n            c4[u4 - 3 * h4] = Bn[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn[255 + l4 + v4], c4[u4 - h4] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d4 - m4], c4[u4 + h4] = Bn[255 + p7 - v4], c4[u4 + 2 * h4] = Bn[255 + g4 - b4];\n          }\n        e3 += n3;\n      }\n    }\n    function Ye(t5, e3, r3, n3, i3, a3, o3, s3) {\n      for (a3 = 2 * a3 + 1; 0 < i3--; ) {\n        if (ze(t5, e3, r3, a3, o3))\n          if (Re(t5, e3, r3, s3))\n            De(t5, e3, r3);\n          else {\n            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d4 = c4[u4 + h4], p7 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p7 + 1 >> 1;\n            c4[u4 - 2 * h4] = Bn[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p7], c4[u4 + h4] = Bn[255 + d4 - m4];\n          }\n        e3 += n3;\n      }\n    }\n    function Je(t5, e3, r3, n3, i3, a3) {\n      Ge(t5, e3, r3, 1, 16, n3, i3, a3);\n    }\n    function Xe(t5, e3, r3, n3, i3, a3) {\n      Ge(t5, e3, 1, r3, 16, n3, i3, a3);\n    }\n    function Ke(t5, e3, r3, n3, i3, a3) {\n      var o3;\n      for (o3 = 3; 0 < o3; --o3)\n        Ye(t5, e3 += 4 * r3, r3, 1, 16, n3, i3, a3);\n    }\n    function Ze(t5, e3, r3, n3, i3, a3) {\n      var o3;\n      for (o3 = 3; 0 < o3; --o3)\n        Ye(t5, e3 += 4, 1, r3, 16, n3, i3, a3);\n    }\n    function $e(t5, e3, r3, n3, i3, a3, o3, s3) {\n      Ge(t5, e3, i3, 1, 8, a3, o3, s3), Ge(r3, n3, i3, 1, 8, a3, o3, s3);\n    }\n    function Qe(t5, e3, r3, n3, i3, a3, o3, s3) {\n      Ge(t5, e3, 1, i3, 8, a3, o3, s3), Ge(r3, n3, 1, i3, 8, a3, o3, s3);\n    }\n    function tr(t5, e3, r3, n3, i3, a3, o3, s3) {\n      Ye(t5, e3 + 4 * i3, i3, 1, 8, a3, o3, s3), Ye(r3, n3 + 4 * i3, i3, 1, 8, a3, o3, s3);\n    }\n    function er(t5, e3, r3, n3, i3, a3, o3, s3) {\n      Ye(t5, e3 + 4, 1, i3, 8, a3, o3, s3), Ye(r3, n3 + 4, 1, i3, 8, a3, o3, s3);\n    }\n    function rr() {\n      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = \"OutputFunc\", this.Jb = \"OutputAlphaFunc\", this.Nd = \"OutputRowFunc\";\n    }\n    function nr() {\n      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;\n    }\n    function ir() {\n      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;\n    }\n    function ar() {\n      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();\n    }\n    function or() {\n      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;\n    }\n    function sr() {\n      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;\n    }\n    function cr(t5, e3, r3, n3, i3, a3, o3) {\n      for (t5 = t5 == null ? 0 : t5[e3 + 0], e3 = 0; e3 < o3; ++e3)\n        i3[a3 + e3] = t5 + r3[n3 + e3] & 255, t5 = i3[a3 + e3];\n    }\n    function ur(t5, e3, r3, n3, i3, a3, o3) {\n      var s3;\n      if (t5 == null)\n        cr(null, null, r3, n3, i3, a3, o3);\n      else\n        for (s3 = 0; s3 < o3; ++s3)\n          i3[a3 + s3] = t5[e3 + s3] + r3[n3 + s3] & 255;\n    }\n    function hr(t5, e3, r3, n3, i3, a3, o3) {\n      if (t5 == null)\n        cr(null, null, r3, n3, i3, a3, o3);\n      else {\n        var s3, c4 = t5[e3 + 0], u4 = c4, h4 = c4;\n        for (s3 = 0; s3 < o3; ++s3)\n          u4 = h4 + (c4 = t5[e3 + s3]) - u4, h4 = r3[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i3[a3 + s3] = h4;\n      }\n    }\n    function lr(t5, r3, i3, o3) {\n      var s3 = r3.width, c4 = r3.o;\n      if (e2(t5 != null && r3 != null), 0 > i3 || 0 >= o3 || i3 + o3 > c4)\n        return null;\n      if (!t5.Cc) {\n        if (t5.ga == null) {\n          var u4;\n          if (t5.ga = new sr(), (u4 = t5.ga == null) || (u4 = r3.width * r3.o, e2(t5.Gb.length == 0), t5.Gb = a2(u4), t5.Uc = 0, t5.Gb == null ? u4 = 0 : (t5.mb = t5.Gb, t5.nb = t5.Uc, t5.rc = null, u4 = 1), u4 = !u4), !u4) {\n            u4 = t5.ga;\n            var h4 = t5.Fa, l4 = t5.P, f4 = t5.qc, d4 = t5.mb, p7 = t5.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;\n            if (e2(h4 != null && d4 != null && r3 != null), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d4, u4.tb = p7, u4.c = r3.width, u4.i = r3.height, e2(0 < u4.c && 0 < u4.i), 1 >= f4)\n              r3 = 0;\n            else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4)\n              r3 = 0;\n            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r3.width, b4.height = r3.height, b4.Da = r3.Da, b4.v = r3.v, b4.va = r3.va, b4.j = r3.j, b4.o = r3.o, u4.$a)\n              t: {\n                e2(u4.$a == 1), r3 = kt2();\n                e:\n                  for (; ; ) {\n                    if (r3 == null) {\n                      r3 = 0;\n                      break t;\n                    }\n                    if (e2(u4 != null), u4.mc = r3, r3.c = u4.c, r3.i = u4.i, r3.l = u4.l, r3.l.ma = u4, r3.l.width = u4.c, r3.l.height = u4.i, r3.a = 0, v3(r3.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r3, null))\n                      break e;\n                    if (r3.ab == 1 && r3.gc[0].hc == 3 && At2(r3.s) ? (u4.ic = 1, h4 = r3.c * r3.i, r3.Ta = null, r3.Ua = 0, r3.V = a2(h4), r3.Ba = 0, r3.V == null ? (r3.a = 1, r3 = 0) : r3 = 1) : (u4.ic = 0, r3 = Ft2(r3, u4.c)), !r3)\n                      break e;\n                    r3 = 1;\n                    break t;\n                  }\n                u4.mc = null, r3 = 0;\n              }\n            else\n              r3 = m4 >= u4.c * u4.i;\n            u4 = !r3;\n          }\n          if (u4)\n            return null;\n          t5.ga.Lc != 1 ? t5.Ga = 0 : o3 = c4 - i3;\n        }\n        e2(t5.ga != null), e2(i3 + o3 <= c4);\n        t: {\n          if (r3 = (h4 = t5.ga).c, c4 = h4.l.o, h4.$a == 0) {\n            if (g4 = t5.rc, m4 = t5.Vc, b4 = t5.Fa, l4 = t5.P + 1 + i3 * r3, f4 = t5.mb, d4 = t5.nb + i3 * r3, e2(l4 <= t5.P + t5.qc), h4.Z != 0)\n              for (e2(mi[h4.Z] != null), u4 = 0; u4 < o3; ++u4)\n                mi[h4.Z](g4, m4, b4, l4, f4, d4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;\n            else\n              for (u4 = 0; u4 < o3; ++u4)\n                n2(f4, d4, b4, l4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;\n            t5.rc = g4, t5.Vc = m4;\n          } else {\n            if (e2(h4.mc != null), r3 = i3 + o3, e2((u4 = h4.mc) != null), e2(r3 <= u4.i), u4.C >= r3)\n              r3 = 1;\n            else if (h4.ic || mr(), h4.ic) {\n              h4 = u4.V, g4 = u4.Ba, m4 = u4.c;\n              var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p7 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r3, x3 = p7.wc, _3 = w4 < L4 ? wt2(p7, f4, l4) : null;\n              e2(w4 <= N4), e2(r3 <= y4), e2(At2(p7));\n              e:\n                for (; ; ) {\n                  for (; !d4.h && w4 < L4; ) {\n                    if (f4 & x3 || (_3 = wt2(p7, f4, l4)), e2(_3 != null), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4)))\n                      h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r3 && !(l4 % 16) && St(u4, l4));\n                    else {\n                      if (!(280 > y4)) {\n                        b4 = 0;\n                        break e;\n                      }\n                      y4 = mt2(y4 - 256, d4);\n                      var P3, k3 = bt2(_3.G[4], _3.H[4], d4);\n                      if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {\n                        b4 = 0;\n                        break e;\n                      }\n                      for (P3 = 0; P3 < y4; ++P3)\n                        h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];\n                      for (w4 += y4, f4 += y4; f4 >= m4; )\n                        f4 -= m4, ++l4 <= r3 && !(l4 % 16) && St(u4, l4);\n                      w4 < L4 && f4 & x3 && (_3 = wt2(p7, f4, l4));\n                    }\n                    e2(d4.h == A3(d4));\n                  }\n                  St(u4, l4 > r3 ? r3 : l4);\n                  break e;\n                }\n              !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r3 = b4;\n            } else\n              r3 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r3, Ct2);\n            if (!r3) {\n              o3 = 0;\n              break t;\n            }\n          }\n          i3 + o3 >= c4 && (t5.Cc = 1), o3 = 1;\n        }\n        if (!o3)\n          return null;\n        if (t5.Cc && ((o3 = t5.ga) != null && (o3.mc = null), t5.ga = null, 0 < t5.Ga))\n          return alert(\"todo:WebPDequantizeLevels\"), null;\n      }\n      return t5.nb + i3 * s3;\n    }\n    function fr(t5, e3, r3, n3, i3, a3) {\n      for (; 0 < i3--; ) {\n        var o3, s3 = t5, c4 = e3 + (r3 ? 1 : 0), u4 = t5, h4 = e3 + (r3 ? 0 : 3);\n        for (o3 = 0; o3 < n3; ++o3) {\n          var l4 = u4[h4 + 4 * o3];\n          l4 != 255 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);\n        }\n        e3 += a3;\n      }\n    }\n    function dr(t5, e3, r3, n3, i3) {\n      for (; 0 < n3--; ) {\n        var a3;\n        for (a3 = 0; a3 < r3; ++a3) {\n          var o3 = t5[e3 + 2 * a3 + 0], s3 = 15 & (u4 = t5[e3 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;\n          t5[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t5[e3 + 2 * a3 + 1] = 240 & u4 | s3;\n        }\n        e3 += i3;\n      }\n    }\n    function pr(t5, e3, r3, n3, i3, a3, o3, s3) {\n      var c4, u4, h4 = 255;\n      for (u4 = 0; u4 < i3; ++u4) {\n        for (c4 = 0; c4 < n3; ++c4) {\n          var l4 = t5[e3 + c4];\n          a3[o3 + 4 * c4] = l4, h4 &= l4;\n        }\n        e3 += r3, o3 += s3;\n      }\n      return h4 != 255;\n    }\n    function gr(t5, e3, r3, n3, i3) {\n      var a3;\n      for (a3 = 0; a3 < i3; ++a3)\n        r3[n3 + a3] = t5[e3 + a3] >> 8;\n    }\n    function mr() {\n      An = fr, xn = dr, Sn = pr, _n = gr;\n    }\n    function vr(r3, n3, i3) {\n      t4[r3] = function(t5, r4, a3, o3, s3, c4, u4, h4, l4, f4, d4, p7, g4, m4, v4, b4, y4) {\n        var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d4[p7 + 0] << 16;\n        e2(t5 != null);\n        var x3 = 3 * L4 + A4 + 131074 >> 2;\n        for (n3(t5[r4 + 0], 255 & x3, x3 >> 16, g4, m4), a3 != null && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {\n          var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d4[p7 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;\n          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t5[r4 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t5[r4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), a3 != null && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i3), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, A4 = _3;\n        }\n        1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t5[r4 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i3), a3 != null && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i3)));\n      };\n    }\n    function br() {\n      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[zn] = Ai, vi[Un] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;\n    }\n    function yr(t5) {\n      return t5 & ~Fi ? 0 > t5 ? 0 : 255 : t5 >> Ii;\n    }\n    function wr(t5, e3) {\n      return yr((19077 * t5 >> 8) + (26149 * e3 >> 8) - 14234);\n    }\n    function Nr(t5, e3, r3) {\n      return yr((19077 * t5 >> 8) - (6419 * e3 >> 8) - (13320 * r3 >> 8) + 8708);\n    }\n    function Lr(t5, e3) {\n      return yr((19077 * t5 >> 8) + (33050 * e3 >> 8) - 17685);\n    }\n    function Ar(t5, e3, r3, n3, i3) {\n      n3[i3 + 0] = wr(t5, r3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = Lr(t5, e3);\n    }\n    function xr(t5, e3, r3, n3, i3) {\n      n3[i3 + 0] = Lr(t5, e3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = wr(t5, r3);\n    }\n    function Sr(t5, e3, r3, n3, i3) {\n      var a3 = Nr(t5, e3, r3);\n      e3 = a3 << 3 & 224 | Lr(t5, e3) >> 3, n3[i3 + 0] = 248 & wr(t5, r3) | a3 >> 5, n3[i3 + 1] = e3;\n    }\n    function _r(t5, e3, r3, n3, i3) {\n      var a3 = 240 & Lr(t5, e3) | 15;\n      n3[i3 + 0] = 240 & wr(t5, r3) | Nr(t5, e3, r3) >> 4, n3[i3 + 1] = a3;\n    }\n    function Pr(t5, e3, r3, n3, i3) {\n      n3[i3 + 0] = 255, Ar(t5, e3, r3, n3, i3 + 1);\n    }\n    function kr(t5, e3, r3, n3, i3) {\n      xr(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;\n    }\n    function Ir(t5, e3, r3, n3, i3) {\n      Ar(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;\n    }\n    function Vt2(t5, e3) {\n      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;\n    }\n    function Fr(e3, r3, n3) {\n      t4[e3] = function(t5, e4, i3, a3, o3, s3, c4, u4, h4) {\n        for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; )\n          r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4), r3(t5[e4 + 1], i3[a3 + 0], o3[s3 + 0], c4, u4 + n3), e4 += 2, ++a3, ++s3, u4 += 2 * n3;\n        1 & h4 && r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4);\n      };\n    }\n    function Cr(t5, e3, r3) {\n      return r3 == 0 ? t5 == 0 ? e3 == 0 ? 6 : 5 : e3 == 0 ? 4 : 0 : r3;\n    }\n    function jr(t5, e3, r3, n3, i3) {\n      switch (t5 >>> 30) {\n        case 3:\n          on(e3, r3, n3, i3, 0);\n          break;\n        case 2:\n          sn(e3, r3, n3, i3);\n          break;\n        case 1:\n          un(e3, r3, n3, i3);\n      }\n    }\n    function Or(t5, e3) {\n      var r3, a3, o3 = e3.M, s3 = e3.Nb, c4 = t5.oc, u4 = t5.pc + 40, h4 = t5.oc, l4 = t5.pc + 584, f4 = t5.oc, d4 = t5.pc + 600;\n      for (r3 = 0; 16 > r3; ++r3)\n        c4[u4 + 32 * r3 - 1] = 129;\n      for (r3 = 0; 8 > r3; ++r3)\n        h4[l4 + 32 * r3 - 1] = 129, f4[d4 + 32 * r3 - 1] = 129;\n      for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(c4, u4 - 32 - 1, 127, 21), i2(h4, l4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t5.za; ++a3) {\n        var p7 = e3.ya[e3.aa + a3];\n        if (0 < a3) {\n          for (r3 = -1; 16 > r3; ++r3)\n            n2(c4, u4 + 32 * r3 - 4, c4, u4 + 32 * r3 + 12, 4);\n          for (r3 = -1; 8 > r3; ++r3)\n            n2(h4, l4 + 32 * r3 - 4, h4, l4 + 32 * r3 + 4, 4), n2(f4, d4 + 32 * r3 - 4, f4, d4 + 32 * r3 + 4, 4);\n        }\n        var g4 = t5.Gd, m4 = t5.Hd + a3, v4 = p7.ad, b4 = p7.Hc;\n        if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p7.Za) {\n          var y4 = c4, w4 = u4 - 32 + 16;\n          for (0 < o3 && (a3 >= t5.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r3 = 0; 4 > r3; r3++)\n            y4[w4 + 128 + r3] = y4[w4 + 256 + r3] = y4[w4 + 384 + r3] = y4[w4 + 0 + r3];\n          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)\n            y4 = c4, w4 = u4 + Di[r3], fi[p7.Ob[r3]](y4, w4), jr(b4, v4, 16 * +r3, y4, w4);\n        } else if (y4 = Cr(a3, o3, p7.Ob[0]), li[y4](c4, u4), b4 != 0)\n          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)\n            jr(b4, v4, 16 * +r3, c4, u4 + Di[r3]);\n        for (r3 = p7.Gc, y4 = Cr(a3, o3, p7.Dd), di[y4](h4, l4), di[y4](f4, d4), b4 = v4, y4 = h4, w4 = l4, 255 & (p7 = r3 >> 0) && (170 & p7 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p7 = f4, b4 = d4, 255 & (r3 >>= 8) && (170 & r3 ? cn(v4, 320, p7, b4) : hn(v4, 320, p7, b4)), o3 < t5.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r3 = 8 * s3 * t5.B, g4 = t5.sa, m4 = t5.ta + 16 * a3 + 16 * s3 * t5.R, v4 = t5.qa, p7 = t5.ra + 8 * a3 + r3, b4 = t5.Ha, y4 = t5.Ia + 8 * a3 + r3, r3 = 0; 16 > r3; ++r3)\n          n2(g4, m4 + r3 * t5.R, c4, u4 + 32 * r3, 16);\n        for (r3 = 0; 8 > r3; ++r3)\n          n2(v4, p7 + r3 * t5.B, h4, l4 + 32 * r3, 8), n2(b4, y4 + r3 * t5.B, f4, d4 + 32 * r3, 8);\n      }\n    }\n    function Br(t5, n3, i3, a3, o3, s3, c4, u4, h4) {\n      var l4 = [0], f4 = [0], d4 = 0, p7 = h4 != null ? h4.kd : 0, g4 = h4 != null ? h4 : new nr();\n      if (t5 == null || 12 > i3)\n        return 7;\n      g4.data = t5, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];\n      t: {\n        var m4 = n3, b4 = i3, y4 = g4.gb;\n        if (e2(t5 != null), e2(b4 != null), e2(y4 != null), y4[0] = 0, 12 <= b4[0] && !r2(t5, m4[0], \"RIFF\")) {\n          if (r2(t5, m4[0] + 8, \"WEBP\")) {\n            y4 = 3;\n            break t;\n          }\n          var w4 = j2(t5, m4[0] + 4);\n          if (12 > w4 || 4294967286 < w4) {\n            y4 = 3;\n            break t;\n          }\n          if (p7 && w4 > b4[0] - 8) {\n            y4 = 7;\n            break t;\n          }\n          y4[0] = w4, m4[0] += 12, b4[0] -= 12;\n        }\n        y4 = 0;\n      }\n      if (y4 != 0)\n        return y4;\n      for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {\n        t: {\n          var L4 = t5;\n          b4 = n3, y4 = i3;\n          var A4 = l4, x3 = f4, S3 = m4 = [0];\n          if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0])\n            y4 = 7;\n          else {\n            if (!r2(L4, b4[0], \"VP8X\")) {\n              if (j2(L4, b4[0] + 4) != 10) {\n                y4 = 3;\n                break t;\n              }\n              if (18 > y4[0]) {\n                y4 = 7;\n                break t;\n              }\n              var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);\n              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {\n                y4 = 3;\n                break t;\n              }\n              S3 != null && (S3[0] = _3), A4 != null && (A4[0] = P3), x3 != null && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;\n            }\n            y4 = 0;\n          }\n        }\n        if (d4 = d4[0], m4 = m4[0], y4 != 0)\n          return y4;\n        if (b4 = !!(2 & m4), !w4 && d4)\n          return 3;\n        if (s3 != null && (s3[0] = !!(16 & m4)), c4 != null && (c4[0] = b4), u4 != null && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && h4 == null) {\n          y4 = 0;\n          break;\n        }\n        if (4 > i3) {\n          y4 = 7;\n          break;\n        }\n        if (w4 && d4 || !w4 && !d4 && !r2(t5, n3[0], \"ALPH\")) {\n          i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];\n          t: {\n            _3 = t5, y4 = n3, w4 = i3;\n            var k3 = g4.gb;\n            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;\n            P3 = 22, e2(_3 != null), e2(w4 != null), L4 = y4[0];\n            var I3 = w4[0];\n            for (e2(A4 != null), e2(S3 != null), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {\n              if (y4[0] = L4, w4[0] = I3, 8 > I3) {\n                y4 = 7;\n                break t;\n              }\n              var F3 = j2(_3, L4 + 4);\n              if (4294967286 < F3) {\n                y4 = 3;\n                break t;\n              }\n              var O3 = 8 + F3 + 1 & -2;\n              if (P3 += O3, 0 < k3 && P3 > k3) {\n                y4 = 3;\n                break t;\n              }\n              if (!r2(_3, L4, \"VP8 \") || !r2(_3, L4, \"VP8L\")) {\n                y4 = 0;\n                break t;\n              }\n              if (I3[0] < O3) {\n                y4 = 7;\n                break t;\n              }\n              r2(_3, L4, \"ALPH\") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;\n            }\n          }\n          if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], y4 != 0)\n            break;\n        }\n        i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];\n        t:\n          if (k3 = t5, y4 = n3, w4 = i3, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r2(k3, _3, \"VP8 \"), P3 = !r2(k3, _3, \"VP8L\"), e2(k3 != null), e2(w4 != null), e2(x3 != null), e2(S3 != null), 8 > w4[0])\n            y4 = 7;\n          else {\n            if (L4 || P3) {\n              if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {\n                y4 = 3;\n                break t;\n              }\n              if (p7 && k3 > w4[0] - 8) {\n                y4 = 7;\n                break t;\n              }\n              x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;\n            } else\n              S3[0] = 5 <= w4[0] && k3[_3 + 0] == 47 && !(k3[_3 + 4] >> 5), x3[0] = w4[0];\n            y4 = 0;\n          }\n        if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], y4 != 0)\n          break;\n        if (4294967286 < g4.Ja)\n          return 3;\n        if (u4 == null || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {\n          if (5 > i3) {\n            y4 = 7;\n            break;\n          }\n          u4 = c4, p7 = m4, b4 = s3, t5 == null || 5 > i3 ? t5 = 0 : 5 <= i3 && t5[n3 + 0] == 47 && !(t5[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t5, n3, i3), gt2(x3, w4, k3, A4) ? (u4 != null && (u4[0] = w4[0]), p7 != null && (p7[0] = k3[0]), b4 != null && (b4[0] = A4[0]), t5 = 1) : t5 = 0) : t5 = 0;\n        } else {\n          if (10 > i3) {\n            y4 = 7;\n            break;\n          }\n          u4 = m4, t5 == null || 10 > i3 || !Xt2(t5, n3 + 3, i3 - 3) ? t5 = 0 : (p7 = t5[n3 + 0] | t5[n3 + 1] << 8 | t5[n3 + 2] << 16, b4 = 16383 & (t5[n3 + 7] << 8 | t5[n3 + 6]), t5 = 16383 & (t5[n3 + 9] << 8 | t5[n3 + 8]), 1 & p7 || 3 < (p7 >> 1 & 7) || !(p7 >> 4 & 1) || p7 >> 5 >= g4.Ja || !b4 || !t5 ? t5 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t5), t5 = 1));\n        }\n        if (!t5)\n          return 3;\n        if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4))\n          return 3;\n        h4 != null && (h4[0] = g4, h4.offset = n3 - h4.w, e2(4294967286 > n3 - h4.w), e2(h4.offset == h4.ha - i3));\n        break;\n      }\n      return y4 == 0 || y4 == 7 && d4 && h4 == null ? (s3 != null && (s3[0] |= g4.na != null && 0 < g4.na.length), a3 != null && (a3[0] = c4), o3 != null && (o3[0] = m4), 0) : y4;\n    }\n    function Mr(t5, e3, r3) {\n      var n3 = e3.width, i3 = e3.height, a3 = 0, o3 = 0, s3 = n3, c4 = i3;\n      if (e3.Da = t5 != null && 0 < t5.Da, e3.Da && (s3 = t5.cd, c4 = t5.bd, a3 = t5.v, o3 = t5.j, 11 > r3 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i3))\n        return 0;\n      if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + c4, e3.U = s3, e3.T = c4, e3.da = t5 != null && 0 < t5.da, e3.da) {\n        if (!E2(s3, c4, r3 = [t5.ib], a3 = [t5.hb]))\n          return 0;\n        e3.ib = r3[0], e3.hb = a3[0];\n      }\n      return e3.ob = t5 != null && t5.ob, e3.Kb = t5 == null || !t5.Sd, e3.da && (e3.ob = e3.ib < 3 * n3 / 4 && e3.hb < 3 * i3 / 4, e3.Kb = 0), 1;\n    }\n    function Er(t5) {\n      if (t5 == null)\n        return 2;\n      if (11 > t5.S) {\n        var e3 = t5.f.RGBA;\n        e3.fb += (t5.height - 1) * e3.A, e3.A = -e3.A;\n      } else\n        e3 = t5.f.kb, t5 = t5.height, e3.O += (t5 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t5 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t5 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, e3.F != null && (e3.J += (t5 - 1) * e3.lb, e3.lb = -e3.lb);\n      return 0;\n    }\n    function qr(t5, e3, r3, n3) {\n      if (n3 == null || 0 >= t5 || 0 >= e3)\n        return 2;\n      if (r3 != null) {\n        if (r3.Da) {\n          var i3 = r3.cd, o3 = r3.bd, s3 = -2 & r3.v, c4 = -2 & r3.j;\n          if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t5 || c4 + o3 > e3)\n            return 2;\n          t5 = i3, e3 = o3;\n        }\n        if (r3.da) {\n          if (!E2(t5, e3, i3 = [r3.ib], o3 = [r3.hb]))\n            return 2;\n          t5 = i3[0], e3 = o3[0];\n        }\n      }\n      n3.width = t5, n3.height = e3;\n      t: {\n        var u4 = n3.width, h4 = n3.height;\n        if (t5 = n3.S, 0 >= u4 || 0 >= h4 || !(t5 >= En && 13 > t5))\n          t5 = 2;\n        else {\n          if (0 >= n3.Rd && n3.sd == null) {\n            s3 = o3 = i3 = e3 = 0;\n            var l4 = (c4 = u4 * Ui[t5]) * h4;\n            if (11 > t5 || (o3 = (h4 + 1) / 2 * (e3 = (u4 + 1) / 2), t5 == 12 && (s3 = (i3 = u4) * h4)), (h4 = a2(l4 + 2 * o3 + s3)) == null) {\n              t5 = 1;\n              break t;\n            }\n            n3.sd = h4, 11 > t5 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e3, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e3, u4.Ed = o3, t5 == 12 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i3);\n          }\n          if (e3 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= En && 13 > i3)\n            if (11 > i3)\n              t5 = n3.f.RGBA, e3 &= (c4 = Math.abs(t5.A)) * (s3 - 1) + o3 <= t5.size, e3 &= c4 >= o3 * Ui[i3], e3 &= t5.eb != null;\n            else {\n              t5 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t5.fa);\n              h4 = Math.abs(t5.Ab);\n              var f4 = Math.abs(t5.Db), d4 = Math.abs(t5.lb), p7 = d4 * (s3 - 1) + o3;\n              e3 &= u4 * (s3 - 1) + o3 <= t5.Fd, e3 &= h4 * (l4 - 1) + c4 <= t5.Cd, e3 = (e3 &= f4 * (l4 - 1) + c4 <= t5.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e3 &= t5.y != null, e3 &= t5.f != null, e3 &= t5.ea != null, i3 == 12 && (e3 &= d4 >= o3, e3 &= p7 <= t5.Tc, e3 &= t5.F != null);\n            }\n          else\n            e3 = 0;\n          t5 = e3 ? 0 : 2;\n        }\n      }\n      return t5 != 0 || r3 != null && r3.fd && (t5 = Er(n3)), t5;\n    }\n    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, zr = 32, Ur = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];\n    R2(\"Predictor0\", \"PredictorAdd0\"), t4.Predictor0 = function() {\n      return 4278190080;\n    }, t4.Predictor1 = function(t5) {\n      return t5;\n    }, t4.Predictor2 = function(t5, e3, r3) {\n      return e3[r3 + 0];\n    }, t4.Predictor3 = function(t5, e3, r3) {\n      return e3[r3 + 1];\n    }, t4.Predictor4 = function(t5, e3, r3) {\n      return e3[r3 - 1];\n    }, t4.Predictor5 = function(t5, e3, r3) {\n      return z2(z2(t5, e3[r3 + 1]), e3[r3 + 0]);\n    }, t4.Predictor6 = function(t5, e3, r3) {\n      return z2(t5, e3[r3 - 1]);\n    }, t4.Predictor7 = function(t5, e3, r3) {\n      return z2(t5, e3[r3 + 0]);\n    }, t4.Predictor8 = function(t5, e3, r3) {\n      return z2(e3[r3 - 1], e3[r3 + 0]);\n    }, t4.Predictor9 = function(t5, e3, r3) {\n      return z2(e3[r3 + 0], e3[r3 + 1]);\n    }, t4.Predictor10 = function(t5, e3, r3) {\n      return z2(z2(t5, e3[r3 - 1]), z2(e3[r3 + 0], e3[r3 + 1]));\n    }, t4.Predictor11 = function(t5, e3, r3) {\n      var n3 = e3[r3 + 0];\n      return 0 >= W2(n3 >> 24 & 255, t5 >> 24 & 255, (e3 = e3[r3 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t5 >> 16 & 255, e3 >> 16 & 255) + W2(n3 >> 8 & 255, t5 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n3, 255 & t5, 255 & e3) ? n3 : t5;\n    }, t4.Predictor12 = function(t5, e3, r3) {\n      var n3 = e3[r3 + 0];\n      return (U2((t5 >> 24 & 255) + (n3 >> 24 & 255) - ((e3 = e3[r3 - 1]) >> 24 & 255)) << 24 | U2((t5 >> 16 & 255) + (n3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | U2((t5 >> 8 & 255) + (n3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | U2((255 & t5) + (255 & n3) - (255 & e3))) >>> 0;\n    }, t4.Predictor13 = function(t5, e3, r3) {\n      var n3 = e3[r3 - 1];\n      return (H4((t5 = z2(t5, e3[r3 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H4(t5 >> 16 & 255, n3 >> 16 & 255) << 16 | H4(t5 >> 8 & 255, n3 >> 8 & 255) << 8 | H4(t5 >> 0 & 255, n3 >> 0 & 255)) >>> 0;\n    };\n    var Wr = t4.PredictorAdd0;\n    t4.PredictorAdd1 = V2, R2(\"Predictor2\", \"PredictorAdd2\"), R2(\"Predictor3\", \"PredictorAdd3\"), R2(\"Predictor4\", \"PredictorAdd4\"), R2(\"Predictor5\", \"PredictorAdd5\"), R2(\"Predictor6\", \"PredictorAdd6\"), R2(\"Predictor7\", \"PredictorAdd7\"), R2(\"Predictor8\", \"PredictorAdd8\"), R2(\"Predictor9\", \"PredictorAdd9\"), R2(\"Predictor10\", \"PredictorAdd10\"), R2(\"Predictor11\", \"PredictorAdd11\"), R2(\"Predictor12\", \"PredictorAdd12\"), R2(\"Predictor13\", \"PredictorAdd13\");\n    var Vr = t4.PredictorAdd2;\n    X2(\"ColorIndexInverseTransform\", \"MapARGB\", \"32b\", function(t5) {\n      return t5 >> 8 & 255;\n    }, function(t5) {\n      return t5;\n    }), X2(\"VP8LColorIndexInverseTransformAlpha\", \"MapAlpha\", \"8b\", function(t5) {\n      return t5;\n    }, function(t5) {\n      return t5 >> 8 & 255;\n    });\n    var Gr, Yr = t4.ColorIndexInverseTransform, Jr = t4.MapARGB, Xr = t4.VP8LColorIndexInverseTransformAlpha, Kr = t4.MapAlpha, Zr = t4.VP8LPredictorsAdd = [];\n    Zr.length = 16, (t4.VP8LPredictors = []).length = 16, (t4.VP8LPredictorsAdd_C = []).length = 16, (t4.VP8LPredictors_C = []).length = 16;\n    var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, zn = 5, Un = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];\n    vr(\"UpsampleRgbLinePair\", Ar, 3), vr(\"UpsampleBgrLinePair\", xr, 3), vr(\"UpsampleRgbaLinePair\", Ir, 4), vr(\"UpsampleBgraLinePair\", kr, 4), vr(\"UpsampleArgbLinePair\", Pr, 4), vr(\"UpsampleRgba4444LinePair\", _r, 2), vr(\"UpsampleRgb565LinePair\", Sr, 2);\n    var bi = t4.UpsampleRgbLinePair, yi = t4.UpsampleBgrLinePair, wi = t4.UpsampleRgbaLinePair, Ni = t4.UpsampleBgraLinePair, Li = t4.UpsampleArgbLinePair, Ai = t4.UpsampleRgba4444LinePair, xi = t4.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);\n    Fr(\"YuvToRgbRow\", Ar, 3), Fr(\"YuvToBgrRow\", xr, 3), Fr(\"YuvToRgbaRow\", Ir, 4), Fr(\"YuvToBgraRow\", kr, 4), Fr(\"YuvToArgbRow\", Pr, 4), Fr(\"YuvToRgba4444Row\", _r, 2), Fr(\"YuvToRgb565Row\", Sr, 2);\n    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], zi = 1;\n    this.WebPDecodeRGBA = function(t5, r3, n3, i3, a3) {\n      var o3 = qn, s3 = new rr(), c4 = new ot2();\n      s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];\n      var u4 = c4.width, h4 = c4.height, l4 = new st2();\n      if (l4 == null || t5 == null)\n        var f4 = 2;\n      else\n        e2(l4 != null), f4 = Br(t5, r3, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);\n      if (f4 != 0 ? u4 = 0 : (u4 != null && (u4[0] = l4.width[0]), h4 != null && (h4[0] = l4.height[0]), u4 = 1), u4) {\n        c4.width = c4.width[0], c4.height = c4.height[0], i3 != null && (i3[0] = c4.width), a3 != null && (a3[0] = c4.height);\n        t: {\n          if (i3 = new Gt2(), (a3 = new nr()).data = t5, a3.w = r3, a3.ha = n3, a3.kd = 1, r3 = [0], e2(a3 != null), ((t5 = Br(a3.data, a3.w, a3.ha, null, null, null, r3, null, a3)) == 0 || t5 == 7) && r3[0] && (t5 = 4), (r3 = t5) == 0) {\n            if (e2(s3 != null), i3.data = a3.data, i3.w = a3.w + a3.offset, i3.ha = a3.ha - a3.offset, i3.put = dt2, i3.ac = ft2, i3.bc = pt2, i3.ma = s3, a3.xa) {\n              if ((t5 = kt2()) == null) {\n                s3 = 1;\n                break t;\n              }\n              if (function(t6, r4) {\n                var n4 = [0], i4 = [0], a4 = [0];\n                e:\n                  for (; ; ) {\n                    if (t6 == null)\n                      return 0;\n                    if (r4 == null)\n                      return t6.a = 2, 0;\n                    if (t6.l = r4, t6.a = 0, v3(t6.m, r4.data, r4.w, r4.ha), !gt2(t6.m, n4, i4, a4)) {\n                      t6.a = 3;\n                      break e;\n                    }\n                    if (t6.xb = gi, r4.width = n4[0], r4.height = i4[0], !It2(n4[0], i4[0], 1, t6, null))\n                      break e;\n                    return 1;\n                  }\n                return e2(t6.a != 0), 0;\n              }(t5, i3)) {\n                if (i3 = (r3 = qr(i3.width, i3.height, s3.Oa, s3.ba)) == 0) {\n                  e: {\n                    i3 = t5;\n                    r:\n                      for (; ; ) {\n                        if (i3 == null) {\n                          i3 = 0;\n                          break e;\n                        }\n                        if (e2(i3.s.yc != null), e2(i3.s.Ya != null), e2(0 < i3.s.Wb), e2((n3 = i3.l) != null), e2((a3 = n3.ma) != null), i3.xb != 0) {\n                          if (i3.ca = a3.ba, i3.tb = a3.tb, e2(i3.ca != null), !Mr(a3.Oa, n3, Rn)) {\n                            i3.a = 2;\n                            break r;\n                          }\n                          if (!Ft2(i3, n3.width))\n                            break r;\n                          if (n3.da)\n                            break r;\n                          if ((n3.da || nt2(i3.ca.S)) && mr(), 11 > i3.ca.S || (alert(\"todo:WebPInitConvertARGBToYUV\"), i3.ca.f.kb.F != null && mr()), i3.Pb && 0 < i3.s.ua && i3.s.vb.X == null && !O2(i3.s.vb, i3.s.Wa.Xa)) {\n                            i3.a = 1;\n                            break r;\n                          }\n                          i3.xb = 0;\n                        }\n                        if (!_t2(i3, i3.V, i3.Ba, i3.c, i3.i, n3.o, Lt2))\n                          break r;\n                        a3.Dc = i3.Ma, i3 = 1;\n                        break e;\n                      }\n                    e2(i3.a != 0), i3 = 0;\n                  }\n                  i3 = !i3;\n                }\n                i3 && (r3 = t5.a);\n              } else\n                r3 = t5.a;\n            } else {\n              if ((t5 = new Yt2()) == null) {\n                s3 = 1;\n                break t;\n              }\n              if (t5.Fa = a3.na, t5.P = a3.P, t5.qc = a3.Sa, Kt2(t5, i3)) {\n                if ((r3 = qr(i3.width, i3.height, s3.Oa, s3.ba)) == 0) {\n                  if (t5.Aa = 0, n3 = s3.Oa, e2((a3 = t5) != null), n3 != null) {\n                    if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {\n                      for (h4 = l4 = 0; 4 > h4; ++h4)\n                        12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;\n                      l4 && (alert(\"todo:VP8InitRandom\"), a3.ia = 1);\n                    }\n                    a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);\n                  }\n                  Qt2(t5, i3) || (r3 = t5.a);\n                }\n              } else\n                r3 = t5.a;\n            }\n            r3 == 0 && s3.Oa != null && s3.Oa.fd && (r3 = Er(s3.ba));\n          }\n          s3 = r3;\n        }\n        o3 = s3 != 0 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;\n      } else\n        o3 = null;\n      return o3;\n    };\n    var Ui = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];\n  };\n  function u2(t4, e3) {\n    for (var r3 = \"\", n3 = 0; n3 < 4; n3++)\n      r3 += String.fromCharCode(t4[e3++]);\n    return r3;\n  }\n  function h2(t4, e3) {\n    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16) >>> 0;\n  }\n  function l2(t4, e3) {\n    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24) >>> 0;\n  }\n  new c2();\n  var f2 = [0], d2 = [0], p5 = [], g2 = new c2(), m2 = t3, v2 = function(t4, e3) {\n    var r3 = {}, n3 = 0, i3 = false, a3 = 0, o3 = 0;\n    if (r3.frames = [], !function(t5, e4, r4, n4) {\n      for (var i4 = 0; i4 < n4; i4++)\n        if (t5[e4 + i4] != r4.charCodeAt(i4))\n          return true;\n      return false;\n    }(t4, e3, \"RIFF\", 4)) {\n      var s3, c3;\n      l2(t4, e3 += 4);\n      for (e3 += 8; e3 < t4.length; ) {\n        var f3 = u2(t4, e3), d3 = l2(t4, e3 += 4);\n        e3 += 4;\n        var p6 = d3 + (1 & d3);\n        switch (f3) {\n          case \"VP8 \":\n          case \"VP8L\":\n            r3.frames[n3] === void 0 && (r3.frames[n3] = {});\n            (v3 = r3.frames[n3]).src_off = i3 ? o3 : e3 - 8, v3.src_size = a3 + d3 + 8, n3++, i3 && (i3 = false, a3 = 0, o3 = 0);\n            break;\n          case \"VP8X\":\n            (v3 = r3.header = {}).feature_flags = t4[e3];\n            var g3 = e3 + 4;\n            v3.canvas_width = 1 + h2(t4, g3);\n            g3 += 3;\n            v3.canvas_height = 1 + h2(t4, g3);\n            g3 += 3;\n            break;\n          case \"ALPH\":\n            i3 = true, a3 = p6 + 8, o3 = e3 - 8;\n            break;\n          case \"ANIM\":\n            (v3 = r3.header).bgcolor = l2(t4, e3);\n            g3 = e3 + 4;\n            v3.loop_count = (s3 = t4)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;\n            g3 += 2;\n            break;\n          case \"ANMF\":\n            var m3, v3;\n            (v3 = r3.frames[n3] = {}).offset_x = 2 * h2(t4, e3), e3 += 3, v3.offset_y = 2 * h2(t4, e3), e3 += 3, v3.width = 1 + h2(t4, e3), e3 += 3, v3.height = 1 + h2(t4, e3), e3 += 3, v3.duration = h2(t4, e3), e3 += 3, m3 = t4[e3++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;\n        }\n        f3 != \"ANMF\" && (e3 += p6);\n      }\n      return r3;\n    }\n  }(m2, 0);\n  v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;\n  var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;\n  if (b2) {\n    b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];\n    for (var w2 = 0; w2 < y2.length && y2[w2].blend != 0; w2++)\n      ;\n  }\n  var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);\n  N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];\n  for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++)\n    p5[A2] = L2[A2];\n  return this.width = d2, this.height = f2, this.data = p5, this;\n}\n!function(t3) {\n  var r2 = function() {\n    return typeof zlibSync == \"function\";\n  }, n2 = function(r3, n3, a3, h3) {\n    var l3 = 4, f3 = s2;\n    switch (h3) {\n      case t3.image_compression.FAST:\n        l3 = 1, f3 = o2;\n        break;\n      case t3.image_compression.MEDIUM:\n        l3 = 6, f3 = c2;\n        break;\n      case t3.image_compression.SLOW:\n        l3 = 9, f3 = u2;\n    }\n    r3 = i2(r3, n3, a3, f3);\n    var d2 = zlibSync(r3, { level: l3 });\n    return t3.__addimage__.arrayBufferToBinaryString(d2);\n  }, i2 = function(t4, e2, r3, n3) {\n    for (var i3, a3, o3, s3 = t4.length / e2, c3 = new Uint8Array(t4.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {\n      if (o3 = h3 * e2, i3 = t4.subarray(o3, o3 + e2), n3)\n        c3.set(n3(i3, r3, a3), o3 + h3);\n      else {\n        for (var d2, p5 = u3.length, g2 = []; d2 < p5; d2 += 1)\n          g2[d2] = u3[d2](i3, r3, a3);\n        var m2 = f2(g2.concat());\n        c3.set(g2[m2], o3 + h3);\n      }\n      a3 = i3;\n    }\n    return c3;\n  }, a2 = function(t4) {\n    var e2 = Array.apply([], t4);\n    return e2.unshift(0), e2;\n  }, o2 = function(t4, e2) {\n    var r3, n3 = [], i3 = t4.length;\n    n3[0] = 1;\n    for (var a3 = 0; a3 < i3; a3 += 1)\n      r3 = t4[a3 - e2] || 0, n3[a3 + 1] = t4[a3] - r3 + 256 & 255;\n    return n3;\n  }, s2 = function(t4, e2, r3) {\n    var n3, i3 = [], a3 = t4.length;\n    i3[0] = 2;\n    for (var o3 = 0; o3 < a3; o3 += 1)\n      n3 = r3 && r3[o3] || 0, i3[o3 + 1] = t4[o3] - n3 + 256 & 255;\n    return i3;\n  }, c2 = function(t4, e2, r3) {\n    var n3, i3, a3 = [], o3 = t4.length;\n    a3[0] = 3;\n    for (var s3 = 0; s3 < o3; s3 += 1)\n      n3 = t4[s3 - e2] || 0, i3 = r3 && r3[s3] || 0, a3[s3 + 1] = t4[s3] + 256 - (n3 + i3 >>> 1) & 255;\n    return a3;\n  }, u2 = function(t4, e2, r3) {\n    var n3, i3, a3, o3, s3 = [], c3 = t4.length;\n    s3[0] = 4;\n    for (var u3 = 0; u3 < c3; u3 += 1)\n      n3 = t4[u3 - e2] || 0, i3 = r3 && r3[u3] || 0, a3 = r3 && r3[u3 - e2] || 0, o3 = h2(n3, i3, a3), s3[u3 + 1] = t4[u3] - o3 + 256 & 255;\n    return s3;\n  }, h2 = function(t4, e2, r3) {\n    if (t4 === e2 && e2 === r3)\n      return t4;\n    var n3 = Math.abs(e2 - r3), i3 = Math.abs(t4 - r3), a3 = Math.abs(t4 + e2 - r3 - r3);\n    return n3 <= i3 && n3 <= a3 ? t4 : i3 <= a3 ? e2 : r3;\n  }, l2 = function() {\n    return [a2, o2, s2, c2, u2];\n  }, f2 = function(t4) {\n    var e2 = t4.map(function(t5) {\n      return t5.reduce(function(t6, e3) {\n        return t6 + Math.abs(e3);\n      }, 0);\n    });\n    return e2.indexOf(Math.min.apply(null, e2));\n  };\n  t3.processPNG = function(e2, i3, a3, o3) {\n    var s3, c3, u3, h3, l3, f3, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = \"\";\n    if (this.__addimage__.isArrayBuffer(e2) && (e2 = new Uint8Array(e2)), this.__addimage__.isArrayBufferView(e2)) {\n      if (e2 = (u3 = new Kt(e2)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, [4, 6].indexOf(u3.colorType) !== -1) {\n        if (u3.bits === 8) {\n          g2 = (p5 = u3.pixelBitlength == 32 ? new Uint32Array(u3.decodePixels().buffer) : u3.pixelBitlength == 16 ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);\n          var x2, S2 = u3.pixelBitlength - u3.bits;\n          for (w2 = 0, N2 = 0; w2 < g2; w2++) {\n            for (y2 = p5[w2], x2 = 0; x2 < S2; )\n              v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;\n            m2[w2] = y2 >>> x2 & 255;\n          }\n        }\n        if (u3.bits === 16) {\n          g2 = (p5 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;\n          for (var _2 = 0; w2 < g2; )\n            y2 = p5[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p5[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;\n          c3 = 8;\n        }\n        o3 !== t3.image_compression.NONE && r2() ? (e2 = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e2 = v2, d2 = m2, L2 = void 0);\n      }\n      if (u3.colorType === 3 && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {\n        var P2 = u3.transparency.indexed, k2 = 0;\n        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2)\n          k2 += P2[w2];\n        if ((k2 /= 255) === g2 - 1 && P2.indexOf(0) !== -1)\n          h3 = [P2.indexOf(0)];\n        else if (k2 !== g2) {\n          for (p5 = u3.decodePixels(), m2 = new Uint8Array(p5.length), w2 = 0, g2 = p5.length; w2 < g2; w2++)\n            m2[w2] = P2[p5[w2]];\n          d2 = n2(m2, u3.width, 1);\n        }\n      }\n      var I2 = function(e3) {\n        var r3;\n        switch (e3) {\n          case t3.image_compression.FAST:\n            r3 = 11;\n            break;\n          case t3.image_compression.MEDIUM:\n            r3 = 13;\n            break;\n          case t3.image_compression.SLOW:\n            r3 = 14;\n            break;\n          default:\n            r3 = 12;\n        }\n        return r3;\n      }(o3);\n      return L2 === this.decode.FLATE_DECODE && (A2 = \"/Predictor \" + I2 + \" \"), A2 += \"/Colors \" + l3 + \" /BitsPerComponent \" + c3 + \" /Columns \" + u3.width, (this.__addimage__.isArrayBuffer(e2) || this.__addimage__.isArrayBufferView(e2)) && (e2 = this.__addimage__.arrayBufferToBinaryString(e2)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e2, index: i3, filter: L2, decodeParameters: A2, transparency: h3, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };\n    }\n  };\n}(E$1.API), function(t3) {\n  t3.processGIF89A = function(e2, r2, n2, i2) {\n    var a2 = new Zt(e2), o2 = a2.width, s2 = a2.height, c2 = [];\n    a2.decodeAndBlitFrameRGBA(0, c2);\n    var u2 = { data: c2, width: o2, height: s2 }, h2 = new Qt(100).encode(u2, 100);\n    return t3.processJPEG.call(this, h2, r2, n2, i2);\n  }, t3.processGIF87A = t3.processGIF89A;\n}(E$1.API), te.prototype.parseHeader = function() {\n  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {\n    var t3 = this.colors === 0 ? 1 << this.bitPP : this.colors;\n    this.palette = new Array(t3);\n    for (var e2 = 0; e2 < t3; e2++) {\n      var r2 = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);\n      this.palette[e2] = { red: i2, green: n2, blue: r2, quad: a2 };\n    }\n  }\n  this.height < 0 && (this.height *= -1, this.bottom_up = false);\n}, te.prototype.parseBGR = function() {\n  this.pos = this.offset;\n  try {\n    var t3 = \"bit\" + this.bitPP, e2 = this.width * this.height * 4;\n    this.data = new Uint8Array(e2), this[t3]();\n  } catch (t4) {\n    a$2.log(\"bit decode error:\" + t4);\n  }\n}, te.prototype.bit1 = function() {\n  var t3, e2 = Math.ceil(this.width / 8), r2 = e2 % 4;\n  for (t3 = this.height - 1; t3 >= 0; t3--) {\n    for (var n2 = this.bottom_up ? t3 : this.height - 1 - t3, i2 = 0; i2 < e2; i2++)\n      for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {\n        var c2 = this.palette[a2 >> 7 - s2 & 1];\n        this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;\n      }\n    r2 !== 0 && (this.pos += 4 - r2);\n  }\n}, te.prototype.bit4 = function() {\n  for (var t3 = Math.ceil(this.width / 2), e2 = t3 % 4, r2 = this.height - 1; r2 >= 0; r2--) {\n    for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < t3; i2++) {\n      var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];\n      if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width)\n        break;\n      u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;\n    }\n    e2 !== 0 && (this.pos += 4 - e2);\n  }\n}, te.prototype.bit8 = function() {\n  for (var t3 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {\n    for (var r2 = this.bottom_up ? e2 : this.height - 1 - e2, n2 = 0; n2 < this.width; n2++) {\n      var i2 = this.datav.getUint8(this.pos++, true), a2 = r2 * this.width * 4 + 4 * n2;\n      if (i2 < this.palette.length) {\n        var o2 = this.palette[i2];\n        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;\n      } else\n        this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;\n    }\n    t3 !== 0 && (this.pos += 4 - t3);\n  }\n}, te.prototype.bit15 = function() {\n  for (var t3 = this.width % 3, e2 = parseInt(\"11111\", 2), r2 = this.height - 1; r2 >= 0; r2--) {\n    for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < this.width; i2++) {\n      var a2 = this.datav.getUint16(this.pos, true);\n      this.pos += 2;\n      var o2 = (a2 & e2) / e2 * 255 | 0, s2 = (a2 >> 5 & e2) / e2 * 255 | 0, c2 = (a2 >> 10 & e2) / e2 * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i2;\n      this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;\n    }\n    this.pos += t3;\n  }\n}, te.prototype.bit16 = function() {\n  for (var t3 = this.width % 3, e2 = parseInt(\"11111\", 2), r2 = parseInt(\"111111\", 2), n2 = this.height - 1; n2 >= 0; n2--) {\n    for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {\n      var o2 = this.datav.getUint16(this.pos, true);\n      this.pos += 2;\n      var s2 = (o2 & e2) / e2 * 255 | 0, c2 = (o2 >> 5 & r2) / r2 * 255 | 0, u2 = (o2 >> 11) / e2 * 255 | 0, h2 = i2 * this.width * 4 + 4 * a2;\n      this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;\n    }\n    this.pos += t3;\n  }\n}, te.prototype.bit24 = function() {\n  for (var t3 = this.height - 1; t3 >= 0; t3--) {\n    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {\n      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e2 * this.width * 4 + 4 * r2;\n      this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;\n    }\n    this.pos += this.width % 4;\n  }\n}, te.prototype.bit32 = function() {\n  for (var t3 = this.height - 1; t3 >= 0; t3--)\n    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {\n      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e2 * this.width * 4 + 4 * r2;\n      this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;\n    }\n}, te.prototype.getData = function() {\n  return this.data;\n}, function(t3) {\n  t3.processBMP = function(e2, r2, n2, i2) {\n    var a2 = new te(e2, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);\n    return t3.processJPEG.call(this, u2, r2, n2, i2);\n  };\n}(E$1.API), ee.prototype.getData = function() {\n  return this.data;\n}, function(t3) {\n  t3.processWEBP = function(e2, r2, n2, i2) {\n    var a2 = new ee(e2, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);\n    return t3.processJPEG.call(this, u2, r2, n2, i2);\n  };\n}(E$1.API), E$1.API.processRGBA = function(t3, e2, r2) {\n  for (var n2 = t3.data, i2 = n2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i2; u2 += 4) {\n    var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];\n    a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;\n  }\n  var p5 = this.__addimage__.arrayBufferToBinaryString(a2);\n  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p5, index: e2, alias: r2, colorSpace: \"DeviceRGB\", bitsPerComponent: 8, width: t3.width, height: t3.height };\n}, E$1.API.setLanguage = function(t3) {\n  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), { af: \"Afrikaans\", sq: \"Albanian\", ar: \"Arabic (Standard)\", \"ar-DZ\": \"Arabic (Algeria)\", \"ar-BH\": \"Arabic (Bahrain)\", \"ar-EG\": \"Arabic (Egypt)\", \"ar-IQ\": \"Arabic (Iraq)\", \"ar-JO\": \"Arabic (Jordan)\", \"ar-KW\": \"Arabic (Kuwait)\", \"ar-LB\": \"Arabic (Lebanon)\", \"ar-LY\": \"Arabic (Libya)\", \"ar-MA\": \"Arabic (Morocco)\", \"ar-OM\": \"Arabic (Oman)\", \"ar-QA\": \"Arabic (Qatar)\", \"ar-SA\": \"Arabic (Saudi Arabia)\", \"ar-SY\": \"Arabic (Syria)\", \"ar-TN\": \"Arabic (Tunisia)\", \"ar-AE\": \"Arabic (U.A.E.)\", \"ar-YE\": \"Arabic (Yemen)\", an: \"Aragonese\", hy: \"Armenian\", as: \"Assamese\", ast: \"Asturian\", az: \"Azerbaijani\", eu: \"Basque\", be: \"Belarusian\", bn: \"Bengali\", bs: \"Bosnian\", br: \"Breton\", bg: \"Bulgarian\", my: \"Burmese\", ca: \"Catalan\", ch: \"Chamorro\", ce: \"Chechen\", zh: \"Chinese\", \"zh-HK\": \"Chinese (Hong Kong)\", \"zh-CN\": \"Chinese (PRC)\", \"zh-SG\": \"Chinese (Singapore)\", \"zh-TW\": \"Chinese (Taiwan)\", cv: \"Chuvash\", co: \"Corsican\", cr: \"Cree\", hr: \"Croatian\", cs: \"Czech\", da: \"Danish\", nl: \"Dutch (Standard)\", \"nl-BE\": \"Dutch (Belgian)\", en: \"English\", \"en-AU\": \"English (Australia)\", \"en-BZ\": \"English (Belize)\", \"en-CA\": \"English (Canada)\", \"en-IE\": \"English (Ireland)\", \"en-JM\": \"English (Jamaica)\", \"en-NZ\": \"English (New Zealand)\", \"en-PH\": \"English (Philippines)\", \"en-ZA\": \"English (South Africa)\", \"en-TT\": \"English (Trinidad & Tobago)\", \"en-GB\": \"English (United Kingdom)\", \"en-US\": \"English (United States)\", \"en-ZW\": \"English (Zimbabwe)\", eo: \"Esperanto\", et: \"Estonian\", fo: \"Faeroese\", fj: \"Fijian\", fi: \"Finnish\", fr: \"French (Standard)\", \"fr-BE\": \"French (Belgium)\", \"fr-CA\": \"French (Canada)\", \"fr-FR\": \"French (France)\", \"fr-LU\": \"French (Luxembourg)\", \"fr-MC\": \"French (Monaco)\", \"fr-CH\": \"French (Switzerland)\", fy: \"Frisian\", fur: \"Friulian\", gd: \"Gaelic (Scots)\", \"gd-IE\": \"Gaelic (Irish)\", gl: \"Galacian\", ka: \"Georgian\", de: \"German (Standard)\", \"de-AT\": \"German (Austria)\", \"de-DE\": \"German (Germany)\", \"de-LI\": \"German (Liechtenstein)\", \"de-LU\": \"German (Luxembourg)\", \"de-CH\": \"German (Switzerland)\", el: \"Greek\", gu: \"Gujurati\", ht: \"Haitian\", he: \"Hebrew\", hi: \"Hindi\", hu: \"Hungarian\", is: \"Icelandic\", id: \"Indonesian\", iu: \"Inuktitut\", ga: \"Irish\", it: \"Italian (Standard)\", \"it-CH\": \"Italian (Switzerland)\", ja: \"Japanese\", kn: \"Kannada\", ks: \"Kashmiri\", kk: \"Kazakh\", km: \"Khmer\", ky: \"Kirghiz\", tlh: \"Klingon\", ko: \"Korean\", \"ko-KP\": \"Korean (North Korea)\", \"ko-KR\": \"Korean (South Korea)\", la: \"Latin\", lv: \"Latvian\", lt: \"Lithuanian\", lb: \"Luxembourgish\", mk: \"North Macedonia\", ms: \"Malay\", ml: \"Malayalam\", mt: \"Maltese\", mi: \"Maori\", mr: \"Marathi\", mo: \"Moldavian\", nv: \"Navajo\", ng: \"Ndonga\", ne: \"Nepali\", no: \"Norwegian\", nb: \"Norwegian (Bokmal)\", nn: \"Norwegian (Nynorsk)\", oc: \"Occitan\", or: \"Oriya\", om: \"Oromo\", fa: \"Persian\", \"fa-IR\": \"Persian/Iran\", pl: \"Polish\", pt: \"Portuguese\", \"pt-BR\": \"Portuguese (Brazil)\", pa: \"Punjabi\", \"pa-IN\": \"Punjabi (India)\", \"pa-PK\": \"Punjabi (Pakistan)\", qu: \"Quechua\", rm: \"Rhaeto-Romanic\", ro: \"Romanian\", \"ro-MO\": \"Romanian (Moldavia)\", ru: \"Russian\", \"ru-MO\": \"Russian (Moldavia)\", sz: \"Sami (Lappish)\", sg: \"Sango\", sa: \"Sanskrit\", sc: \"Sardinian\", sd: \"Sindhi\", si: \"Singhalese\", sr: \"Serbian\", sk: \"Slovak\", sl: \"Slovenian\", so: \"Somani\", sb: \"Sorbian\", es: \"Spanish\", \"es-AR\": \"Spanish (Argentina)\", \"es-BO\": \"Spanish (Bolivia)\", \"es-CL\": \"Spanish (Chile)\", \"es-CO\": \"Spanish (Colombia)\", \"es-CR\": \"Spanish (Costa Rica)\", \"es-DO\": \"Spanish (Dominican Republic)\", \"es-EC\": \"Spanish (Ecuador)\", \"es-SV\": \"Spanish (El Salvador)\", \"es-GT\": \"Spanish (Guatemala)\", \"es-HN\": \"Spanish (Honduras)\", \"es-MX\": \"Spanish (Mexico)\", \"es-NI\": \"Spanish (Nicaragua)\", \"es-PA\": \"Spanish (Panama)\", \"es-PY\": \"Spanish (Paraguay)\", \"es-PE\": \"Spanish (Peru)\", \"es-PR\": \"Spanish (Puerto Rico)\", \"es-ES\": \"Spanish (Spain)\", \"es-UY\": \"Spanish (Uruguay)\", \"es-VE\": \"Spanish (Venezuela)\", sx: \"Sutu\", sw: \"Swahili\", sv: \"Swedish\", \"sv-FI\": \"Swedish (Finland)\", \"sv-SV\": \"Swedish (Sweden)\", ta: \"Tamil\", tt: \"Tatar\", te: \"Teluga\", th: \"Thai\", tig: \"Tigre\", ts: \"Tsonga\", tn: \"Tswana\", tr: \"Turkish\", tk: \"Turkmen\", uk: \"Ukrainian\", hsb: \"Upper Sorbian\", ur: \"Urdu\", ve: \"Venda\", vi: \"Vietnamese\", vo: \"Volapuk\", wa: \"Walloon\", cy: \"Welsh\", xh: \"Xhosa\", ji: \"Yiddish\", zu: \"Zulu\" }[t3] !== void 0 && (this.internal.languageSettings.languageCode = t3, this.internal.languageSettings.isSubscribed === false && (this.internal.events.subscribe(\"putCatalog\", function() {\n    this.internal.write(\"/Lang (\" + this.internal.languageSettings.languageCode + \")\");\n  }), this.internal.languageSettings.isSubscribed = true)), this;\n}, Vt = E$1.API, Gt = Vt.getCharWidthsArray = function(e2, r2) {\n  var n2, i2, a2 = (r2 = r2 || {}).font || this.internal.getFont(), o2 = r2.fontSize || this.internal.getFontSize(), s2 = r2.charSpace || this.internal.getCharSpace(), c2 = r2.widths ? r2.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r2.kerning ? r2.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = r2.doKerning !== false, d2 = 0, p5 = e2.length, g2 = 0, m2 = c2[0] || u2, v2 = [];\n  for (n2 = 0; n2 < p5; n2++)\n    i2 = e2.charCodeAt(n2), typeof a2.metadata.widthOfString == \"function\" ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && _typeof$2(h2[i2]) === \"object\" && !isNaN(parseInt(h2[i2][g2], 10)) ? h2[i2][g2] / l2 : 0, v2.push((c2[i2] || m2) / u2 + d2)), g2 = i2;\n  return v2;\n}, Yt = Vt.getStringUnitWidth = function(t3, e2) {\n  var r2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), n2 = e2.font || this.internal.getFont(), i2 = e2.charSpace || this.internal.getCharSpace();\n  return Vt.processArabic && (t3 = Vt.processArabic(t3)), typeof n2.metadata.widthOfString == \"function\" ? n2.metadata.widthOfString(t3, r2, i2) / r2 : Gt.apply(this, arguments).reduce(function(t4, e3) {\n    return t4 + e3;\n  }, 0);\n}, Jt = function(t3, e2, r2, n2) {\n  for (var i2 = [], a2 = 0, o2 = t3.length, s2 = 0; a2 !== o2 && s2 + e2[a2] < r2; )\n    s2 += e2[a2], a2++;\n  i2.push(t3.slice(0, a2));\n  var c2 = a2;\n  for (s2 = 0; a2 !== o2; )\n    s2 + e2[a2] > n2 && (i2.push(t3.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e2[a2], a2++;\n  return c2 !== a2 && i2.push(t3.slice(c2, a2)), i2;\n}, Xt = function(t3, e2, r2) {\n  r2 || (r2 = {});\n  var n2, i2, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r2.textIndent || 0, d2 = 0, p5 = 0, g2 = t3.split(\" \"), m2 = Gt.apply(this, [\" \", r2])[0];\n  if (c2 = r2.lineIndent === -1 ? g2[0].length + 2 : r2.lineIndent || 0) {\n    var v2 = Array(c2).join(\" \"), b2 = [];\n    g2.map(function(t4) {\n      (t4 = t4.split(/\\s*\\n/)).length > 1 ? b2 = b2.concat(t4.map(function(t5, e3) {\n        return (e3 && t5.length ? \"\\n\" : \"\") + t5;\n      })) : b2.push(t4[0]);\n    }), g2 = b2, c2 = Yt.apply(this, [v2, r2]);\n  }\n  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {\n    var y2 = 0;\n    if (n2 = g2[a2], c2 && n2[0] == \"\\n\" && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p5 = (i2 = Gt.apply(this, [n2, r2])).reduce(function(t4, e3) {\n      return t4 + e3;\n    }, 0)) > e2 || y2) {\n      if (p5 > e2) {\n        for (s2 = Jt.apply(this, [n2, i2, e2 - (f2 + d2), e2]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; )\n          l2.push([s2.shift()]);\n        p5 = i2.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t4, e3) {\n          return t4 + e3;\n        }, 0);\n      } else\n        h2 = [n2];\n      l2.push(h2), f2 = p5 + c2, d2 = m2;\n    } else\n      h2.push(n2), f2 += d2 + p5, d2 = m2;\n  }\n  return u2 = c2 ? function(t4, e3) {\n    return (e3 ? v2 : \"\") + t4.join(\" \");\n  } : function(t4) {\n    return t4.join(\" \");\n  }, l2.map(u2);\n}, Vt.splitTextToSize = function(t3, e2, r2) {\n  var n2, i2 = (r2 = r2 || {}).fontSize || this.internal.getFontSize(), a2 = function(t4) {\n    if (t4.widths && t4.kerning)\n      return { widths: t4.widths, kerning: t4.kerning };\n    var e3 = this.internal.getFont(t4.fontName, t4.fontStyle);\n    return e3.metadata.Unicode ? { widths: e3.metadata.Unicode.widths || { 0: 1 }, kerning: e3.metadata.Unicode.kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };\n  }.call(this, r2);\n  n2 = Array.isArray(t3) ? t3 : String(t3).split(/\\r?\\n/);\n  var o2 = 1 * this.internal.scaleFactor * e2 / i2;\n  a2.textIndent = r2.textIndent ? 1 * r2.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = r2.lineIndent;\n  var s2, c2, u2 = [];\n  for (s2 = 0, c2 = n2.length; s2 < c2; s2++)\n    u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));\n  return u2;\n}, function(e2) {\n  e2.__fontmetrics__ = e2.__fontmetrics__ || {};\n  for (var r2 = \"klmnopqrstuvwxyz\", n2 = {}, i2 = {}, a2 = 0; a2 < r2.length; a2++)\n    n2[r2[a2]] = \"0123456789abcdef\"[a2], i2[\"0123456789abcdef\"[a2]] = r2[a2];\n  var o2 = function(t3) {\n    return \"0x\" + parseInt(t3, 10).toString(16);\n  }, s2 = e2.__fontmetrics__.compress = function(e3) {\n    var r3, n3, a3, c3, u3 = [\"{\"];\n    for (var h3 in e3) {\n      if (r3 = e3[h3], isNaN(parseInt(h3, 10)) ? n3 = \"'\" + h3 + \"'\" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i2[n3.slice(-1)]), typeof r3 == \"number\")\n        r3 < 0 ? (a3 = o2(r3).slice(3), c3 = \"-\") : (a3 = o2(r3).slice(2), c3 = \"\"), a3 = c3 + a3.slice(0, -1) + i2[a3.slice(-1)];\n      else {\n        if (_typeof$2(r3) !== \"object\")\n          throw new Error(\"Don't know what to do with value type \" + _typeof$2(r3) + \".\");\n        a3 = s2(r3);\n      }\n      u3.push(n3 + a3);\n    }\n    return u3.push(\"}\"), u3.join(\"\");\n  }, c2 = e2.__fontmetrics__.uncompress = function(t3) {\n    if (typeof t3 != \"string\")\n      throw new Error(\"Invalid argument passed to uncompress.\");\n    for (var e3, r3, i3, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = \"\", l3 = \"\", f2 = t3.length - 1, d2 = 1; d2 < f2; d2 += 1)\n      (a3 = t3[d2]) == \"'\" ? e3 ? (i3 = e3.join(\"\"), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : a3 == \"{\" ? (u3.push([c3, i3]), c3 = {}, i3 = void 0) : a3 == \"}\" ? ((r3 = u3.pop())[0][r3[1]] = c3, i3 = void 0, c3 = r3[0]) : a3 == \"-\" ? s3 = -1 : i3 === void 0 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i3 = parseInt(h3, 16) * s3, s3 = 1, h3 = \"\") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i3] = parseInt(l3, 16) * s3, s3 = 1, i3 = void 0, l3 = \"\") : l3 += a3;\n    return o3;\n  }, u2 = { codePages: [\"WinAnsiEncoding\"], WinAnsiEncoding: c2(\"{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}\") }, h2 = { Unicode: { Courier: u2, \"Courier-Bold\": u2, \"Courier-BoldOblique\": u2, \"Courier-Oblique\": u2, Helvetica: u2, \"Helvetica-Bold\": u2, \"Helvetica-BoldOblique\": u2, \"Helvetica-Oblique\": u2, \"Times-Roman\": u2, \"Times-Bold\": u2, \"Times-BoldItalic\": u2, \"Times-Italic\": u2 } }, l2 = { Unicode: { \"Courier-Oblique\": c2(\"{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}\"), \"Times-BoldItalic\": c2(\"{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}\"), \"Helvetica-Bold\": c2(\"{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}\"), Courier: c2(\"{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}\"), \"Courier-BoldOblique\": c2(\"{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}\"), \"Times-Bold\": c2(\"{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}\"), Symbol: c2(\"{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}\"), Helvetica: c2(\"{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}\"), \"Helvetica-BoldOblique\": c2(\"{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}\"), ZapfDingbats: c2(\"{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}\"), \"Courier-Bold\": c2(\"{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}\"), \"Times-Italic\": c2(\"{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}\"), \"Times-Roman\": c2(\"{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}\"), \"Helvetica-Oblique\": c2(\"{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}\") } };\n  e2.events.push([\"addFont\", function(t3) {\n    var e3 = t3.font, r3 = l2.Unicode[e3.postScriptName];\n    r3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r3.widths, e3.metadata.Unicode.kerning = r3.kerning);\n    var n3 = h2.Unicode[e3.postScriptName];\n    n3 && (e3.metadata.Unicode.encoding = n3, e3.encoding = n3.codePages[0]);\n  }]);\n}(E$1.API), function(t3) {\n  var e2 = function(t4) {\n    for (var e3 = t4.length, r2 = new Uint8Array(e3), n2 = 0; n2 < e3; n2++)\n      r2[n2] = t4.charCodeAt(n2);\n    return r2;\n  };\n  t3.API.events.push([\"addFont\", function(r2) {\n    var n2 = void 0, i2 = r2.font, a2 = r2.instance;\n    if (!i2.isStandardFont) {\n      if (a2 === void 0)\n        throw new Error(\"Font does not exist in vFS, import fonts or remove declaration doc.addFont('\" + i2.postScriptName + \"').\");\n      if (typeof (n2 = a2.existsFileInVFS(i2.postScriptName) === false ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName)) != \"string\")\n        throw new Error(\"Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('\" + i2.postScriptName + \"').\");\n      !function(r3, n3) {\n        n3 = /^\\x00\\x01\\x00\\x00/.test(n3) ? e2(n3) : e2(u$2(n3)), r3.metadata = t3.API.TTFFont.open(n3), r3.metadata.Unicode = r3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r3.metadata.glyIdsUsed = [0];\n      }(i2, n2);\n    }\n  }]);\n}(E$1), function(t3) {\n  function e2() {\n    return (n$1.canvg ? Promise.resolve(n$1.canvg) : Promise.resolve().then(function() {\n      return index_es;\n    })).catch(function(t4) {\n      return Promise.reject(new Error(\"Could not load canvg: \" + t4));\n    }).then(function(t4) {\n      return t4.default ? t4.default : t4;\n    });\n  }\n  E$1.API.addSvgAsImage = function(t4, r2, n2, i2, o2, s2, c2, u2) {\n    if (isNaN(r2) || isNaN(n2))\n      throw a$2.error(\"jsPDF.addSvgAsImage: Invalid coordinates\", arguments), new Error(\"Invalid coordinates passed to jsPDF.addSvgAsImage\");\n    if (isNaN(i2) || isNaN(o2))\n      throw a$2.error(\"jsPDF.addSvgAsImage: Invalid measurements\", arguments), new Error(\"Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage\");\n    var h2 = document.createElement(\"canvas\");\n    h2.width = i2, h2.height = o2;\n    var l2 = h2.getContext(\"2d\");\n    l2.fillStyle = \"#fff\", l2.fillRect(0, 0, h2.width, h2.height);\n    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;\n    return e2().then(function(e3) {\n      return e3.fromString(l2, t4, f2);\n    }, function() {\n      return Promise.reject(new Error(\"Could not load canvg.\"));\n    }).then(function(t5) {\n      return t5.render(f2);\n    }).then(function() {\n      d2.addImage(h2.toDataURL(\"image/jpeg\", 1), r2, n2, i2, o2, c2, u2);\n    });\n  };\n}(), E$1.API.putTotalPages = function(t3) {\n  var e2, r2 = 0;\n  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t3, \"g\"), r2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t3, this.internal.getFont()), \"g\"), r2 = this.pdfEscape16(this.internal.getNumberOfPages() + \"\", this.internal.getFont()));\n  for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++)\n    for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++)\n      this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e2, r2);\n  return this;\n}, E$1.API.viewerPreferences = function(e2, r2) {\n  var n2;\n  e2 = e2 || {}, r2 = r2 || false;\n  var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: \"boolean\", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: \"boolean\", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: \"boolean\", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: \"boolean\", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: \"boolean\", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: \"boolean\", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: \"UseNone\", value: \"UseNone\", type: \"name\", explicitSet: false, valueSet: [\"UseNone\", \"UseOutlines\", \"UseThumbs\", \"UseOC\"], pdfVersion: 1.3 }, Direction: { defaultValue: \"L2R\", value: \"L2R\", type: \"name\", explicitSet: false, valueSet: [\"L2R\", \"R2L\"], pdfVersion: 1.3 }, ViewArea: { defaultValue: \"CropBox\", value: \"CropBox\", type: \"name\", explicitSet: false, valueSet: [\"MediaBox\", \"CropBox\", \"TrimBox\", \"BleedBox\", \"ArtBox\"], pdfVersion: 1.4 }, ViewClip: { defaultValue: \"CropBox\", value: \"CropBox\", type: \"name\", explicitSet: false, valueSet: [\"MediaBox\", \"CropBox\", \"TrimBox\", \"BleedBox\", \"ArtBox\"], pdfVersion: 1.4 }, PrintArea: { defaultValue: \"CropBox\", value: \"CropBox\", type: \"name\", explicitSet: false, valueSet: [\"MediaBox\", \"CropBox\", \"TrimBox\", \"BleedBox\", \"ArtBox\"], pdfVersion: 1.4 }, PrintClip: { defaultValue: \"CropBox\", value: \"CropBox\", type: \"name\", explicitSet: false, valueSet: [\"MediaBox\", \"CropBox\", \"TrimBox\", \"BleedBox\", \"ArtBox\"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: \"AppDefault\", value: \"AppDefault\", type: \"name\", explicitSet: false, valueSet: [\"AppDefault\", \"None\"], pdfVersion: 1.6 }, Duplex: { defaultValue: \"\", value: \"none\", type: \"name\", explicitSet: false, valueSet: [\"Simplex\", \"DuplexFlipShortEdge\", \"DuplexFlipLongEdge\", \"none\"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: \"boolean\", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: \"\", value: \"\", type: \"array\", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: \"integer\", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;\n  function d2(t3, e3) {\n    var r3, n3 = false;\n    for (r3 = 0; r3 < t3.length; r3 += 1)\n      t3[r3] === e3 && (n3 = true);\n    return n3;\n  }\n  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, e2 === \"reset\" || r2 === true) {\n    var p5 = c2.length;\n    for (f2 = 0; f2 < p5; f2 += 1)\n      n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;\n  }\n  if (_typeof$2(e2) === \"object\") {\n    for (a2 in e2)\n      if (o2 = e2[a2], d2(c2, a2) && o2 !== void 0) {\n        if (n2[a2].type === \"boolean\" && typeof o2 == \"boolean\")\n          n2[a2].value = o2;\n        else if (n2[a2].type === \"name\" && d2(n2[a2].valueSet, o2))\n          n2[a2].value = o2;\n        else if (n2[a2].type === \"integer\" && Number.isInteger(o2))\n          n2[a2].value = o2;\n        else if (n2[a2].type === \"array\") {\n          for (h2 = 0; h2 < o2.length; h2 += 1)\n            if (i2 = true, o2[h2].length === 1 && typeof o2[h2][0] == \"number\")\n              u2.push(String(o2[h2] - 1));\n            else if (o2[h2].length > 1) {\n              for (l2 = 0; l2 < o2[h2].length; l2 += 1)\n                typeof o2[h2][l2] != \"number\" && (i2 = false);\n              i2 === true && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(\" \"));\n            }\n          n2[a2].value = \"[\" + u2.join(\" \") + \"]\";\n        } else\n          n2[a2].value = n2[a2].defaultValue;\n        n2[a2].explicitSet = true;\n      }\n  }\n  return this.internal.viewerpreferences.isSubscribed === false && (this.internal.events.subscribe(\"putCatalog\", function() {\n    var t3, e3 = [];\n    for (t3 in n2)\n      n2[t3].explicitSet === true && (n2[t3].type === \"name\" ? e3.push(\"/\" + t3 + \" /\" + n2[t3].value) : e3.push(\"/\" + t3 + \" \" + n2[t3].value));\n    e3.length !== 0 && this.internal.write(\"/ViewerPreferences\\n<<\\n\" + e3.join(\"\\n\") + \"\\n>>\");\n  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;\n}, function(t3) {\n  var e2 = function() {\n    var t4 = '<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"><rdf:Description rdf:about=\"\" xmlns:jspdf=\"' + this.internal.__metadata__.namespaceuri + '\"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x=\"adobe:ns:meta/\">')), r3 = unescape(encodeURIComponent(t4)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent(\"</jspdf:metadata></rdf:Description></rdf:RDF>\")), a2 = unescape(encodeURIComponent(\"</x:xmpmeta>\")), o2 = r3.length + n2.length + i2.length + e3.length + a2.length;\n    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write(\"<< /Type /Metadata /Subtype /XML /Length \" + o2 + \" >>\"), this.internal.write(\"stream\"), this.internal.write(e3 + r3 + n2 + i2 + a2), this.internal.write(\"endstream\"), this.internal.write(\"endobj\");\n  }, r2 = function() {\n    this.internal.__metadata__.metadata_object_number && this.internal.write(\"/Metadata \" + this.internal.__metadata__.metadata_object_number + \" 0 R\");\n  };\n  t3.addMetadata = function(t4, n2) {\n    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: t4, namespaceuri: n2 || \"http://jspdf.default.namespaceuri/\" }, this.internal.events.subscribe(\"putCatalog\", r2), this.internal.events.subscribe(\"postPutResources\", e2)), this;\n  };\n}(E$1.API), function(t3) {\n  var e2 = t3.API, r2 = e2.pdfEscape16 = function(t4, e3) {\n    for (var r3, n3 = e3.metadata.Unicode.widths, i3 = [\"\", \"0\", \"00\", \"000\", \"0000\"], a2 = [\"\"], o2 = 0, s2 = t4.length; o2 < s2; ++o2) {\n      if (r3 = e3.metadata.characterToGlyph(t4.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(r3), e3.metadata.toUnicode[r3] = t4.charCodeAt(o2), n3.indexOf(r3) == -1 && (n3.push(r3), n3.push([parseInt(e3.metadata.widthOfGlyph(r3), 10)])), r3 == \"0\")\n        return a2.join(\"\");\n      r3 = r3.toString(16), a2.push(i3[4 - r3.length], r3);\n    }\n    return a2.join(\"\");\n  }, n2 = function(t4) {\n    var e3, r3, n3, i3, a2, o2, s2;\n    for (a2 = \"/CIDInit /ProcSet findresource begin\\n12 dict begin\\nbegincmap\\n/CIDSystemInfo <<\\n  /Registry (Adobe)\\n  /Ordering (UCS)\\n  /Supplement 0\\n>> def\\n/CMapName /Adobe-Identity-UCS def\\n/CMapType 2 def\\n1 begincodespacerange\\n<0000><ffff>\\nendcodespacerange\", n3 = [], o2 = 0, s2 = (r3 = Object.keys(t4).sort(function(t5, e4) {\n      return t5 - e4;\n    })).length; o2 < s2; o2++)\n      e3 = r3[o2], n3.length >= 100 && (a2 += \"\\n\" + n3.length + \" beginbfchar\\n\" + n3.join(\"\\n\") + \"\\nendbfchar\", n3 = []), t4[e3] !== void 0 && t4[e3] !== null && typeof t4[e3].toString == \"function\" && (i3 = (\"0000\" + t4[e3].toString(16)).slice(-4), e3 = (\"0000\" + (+e3).toString(16)).slice(-4), n3.push(\"<\" + e3 + \"><\" + i3 + \">\"));\n    return n3.length && (a2 += \"\\n\" + n3.length + \" beginbfchar\\n\" + n3.join(\"\\n\") + \"\\nendbfchar\\n\"), a2 += \"endcmap\\nCMapName currentdict /CMap defineresource pop\\nend\\nend\";\n  };\n  e2.events.push([\"putFont\", function(e3) {\n    !function(e4) {\n      var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;\n      if (r3.metadata instanceof t3.API.TTFFont && r3.encoding === \"Identity-H\") {\n        for (var s2 = r3.metadata.Unicode.widths, c2 = r3.metadata.subset.encode(r3.metadata.glyIdsUsed, 1), u2 = \"\", h2 = 0; h2 < c2.length; h2++)\n          u2 += String.fromCharCode(c2[h2]);\n        var l2 = a2();\n        o2({ data: u2, addLength1: true, objectId: l2 }), i3(\"endobj\");\n        var f2 = a2();\n        o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: f2 }), i3(\"endobj\");\n        var d2 = a2();\n        i3(\"<<\"), i3(\"/Type /FontDescriptor\"), i3(\"/FontName /\" + F$1(r3.fontName)), i3(\"/FontFile2 \" + l2 + \" 0 R\"), i3(\"/FontBBox \" + t3.API.PDFObject.convert(r3.metadata.bbox)), i3(\"/Flags \" + r3.metadata.flags), i3(\"/StemV \" + r3.metadata.stemV), i3(\"/ItalicAngle \" + r3.metadata.italicAngle), i3(\"/Ascent \" + r3.metadata.ascender), i3(\"/Descent \" + r3.metadata.decender), i3(\"/CapHeight \" + r3.metadata.capHeight), i3(\">>\"), i3(\"endobj\");\n        var p5 = a2();\n        i3(\"<<\"), i3(\"/Type /Font\"), i3(\"/BaseFont /\" + F$1(r3.fontName)), i3(\"/FontDescriptor \" + d2 + \" 0 R\"), i3(\"/W \" + t3.API.PDFObject.convert(s2)), i3(\"/CIDToGIDMap /Identity\"), i3(\"/DW 1000\"), i3(\"/Subtype /CIDFontType2\"), i3(\"/CIDSystemInfo\"), i3(\"<<\"), i3(\"/Supplement 0\"), i3(\"/Registry (Adobe)\"), i3(\"/Ordering (\" + r3.encoding + \")\"), i3(\">>\"), i3(\">>\"), i3(\"endobj\"), r3.objectNumber = a2(), i3(\"<<\"), i3(\"/Type /Font\"), i3(\"/Subtype /Type0\"), i3(\"/ToUnicode \" + f2 + \" 0 R\"), i3(\"/BaseFont /\" + F$1(r3.fontName)), i3(\"/Encoding /\" + r3.encoding), i3(\"/DescendantFonts [\" + p5 + \" 0 R]\"), i3(\">>\"), i3(\"endobj\"), r3.isAlreadyPutted = true;\n      }\n    }(e3);\n  }]);\n  e2.events.push([\"putFont\", function(e3) {\n    !function(e4) {\n      var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;\n      if (r3.metadata instanceof t3.API.TTFFont && r3.encoding === \"WinAnsiEncoding\") {\n        for (var s2 = r3.metadata.rawData, c2 = \"\", u2 = 0; u2 < s2.length; u2++)\n          c2 += String.fromCharCode(s2[u2]);\n        var h2 = a2();\n        o2({ data: c2, addLength1: true, objectId: h2 }), i3(\"endobj\");\n        var l2 = a2();\n        o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: l2 }), i3(\"endobj\");\n        var f2 = a2();\n        i3(\"<<\"), i3(\"/Descent \" + r3.metadata.decender), i3(\"/CapHeight \" + r3.metadata.capHeight), i3(\"/StemV \" + r3.metadata.stemV), i3(\"/Type /FontDescriptor\"), i3(\"/FontFile2 \" + h2 + \" 0 R\"), i3(\"/Flags 96\"), i3(\"/FontBBox \" + t3.API.PDFObject.convert(r3.metadata.bbox)), i3(\"/FontName /\" + F$1(r3.fontName)), i3(\"/ItalicAngle \" + r3.metadata.italicAngle), i3(\"/Ascent \" + r3.metadata.ascender), i3(\">>\"), i3(\"endobj\"), r3.objectNumber = a2();\n        for (var d2 = 0; d2 < r3.metadata.hmtx.widths.length; d2++)\n          r3.metadata.hmtx.widths[d2] = parseInt(r3.metadata.hmtx.widths[d2] * (1e3 / r3.metadata.head.unitsPerEm));\n        i3(\"<</Subtype/TrueType/Type/Font/ToUnicode \" + l2 + \" 0 R/BaseFont/\" + F$1(r3.fontName) + \"/FontDescriptor \" + f2 + \" 0 R/Encoding/\" + r3.encoding + \" /FirstChar 29 /LastChar 255 /Widths \" + t3.API.PDFObject.convert(r3.metadata.hmtx.widths) + \">>\"), i3(\"endobj\"), r3.isAlreadyPutted = true;\n      }\n    }(e3);\n  }]);\n  var i2 = function(t4) {\n    var e3, n3 = t4.text || \"\", i3 = t4.x, a2 = t4.y, o2 = t4.options || {}, s2 = t4.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = \"\", d2 = 0, p5 = \"\", g2 = h2[l2].encoding;\n    if (h2[l2].encoding !== \"Identity-H\")\n      return { text: n3, x: i3, y: a2, options: o2, mutex: s2 };\n    for (p5 = n3, l2 = u2, Array.isArray(n3) && (p5 = n3[0]), d2 = 0; d2 < p5.length; d2 += 1)\n      h2[l2].metadata.hasOwnProperty(\"cmap\") && (e3 = h2[l2].metadata.cmap.unicode.codeMap[p5[d2].charCodeAt(0)]), e3 || p5[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty(\"Unicode\") ? f2 += p5[d2] : f2 += \"\";\n    var m2 = \"\";\n    return parseInt(l2.slice(1)) < 14 || g2 === \"WinAnsiEncoding\" ? m2 = c2(f2, l2).split(\"\").map(function(t5) {\n      return t5.charCodeAt(0).toString(16);\n    }).join(\"\") : g2 === \"Identity-H\" && (m2 = r2(f2, h2[l2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };\n  };\n  e2.events.push([\"postProcessText\", function(t4) {\n    var e3 = t4.text || \"\", r3 = [], n3 = { text: e3, x: t4.x, y: t4.y, options: t4.options, mutex: t4.mutex };\n    if (Array.isArray(e3)) {\n      var a2 = 0;\n      for (a2 = 0; a2 < e3.length; a2 += 1)\n        Array.isArray(e3[a2]) && e3[a2].length === 3 ? r3.push([i2(Object.assign({}, n3, { text: e3[a2][0] })).text, e3[a2][1], e3[a2][2]]) : r3.push(i2(Object.assign({}, n3, { text: e3[a2] })).text);\n      t4.text = r3;\n    } else\n      t4.text = i2(Object.assign({}, n3, { text: e3 })).text;\n  }]);\n}(E$1), function(t3) {\n  var e2 = function() {\n    return this.internal.vFS === void 0 && (this.internal.vFS = {}), true;\n  };\n  t3.existsFileInVFS = function(t4) {\n    return e2.call(this), this.internal.vFS[t4] !== void 0;\n  }, t3.addFileToVFS = function(t4, r2) {\n    return e2.call(this), this.internal.vFS[t4] = r2, this;\n  }, t3.getFileFromVFS = function(t4) {\n    return e2.call(this), this.internal.vFS[t4] !== void 0 ? this.internal.vFS[t4] : null;\n  };\n}(E$1.API), function(t3) {\n  t3.__bidiEngine__ = t3.prototype.__bidiEngine__ = function(t4) {\n    var r3, n2, i2, a2, o2, s2, c2, u2 = e2, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p5 = [\"(\", \")\", \"(\", \"<\", \">\", \"<\", \"[\", \"]\", \"[\", \"{\", \"}\", \"{\", \"\\xAB\", \"\\xBB\", \"\\xAB\", \"\\u2039\", \"\\u203A\", \"\\u2039\", \"\\u2045\", \"\\u2046\", \"\\u2045\", \"\\u207D\", \"\\u207E\", \"\\u207D\", \"\\u208D\", \"\\u208E\", \"\\u208D\", \"\\u2264\", \"\\u2265\", \"\\u2264\", \"\\u2329\", \"\\u232A\", \"\\u2329\", \"\\uFE59\", \"\\uFE5A\", \"\\uFE59\", \"\\uFE5B\", \"\\uFE5C\", \"\\uFE5B\", \"\\uFE5D\", \"\\uFE5E\", \"\\uFE5D\", \"\\uFE64\", \"\\uFE65\", \"\\uFE64\"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;\n    this.__bidiEngine__ = {};\n    var b2 = function(t5) {\n      var e3 = t5.charCodeAt(), r4 = e3 >> 8, n3 = d2[r4];\n      return n3 !== void 0 ? u2[256 * n3 + (255 & e3)] : r4 === 252 || r4 === 253 ? \"AL\" : g2.test(r4) ? \"L\" : r4 === 8 ? \"R\" : \"N\";\n    }, y2 = function(t5) {\n      for (var e3, r4 = 0; r4 < t5.length; r4++) {\n        if ((e3 = b2(t5.charAt(r4))) === \"L\")\n          return false;\n        if (e3 === \"R\")\n          return true;\n      }\n      return false;\n    }, w2 = function(t5, e3, o3, s3) {\n      var c3, u3, h3, l3, f3 = e3[s3];\n      switch (f3) {\n        case \"L\":\n        case \"R\":\n          m2 = false;\n          break;\n        case \"N\":\n        case \"AN\":\n          break;\n        case \"EN\":\n          m2 && (f3 = \"AN\");\n          break;\n        case \"AL\":\n          m2 = true, f3 = \"R\";\n          break;\n        case \"WS\":\n          f3 = \"N\";\n          break;\n        case \"CS\":\n          s3 < 1 || s3 + 1 >= e3.length || (c3 = o3[s3 - 1]) !== \"EN\" && c3 !== \"AN\" || (u3 = e3[s3 + 1]) !== \"EN\" && u3 !== \"AN\" ? f3 = \"N\" : m2 && (u3 = \"AN\"), f3 = u3 === c3 ? u3 : \"N\";\n          break;\n        case \"ES\":\n          f3 = (c3 = s3 > 0 ? o3[s3 - 1] : \"B\") === \"EN\" && s3 + 1 < e3.length && e3[s3 + 1] === \"EN\" ? \"EN\" : \"N\";\n          break;\n        case \"ET\":\n          if (s3 > 0 && o3[s3 - 1] === \"EN\") {\n            f3 = \"EN\";\n            break;\n          }\n          if (m2) {\n            f3 = \"N\";\n            break;\n          }\n          for (h3 = s3 + 1, l3 = e3.length; h3 < l3 && e3[h3] === \"ET\"; )\n            h3++;\n          f3 = h3 < l3 && e3[h3] === \"EN\" ? \"EN\" : \"N\";\n          break;\n        case \"NSM\":\n          if (i2 && !a2) {\n            for (l3 = e3.length, h3 = s3 + 1; h3 < l3 && e3[h3] === \"NSM\"; )\n              h3++;\n            if (h3 < l3) {\n              var d3 = t5[s3], p6 = d3 >= 1425 && d3 <= 2303 || d3 === 64286;\n              if (c3 = e3[h3], p6 && (c3 === \"R\" || c3 === \"AL\")) {\n                f3 = \"R\";\n                break;\n              }\n            }\n          }\n          f3 = s3 < 1 || (c3 = e3[s3 - 1]) === \"B\" ? \"N\" : o3[s3 - 1];\n          break;\n        case \"B\":\n          m2 = false, r3 = true, f3 = v2;\n          break;\n        case \"S\":\n          n2 = true, f3 = \"N\";\n          break;\n        case \"LRE\":\n        case \"RLE\":\n        case \"LRO\":\n        case \"RLO\":\n        case \"PDF\":\n          m2 = false;\n          break;\n        case \"BN\":\n          f3 = \"N\";\n      }\n      return f3;\n    }, N2 = function(t5, e3, r4) {\n      var n3 = t5.split(\"\");\n      return r4 && L2(n3, r4, { hiLevel: v2 }), n3.reverse(), e3 && e3.reverse(), n3.join(\"\");\n    }, L2 = function(t5, e3, i3) {\n      var a3, o3, s3, c3, u3, d3 = -1, p6 = t5.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];\n      for (m2 = false, r3 = false, n2 = false, o3 = 0; o3 < p6; o3++)\n        L3[o3] = b2(t5[o3]);\n      for (s3 = 0; s3 < p6; s3++) {\n        if (u3 = g3, y3[s3] = w2(t5, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e3[s3] = c3 = N3[g3][5], a3 > 0)\n          if (a3 === 16) {\n            for (o3 = d3; o3 < s3; o3++)\n              e3[o3] = 1;\n            d3 = -1;\n          } else\n            d3 = -1;\n        if (N3[g3][6])\n          d3 === -1 && (d3 = s3);\n        else if (d3 > -1) {\n          for (o3 = d3; o3 < s3; o3++)\n            e3[o3] = c3;\n          d3 = -1;\n        }\n        L3[s3] === \"B\" && (e3[s3] = 0), i3.hiLevel |= c3;\n      }\n      n2 && function(t6, e4, r4) {\n        for (var n3 = 0; n3 < r4; n3++)\n          if (t6[n3] === \"S\") {\n            e4[n3] = v2;\n            for (var i4 = n3 - 1; i4 >= 0 && t6[i4] === \"WS\"; i4--)\n              e4[i4] = v2;\n          }\n      }(L3, e3, p6);\n    }, A2 = function(t5, e3, n3, i3, a3) {\n      if (!(a3.hiLevel < t5)) {\n        if (t5 === 1 && v2 === 1 && !r3)\n          return e3.reverse(), void (n3 && n3.reverse());\n        for (var o3, s3, c3, u3, h3 = e3.length, l3 = 0; l3 < h3; ) {\n          if (i3[l3] >= t5) {\n            for (c3 = l3 + 1; c3 < h3 && i3[c3] >= t5; )\n              c3++;\n            for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--)\n              o3 = e3[u3], e3[u3] = e3[s3], e3[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);\n            l3 = c3;\n          }\n          l3++;\n        }\n      }\n    }, x2 = function(t5, e3, r4) {\n      var n3 = t5.split(\"\"), i3 = { hiLevel: v2 };\n      return r4 || (r4 = []), L2(n3, r4, i3), function(t6, e4, r5) {\n        if (r5.hiLevel !== 0 && c2)\n          for (var n4, i4 = 0; i4 < t6.length; i4++)\n            e4[i4] === 1 && (n4 = p5.indexOf(t6[i4])) >= 0 && (t6[i4] = p5[n4 + 1]);\n      }(n3, r4, i3), A2(2, n3, e3, r4, i3), A2(1, n3, e3, r4, i3), n3.join(\"\");\n    };\n    return this.__bidiEngine__.doBidiReorder = function(t5, e3, r4) {\n      if (function(t6, e4) {\n        if (e4)\n          for (var r5 = 0; r5 < t6.length; r5++)\n            e4[r5] = r5;\n        a2 === void 0 && (a2 = y2(t6)), s2 === void 0 && (s2 = y2(t6));\n      }(t5, e3), i2 || !o2 || s2)\n        if (i2 && o2 && a2 ^ s2)\n          v2 = a2 ? 1 : 0, t5 = N2(t5, e3, r4);\n        else if (!i2 && o2 && s2)\n          v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);\n        else if (!i2 || a2 || o2 || s2) {\n          if (i2 && !o2 && a2 ^ s2)\n            t5 = N2(t5, e3), a2 ? (v2 = 0, t5 = x2(t5, e3, r4)) : (v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3));\n          else if (i2 && a2 && !o2 && s2)\n            v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);\n          else if (!i2 && !o2 && a2 ^ s2) {\n            var n3 = c2;\n            a2 ? (v2 = 1, t5 = x2(t5, e3, r4), v2 = 0, c2 = false, t5 = x2(t5, e3, r4), c2 = n3) : (v2 = 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3), v2 = 1, c2 = false, t5 = x2(t5, e3, r4), c2 = n3, t5 = N2(t5, e3));\n          }\n        } else\n          v2 = 0, t5 = x2(t5, e3, r4);\n      else\n        v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4);\n      return t5;\n    }, this.__bidiEngine__.setOptions = function(t5) {\n      t5 && (i2 = t5.isInputVisual, o2 = t5.isOutputVisual, a2 = t5.isInputRtl, s2 = t5.isOutputRtl, c2 = t5.isSymmetricSwapping);\n    }, this.__bidiEngine__.setOptions(t4), this.__bidiEngine__;\n  };\n  var e2 = [\"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"S\", \"B\", \"S\", \"WS\", \"B\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"B\", \"B\", \"B\", \"S\", \"WS\", \"N\", \"N\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ES\", \"CS\", \"ES\", \"CS\", \"CS\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"CS\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"B\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"CS\", \"N\", \"ET\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"L\", \"N\", \"N\", \"BN\", \"N\", \"N\", \"ET\", \"ET\", \"EN\", \"EN\", \"N\", \"L\", \"N\", \"N\", \"N\", \"EN\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ET\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"R\", \"NSM\", \"R\", \"NSM\", \"NSM\", \"R\", \"NSM\", \"NSM\", \"R\", \"NSM\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"N\", \"N\", \"N\", \"N\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"N\", \"N\", \"AL\", \"ET\", \"ET\", \"AL\", \"CS\", \"AL\", \"N\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"AN\", \"ET\", \"AN\", \"AN\", \"AL\", \"AL\", \"AL\", \"NSM\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AN\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"AL\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"N\", \"AL\", \"AL\", \"NSM\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"N\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"AL\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"R\", \"R\", \"N\", \"N\", \"N\", \"N\", \"R\", \"N\", \"N\", \"N\", \"N\", \"N\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"WS\", \"BN\", \"BN\", \"BN\", \"L\", \"R\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"WS\", \"B\", \"LRE\", \"RLE\", \"PDF\", \"LRO\", \"RLO\", \"CS\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"CS\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"WS\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"N\", \"LRI\", \"RLI\", \"FSI\", \"PDI\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"BN\", \"EN\", \"L\", \"N\", \"N\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"ES\", \"ES\", \"N\", \"N\", \"N\", \"L\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"ES\", \"ES\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"R\", \"NSM\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"ES\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"N\", \"R\", \"N\", \"R\", \"R\", \"N\", \"R\", \"R\", \"N\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"NSM\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"CS\", \"N\", \"CS\", \"N\", \"N\", \"CS\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ET\", \"N\", \"N\", \"ES\", \"ES\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"N\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"AL\", \"N\", \"N\", \"BN\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"ES\", \"CS\", \"ES\", \"CS\", \"CS\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"EN\", \"CS\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"N\", \"N\", \"L\", \"L\", \"L\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"ET\", \"ET\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\"], r2 = new t3.__bidiEngine__({ isInputVisual: true });\n  t3.API.events.push([\"postProcessText\", function(t4) {\n    var e3 = t4.text, n2 = (t4.x, t4.y, t4.options || {}), i2 = (t4.mutex, n2.lang, []);\n    if (n2.isInputVisual = typeof n2.isInputVisual != \"boolean\" || n2.isInputVisual, r2.setOptions(n2), Object.prototype.toString.call(e3) === \"[object Array]\") {\n      var a2 = 0;\n      for (i2 = [], a2 = 0; a2 < e3.length; a2 += 1)\n        Object.prototype.toString.call(e3[a2]) === \"[object Array]\" ? i2.push([r2.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i2.push([r2.doBidiReorder(e3[a2])]);\n      t4.text = i2;\n    } else\n      t4.text = r2.doBidiReorder(e3);\n    r2.setOptions({ isInputVisual: true });\n  }]);\n}(E$1), E$1.API.TTFFont = function() {\n  function t3(t4) {\n    var e2;\n    if (this.rawData = t4, e2 = this.contents = new ne(t4), this.contents.pos = 4, e2.readString(4) === \"ttcf\")\n      throw new Error(\"TTCF not supported.\");\n    e2.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();\n  }\n  return t3.open = function(e2) {\n    return new t3(e2);\n  }, t3.prototype.parse = function() {\n    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];\n  }, t3.prototype.registerTTF = function() {\n    var t4, e2, r2, n2, i2;\n    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {\n      var e3, r3, n3, i3;\n      for (i3 = [], e3 = 0, r3 = (n3 = this.bbox).length; e3 < r3; e3++)\n        t4 = n3[e3], i3.push(Math.round(t4 * this.scaleFactor));\n      return i3;\n    }.call(this), this.stemV = 0, this.post.exists ? (r2 = 255 & (n2 = this.post.italic_angle), (32768 & (e2 = n2 >> 16)) != 0 && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + \".\" + r2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (i2 = this.familyClass) === 1 || i2 === 2 || i2 === 3 || i2 === 4 || i2 === 5 || i2 === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)\n      throw new Error(\"No unicode cmap for font\");\n  }, t3.prototype.characterToGlyph = function(t4) {\n    var e2;\n    return ((e2 = this.cmap.unicode) != null ? e2.codeMap[t4] : void 0) || 0;\n  }, t3.prototype.widthOfGlyph = function(t4) {\n    var e2;\n    return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t4).advance * e2;\n  }, t3.prototype.widthOfString = function(t4, e2, r2) {\n    var n2, i2, a2, o2;\n    for (a2 = 0, i2 = 0, o2 = (t4 = \"\" + t4).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2)\n      n2 = t4.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r2 * (1e3 / e2) || 0;\n    return a2 * (e2 / 1e3);\n  }, t3.prototype.lineHeight = function(t4, e2) {\n    var r2;\n    return e2 == null && (e2 = false), r2 = e2 ? this.lineGap : 0, (this.ascender + r2 - this.decender) / 1e3 * t4;\n  }, t3;\n}();\nvar re, ne = function() {\n  function t3(t4) {\n    this.data = t4 != null ? t4 : [], this.pos = 0, this.length = this.data.length;\n  }\n  return t3.prototype.readByte = function() {\n    return this.data[this.pos++];\n  }, t3.prototype.writeByte = function(t4) {\n    return this.data[this.pos++] = t4;\n  }, t3.prototype.readUInt32 = function() {\n    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();\n  }, t3.prototype.writeUInt32 = function(t4) {\n    return this.writeByte(t4 >>> 24 & 255), this.writeByte(t4 >> 16 & 255), this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);\n  }, t3.prototype.readInt32 = function() {\n    var t4;\n    return (t4 = this.readUInt32()) >= 2147483648 ? t4 - 4294967296 : t4;\n  }, t3.prototype.writeInt32 = function(t4) {\n    return t4 < 0 && (t4 += 4294967296), this.writeUInt32(t4);\n  }, t3.prototype.readUInt16 = function() {\n    return this.readByte() << 8 | this.readByte();\n  }, t3.prototype.writeUInt16 = function(t4) {\n    return this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);\n  }, t3.prototype.readInt16 = function() {\n    var t4;\n    return (t4 = this.readUInt16()) >= 32768 ? t4 - 65536 : t4;\n  }, t3.prototype.writeInt16 = function(t4) {\n    return t4 < 0 && (t4 += 65536), this.writeUInt16(t4);\n  }, t3.prototype.readString = function(t4) {\n    var e2, r2;\n    for (r2 = [], e2 = 0; 0 <= t4 ? e2 < t4 : e2 > t4; e2 = 0 <= t4 ? ++e2 : --e2)\n      r2[e2] = String.fromCharCode(this.readByte());\n    return r2.join(\"\");\n  }, t3.prototype.writeString = function(t4) {\n    var e2, r2, n2;\n    for (n2 = [], e2 = 0, r2 = t4.length; 0 <= r2 ? e2 < r2 : e2 > r2; e2 = 0 <= r2 ? ++e2 : --e2)\n      n2.push(this.writeByte(t4.charCodeAt(e2)));\n    return n2;\n  }, t3.prototype.readShort = function() {\n    return this.readInt16();\n  }, t3.prototype.writeShort = function(t4) {\n    return this.writeInt16(t4);\n  }, t3.prototype.readLongLong = function() {\n    var t4, e2, r2, n2, i2, a2, o2, s2;\n    return t4 = this.readByte(), e2 = this.readByte(), r2 = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t4 ? -1 * (72057594037927940 * (255 ^ t4) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ r2) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t4 + 281474976710656 * e2 + 1099511627776 * r2 + 4294967296 * n2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;\n  }, t3.prototype.writeLongLong = function(t4) {\n    var e2, r2;\n    return e2 = Math.floor(t4 / 4294967296), r2 = 4294967295 & t4, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(r2 >> 24 & 255), this.writeByte(r2 >> 16 & 255), this.writeByte(r2 >> 8 & 255), this.writeByte(255 & r2);\n  }, t3.prototype.readInt = function() {\n    return this.readInt32();\n  }, t3.prototype.writeInt = function(t4) {\n    return this.writeInt32(t4);\n  }, t3.prototype.read = function(t4) {\n    var e2, r2;\n    for (e2 = [], r2 = 0; 0 <= t4 ? r2 < t4 : r2 > t4; r2 = 0 <= t4 ? ++r2 : --r2)\n      e2.push(this.readByte());\n    return e2;\n  }, t3.prototype.write = function(t4) {\n    var e2, r2, n2, i2;\n    for (i2 = [], r2 = 0, n2 = t4.length; r2 < n2; r2++)\n      e2 = t4[r2], i2.push(this.writeByte(e2));\n    return i2;\n  }, t3;\n}(), ie = function() {\n  var t3;\n  function e2(t4) {\n    var e3, r2, n2;\n    for (this.scalarType = t4.readInt(), this.tableCount = t4.readShort(), this.searchRange = t4.readShort(), this.entrySelector = t4.readShort(), this.rangeShift = t4.readShort(), this.tables = {}, r2 = 0, n2 = this.tableCount; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2)\n      e3 = { tag: t4.readString(4), checksum: t4.readInt(), offset: t4.readInt(), length: t4.readInt() }, this.tables[e3.tag] = e3;\n  }\n  return e2.prototype.encode = function(e3) {\n    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5;\n    for (p5 in f2 = Object.keys(e3).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i2 = 16 * f2, c2 = n2.pos + i2, o2 = null, d2 = [], e3)\n      for (l2 = e3[p5], n2.writeString(p5), n2.writeInt(t3(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), p5 === \"head\" && (o2 = c2), c2 += l2.length; c2 % 4; )\n        d2.push(0), c2++;\n    return n2.write(d2), r2 = 2981146554 - t3(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r2), n2.data;\n  }, t3 = function(t4) {\n    var e3, r2, n2, i2;\n    for (t4 = ve.call(t4); t4.length % 4; )\n      t4.push(0);\n    for (n2 = new ne(t4), r2 = 0, e3 = 0, i2 = t4.length; e3 < i2; e3 = e3 += 4)\n      r2 += n2.readUInt32();\n    return 4294967295 & r2;\n  }, e2;\n}(), ae = {}.hasOwnProperty, oe = function(t3, e2) {\n  for (var r2 in e2)\n    ae.call(e2, r2) && (t3[r2] = e2[r2]);\n  function n2() {\n    this.constructor = t3;\n  }\n  return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;\n};\nre = function() {\n  function t3(t4) {\n    var e2;\n    this.file = t4, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));\n  }\n  return t3.prototype.parse = function() {\n  }, t3.prototype.encode = function() {\n  }, t3.prototype.raw = function() {\n    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;\n  }, t3;\n}();\nvar se = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"head\", e2.prototype.parse = function(t4) {\n    return t4.pos = this.offset, this.version = t4.readInt(), this.revision = t4.readInt(), this.checkSumAdjustment = t4.readInt(), this.magicNumber = t4.readInt(), this.flags = t4.readShort(), this.unitsPerEm = t4.readShort(), this.created = t4.readLongLong(), this.modified = t4.readLongLong(), this.xMin = t4.readShort(), this.yMin = t4.readShort(), this.xMax = t4.readShort(), this.yMax = t4.readShort(), this.macStyle = t4.readShort(), this.lowestRecPPEM = t4.readShort(), this.fontDirectionHint = t4.readShort(), this.indexToLocFormat = t4.readShort(), this.glyphDataFormat = t4.readShort();\n  }, e2.prototype.encode = function(t4) {\n    var e3;\n    return (e3 = new ne()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t4), e3.writeShort(this.glyphDataFormat), e3.data;\n  }, e2;\n}(), ce = function() {\n  function t3(t4, e2) {\n    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2, v2, b2;\n    switch (this.platformID = t4.readUInt16(), this.encodingID = t4.readShort(), this.offset = e2 + t4.readInt(), h2 = t4.pos, t4.pos = this.offset, this.format = t4.readUInt16(), this.length = t4.readUInt16(), this.language = t4.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {\n      case 0:\n        for (s2 = 0; s2 < 256; ++s2)\n          this.codeMap[s2] = t4.readByte();\n        break;\n      case 4:\n        for (f2 = t4.readUInt16(), l2 = f2 / 2, t4.pos += 6, i2 = function() {\n          var e3, r3;\n          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)\n            r3.push(t4.readUInt16());\n          return r3;\n        }(), t4.pos += 2, p5 = function() {\n          var e3, r3;\n          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)\n            r3.push(t4.readUInt16());\n          return r3;\n        }(), c2 = function() {\n          var e3, r3;\n          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)\n            r3.push(t4.readUInt16());\n          return r3;\n        }(), u2 = function() {\n          var e3, r3;\n          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)\n            r3.push(t4.readUInt16());\n          return r3;\n        }(), n2 = (this.length - t4.pos + this.offset) / 2, o2 = function() {\n          var e3, r3;\n          for (r3 = [], s2 = e3 = 0; 0 <= n2 ? e3 < n2 : e3 > n2; s2 = 0 <= n2 ? ++e3 : --e3)\n            r3.push(t4.readUInt16());\n          return r3;\n        }(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2)\n          for (g2 = i2[s2], r2 = v2 = d2 = p5[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r2 = d2 <= g2 ? ++v2 : --v2)\n            u2[s2] === 0 ? a2 = r2 + c2[s2] : (a2 = o2[u2[s2] / 2 + (r2 - d2) - (l2 - s2)] || 0) !== 0 && (a2 += c2[s2]), this.codeMap[r2] = 65535 & a2;\n    }\n    t4.pos = h2;\n  }\n  return t3.encode = function(t4, e2) {\n    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B3, M2, E2, q2, D2, R2, T2, z2, U2, H4, W2, V2, G2, Y2;\n    switch (I2 = new ne(), a2 = Object.keys(t4).sort(function(t5, e3) {\n      return t5 - e3;\n    }), e2) {\n      case \"macroman\":\n        for (p5 = 0, g2 = function() {\n          var t5 = [];\n          for (d2 = 0; d2 < 256; ++d2)\n            t5.push(0);\n          return t5;\n        }(), v2 = { 0: 0 }, i2 = {}, F2 = 0, B3 = a2.length; F2 < B3; F2++)\n          v2[W2 = t4[n2 = a2[F2]]] == null && (v2[W2] = ++p5), i2[n2] = { old: t4[n2], new: v2[t4[n2]] }, g2[n2] = v2[t4[n2]];\n        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i2, subtable: I2.data, maxGlyphID: p5 + 1 };\n      case \"unicode\":\n        for (P2 = [], h2 = [], b2 = 0, v2 = {}, r2 = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++)\n          v2[w2 = t4[n2 = a2[C2]]] == null && (v2[w2] = ++b2), r2[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, m2 != null && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;\n        for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {\n          if (_2 = P2[d2], u2 = h2[d2], _2 === 65535) {\n            s2.push(0), N2.push(0);\n            break;\n          }\n          if (_2 - (k2 = r2[_2].new) >= 32768)\n            for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2)\n              f2.push(r2[n2].new);\n          else\n            s2.push(k2 - _2), N2.push(0);\n        }\n        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), U2 = 0, q2 = h2.length; U2 < q2; U2++)\n          n2 = h2[U2], I2.writeUInt16(n2);\n        for (I2.writeUInt16(0), H4 = 0, D2 = P2.length; H4 < D2; H4++)\n          n2 = P2[H4], I2.writeUInt16(n2);\n        for (V2 = 0, R2 = s2.length; V2 < R2; V2++)\n          o2 = s2[V2], I2.writeUInt16(o2);\n        for (G2 = 0, T2 = N2.length; G2 < T2; G2++)\n          y2 = N2[G2], I2.writeUInt16(y2);\n        for (Y2 = 0, z2 = f2.length; Y2 < z2; Y2++)\n          p5 = f2[Y2], I2.writeUInt16(p5);\n        return { charMap: r2, subtable: I2.data, maxGlyphID: b2 + 1 };\n    }\n  }, t3;\n}(), ue = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"cmap\", e2.prototype.parse = function(t4) {\n    var e3, r2, n2;\n    for (t4.pos = this.offset, this.version = t4.readUInt16(), n2 = t4.readUInt16(), this.tables = [], this.unicode = null, r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2)\n      e3 = new ce(t4, this.offset), this.tables.push(e3), e3.isUnicode && this.unicode == null && (this.unicode = e3);\n    return true;\n  }, e2.encode = function(t4, e3) {\n    var r2, n2;\n    return e3 == null && (e3 = \"macroman\"), r2 = ce.encode(t4, e3), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r2.table = n2.data.concat(r2.subtable), r2;\n  }, e2;\n}(), he = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"hhea\", e2.prototype.parse = function(t4) {\n    return t4.pos = this.offset, this.version = t4.readInt(), this.ascender = t4.readShort(), this.decender = t4.readShort(), this.lineGap = t4.readShort(), this.advanceWidthMax = t4.readShort(), this.minLeftSideBearing = t4.readShort(), this.minRightSideBearing = t4.readShort(), this.xMaxExtent = t4.readShort(), this.caretSlopeRise = t4.readShort(), this.caretSlopeRun = t4.readShort(), this.caretOffset = t4.readShort(), t4.pos += 8, this.metricDataFormat = t4.readShort(), this.numberOfMetrics = t4.readUInt16();\n  }, e2;\n}(), le = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"OS/2\", e2.prototype.parse = function(t4) {\n    if (t4.pos = this.offset, this.version = t4.readUInt16(), this.averageCharWidth = t4.readShort(), this.weightClass = t4.readUInt16(), this.widthClass = t4.readUInt16(), this.type = t4.readShort(), this.ySubscriptXSize = t4.readShort(), this.ySubscriptYSize = t4.readShort(), this.ySubscriptXOffset = t4.readShort(), this.ySubscriptYOffset = t4.readShort(), this.ySuperscriptXSize = t4.readShort(), this.ySuperscriptYSize = t4.readShort(), this.ySuperscriptXOffset = t4.readShort(), this.ySuperscriptYOffset = t4.readShort(), this.yStrikeoutSize = t4.readShort(), this.yStrikeoutPosition = t4.readShort(), this.familyClass = t4.readShort(), this.panose = function() {\n      var e3, r2;\n      for (r2 = [], e3 = 0; e3 < 10; ++e3)\n        r2.push(t4.readByte());\n      return r2;\n    }(), this.charRange = function() {\n      var e3, r2;\n      for (r2 = [], e3 = 0; e3 < 4; ++e3)\n        r2.push(t4.readInt());\n      return r2;\n    }(), this.vendorID = t4.readString(4), this.selection = t4.readShort(), this.firstCharIndex = t4.readShort(), this.lastCharIndex = t4.readShort(), this.version > 0 && (this.ascent = t4.readShort(), this.descent = t4.readShort(), this.lineGap = t4.readShort(), this.winAscent = t4.readShort(), this.winDescent = t4.readShort(), this.codePageRange = function() {\n      var e3, r2;\n      for (r2 = [], e3 = 0; e3 < 2; e3 = ++e3)\n        r2.push(t4.readInt());\n      return r2;\n    }(), this.version > 1))\n      return this.xHeight = t4.readShort(), this.capHeight = t4.readShort(), this.defaultChar = t4.readShort(), this.breakChar = t4.readShort(), this.maxContext = t4.readShort();\n  }, e2;\n}(), fe = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"post\", e2.prototype.parse = function(t4) {\n    var e3, r2, n2;\n    switch (t4.pos = this.offset, this.format = t4.readInt(), this.italicAngle = t4.readInt(), this.underlinePosition = t4.readShort(), this.underlineThickness = t4.readShort(), this.isFixedPitch = t4.readInt(), this.minMemType42 = t4.readInt(), this.maxMemType42 = t4.readInt(), this.minMemType1 = t4.readInt(), this.maxMemType1 = t4.readInt(), this.format) {\n      case 65536:\n        break;\n      case 131072:\n        var i2;\n        for (r2 = t4.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r2 ? i2 < r2 : i2 > r2; i2 = 0 <= r2 ? ++i2 : --i2)\n          this.glyphNameIndex.push(t4.readUInt16());\n        for (this.names = [], n2 = []; t4.pos < this.offset + this.length; )\n          e3 = t4.readByte(), n2.push(this.names.push(t4.readString(e3)));\n        return n2;\n      case 151552:\n        return r2 = t4.readUInt16(), this.offsets = t4.read(r2);\n      case 196608:\n        break;\n      case 262144:\n        return this.map = function() {\n          var e4, r3, n3;\n          for (n3 = [], i2 = e4 = 0, r3 = this.file.maxp.numGlyphs; 0 <= r3 ? e4 < r3 : e4 > r3; i2 = 0 <= r3 ? ++e4 : --e4)\n            n3.push(t4.readUInt32());\n          return n3;\n        }.call(this);\n    }\n  }, e2;\n}(), de = function(t3, e2) {\n  this.raw = t3, this.length = t3.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;\n}, pe = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"name\", e2.prototype.parse = function(t4) {\n    var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2, l2;\n    for (t4.pos = this.offset, t4.readShort(), e3 = t4.readShort(), o2 = t4.readShort(), r2 = [], i2 = 0; 0 <= e3 ? i2 < e3 : i2 > e3; i2 = 0 <= e3 ? ++i2 : --i2)\n      r2.push({ platformID: t4.readShort(), encodingID: t4.readShort(), languageID: t4.readShort(), nameID: t4.readShort(), length: t4.readShort(), offset: this.offset + o2 + t4.readShort() });\n    for (s2 = {}, i2 = u2 = 0, h2 = r2.length; u2 < h2; i2 = ++u2)\n      n2 = r2[i2], t4.pos = n2.offset, c2 = t4.readString(n2.length), a2 = new de(c2, n2), s2[l2 = n2.nameID] == null && (s2[l2] = []), s2[n2.nameID].push(a2);\n    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];\n    try {\n      this.postscriptName = s2[6][0].raw.replace(/[\\x00-\\x19\\x80-\\xff]/g, \"\");\n    } catch (t5) {\n      this.postscriptName = s2[4][0].raw.replace(/[\\x00-\\x19\\x80-\\xff]/g, \"\");\n    }\n    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];\n  }, e2;\n}(), ge = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"maxp\", e2.prototype.parse = function(t4) {\n    return t4.pos = this.offset, this.version = t4.readInt(), this.numGlyphs = t4.readUInt16(), this.maxPoints = t4.readUInt16(), this.maxContours = t4.readUInt16(), this.maxCompositePoints = t4.readUInt16(), this.maxComponentContours = t4.readUInt16(), this.maxZones = t4.readUInt16(), this.maxTwilightPoints = t4.readUInt16(), this.maxStorage = t4.readUInt16(), this.maxFunctionDefs = t4.readUInt16(), this.maxInstructionDefs = t4.readUInt16(), this.maxStackElements = t4.readUInt16(), this.maxSizeOfInstructions = t4.readUInt16(), this.maxComponentElements = t4.readUInt16(), this.maxComponentDepth = t4.readUInt16();\n  }, e2;\n}(), me = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"hmtx\", e2.prototype.parse = function(t4) {\n    var e3, r2, n2, i2, a2, o2, s2;\n    for (t4.pos = this.offset, this.metrics = [], e3 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e3 < o2 : e3 > o2; e3 = 0 <= o2 ? ++e3 : --e3)\n      this.metrics.push({ advance: t4.readUInt16(), lsb: t4.readInt16() });\n    for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {\n      var r3, i3;\n      for (i3 = [], e3 = r3 = 0; 0 <= n2 ? r3 < n2 : r3 > n2; e3 = 0 <= n2 ? ++r3 : --r3)\n        i3.push(t4.readInt16());\n      return i3;\n    }(), this.widths = function() {\n      var t5, e4, r3, n3;\n      for (n3 = [], t5 = 0, e4 = (r3 = this.metrics).length; t5 < e4; t5++)\n        i2 = r3[t5], n3.push(i2.advance);\n      return n3;\n    }.call(this), r2 = this.widths[this.widths.length - 1], s2 = [], e3 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e3 = 0 <= n2 ? ++a2 : --a2)\n      s2.push(this.widths.push(r2));\n    return s2;\n  }, e2.prototype.forGlyph = function(t4) {\n    return t4 in this.metrics ? this.metrics[t4] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t4 - this.metrics.length] };\n  }, e2;\n}(), ve = [].slice, be = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"glyf\", e2.prototype.parse = function() {\n    return this.cache = {};\n  }, e2.prototype.glyphFor = function(t4) {\n    var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2;\n    return t4 in this.cache ? this.cache[t4] : (i2 = this.file.loca, e3 = this.file.contents, r2 = i2.indexOf(t4), (n2 = i2.lengthOf(t4)) === 0 ? this.cache[t4] = null : (e3.pos = this.offset + r2, a2 = (o2 = new ne(e3.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t4] = a2 === -1 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t4]));\n  }, e2.prototype.encode = function(t4, e3, r2) {\n    var n2, i2, a2, o2, s2;\n    for (a2 = [], i2 = [], o2 = 0, s2 = e3.length; o2 < s2; o2++)\n      n2 = t4[e3[o2]], i2.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r2)));\n    return i2.push(a2.length), { table: a2, offsets: i2 };\n  }, e2;\n}(), ye = function() {\n  function t3(t4, e2, r2, n2, i2, a2) {\n    this.raw = t4, this.numberOfContours = e2, this.xMin = r2, this.yMin = n2, this.xMax = i2, this.yMax = a2, this.compound = false;\n  }\n  return t3.prototype.encode = function() {\n    return this.raw.data;\n  }, t3;\n}(), we = function() {\n  function t3(t4, e2, r2, n2, i2) {\n    var a2, o2;\n    for (this.raw = t4, this.xMin = e2, this.yMin = r2, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; )\n      a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);\n  }\n  return t3.prototype.encode = function() {\n    var t4, e2, r2;\n    for (e2 = new ne(ve.call(this.raw.data)), t4 = 0, r2 = this.glyphIDs.length; t4 < r2; ++t4)\n      e2.pos = this.glyphOffsets[t4];\n    return e2.data;\n  }, t3;\n}(), Ne = function(t3) {\n  function e2() {\n    return e2.__super__.constructor.apply(this, arguments);\n  }\n  return oe(e2, re), e2.prototype.tag = \"loca\", e2.prototype.parse = function(t4) {\n    var e3, r2;\n    return t4.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = e3 === 0 ? function() {\n      var e4, n2;\n      for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 2)\n        n2.push(2 * t4.readUInt16());\n      return n2;\n    }.call(this) : function() {\n      var e4, n2;\n      for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 4)\n        n2.push(t4.readUInt32());\n      return n2;\n    }.call(this);\n  }, e2.prototype.indexOf = function(t4) {\n    return this.offsets[t4];\n  }, e2.prototype.lengthOf = function(t4) {\n    return this.offsets[t4 + 1] - this.offsets[t4];\n  }, e2.prototype.encode = function(t4, e3) {\n    for (var r2 = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a2 = 0; a2 < r2.length; ++a2)\n      if (r2[a2] = n2, i2 < e3.length && e3[i2] == a2) {\n        ++i2, r2[a2] = n2;\n        var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;\n        s2 > 0 && (n2 += s2);\n      }\n    for (var c2 = new Array(4 * r2.length), u2 = 0; u2 < r2.length; ++u2)\n      c2[4 * u2 + 3] = 255 & r2[u2], c2[4 * u2 + 2] = (65280 & r2[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r2[u2]) >> 16, c2[4 * u2] = (4278190080 & r2[u2]) >> 24;\n    return c2;\n  }, e2;\n}(), Le = function() {\n  function t3(t4) {\n    this.font = t4, this.subset = {}, this.unicodes = {}, this.next = 33;\n  }\n  return t3.prototype.generateCmap = function() {\n    var t4, e2, r2, n2, i2;\n    for (e2 in n2 = this.font.cmap.tables[0].codeMap, t4 = {}, i2 = this.subset)\n      r2 = i2[e2], t4[e2] = n2[r2];\n    return t4;\n  }, t3.prototype.glyphsFor = function(t4) {\n    var e2, r2, n2, i2, a2, o2, s2;\n    for (n2 = {}, a2 = 0, o2 = t4.length; a2 < o2; a2++)\n      n2[i2 = t4[a2]] = this.font.glyf.glyphFor(i2);\n    for (i2 in e2 = [], n2)\n      ((r2 = n2[i2]) != null ? r2.compound : void 0) && e2.push.apply(e2, r2.glyphIDs);\n    if (e2.length > 0)\n      for (i2 in s2 = this.glyphsFor(e2))\n        r2 = s2[i2], n2[i2] = r2;\n    return n2;\n  }, t3.prototype.encode = function(t4, e2) {\n    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p5, g2, m2;\n    for (n2 in r2 = ue.encode(this.generateCmap(), \"unicode\"), a2 = this.glyphsFor(t4), f2 = { 0: 0 }, m2 = r2.charMap)\n      f2[(s2 = m2[n2]).old] = s2.new;\n    for (d2 in l2 = r2.maxGlyphID, a2)\n      d2 in f2 || (f2[d2] = l2++);\n    return u2 = function(t5) {\n      var e3, r3;\n      for (e3 in r3 = {}, t5)\n        r3[t5[e3]] = e3;\n      return r3;\n    }(f2), h2 = Object.keys(u2).sort(function(t5, e3) {\n      return t5 - e3;\n    }), p5 = function() {\n      var t5, e3, r3;\n      for (r3 = [], t5 = 0, e3 = h2.length; t5 < e3; t5++)\n        o2 = h2[t5], r3.push(u2[o2]);\n      return r3;\n    }(), i2 = this.font.glyf.encode(a2, p5, f2), c2 = this.font.loca.encode(i2.offsets, p5), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2[\"OS/2\"] = this.font.os2.raw()), this.font.directory.encode(g2);\n  }, t3;\n}();\nE$1.API.PDFObject = function() {\n  var t3;\n  function e2() {\n  }\n  return t3 = function(t4, e3) {\n    return (Array(e3 + 1).join(\"0\") + t4).slice(-e3);\n  }, e2.convert = function(r2) {\n    var n2, i2, a2, o2;\n    if (Array.isArray(r2))\n      return \"[\" + function() {\n        var t4, i3, a3;\n        for (a3 = [], t4 = 0, i3 = r2.length; t4 < i3; t4++)\n          n2 = r2[t4], a3.push(e2.convert(n2));\n        return a3;\n      }().join(\" \") + \"]\";\n    if (typeof r2 == \"string\")\n      return \"/\" + r2;\n    if (r2 != null ? r2.isString : void 0)\n      return \"(\" + r2 + \")\";\n    if (r2 instanceof Date)\n      return \"(D:\" + t3(r2.getUTCFullYear(), 4) + t3(r2.getUTCMonth(), 2) + t3(r2.getUTCDate(), 2) + t3(r2.getUTCHours(), 2) + t3(r2.getUTCMinutes(), 2) + t3(r2.getUTCSeconds(), 2) + \"Z)\";\n    if ({}.toString.call(r2) === \"[object Object]\") {\n      for (i2 in a2 = [\"<<\"], r2)\n        o2 = r2[i2], a2.push(\"/\" + i2 + \" \" + e2.convert(o2));\n      return a2.push(\">>\"), a2.join(\"\\n\");\n    }\n    return \"\" + r2;\n  }, e2;\n}();\nconst _sfc_main$w = {\n  name: \"ol-control-printdialog\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_PrintDialog, props, context);\n    control.value.on([\"print\", \"error\"], function(e2) {\n      if (e2.image) {\n        if (e2.pdf) {\n          var pdf = new E$1({\n            orientation: e2.print.orientation,\n            unit: e2.print.unit,\n            format: e2.print.size\n          });\n          pdf.addImage(e2.image, \"JPEG\", e2.print.position[0], e2.print.position[0], e2.print.imageWidth, e2.print.imageHeight);\n          pdf.save(e2.print.legend ? \"legend.pdf\" : \"map.pdf\");\n        } else {\n          e2.canvas.toBlob(function(blob) {\n            var name = (e2.print.legend ? \"legend.\" : \"map.\") + e2.imageType.replace(\"image/\", \"\");\n            FileSaver_min.exports.saveAs(blob, name);\n          }, e2.imageType, e2.quality);\n        }\n      } else {\n        console.warn(\"No canvas to export\");\n      }\n    });\n    return {\n      control\n    };\n  },\n  props: {\n    lang: {\n      type: String\n    }\n  }\n};\nfunction _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar PrintDialog = /* @__PURE__ */ _export_sfc(_sfc_main$w, [[\"render\", _sfc_render$w]]);\nvar ol_control_VideoRecorder = function(options) {\n  if (!options)\n    options = {};\n  var element = ol_ext_element.create(\"DIV\", {\n    className: (options.className || \"ol-videorec\") + \" ol-unselectable ol-control\"\n  });\n  ol_ext_element.create(\"BUTTON\", {\n    type: \"button\",\n    className: \"ol-start\",\n    title: \"start\",\n    click: function() {\n      this.start();\n    }.bind(this),\n    parent: element\n  });\n  ol_ext_element.create(\"BUTTON\", {\n    type: \"button\",\n    className: \"ol-stop\",\n    title: \"stop\",\n    click: function() {\n      this.stop();\n    }.bind(this),\n    parent: element\n  });\n  ol_ext_element.create(\"BUTTON\", {\n    type: \"button\",\n    className: \"ol-pause\",\n    title: \"pause\",\n    click: function() {\n      this.pause();\n    }.bind(this),\n    parent: element\n  });\n  ol_ext_element.create(\"BUTTON\", {\n    type: \"button\",\n    className: \"ol-resume\",\n    title: \"resume\",\n    click: function() {\n      this.resume();\n    }.bind(this),\n    parent: element\n  });\n  ol_control_Control.call(this, {\n    element,\n    target: options.target\n  });\n  this.set(\"framerate\", 30);\n  this.set(\"videoBitsPerSecond\", 5e6);\n  if (options.videoTarget === \"DIALOG\") {\n    this._dialog = new ol_control_Dialog({\n      className: \"ol-fullscreen-dialog\",\n      target: document.body,\n      closeBox: true\n    });\n    this._videoTarget = this._dialog.getContentElement();\n  } else {\n    this._videoTarget = options.videoTarget;\n  }\n  this._printCtrl = new ol_control_Print({\n    target: ol_ext_element.create(\"DIV\")\n  });\n};\nol_ext_inherits(ol_control_VideoRecorder, ol_control_Control);\nol_control_VideoRecorder.prototype.setMap = function(map) {\n  if (this.getMap()) {\n    this.getMap().removeControl(this._printCtrl);\n    if (this._dialog)\n      this.getMap().removeControl(this._dialog);\n  }\n  ol_control_Control.prototype.setMap.call(this, map);\n  if (this.getMap()) {\n    this.getMap().addControl(this._printCtrl);\n    if (this._dialog)\n      this.getMap().addControl(this._dialog);\n  }\n};\nol_control_VideoRecorder.prototype.start = function() {\n  var print = this._printCtrl;\n  var stop = false;\n  function capture(canvas) {\n    if (stop)\n      return;\n    print.fastPrint({\n      canvas\n    }, capture);\n  }\n  print.fastPrint({}, function(canvas) {\n    var videoStream;\n    try {\n      videoStream = canvas.captureStream(this.get(\"framerate\") || 30);\n    } catch (e2) {\n      this.dispatchEvent({\n        type: \"error\",\n        error: e2\n      });\n      return;\n    }\n    this._mediaRecorder = new MediaRecorder(videoStream, {\n      videoBitsPerSecond: this.get(\"videoBitsPerSecond\") || 5e6\n    });\n    var chunks = [];\n    this._mediaRecorder.ondataavailable = function(e2) {\n      chunks.push(e2.data);\n    };\n    this._mediaRecorder.onstop = function() {\n      stop = true;\n      var blob = new Blob(chunks, { \"type\": \"video/mp4\" });\n      chunks = [];\n      if (this._videoTarget instanceof Element) {\n        var video;\n        if (this._videoTarget.tagName === \"VIDEO\") {\n          video = this._videoTarget;\n        } else {\n          video = this._videoTarget.querySelector(\"video\");\n          if (!video) {\n            video = ol_ext_element.create(\"VIDEO\", {\n              controls: \"\",\n              parent: this._videoTarget\n            });\n          }\n        }\n        if (this._dialog)\n          this._dialog.show();\n        video.src = URL.createObjectURL(blob);\n        this.dispatchEvent({ type: \"stop\", videoURL: video.src });\n      } else {\n        this.dispatchEvent({ type: \"stop\", videoURL: URL.createObjectURL(blob) });\n      }\n    }.bind(this);\n    this._mediaRecorder.onpause = function() {\n      stop = true;\n      this.dispatchEvent({ type: \"pause\" });\n    }.bind(this);\n    this._mediaRecorder.onresume = function() {\n      stop = false;\n      capture(canvas);\n      this.dispatchEvent({ type: \"resume\" });\n    }.bind(this);\n    this._mediaRecorder.onerror = function(e2) {\n      this.dispatchEvent({ type: \"error\", error: e2 });\n    }.bind(this);\n    stop = false;\n    capture(canvas);\n    this._mediaRecorder.start();\n    this.dispatchEvent({ type: \"start\", canvas });\n    this.element.setAttribute(\"data-state\", \"rec\");\n  }.bind(this));\n};\nol_control_VideoRecorder.prototype.stop = function() {\n  if (this._mediaRecorder) {\n    this._mediaRecorder.stop();\n    this._mediaRecorder = null;\n    this.element.setAttribute(\"data-state\", \"inactive\");\n  }\n};\nol_control_VideoRecorder.prototype.pause = function() {\n  if (this._mediaRecorder) {\n    this._mediaRecorder.pause();\n    this.element.setAttribute(\"data-state\", \"pause\");\n  }\n};\nol_control_VideoRecorder.prototype.resume = function() {\n  if (this._mediaRecorder) {\n    this._mediaRecorder.resume();\n    this.element.setAttribute(\"data-state\", \"rec\");\n  }\n};\nconst _sfc_main$v = {\n  name: \"ol-control-videorecorder\",\n  emits: [\"start\", \"stop\"],\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_VideoRecorder, props, context);\n    const { downloadName } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(props);\n    control.value.on(\"start\", (event) => {\n      context.emit(\"start\", event);\n    });\n    control.value.on(\"stop\", (event) => {\n      context.emit(\"stop\", event);\n      FileSaver_min.exports.saveAs(event.videoURL, downloadName.value);\n    });\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String\n    },\n    framerate: {\n      type: Number,\n      default: 30\n    },\n    videoBitsPerSecond: {\n      type: Number,\n      default: 5e6\n    },\n    videoTarget: {\n      type: String\n    },\n    downloadName: {\n      type: String,\n      default: \"mapVideo.mp4\"\n    }\n  }\n};\nfunction _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar VideoRecorderControl = /* @__PURE__ */ _export_sfc(_sfc_main$v, [[\"render\", _sfc_render$v]]);\nvar VectorTileRenderType = {\n  IMAGE: \"image\",\n  HYBRID: \"hybrid\",\n  VECTOR: \"vector\"\n};\nvar __extends$t = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar IMAGE_REPLAYS = {\n  \"image\": [\n    ReplayType.POLYGON,\n    ReplayType.CIRCLE,\n    ReplayType.LINE_STRING,\n    ReplayType.IMAGE,\n    ReplayType.TEXT\n  ],\n  \"hybrid\": [ReplayType.POLYGON, ReplayType.LINE_STRING],\n  \"vector\": []\n};\nvar VECTOR_REPLAYS = {\n  \"hybrid\": [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  \"vector\": [\n    ReplayType.POLYGON,\n    ReplayType.CIRCLE,\n    ReplayType.LINE_STRING,\n    ReplayType.IMAGE,\n    ReplayType.TEXT,\n    ReplayType.DEFAULT\n  ]\n};\nvar CanvasVectorTileLayerRenderer = function(_super) {\n  __extends$t(CanvasVectorTileLayerRenderer2, _super);\n  function CanvasVectorTileLayerRenderer2(layer) {\n    var _this = _super.call(this, layer) || this;\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n    _this.dirty_ = false;\n    _this.renderedLayerRevision_;\n    _this.renderedPixelToCoordinateTransform_ = null;\n    _this.renderedRotation_;\n    _this.tmpTransform_ = create$6();\n    return _this;\n  }\n  CanvasVectorTileLayerRenderer2.prototype.prepareTile = function(tile2, pixelRatio, projection) {\n    var render2;\n    var state = tile2.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile2, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile2)) {\n        render2 = true;\n      }\n    }\n    return render2;\n  };\n  CanvasVectorTileLayerRenderer2.prototype.getTile = function(z2, x2, y2, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var resolution = viewState.resolution;\n    var projection = viewState.projection;\n    var layer = this.getLayer();\n    var tile2 = layer.getSource().getTile(z2, x2, y2, pixelRatio, projection);\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    if (hifi || !tile2.wantedResolution) {\n      tile2.wantedResolution = resolution;\n    }\n    var render2 = this.prepareTile(tile2, pixelRatio, projection);\n    if (render2 && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== VectorTileRenderType.VECTOR) {\n      this.renderTileImage_(tile2, frameState);\n    }\n    return _super.prototype.getTile.call(this, z2, x2, y2, frameState);\n  };\n  CanvasVectorTileLayerRenderer2.prototype.isDrawableTile = function(tile2) {\n    var layer = this.getLayer();\n    return _super.prototype.isDrawableTile.call(this, tile2) && (layer.getRenderMode() === VectorTileRenderType.VECTOR ? getUid(layer) in tile2.executorGroups : tile2.hasContext(layer));\n  };\n  CanvasVectorTileLayerRenderer2.prototype.getTileImage = function(tile2) {\n    return tile2.getImage(this.getLayer());\n  };\n  CanvasVectorTileLayerRenderer2.prototype.prepareFrame = function(frameState) {\n    var layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return _super.prototype.prepareFrame.call(this, frameState);\n  };\n  CanvasVectorTileLayerRenderer2.prototype.updateExecutorGroup_ = function(tile2, pixelRatio, projection) {\n    var layer = this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = layer.getRenderOrder() || null;\n    var resolution = tile2.wantedResolution;\n    var builderState = tile2.getReplayState(layer);\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n    var source = layer.getSource();\n    var declutter = layer.getDeclutter();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);\n    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile2);\n    var layerUid = getUid(layer);\n    delete tile2.hitDetectionImageData[layerUid];\n    tile2.executorGroups[layerUid] = [];\n    if (declutter) {\n      tile2.declutterExecutorGroups[layerUid] = [];\n    }\n    var _loop_1 = function(t4, tt3) {\n      var sourceTile = sourceTiles[t4];\n      if (sourceTile.getState() != TileState.LOADED) {\n        return \"continue\";\n      }\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      var builderExtent = buffer$1(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n      var bufferedExtent = equals$1(sourceTileExtent, sharedExtent) ? null : builderExtent;\n      builderState.dirty = false;\n      var builderGroup = new CanvasBuilderGroup(0, builderExtent, resolution, pixelRatio);\n      var declutterBuilderGroup = declutter ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio) : void 0;\n      var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);\n      var render2 = function(feature3) {\n        var styles;\n        var styleFunction = feature3.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature3, resolution);\n        }\n        if (styles) {\n          var dirty = this.renderFeature(feature3, squaredTolerance, styles, builderGroup, declutterBuilderGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n      var features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {\n        var feature2 = features[i2];\n        if (!bufferedExtent || intersects$1(bufferedExtent, feature2.getGeometry().getExtent())) {\n          render2.call(this_1, feature2);\n        }\n      }\n      var executorGroupInstructions = builderGroup.finish();\n      var replayExtent = layer.getRenderMode() !== VectorTileRenderType.VECTOR && declutter && sourceTiles.length === 1 ? null : sharedExtent;\n      var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n      tile2.executorGroups[layerUid].push(renderingReplayGroup);\n      if (declutterBuilderGroup) {\n        var declutterExecutorGroup = new CanvasExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());\n        tile2.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    };\n    var this_1 = this;\n    for (var t3 = 0, tt2 = sourceTiles.length; t3 < tt2; ++t3) {\n      _loop_1(t3);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  };\n  CanvasVectorTileLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == void 0 ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    var source = layer.getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var hitExtent = boundingExtent([coordinate]);\n    buffer$1(hitExtent, resolution * hitTolerance, hitExtent);\n    var features = {};\n    var featureCallback = function(feature2, geometry, distanceSq) {\n      var key = feature2.getId();\n      if (key === void 0) {\n        key = getUid(feature2);\n      }\n      var match2 = features[key];\n      if (!match2) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature2, layer, geometry);\n        }\n        matches.push(features[key] = {\n          feature: feature2,\n          layer,\n          geometry,\n          distanceSq,\n          callback\n        });\n      } else if (match2 !== true && distanceSq < match2.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match2), 1);\n          return callback(feature2, layer, geometry);\n        }\n        match2.geometry = geometry;\n        match2.distanceSq = distanceSq;\n      }\n      return void 0;\n    };\n    var renderedTiles = this.renderedTiles;\n    var found;\n    var _loop_2 = function(i3, ii2) {\n      var tile2 = renderedTiles[i3];\n      var tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);\n      if (!intersects$1(tileExtent, hitExtent)) {\n        return \"continue\";\n      }\n      var layerUid = getUid(layer);\n      var executorGroups = [tile2.executorGroups[layerUid]];\n      var declutterExecutorGroups = tile2.declutterExecutorGroups[layerUid];\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n      executorGroups.some(function(executorGroups2) {\n        var declutteredFeatures = executorGroups2 === declutterExecutorGroups ? frameState.declutterTree.all().map(function(item) {\n          return item.value;\n        }) : null;\n        for (var t3 = 0, tt2 = executorGroups2.length; t3 < tt2; ++t3) {\n          var executorGroup = executorGroups2[t3];\n          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);\n          if (found) {\n            return true;\n          }\n        }\n      });\n    };\n    for (var i2 = 0, ii = renderedTiles.length; !found && i2 < ii; ++i2) {\n      _loop_2(i2);\n    }\n    return found;\n  };\n  CanvasVectorTileLayerRenderer2.prototype.getFeatures = function(pixel) {\n    return new Promise(function(resolve2, reject2) {\n      var layer = this.getLayer();\n      var layerUid = getUid(layer);\n      var source = layer.getSource();\n      var projection = this.renderedProjection;\n      var projectionExtent = projection.getExtent();\n      var resolution = this.renderedResolution;\n      var tileGrid = source.getTileGridForProjection(projection);\n      var coordinate = apply$5(this.renderedPixelToCoordinateTransform_, pixel.slice());\n      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n      var tile2;\n      for (var i2 = 0, ii = this.renderedTiles.length; i2 < ii; ++i2) {\n        if (tileCoord.toString() === this.renderedTiles[i2].tileCoord.toString()) {\n          tile2 = this.renderedTiles[i2];\n          if (tile2.getState() === TileState.LOADED) {\n            var extent_1 = tileGrid.getTileCoordExtent(tile2.tileCoord);\n            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent_1)) {\n              wrapX$1(coordinate, projection);\n            }\n            break;\n          }\n          tile2 = void 0;\n        }\n      }\n      if (!tile2 || tile2.loadingSourceTiles > 0) {\n        resolve2([]);\n        return;\n      }\n      var extent2 = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);\n      var corner = getTopLeft(extent2);\n      var tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution\n      ];\n      var features = tile2.getSourceTiles().reduce(function(accumulator, sourceTile) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      var hitDetectionImageData = tile2.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n        var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));\n        var rotation = this.renderedRotation_;\n        var transforms2 = [\n          this.getRenderTransform(tileGrid.getTileCoordCenter(tile2.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)\n        ];\n        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms2, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile2.wrappedTileCoord), tile2.getReplayState(layer).renderedResolution, rotation);\n        tile2.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve2(hitDetect(tilePixel, features, hitDetectionImageData));\n    }.bind(this));\n  };\n  CanvasVectorTileLayerRenderer2.prototype.handleFontsChanged = function() {\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== void 0) {\n      layer.changed();\n    }\n  };\n  CanvasVectorTileLayerRenderer2.prototype.handleStyleImageChange_ = function(event) {\n    this.renderIfReadyAndVisible();\n  };\n  CanvasVectorTileLayerRenderer2.prototype.renderDeclutter = function(frameState) {\n    var context = this.context;\n    var alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    var tiles = this.renderedTiles;\n    for (var i2 = 0, ii = tiles.length; i2 < ii; ++i2) {\n      var tile2 = tiles[i2];\n      var declutterExecutorGroups = tile2.declutterExecutorGroups[getUid(this.getLayer())];\n      if (declutterExecutorGroups) {\n        for (var j2 = declutterExecutorGroups.length - 1; j2 >= 0; --j2) {\n          declutterExecutorGroups[j2].execute(this.context, 1, this.getTileRenderTransform(tile2, frameState), frameState.viewState.rotation, hifi, void 0, frameState.declutterTree);\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  };\n  CanvasVectorTileLayerRenderer2.prototype.getTileRenderTransform = function(tile2, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var center = viewState.center;\n    var resolution = viewState.resolution;\n    var rotation = viewState.rotation;\n    var size = frameState.size;\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var source = this.getLayer().getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var tileCoord = tile2.tileCoord;\n    var tileExtent = tileGrid.getTileCoordExtent(tile2.wrappedTileCoord);\n    var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    var transform2 = multiply(scale$3(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n    return transform2;\n  };\n  CanvasVectorTileLayerRenderer2.prototype.renderFrame = function(frameState, target) {\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    _super.prototype.renderFrame.call(this, frameState, target);\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    var layer = this.getLayer();\n    var renderMode = layer.getRenderMode();\n    var context = this.context;\n    var alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    var replayTypes = VECTOR_REPLAYS[renderMode];\n    var viewState = frameState.viewState;\n    var rotation = viewState.rotation;\n    var tileSource = layer.getSource();\n    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    var z2 = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n    var tiles = this.renderedTiles;\n    var clips = [];\n    var clipZs = [];\n    for (var i2 = tiles.length - 1; i2 >= 0; --i2) {\n      var tile2 = tiles[i2];\n      var executorGroups = tile2.executorGroups[getUid(layer)].filter(function(group) {\n        return group.hasExecutors(replayTypes);\n      });\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      var transform2 = this.getTileRenderTransform(tile2, frameState);\n      var currentZ = tile2.tileCoord[0];\n      var contextSaved = false;\n      var currentClip = executorGroups[0].getClipCoords(transform2);\n      for (var j2 = 0, jj = clips.length; j2 < jj; ++j2) {\n        if (z2 !== currentZ && currentZ < clipZs[j2]) {\n          var clip = clips[j2];\n          if (intersects$1([currentClip[0], currentClip[3], currentClip[4], currentClip[7]], [clip[0], clip[3], clip[4], clip[7]])) {\n            if (!contextSaved) {\n              context.save();\n              contextSaved = true;\n            }\n            context.beginPath();\n            context.moveTo(currentClip[0], currentClip[1]);\n            context.lineTo(currentClip[2], currentClip[3]);\n            context.lineTo(currentClip[4], currentClip[5]);\n            context.lineTo(currentClip[6], currentClip[7]);\n            context.moveTo(clip[6], clip[7]);\n            context.lineTo(clip[4], clip[5]);\n            context.lineTo(clip[2], clip[3]);\n            context.lineTo(clip[0], clip[1]);\n            context.clip();\n          }\n        }\n      }\n      clips.push(currentClip);\n      clipZs.push(currentZ);\n      for (var t3 = 0, tt2 = executorGroups.length; t3 < tt2; ++t3) {\n        var executorGroup = executorGroups[t3];\n        executorGroup.execute(context, 1, transform2, rotation, hifi, replayTypes);\n      }\n      if (contextSaved) {\n        context.restore();\n      }\n    }\n    context.globalAlpha = alpha;\n    return this.container;\n  };\n  CanvasVectorTileLayerRenderer2.prototype.renderFeature = function(feature2, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i2 = 0, ii = styles.length; i2 < ii; ++i2) {\n        loading = renderFeature(builderGroup, feature2, styles[i2], squaredTolerance, this.boundHandleStyleImageChange_, void 0, opt_declutterBuilderGroup) || loading;\n      }\n    } else {\n      loading = renderFeature(builderGroup, feature2, styles, squaredTolerance, this.boundHandleStyleImageChange_, void 0, opt_declutterBuilderGroup);\n    }\n    return loading;\n  };\n  CanvasVectorTileLayerRenderer2.prototype.tileImageNeedsRender_ = function(tile2) {\n    var layer = this.getLayer();\n    if (layer.getRenderMode() === VectorTileRenderType.VECTOR) {\n      return false;\n    }\n    var replayState = tile2.getReplayState(layer);\n    var revision = layer.getRevision();\n    var resolution = tile2.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;\n  };\n  CanvasVectorTileLayerRenderer2.prototype.renderTileImage_ = function(tile2, frameState) {\n    var layer = this.getLayer();\n    var replayState = tile2.getReplayState(layer);\n    var revision = layer.getRevision();\n    var executorGroups = tile2.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n    var tileCoord = tile2.wrappedTileCoord;\n    var z2 = tileCoord[0];\n    var source = layer.getSource();\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileResolution = tileGrid.getResolution(tile2.tileCoord[0]);\n    var renderPixelRatio = frameState.pixelRatio / tile2.wantedResolution * tileResolution;\n    var resolution = tileGrid.getResolution(z2);\n    var context = tile2.getContext(layer);\n    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));\n    var size = source.getTilePixelSize(z2, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    var renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      var canvasTransform = reset(this.tmpTransform_);\n      scale$3(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var pixelScale = renderPixelRatio / resolution;\n    var transform2 = reset(this.tmpTransform_);\n    scale$3(transform2, pixelScale, -pixelScale);\n    translate$1(transform2, -tileExtent[0], -tileExtent[3]);\n    for (var i2 = 0, ii = executorGroups.length; i2 < ii; ++i2) {\n      var executorGroup = executorGroups[i2];\n      executorGroup.execute(context, renderScale, transform2, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n    }\n    replayState.renderedTileResolution = tile2.wantedResolution;\n  };\n  return CanvasVectorTileLayerRenderer2;\n}(CanvasTileLayerRenderer$1);\nvar CanvasVectorTileLayerRenderer$1 = CanvasVectorTileLayerRenderer;\nvar __extends$s = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar VectorTileLayer = function(_super) {\n  __extends$s(VectorTileLayer2, _super);\n  function VectorTileLayer2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({}, options);\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    _this = _super.call(this, baseOptions) || this;\n    _this.on;\n    _this.once;\n    _this.un;\n    if (options.renderMode === VectorTileRenderType.IMAGE) {\n      console.warn('renderMode: \"image\" is deprecated. Option ignored.');\n      options.renderMode = void 0;\n    }\n    var renderMode = options.renderMode || VectorTileRenderType.HYBRID;\n    assert(renderMode == VectorTileRenderType.HYBRID || renderMode == VectorTileRenderType.VECTOR, 28);\n    _this.renderMode_ = renderMode;\n    _this.setPreload(options.preload ? options.preload : 0);\n    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);\n    _this.getBackground;\n    _this.setBackground;\n    return _this;\n  }\n  VectorTileLayer2.prototype.createRenderer = function() {\n    return new CanvasVectorTileLayerRenderer$1(this);\n  };\n  VectorTileLayer2.prototype.getFeatures = function(pixel) {\n    return _super.prototype.getFeatures.call(this, pixel);\n  };\n  VectorTileLayer2.prototype.getRenderMode = function() {\n    return this.renderMode_;\n  };\n  VectorTileLayer2.prototype.getPreload = function() {\n    return this.get(TileProperty.PRELOAD);\n  };\n  VectorTileLayer2.prototype.getUseInterimTilesOnError = function() {\n    return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);\n  };\n  VectorTileLayer2.prototype.setPreload = function(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  };\n  VectorTileLayer2.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  };\n  return VectorTileLayer2;\n}(BaseVector);\nvar ol_layer_VectorTile = VectorTileLayer;\nvar __extends$r = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Property$1 = {\n  BLUR: \"blur\",\n  GRADIENT: \"gradient\",\n  RADIUS: \"radius\"\n};\nvar DEFAULT_GRADIENT = [\"#00f\", \"#0ff\", \"#0f0\", \"#ff0\", \"#f00\"];\nvar Heatmap = function(_super) {\n  __extends$r(Heatmap2, _super);\n  function Heatmap2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({}, options);\n    delete baseOptions.gradient;\n    delete baseOptions.radius;\n    delete baseOptions.blur;\n    delete baseOptions.weight;\n    _this = _super.call(this, baseOptions) || this;\n    _this.gradient_ = null;\n    _this.addChangeListener(Property$1.GRADIENT, _this.handleGradientChanged_);\n    _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n    _this.setBlur(options.blur !== void 0 ? options.blur : 15);\n    _this.setRadius(options.radius !== void 0 ? options.radius : 8);\n    var weight = options.weight ? options.weight : \"weight\";\n    if (typeof weight === \"string\") {\n      _this.weightFunction_ = function(feature2) {\n        return feature2.get(weight);\n      };\n    } else {\n      _this.weightFunction_ = weight;\n    }\n    _this.setRenderOrder(null);\n    return _this;\n  }\n  Heatmap2.prototype.getBlur = function() {\n    return this.get(Property$1.BLUR);\n  };\n  Heatmap2.prototype.getGradient = function() {\n    return this.get(Property$1.GRADIENT);\n  };\n  Heatmap2.prototype.getRadius = function() {\n    return this.get(Property$1.RADIUS);\n  };\n  Heatmap2.prototype.handleGradientChanged_ = function() {\n    this.gradient_ = createGradient(this.getGradient());\n  };\n  Heatmap2.prototype.setBlur = function(blur) {\n    this.set(Property$1.BLUR, blur);\n  };\n  Heatmap2.prototype.setGradient = function(colors) {\n    this.set(Property$1.GRADIENT, colors);\n  };\n  Heatmap2.prototype.setRadius = function(radius) {\n    this.set(Property$1.RADIUS, radius);\n  };\n  Heatmap2.prototype.createRenderer = function() {\n    return new WebGLPointsLayerRenderer$1(this, {\n      className: this.getClassName(),\n      attributes: [\n        {\n          name: \"weight\",\n          callback: function(feature2) {\n            var weight = this.weightFunction_(feature2);\n            return weight !== void 0 ? clamp(weight, 0, 1) : 1;\n          }.bind(this)\n        }\n      ],\n      vertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_weight = a_weight;\\n        }\",\n      fragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\\n        }\",\n      hitVertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n        attribute vec4 a_hitColor;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_hitColor = a_hitColor;\\n          v_weight = a_weight;\\n        }\",\n      hitFragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          if (alpha < 0.05) {\\n            discard;\\n          }\\n\\n          gl_FragColor = v_hitColor;\\n        }\",\n      uniforms: {\n        u_size: function() {\n          return (this.get(Property$1.RADIUS) + this.get(Property$1.BLUR)) * 2;\n        }.bind(this),\n        u_blurSlope: function() {\n          return this.get(Property$1.RADIUS) / Math.max(1, this.get(Property$1.BLUR));\n        }.bind(this)\n      },\n      postProcesses: [\n        {\n          fragmentShader: \"\\n            precision mediump float;\\n\\n            uniform sampler2D u_image;\\n            uniform sampler2D u_gradientTexture;\\n            uniform float u_opacity;\\n\\n            varying vec2 v_texCoord;\\n\\n            void main() {\\n              vec4 color = texture2D(u_image, v_texCoord);\\n              gl_FragColor.a = color.a * u_opacity;\\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\\n              gl_FragColor.rgb *= gl_FragColor.a;\\n            }\",\n          uniforms: {\n            u_gradientTexture: function() {\n              return this.gradient_;\n            }.bind(this),\n            u_opacity: function() {\n              return this.getOpacity();\n            }.bind(this)\n          }\n        }\n      ]\n    });\n  };\n  Heatmap2.prototype.renderDeclutter = function() {\n  };\n  return Heatmap2;\n}(BaseVector);\nfunction createGradient(colors) {\n  var width = 1;\n  var height = 256;\n  var context = createCanvasContext2D(width, height);\n  var gradient = context.createLinearGradient(0, 0, width, height);\n  var step = 1 / (colors.length - 1);\n  for (var i2 = 0, ii = colors.length; i2 < ii; ++i2) {\n    gradient.addColorStop(i2 * step, colors[i2]);\n  }\n  context.fillStyle = gradient;\n  context.fillRect(0, 0, width, height);\n  return context.canvas;\n}\nvar ol_layer_Heatmap = Heatmap;\nvar ol_control_LayerSwitcher = function(options) {\n  options = options || {};\n  var self2 = this;\n  this.dcount = 0;\n  this.show_progress = options.show_progress;\n  this.oninfo = typeof options.oninfo == \"function\" ? options.oninfo : null;\n  this.onextent = typeof options.onextent == \"function\" ? options.onextent : null;\n  this.hasextent = options.extent || options.onextent;\n  this.hastrash = options.trash;\n  this.reordering = options.reordering !== false;\n  this._layers = [];\n  this._layerGroup = options.layerGroup && options.layerGroup.getLayers ? options.layerGroup : null;\n  this.onchangeCheck = typeof options.onchangeCheck == \"function\" ? options.onchangeCheck : null;\n  if (typeof options.displayInLayerSwitcher === \"function\") {\n    this.displayInLayerSwitcher = options.displayInLayerSwitcher;\n  }\n  var element;\n  if (options.target) {\n    element = ol_ext_element.create(\"DIV\", {\n      className: options.switcherClass || \"ol-layerswitcher\"\n    });\n  } else {\n    element = ol_ext_element.create(\"DIV\", {\n      className: (options.switcherClass || \"ol-layerswitcher\") + \" ol-unselectable ol-control\"\n    });\n    if (options.collapsed !== false)\n      element.classList.add(\"ol-collapsed\");\n    else\n      element.classList.add(\"ol-forceopen\");\n    this.button = ol_ext_element.create(\"BUTTON\", {\n      type: \"button\",\n      parent: element\n    });\n    this.button.addEventListener(\"touchstart\", function(e2) {\n      element.classList.toggle(\"ol-forceopen\");\n      element.classList.add(\"ol-collapsed\");\n      self2.dispatchEvent({ type: \"toggle\", collapsed: element.classList.contains(\"ol-collapsed\") });\n      e2.preventDefault();\n      self2.overflow();\n    });\n    this.button.addEventListener(\"click\", function() {\n      element.classList.toggle(\"ol-forceopen\");\n      element.classList.add(\"ol-collapsed\");\n      self2.dispatchEvent({ type: \"toggle\", collapsed: !element.classList.contains(\"ol-forceopen\") });\n      self2.overflow();\n    });\n    if (options.mouseover) {\n      element.addEventListener(\"mouseleave\", function() {\n        element.classList.add(\"ol-collapsed\");\n        self2.dispatchEvent({ type: \"toggle\", collapsed: true });\n      });\n      element.addEventListener(\"mouseover\", function() {\n        element.classList.remove(\"ol-collapsed\");\n        self2.dispatchEvent({ type: \"toggle\", collapsed: false });\n      });\n    }\n    if (options.minibar)\n      options.noScroll = true;\n    if (!options.noScroll) {\n      this.topv = ol_ext_element.create(\"DIV\", {\n        className: \"ol-switchertopdiv\",\n        parent: element,\n        click: function() {\n          self2.overflow(\"+50%\");\n        }\n      });\n      this.botv = ol_ext_element.create(\"DIV\", {\n        className: \"ol-switcherbottomdiv\",\n        parent: element,\n        click: function() {\n          self2.overflow(\"-50%\");\n        }\n      });\n    }\n    this._noScroll = options.noScroll;\n  }\n  this.panel_ = ol_ext_element.create(\"UL\", {\n    className: \"panel\"\n  });\n  this.panelContainer_ = ol_ext_element.create(\"DIV\", {\n    className: \"panel-container\",\n    html: this.panel_,\n    parent: element\n  });\n  if (!options.target && !options.noScroll) {\n    ol_ext_element.addListener(this.panel_, \"mousewheel DOMMouseScroll onmousewheel\", function(e2) {\n      if (self2.overflow(Math.max(-1, Math.min(1, e2.wheelDelta || -e2.detail)))) {\n        e2.stopPropagation();\n        e2.preventDefault();\n      }\n    });\n  }\n  this.header_ = ol_ext_element.create(\"LI\", {\n    className: \"ol-header\",\n    parent: this.panel_\n  });\n  ol_control_Control.call(this, {\n    element,\n    target: options.target\n  });\n  this.set(\"drawDelay\", options.drawDelay || 0);\n  this.set(\"selection\", options.selection);\n  if (options.minibar) {\n    setTimeout(function() {\n      var mbar = ol_ext_element.scrollDiv(this.panelContainer_, {\n        mousewheel: true,\n        vertical: true,\n        minibar: true\n      });\n      this.on([\"drawlist\", \"toggle\"], function() {\n        mbar.refresh();\n      });\n    }.bind(this));\n  }\n};\nol_ext_inherits(ol_control_LayerSwitcher, ol_control_Control);\nol_control_LayerSwitcher.prototype.tip = {\n  up: \"up/down\",\n  down: \"down\",\n  info: \"informations...\",\n  extent: \"zoom to extent\",\n  trash: \"remove layer\",\n  plus: \"expand/shrink\"\n};\nol_control_LayerSwitcher.prototype.displayInLayerSwitcher = function(layer) {\n  return layer.get(\"displayInLayerSwitcher\") !== false;\n};\nol_control_LayerSwitcher.prototype.setMap = function(map) {\n  ol_control_Control.prototype.setMap.call(this, map);\n  this.drawPanel();\n  if (this._listener) {\n    for (var i2 in this._listener)\n      unByKey(this._listener[i2]);\n  }\n  this._listener = null;\n  if (map) {\n    this._listener = {\n      moveend: map.on(\"moveend\", this.viewChange.bind(this)),\n      size: map.on(\"change:size\", this.overflow.bind(this))\n    };\n    if (this._layerGroup) {\n      this._listener.change = this._layerGroup.getLayers().on(\"change:length\", this.drawPanel.bind(this));\n    } else {\n      this._listener.change = map.getLayerGroup().getLayers().on(\"change:length\", this.drawPanel.bind(this));\n    }\n  }\n};\nol_control_LayerSwitcher.prototype.show = function() {\n  this.element.classList.add(\"ol-forceopen\");\n  this.overflow();\n  self.dispatchEvent({ type: \"toggle\", collapsed: false });\n};\nol_control_LayerSwitcher.prototype.hide = function() {\n  this.element.classList.remove(\"ol-forceopen\");\n  this.overflow();\n  self.dispatchEvent({ type: \"toggle\", collapsed: true });\n};\nol_control_LayerSwitcher.prototype.toggle = function() {\n  this.element.classList.toggle(\"ol-forceopen\");\n  this.overflow();\n};\nol_control_LayerSwitcher.prototype.isOpen = function() {\n  return this.element.classList.contains(\"ol-forceopen\");\n};\nol_control_LayerSwitcher.prototype.setHeader = function(html2) {\n  ol_ext_element.setHTML(this.header_, html2);\n};\nol_control_LayerSwitcher.prototype.overflow = function(dir) {\n  if (this.button && !this._noScroll) {\n    if (ol_ext_element.hidden(this.panel_)) {\n      ol_ext_element.setStyle(this.element, { height: \"auto\" });\n      return;\n    }\n    var h2 = ol_ext_element.outerHeight(this.element);\n    var hp = ol_ext_element.outerHeight(this.panel_);\n    var dh = this.button.offsetTop + ol_ext_element.outerHeight(this.button);\n    var top = this.panel_.offsetTop - dh;\n    if (hp > h2 - dh) {\n      ol_ext_element.setStyle(this.element, { height: \"100%\" });\n      var li = this.panel_.querySelectorAll(\"li.visible .li-content\")[0];\n      var lh = li ? 2 * ol_ext_element.getStyle(li, \"height\") : 0;\n      switch (dir) {\n        case 1:\n          top += lh;\n          break;\n        case -1:\n          top -= lh;\n          break;\n        case \"+50%\":\n          top += Math.round(h2 / 2);\n          break;\n        case \"-50%\":\n          top -= Math.round(h2 / 2);\n          break;\n      }\n      if (top + hp <= h2 - 3 * dh / 2) {\n        top = h2 - 3 * dh / 2 - hp;\n        ol_ext_element.hide(this.botv);\n      } else {\n        ol_ext_element.show(this.botv);\n      }\n      if (top >= 0) {\n        top = 0;\n        ol_ext_element.hide(this.topv);\n      } else {\n        ol_ext_element.show(this.topv);\n      }\n      ol_ext_element.setStyle(this.panel_, { top: top + \"px\" });\n      return true;\n    } else {\n      ol_ext_element.setStyle(this.element, { height: \"auto\" });\n      ol_ext_element.setStyle(this.panel_, { top: 0 });\n      ol_ext_element.hide(this.botv);\n      ol_ext_element.hide(this.topv);\n      return false;\n    }\n  } else\n    return false;\n};\nol_control_LayerSwitcher.prototype._setLayerForLI = function(li, layer) {\n  var listeners = [];\n  if (layer.getLayers) {\n    listeners.push(layer.getLayers().on(\"change:length\", this.drawPanel.bind(this)));\n  }\n  if (li) {\n    listeners.push(layer.on(\"change:opacity\", function() {\n      this.setLayerOpacity(layer, li);\n    }.bind(this)));\n    listeners.push(layer.on(\"change:visible\", function() {\n      this.setLayerVisibility(layer, li);\n    }.bind(this)));\n  }\n  listeners.push(layer.on(\"propertychange\", function(e2) {\n    if (e2.key === \"displayInLayerSwitcher\" || e2.key === \"openInLayerSwitcher\") {\n      this.drawPanel(e2);\n    }\n  }.bind(this)));\n  this._layers.push({ li, layer, listeners });\n};\nol_control_LayerSwitcher.prototype.setLayerOpacity = function(layer, li) {\n  var i2 = li.querySelector(\".layerswitcher-opacity-cursor\");\n  if (i2)\n    i2.style.left = layer.getOpacity() * 100 + \"%\";\n  this.dispatchEvent({ type: \"layer:opacity\", layer });\n};\nol_control_LayerSwitcher.prototype.setLayerVisibility = function(layer, li) {\n  var i2 = li.querySelector(\".ol-visibility\");\n  if (i2)\n    i2.checked = layer.getVisible();\n  if (layer.getVisible())\n    li.classList.add(\"ol-visible\");\n  else\n    li.classList.remove(\"ol-visible\");\n  this.dispatchEvent({ type: \"layer:visible\", layer });\n};\nol_control_LayerSwitcher.prototype._clearLayerForLI = function() {\n  this._layers.forEach(function(li) {\n    li.listeners.forEach(function(l2) {\n      unByKey(l2);\n    });\n  });\n  this._layers = [];\n};\nol_control_LayerSwitcher.prototype._getLayerForLI = function(li) {\n  for (var i2 = 0, l2; l2 = this._layers[i2]; i2++) {\n    if (l2.li === li)\n      return l2.layer;\n  }\n  return null;\n};\nol_control_LayerSwitcher.prototype.viewChange = function() {\n  this.panel_.querySelectorAll(\"li\").forEach(function(li) {\n    var l2 = this._getLayerForLI(li);\n    if (l2) {\n      if (this.testLayerVisibility(l2))\n        li.classList.remove(\"ol-layer-hidden\");\n      else\n        li.classList.add(\"ol-layer-hidden\");\n    }\n  }.bind(this));\n};\nol_control_LayerSwitcher.prototype.getPanel = function() {\n  return this.panelContainer_;\n};\nol_control_LayerSwitcher.prototype.drawPanel = function() {\n  if (!this.getMap())\n    return;\n  var self2 = this;\n  this.dcount++;\n  setTimeout(function() {\n    self2.drawPanel_();\n  }, this.get(\"drawDelay\") || 0);\n};\nol_control_LayerSwitcher.prototype.drawPanel_ = function() {\n  if (--this.dcount || this.dragging_)\n    return;\n  var scrollTop = this.panelContainer_.scrollTop;\n  this._clearLayerForLI();\n  this.panel_.querySelectorAll(\"li\").forEach(function(li) {\n    if (!li.classList.contains(\"ol-header\"))\n      li.remove();\n  }.bind(this));\n  if (this._layerGroup)\n    this.drawList(this.panel_, this._layerGroup.getLayers());\n  else if (this.getMap())\n    this.drawList(this.panel_, this.getMap().getLayers());\n  this.panelContainer_.scrollTop = scrollTop;\n};\nol_control_LayerSwitcher.prototype.switchLayerVisibility = function(l2, layers) {\n  if (!l2.get(\"baseLayer\")) {\n    l2.setVisible(!l2.getVisible());\n  } else {\n    if (!l2.getVisible())\n      l2.setVisible(true);\n    layers.forEach(function(li) {\n      if (l2 !== li && li.get(\"baseLayer\") && li.getVisible())\n        li.setVisible(false);\n    });\n  }\n};\nol_control_LayerSwitcher.prototype.testLayerVisibility = function(layer) {\n  if (!this.getMap())\n    return true;\n  var res = this.getMap().getView().getResolution();\n  var zoom = this.getMap().getView().getZoom();\n  if (layer.getMaxResolution() <= res || layer.getMinResolution() >= res) {\n    return false;\n  } else if (layer.getMinZoom && (layer.getMinZoom() >= zoom || layer.getMaxZoom() < zoom)) {\n    return false;\n  } else {\n    var ex0 = layer.getExtent();\n    if (ex0) {\n      var ex = this.getMap().getView().calculateExtent(this.getMap().getSize());\n      return intersects$1(ex, ex0);\n    }\n    return true;\n  }\n};\nol_control_LayerSwitcher.prototype.dragOrdering_ = function(e2) {\n  e2.stopPropagation();\n  e2.preventDefault();\n  var self2 = this;\n  var elt = e2.currentTarget.parentNode.parentNode;\n  var start2 = true;\n  var panel = this.panel_;\n  var pageY;\n  var pageY0 = e2.pageY || e2.touches && e2.touches.length && e2.touches[0].pageY || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageY;\n  var target, dragElt;\n  var layer, group;\n  elt.parentNode.classList.add(\"drag\");\n  function stop() {\n    if (target) {\n      var drop = layer;\n      var isSelected = self2.getSelection() === drop;\n      if (drop && target) {\n        var collection;\n        if (group)\n          collection = group.getLayers();\n        else\n          collection = self2._layerGroup ? self2._layerGroup.getLayers() : self2.getMap().getLayers();\n        var layers = collection.getArray();\n        for (var i2 = 0; i2 < layers.length; i2++) {\n          if (layers[i2] == drop) {\n            collection.removeAt(i2);\n            break;\n          }\n        }\n        for (var j2 = 0; j2 < layers.length; j2++) {\n          if (layers[j2] === target) {\n            if (i2 > j2)\n              collection.insertAt(j2, drop);\n            else\n              collection.insertAt(j2 + 1, drop);\n            break;\n          }\n        }\n      }\n      if (isSelected)\n        self2.selectLayer(drop);\n      self2.dispatchEvent({ type: \"reorder-end\", layer: drop, group });\n    }\n    elt.parentNode.querySelectorAll(\"li\").forEach(function(li) {\n      li.classList.remove(\"dropover\");\n      li.classList.remove(\"dropover-after\");\n      li.classList.remove(\"dropover-before\");\n    });\n    elt.classList.remove(\"drag\");\n    elt.parentNode.classList.remove(\"drag\");\n    self2.element.classList.remove(\"drag\");\n    if (dragElt)\n      dragElt.remove();\n    ol_ext_element.removeListener(document, \"mousemove touchmove\", move);\n    ol_ext_element.removeListener(document, \"mouseup touchend touchcancel\", stop);\n  }\n  function move(e3) {\n    pageY = e3.pageY || e3.touches && e3.touches.length && e3.touches[0].pageY || e3.changedTouches && e3.changedTouches.length && e3.changedTouches[0].pageY;\n    if (start2 && Math.abs(pageY0 - pageY) > 2) {\n      start2 = false;\n      elt.classList.add(\"drag\");\n      layer = self2._getLayerForLI(elt);\n      target = false;\n      group = self2._getLayerForLI(elt.parentNode.parentNode);\n      dragElt = ol_ext_element.create(\"LI\", {\n        className: \"ol-dragover\",\n        html: elt.innerHTML,\n        style: {\n          position: \"absolute\",\n          \"z-index\": 1e4,\n          left: elt.offsetLeft,\n          opacity: 0.5,\n          width: ol_ext_element.outerWidth(elt),\n          height: ol_ext_element.getStyle(elt, \"height\")\n        },\n        parent: panel\n      });\n      self2.element.classList.add(\"drag\");\n      self2.dispatchEvent({ type: \"reorder-start\", layer, group });\n    }\n    if (!start2) {\n      e3.preventDefault();\n      e3.stopPropagation();\n      ol_ext_element.setStyle(dragElt, { top: pageY - ol_ext_element.offsetRect(panel).top + panel.scrollTop + 5 });\n      var li;\n      if (!e3.touches) {\n        li = e3.target;\n      } else {\n        li = document.elementFromPoint(e3.touches[0].clientX, e3.touches[0].clientY);\n      }\n      if (li.classList.contains(\"ol-switcherbottomdiv\")) {\n        self2.overflow(-1);\n      } else if (li.classList.contains(\"ol-switchertopdiv\")) {\n        self2.overflow(1);\n      }\n      while (li && li.tagName !== \"LI\") {\n        li = li.parentNode;\n      }\n      if (!li || !li.classList.contains(\"dropover\")) {\n        elt.parentNode.querySelectorAll(\"li\").forEach(function(li2) {\n          li2.classList.remove(\"dropover\");\n          li2.classList.remove(\"dropover-after\");\n          li2.classList.remove(\"dropover-before\");\n        });\n      }\n      if (li && li.parentNode.classList.contains(\"drag\") && li !== elt) {\n        target = self2._getLayerForLI(li);\n        if (target && !target.get(\"allwaysOnTop\") == !layer.get(\"allwaysOnTop\")) {\n          li.classList.add(\"dropover\");\n          li.classList.add(elt.offsetTop < li.offsetTop ? \"dropover-after\" : \"dropover-before\");\n        } else {\n          target = false;\n        }\n        ol_ext_element.show(dragElt);\n      } else {\n        target = false;\n        if (li === elt)\n          ol_ext_element.hide(dragElt);\n        else\n          ol_ext_element.show(dragElt);\n      }\n      if (!target)\n        dragElt.classList.add(\"forbidden\");\n      else\n        dragElt.classList.remove(\"forbidden\");\n    }\n  }\n  ol_ext_element.addListener(document, \"mousemove touchmove\", move);\n  ol_ext_element.addListener(document, \"mouseup touchend touchcancel\", stop);\n};\nol_control_LayerSwitcher.prototype.dragOpacity_ = function(e2) {\n  e2.stopPropagation();\n  e2.preventDefault();\n  var self2 = this;\n  var elt = e2.target;\n  var layer = this._getLayerForLI(elt.parentNode.parentNode.parentNode);\n  if (!layer)\n    return;\n  var x2 = e2.pageX || e2.touches && e2.touches.length && e2.touches[0].pageX || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageX;\n  var start2 = ol_ext_element.getStyle(elt, \"left\") - x2;\n  self2.dragging_ = true;\n  function stop() {\n    ol_ext_element.removeListener(document, \"mouseup touchend touchcancel\", stop);\n    ol_ext_element.removeListener(document, \"mousemove touchmove\", move);\n    self2.dragging_ = false;\n  }\n  function move(e3) {\n    var x3 = e3.pageX || e3.touches && e3.touches.length && e3.touches[0].pageX || e3.changedTouches && e3.changedTouches.length && e3.changedTouches[0].pageX;\n    var delta = (start2 + x3) / ol_ext_element.getStyle(elt.parentNode, \"width\");\n    var opacity2 = Math.max(0, Math.min(1, delta));\n    ol_ext_element.setStyle(elt, { left: opacity2 * 100 + \"%\" });\n    elt.parentNode.nextElementSibling.innerHTML = Math.round(opacity2 * 100);\n    layer.setOpacity(opacity2);\n  }\n  ol_ext_element.addListener(document, \"mouseup touchend touchcancel\", stop);\n  ol_ext_element.addListener(document, \"mousemove touchmove\", move);\n};\nol_control_LayerSwitcher.prototype.drawList = function(ul, collection) {\n  var self2 = this;\n  var layers = collection.getArray();\n  var setVisibility = function(e2) {\n    e2.stopPropagation();\n    e2.preventDefault();\n    var l2 = self2._getLayerForLI(this.parentNode.parentNode);\n    self2.switchLayerVisibility(l2, collection);\n    if (self2.get(\"selection\") && l2.getVisible()) {\n      self2.selectLayer(l2);\n    }\n    if (self2.onchangeCheck) {\n      self2.onchangeCheck(l2);\n    }\n  };\n  function onInfo(e2) {\n    e2.stopPropagation();\n    e2.preventDefault();\n    var l2 = self2._getLayerForLI(this.parentNode.parentNode);\n    self2.oninfo(l2);\n    self2.dispatchEvent({ type: \"info\", layer: l2 });\n  }\n  function zoomExtent(e2) {\n    e2.stopPropagation();\n    e2.preventDefault();\n    var l2 = self2._getLayerForLI(this.parentNode.parentNode);\n    if (self2.onextent)\n      self2.onextent(l2);\n    else\n      self2.getMap().getView().fit(l2.getExtent(), self2.getMap().getSize());\n    self2.dispatchEvent({ type: \"extent\", layer: l2 });\n  }\n  function removeLayer(e2) {\n    e2.stopPropagation();\n    e2.preventDefault();\n    var li = this.parentNode.parentNode.parentNode.parentNode;\n    var layer, group = self2._getLayerForLI(li);\n    if (group) {\n      layer = self2._getLayerForLI(this.parentNode.parentNode);\n      group.getLayers().remove(layer);\n      if (group.getLayers().getLength() == 0 && !group.get(\"noSwitcherDelete\")) {\n        removeLayer.call(li.querySelectorAll(\".layerTrash\")[0], e2);\n      }\n    } else {\n      li = this.parentNode.parentNode;\n      self2.getMap().removeLayer(self2._getLayerForLI(li));\n    }\n  }\n  function createLi(layer) {\n    if (!this.displayInLayerSwitcher(layer)) {\n      this._setLayerForLI(null, layer);\n      return;\n    }\n    var li = ol_ext_element.create(\"LI\", {\n      className: (layer.getVisible() ? \"visible \" : \" \") + (layer.get(\"baseLayer\") ? \"baselayer\" : \"\"),\n      parent: ul\n    });\n    this._setLayerForLI(li, layer);\n    if (this._selectedLayer === layer) {\n      li.classList.add(\"ol-layer-select\");\n    }\n    var layer_buttons = ol_ext_element.create(\"DIV\", {\n      className: \"ol-layerswitcher-buttons\",\n      parent: li\n    });\n    var d2 = ol_ext_element.create(\"DIV\", {\n      className: \"li-content\",\n      parent: li\n    });\n    ol_ext_element.create(\"INPUT\", {\n      type: layer.get(\"baseLayer\") ? \"radio\" : \"checkbox\",\n      className: \"ol-visibility\",\n      checked: layer.getVisible(),\n      click: setVisibility,\n      parent: d2\n    });\n    var label = ol_ext_element.create(\"LABEL\", {\n      title: layer.get(\"title\") || layer.get(\"name\"),\n      click: setVisibility,\n      unselectable: \"on\",\n      style: {\n        userSelect: \"none\"\n      },\n      parent: d2\n    });\n    label.addEventListener(\"selectstart\", function() {\n      return false;\n    });\n    ol_ext_element.create(\"SPAN\", {\n      html: layer.get(\"title\") || layer.get(\"name\"),\n      click: function(e2) {\n        if (this.get(\"selection\")) {\n          e2.stopPropagation();\n          this.selectLayer(layer);\n        }\n      }.bind(this),\n      parent: label\n    });\n    if (this.reordering) {\n      if (i2 < layers.length - 1 && (layer.get(\"allwaysOnTop\") || !layers[i2 + 1].get(\"allwaysOnTop\")) || i2 > 0 && (!layer.get(\"allwaysOnTop\") || layers[i2 - 1].get(\"allwaysOnTop\"))) {\n        ol_ext_element.create(\"DIV\", {\n          className: \"layerup ol-noscroll\",\n          title: this.tip.up,\n          on: { \"mousedown touchstart\": function(e2) {\n            self2.dragOrdering_(e2);\n          } },\n          parent: layer_buttons\n        });\n      }\n    }\n    if (layer.getLayers) {\n      var nb = 0;\n      layer.getLayers().forEach(function(l2) {\n        if (self2.displayInLayerSwitcher(l2))\n          nb++;\n      });\n      if (nb) {\n        ol_ext_element.create(\"DIV\", {\n          className: layer.get(\"openInLayerSwitcher\") ? \"collapse-layers\" : \"expend-layers\",\n          title: this.tip.plus,\n          click: function() {\n            var l2 = self2._getLayerForLI(this.parentNode.parentNode);\n            l2.set(\"openInLayerSwitcher\", !l2.get(\"openInLayerSwitcher\"));\n          },\n          parent: layer_buttons\n        });\n      }\n    }\n    if (this.oninfo) {\n      ol_ext_element.create(\"DIV\", {\n        className: \"layerInfo\",\n        title: this.tip.info,\n        click: onInfo,\n        parent: layer_buttons\n      });\n    }\n    if (this.hastrash && !layer.get(\"noSwitcherDelete\")) {\n      ol_ext_element.create(\"DIV\", {\n        className: \"layerTrash\",\n        title: this.tip.trash,\n        click: removeLayer,\n        parent: layer_buttons\n      });\n    }\n    if (this.hasextent && layers[i2].getExtent()) {\n      var ex = layers[i2].getExtent();\n      if (ex.length == 4 && ex[0] < ex[2] && ex[1] < ex[3]) {\n        ol_ext_element.create(\"DIV\", {\n          className: \"layerExtent\",\n          title: this.tip.extent,\n          click: zoomExtent,\n          parent: layer_buttons\n        });\n      }\n    }\n    if (this.show_progress && layer instanceof ol_layer_Tile) {\n      var p5 = ol_ext_element.create(\"DIV\", {\n        className: \"layerswitcher-progress\",\n        parent: d2\n      });\n      this.setprogress_(layer);\n      layer.layerswitcher_progress = ol_ext_element.create(\"DIV\", { parent: p5 });\n    }\n    var opacity2 = ol_ext_element.create(\"DIV\", {\n      className: \"layerswitcher-opacity\",\n      click: function(e2) {\n        if (e2.target !== this)\n          return;\n        e2.stopPropagation();\n        e2.preventDefault();\n        var op = Math.max(0, Math.min(1, e2.offsetX / ol_ext_element.getStyle(this, \"width\")));\n        self2._getLayerForLI(this.parentNode.parentNode).setOpacity(op);\n      },\n      parent: d2\n    });\n    ol_ext_element.create(\"DIV\", {\n      className: \"layerswitcher-opacity-cursor ol-noscroll\",\n      style: { left: layer.getOpacity() * 100 + \"%\" },\n      on: {\n        \"mousedown touchstart\": function(e2) {\n          self2.dragOpacity_(e2);\n        }\n      },\n      parent: opacity2\n    });\n    ol_ext_element.create(\"DIV\", {\n      className: \"layerswitcher-opacity-label\",\n      html: Math.round(layer.getOpacity() * 100),\n      parent: d2\n    });\n    if (layer.getLayers) {\n      li.classList.add(\"ol-layer-group\");\n      if (layer.get(\"openInLayerSwitcher\") === true) {\n        var ul2 = ol_ext_element.create(\"UL\", {\n          parent: li\n        });\n        this.drawList(ul2, layer.getLayers());\n      }\n    }\n    li.classList.add(this.getLayerClass(layer));\n    this.dispatchEvent({ type: \"drawlist\", layer, li });\n  }\n  for (var i2 = layers.length - 1; i2 >= 0; i2--) {\n    createLi.call(this, layers[i2]);\n  }\n  this.viewChange();\n  if (ul === this.panel_)\n    this.overflow();\n};\nol_control_LayerSwitcher.prototype.getLayerClass = function(layer) {\n  if (!layer)\n    return \"none\";\n  if (layer.getLayers)\n    return \"ol-layer-group\";\n  if (layer instanceof ol_layer_Vector)\n    return \"ol-layer-vector\";\n  if (layer instanceof ol_layer_VectorTile)\n    return \"ol-layer-vectortile\";\n  if (layer instanceof ol_layer_Tile)\n    return \"ol-layer-tile\";\n  if (layer instanceof ol_layer_Image)\n    return \"ol-layer-image\";\n  if (layer instanceof ol_layer_Heatmap)\n    return \"ol-layer-heatmap\";\n  if (layer.getFeatures)\n    return \"ol-layer-vectorimage\";\n  return \"unknown\";\n};\nol_control_LayerSwitcher.prototype.selectLayer = function(layer, silent) {\n  if (!layer) {\n    if (!this.getMap())\n      return;\n    layer = this.getMap().getLayers().item(this.getMap().getLayers().getLength() - 1);\n  }\n  this._selectedLayer = layer;\n  this.drawPanel();\n  if (!silent)\n    this.dispatchEvent({ type: \"select\", layer });\n};\nol_control_LayerSwitcher.prototype.getSelection = function() {\n  return this._selectedLayer;\n};\nol_control_LayerSwitcher.prototype.setprogress_ = function(layer) {\n  if (!layer.layerswitcher_progress) {\n    var loaded = 0;\n    var loading = 0;\n    var draw = function() {\n      if (loading === loaded) {\n        loading = loaded = 0;\n        ol_ext_element.setStyle(layer.layerswitcher_progress, { width: 0 });\n      } else {\n        ol_ext_element.setStyle(layer.layerswitcher_progress, { width: (loaded / loading * 100).toFixed(1) + \"%\" });\n      }\n    };\n    layer.getSource().on(\"tileloadstart\", function() {\n      loading++;\n      draw();\n    });\n    layer.getSource().on(\"tileloadend\", function() {\n      loaded++;\n      draw();\n    });\n    layer.getSource().on(\"tileloaderror\", function() {\n      loaded++;\n      draw();\n    });\n  }\n};\nconst _sfc_main$u = {\n  name: \"ol-layerswitcher-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_LayerSwitcher, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    selection: {\n      type: Boolean\n    },\n    displayInLayerSwitcher: {\n      type: Function\n    },\n    show_progress: {\n      type: Boolean,\n      default: false\n    },\n    mouseover: {\n      type: Boolean,\n      default: false\n    },\n    reordering: {\n      type: Boolean,\n      default: true\n    },\n    trash: {\n      type: Boolean,\n      default: false\n    },\n    oninfo: {\n      type: Function\n    },\n    extent: {\n      type: Boolean\n    },\n    onextent: {\n      type: Function\n    },\n    drawDelay: {\n      type: Number\n    },\n    collapsed: {\n      type: Boolean,\n      default: true\n    },\n    layerGroup: {\n      type: Object\n    },\n    noScroll: {\n      type: Boolean,\n      default: false\n    }\n  }\n};\nfunction _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar LayerSwitcherControl = /* @__PURE__ */ _export_sfc(_sfc_main$u, [[\"render\", _sfc_render$u]]);\nol_source_Source.prototype.getPreview = function() {\n  return \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAk6QAAJOkBUCTn+AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANeSURBVHic7ZpPiE1RHMc/780MBhkik79JSUlIUbOxI+wkI2yRhYSUlJLNpJF/xcpiJBmZGBZsNM1CkmhKITGkGbH0/BuPmXnP4rxbb/TOn3fvOffeec6nfqvb/b7f93fveeec37ng8Xg8Ho/nf6Uu4d+fDswFssCvhHOJhaXAMeApMAQUyyIPPAdOAiuTStAVy4EHjDWsix5gdRLJ2mY34ulWYz6IEeA4kIk9awtkgTOEM/5vdAKT4k0/Ou3YMR/ELcbRm9AKFLBbgCJwNE4TYZkJfMG++SIwDCyLz0o4bI17WdyJz0r1TAZ+oDcxCBwAFgIzEIuhvcBbg3sLwOK4DFXLFvQGniCGSSUagS4DjUPOHESkA3XiOWCORqMR6Nfo9DjI3QqPUSd+ylBnv0Zn0GrWFvmIOvGNhjqrNDp/EAutyFgRKUM2tgO+Gur81FxvAKYZaimxXYBvmuuLDHWWaK4X0RfJCNsF6NdcbzXU2a65PohYFKWOc+jn8PUajbWIXaBKp9NB7lZYh34OzwFbFfd/NtDYYSth27urLGIm0M31AL3APWAAmIooymaDnPIl/Vz4NN1yHrd7gcvxWQnHAuA3bsyPop8hUsE13BSgK04TUViBeFo2zedJ8S6wElexW4D2eNOPTjNi6WvD/DtEr8E6tk6GGoAmxFY2iFHE9NZiQf8gogiB9gTEH23izAZuE77vHyU+ANucO1QwD3hD/MbLowAcdm20EmkwXx4n3NodS9rMB2HabYpEWs0HcRqHp0fNwAvJD+eBTZr7p6BvmQVxUaEzEbiruNfJekH15L8jtrEm7JJolEcOmKXRqQOuKDQuY7HZY8s8iNfzkSLxIuI43FTrkkLnOlBfRW4VsWk+oAX5weknxFAxJQNckGgVgZuIRVoomoGXEmGTMa+iQ6K7M4SW7k24QYgiuDQPYinbhugiF4H3RGtzZYCzyIvQXfpNI1ybLyeLpf5+iTbkRbiP2EcocTHm4+YI8iI8RFHwWjAfsA95Q+YZFU6wasl8wB7kReijtNbIILa0vcg/PRlGfPQwHmlCviDqAzaA+OREtzqr1ejOIDorxlNEjTGUBV4nnUWCvAJxGDlA8q9j3DEArAn2zvXAfOwfl6eVAmJrPpJ0Ih6Px+PxeJLjLwPul3vj5d0eAAAAAElFTkSuQmCC\";\n};\nol_source_Tile.prototype.getPreview = function(lonlat, resolution) {\n  if (!lonlat)\n    lonlat = [21020, 6355964];\n  if (!resolution)\n    resolution = 150;\n  var coord = this.getTileGrid().getTileCoordForCoordAndResolution(lonlat, resolution);\n  var fn = this.getTileUrlFunction();\n  return fn.call(this, coord, this.getProjection());\n};\nol_source_TileWMS.prototype.getPreview = function(lonlat, resolution) {\n  if (!lonlat)\n    lonlat = [21020, 6355964];\n  if (!resolution)\n    resolution = 150;\n  var fn = this.getTileUrlFunction();\n  if (fn) {\n    var tileGrid = this.getTileGrid() || this.getTileGridForProjection(this.getProjection());\n    var coord = tileGrid.getTileCoordForCoordAndResolution(lonlat, resolution);\n    return fn.call(this, coord, 1, this.getProjection());\n  }\n  var url = this.getGetFeatureInfoUrl ? this.getGetFeatureInfoUrl(lonlat, resolution, this.getProjection() || \"EPSG:3857\", {}) : this.getFeatureInfoUrl(lonlat, resolution, this.getProjection() || \"EPSG:3857\", {});\n  url = url.replace(/getfeatureinfo/i, \"GetMap\");\n  return url;\n};\nol_layer_Base.prototype.getPreview = function(lonlat, resolution, projection) {\n  if (this.get(\"preview\"))\n    return [this.get(\"preview\")];\n  if (!resolution)\n    resolution = 150;\n  if (resolution < this.getMinResolution() || resolution > this.getMaxResolution()) {\n    var rmin = this.getMinResolution(), rmax = this.getMaxResolution();\n    if (rmax > 1e5)\n      rmax = 156543;\n    if (rmin < 0.15)\n      rmin = 0.15;\n    resolution = rmax;\n    while (rmax > rmin) {\n      rmin *= 2;\n      rmax /= 2;\n      resolution = rmin;\n    }\n  }\n  var e2 = this.getExtent();\n  if (!lonlat)\n    lonlat = [21020, 6355964];\n  if (e2 && !containsCoordinate(e2, lonlat))\n    lonlat = [(e2[0] + e2[2]) / 2, (e2[1] + e2[3]) / 2];\n  if (projection)\n    lonlat = transform$3(lonlat, projection, this.getSource().getProjection());\n  if (this.getSource && this.getSource()) {\n    return [this.getSource().getPreview(lonlat, resolution)];\n  }\n  return [];\n};\nol_layer_Group.prototype.getPreview = function(lonlat, resolution) {\n  if (this.get(\"preview\"))\n    return [this.get(\"preview\")];\n  var t3 = [];\n  if (this.getLayers) {\n    var l2 = this.getLayers().getArray();\n    for (var i2 = 0; i2 < l2.length; i2++) {\n      t3 = t3.concat(l2[i2].getPreview(lonlat, resolution));\n    }\n  }\n  return t3;\n};\nvar ol_control_LayerSwitcherImage = function(options) {\n  options = options || {};\n  options.switcherClass = \"ol-layerswitcher-image\";\n  if (options.mouseover !== false)\n    options.mouseover = true;\n  ol_control_LayerSwitcher.call(this, options);\n};\nol_ext_inherits(ol_control_LayerSwitcherImage, ol_control_LayerSwitcher);\nol_control_LayerSwitcherImage.prototype.drawList = function(ul, layers) {\n  var self2 = this;\n  var setVisibility = function(e2) {\n    e2.preventDefault();\n    var l2 = self2._getLayerForLI(this);\n    self2.switchLayerVisibility(l2, layers);\n    if (e2.type == \"touchstart\")\n      self2.element.classList.add(\"ol-collapsed\");\n  };\n  ol_ext_element.setStyle(ul, { height: \"auto\" });\n  layers.forEach(function(layer) {\n    if (self2.displayInLayerSwitcher(layer)) {\n      var preview = layer.getPreview ? layer.getPreview() : [\"none\"];\n      var d2 = ol_ext_element.create(\"LI\", {\n        className: \"ol-imgcontainer\" + (layer.getVisible() ? \" ol-visible\" : \"\"),\n        on: { \"touchstart click\": setVisibility },\n        parent: ul\n      });\n      self2._setLayerForLI(d2, layer);\n      preview.forEach(function(img) {\n        ol_ext_element.create(\"IMG\", {\n          src: img,\n          parent: d2\n        });\n      });\n      ol_ext_element.create(\"p\", {\n        html: layer.get(\"title\") || layer.get(\"name\"),\n        parent: d2\n      });\n      if (self2.testLayerVisibility(layer))\n        d2.classList.add(\"ol-layer-hidden\");\n    }\n  });\n};\nol_control_LayerSwitcherImage.prototype.overflow = function() {\n};\nconst _sfc_main$t = {\n  name: \"ol-layerswitcherimage-control\",\n  extends: LayerSwitcherControl,\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_LayerSwitcherImage, props, context);\n    return {\n      control\n    };\n  }\n};\nfunction _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar LayerSwitcherImageControl = /* @__PURE__ */ _export_sfc(_sfc_main$t, [[\"render\", _sfc_render$t]]);\nvar ol_control_MapZone = function(options) {\n  if (!options)\n    options = {};\n  var element = document.createElement(\"div\");\n  if (options.target) {\n    element = ol_ext_element.create(\"DIV\", {\n      className: options.className || \"ol-mapzone\"\n    });\n  } else {\n    element = ol_ext_element.create(\"DIV\", {\n      className: (options.className || \"ol-mapzone\") + \" ol-unselectable ol-control ol-collapsed\"\n    });\n    var bt2 = ol_ext_element.create(\"BUTTON\", {\n      type: \"button\",\n      on: {\n        \"click\": function() {\n          element.classList.toggle(\"ol-collapsed\");\n          maps.forEach(function(m2) {\n            m2.updateSize();\n          });\n        }.bind(this)\n      },\n      parent: element\n    });\n    ol_ext_element.create(\"I\", {\n      parent: bt2\n    });\n  }\n  ol_control_Control.call(this, {\n    element,\n    target: options.target\n  });\n  this.set(\"centerOnClick\", options.centerOnClick);\n  var maps = this._maps = [];\n  this._projection = options.projection;\n  this._layer = options.layer;\n  options.zones.forEach(this.addZone.bind(this));\n  setTimeout(function() {\n    maps.forEach(function(m2) {\n      m2.updateSize();\n    });\n  });\n};\nol_ext_inherits(ol_control_MapZone, ol_control_Control);\nol_control_MapZone.prototype.setCollapsed = function(b2) {\n  if (b2) {\n    this.element.classList.remove(\"ol-collapsed\");\n    this.getMaps().forEach(function(m2) {\n      m2.updateSize();\n    });\n  } else {\n    this.element.classList.add(\"ol-collapsed\");\n  }\n};\nol_control_MapZone.prototype.getCollapsed = function() {\n  return this.element.classList.contains(\"ol-collapsed\");\n};\nol_control_MapZone.prototype.setVisible = ol_control_MapZone.prototype.setCollapsed;\nol_control_MapZone.prototype.getMaps = function() {\n  return this._maps;\n};\nol_control_MapZone.prototype.getLength = function() {\n  return this._maps.length;\n};\nol_control_MapZone.prototype.addZone = function(z2) {\n  var view = new ol_View({ zoom: 6, center: [0, 0], projection: this._projection });\n  var extent2;\n  if (z2.map) {\n    extent2 = transformExtent(z2.map.getView().calculateExtent(), z2.map.getView().getProjection(), view.getProjection());\n  } else {\n    extent2 = transformExtent(z2.extent, \"EPSG:4326\", view.getProjection());\n  }\n  var div = ol_ext_element.create(\"DIV\", {\n    className: \"ol-mapzonezone\",\n    parent: this.element,\n    click: function() {\n      var index2 = -1;\n      this._maps.forEach(function(m2, i2) {\n        if (m2.get(\"zone\") === z2) {\n          index2 = i2;\n        }\n      });\n      this.dispatchEvent({\n        type: \"select\",\n        zone: z2,\n        index: index2,\n        coordinate: getCenter(extent2),\n        extent: extent2\n      });\n      if (this.get(\"centerOnClick\") !== false) {\n        this.getMap().getView().fit(extent2);\n      }\n      this.setVisible(false);\n    }.bind(this)\n  });\n  var layer;\n  if (z2.layer) {\n    layer = z2.layer;\n  } else if (typeof this._layer === \"function\") {\n    layer = this._layer(z2);\n  } else {\n    layer = new this._layer.constructor({\n      source: this._layer.getSource()\n    });\n  }\n  var map = new ol_Map({\n    target: div,\n    view,\n    controls: [],\n    interactions: [],\n    layers: [layer]\n  });\n  map.set(\"zone\", z2);\n  this._maps.push(map);\n  view.fit(extent2);\n  ol_ext_element.create(\"P\", {\n    html: z2.title,\n    parent: div\n  });\n};\nol_control_MapZone.prototype.removeZone = function(index2) {\n  var z2 = this.element.querySelectorAll(\".ol-mapzonezone\")[index2];\n  if (z2) {\n    z2.remove();\n    this._maps.splice(index2, 1);\n  }\n};\nol_control_MapZone.zones = {};\nol_control_MapZone.zones.DOM = [{\n  \"title\": \"Guadeloupe\",\n  \"extent\": [-61.898594315312444, 15.75623038647845, -60.957887532935324, 16.575317670979473]\n}, {\n  \"title\": \"Guyane\",\n  \"extent\": [-54.72525931072715, 2.1603763430019, -51.528236062921344, 5.7984307809552575]\n}, {\n  \"title\": \"Martinique\",\n  \"extent\": [-61.257556528564756, 14.387506317407514, -60.76934912110432, 14.895067461729951]\n}, {\n  \"title\": \"Mayotte\",\n  \"extent\": [44.959844536967815, -13.01674138212816, 45.35328866510648, -12.65521942207829]\n}, {\n  \"title\": \"La r\\xE9union\",\n  \"extent\": [55.17059012967656, -21.407680069231688, 55.88195702001797, -20.85560221637526]\n}];\nol_control_MapZone.zones.TOM = [{\n  \"title\": \"Polyn\\xE9sie Fran\\xE7aise\",\n  \"extent\": [206.23664226630862, -22.189040615809787, 221.85920743981987, -10.835039595040698]\n}, {\n  \"title\": \"Nouvelle Cal\\xE9donie\",\n  \"extent\": [163.76420580160925, -22.581641092751838, 167.66984709498706, -19.816411635668445]\n}, {\n  \"title\": \"St-Pierre et Miquelon\",\n  \"extent\": [-56.453698765748676, 46.74449858188555, -56.0980198121544, 47.14669874229787]\n}, {\n  \"title\": \"Wallis et Futuna\",\n  \"extent\": [181.7588623143665, -14.7341169873267, 183.95612353301715, -13.134720799175085]\n}, {\n  \"title\": \"St-Martin St-Barth\\xE9lemy\",\n  \"extent\": [-63.1726389501678, 17.806097291313506, -62.7606535945649, 18.13267688837938]\n}];\nol_control_MapZone.zones.DOMTOM = [{\n  title: \"M\\xE9tropole\",\n  extent: [-5.318421740712579, 41.16082274292913, 9.73284186155716, 51.21957336557702]\n}].concat(ol_control_MapZone.zones.DOM, ol_control_MapZone.zones.TOM);\nconst _sfc_main$s = {\n  name: \"ol-zone-control\",\n  setup(props, context) {\n    const {\n      control\n    } = useControl(ol_control_MapZone, props, context);\n    return {\n      control\n    };\n  },\n  props: {\n    className: {\n      type: String\n    },\n    zones: {\n      type: Array\n    },\n    layer: {\n      type: [Object, Function]\n    },\n    projection: {\n      type: String,\n      default: \"EPSG:3857\"\n    },\n    centerOnClick: {\n      type: Boolean,\n      default: true\n    }\n  }\n};\nfunction _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar ZoneControl = /* @__PURE__ */ _export_sfc(_sfc_main$s, [[\"render\", _sfc_render$s]]);\nfunction install$5(app) {\n  if (install$5.installed) {\n    return;\n  }\n  install$5.installed = true;\n  app.component(FullScreenControl.name, FullScreenControl);\n  app.component(MousePositionControl.name, MousePositionControl);\n  app.component(AttributionControl.name, AttributionControl);\n  app.component(OverviewMapControl.name, OverviewMapControl);\n  app.component(ScaleLineControl.name, ScaleLineControl);\n  app.component(ZoomControl.name, ZoomControl);\n  app.component(ZoomSliderControl.name, ZoomSliderControl);\n  app.component(ZoomToExtentControl.name, ZoomToExtentControl);\n  app.component(RotateControl.name, RotateControl);\n  app.component(ContextMenuControl.name, ContextMenuControl);\n  app.component(SwipeControl.name, SwipeControl);\n  app.component(ControlBar.name, ControlBar);\n  app.component(ToggleControl.name, ToggleControl);\n  app.component(ButtonControl.name, ButtonControl);\n  app.component(PrintDialog.name, PrintDialog);\n  app.component(VideoRecorderControl.name, VideoRecorderControl);\n  app.component(LayerSwitcherControl.name, LayerSwitcherControl);\n  app.component(LayerSwitcherImageControl.name, LayerSwitcherImageControl);\n  app.component(ZoneControl.name, ZoneControl);\n}\nvar MapControls = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": install$5,\n  install: install$5,\n  FullScreenControl,\n  MousePositionControl,\n  AttributionControl,\n  OverviewMapControl,\n  ScaleLineControl,\n  ZoomControl,\n  ZoomSliderControl,\n  ZoomToExtentControl,\n  ContextMenuControl,\n  SwipeControl,\n  ControlBar,\n  ToggleControl,\n  ButtonControl,\n  PrintDialog,\n  VideoRecorderControl,\n  LayerSwitcherControl,\n  LayerSwitcherImageControl,\n  ZoneControl\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction useGeometry(GeometryType2, props) {\n  const feature2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"feature\");\n  const {\n    properties\n  } = usePropsAsObjectProperties(props);\n  let geometry = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new GeometryType2(...Object.values(properties)));\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n    feature2.value.setGeometry(geometry.value);\n    feature2.value.changed();\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(feature2, () => {\n    feature2.value.setGeometry(geometry.value);\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n    feature2.value.setGeometry(geometry.value);\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n    feature2.value.setGeometry(null);\n  });\n  return {\n    geometry\n  };\n}\nconst _sfc_main$r = {\n  name: \"ol-geom-point\",\n  setup(props) {\n    const {\n      geometry\n    } = useGeometry(Point$4, props);\n    return {\n      geometry\n    };\n  },\n  props: {\n    coordinates: {\n      type: Array\n    },\n    opt_layout: {\n      type: String,\n      default: \"XY\"\n    }\n  }\n};\nfunction _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar Point$1 = /* @__PURE__ */ _export_sfc(_sfc_main$r, [[\"render\", _sfc_render$r]]);\nconst _sfc_main$q = {\n  name: \"ol-geom-line-string\",\n  setup(props) {\n    const {\n      geometry\n    } = useGeometry(LineString$2, props);\n    return {\n      geometry\n    };\n  },\n  props: {\n    coordinates: {\n      type: Array\n    },\n    opt_layout: {\n      type: String,\n      default: \"XY\"\n    }\n  }\n};\nfunction _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar LineString = /* @__PURE__ */ _export_sfc(_sfc_main$q, [[\"render\", _sfc_render$q]]);\nconst _sfc_main$p = {\n  name: \"ol-geom-polygon\",\n  setup(props) {\n    const {\n      geometry\n    } = useGeometry(Polygon$2, props);\n    return {\n      geometry\n    };\n  },\n  props: {\n    coordinates: {\n      type: Array\n    },\n    opt_layout: {\n      type: String,\n      default: \"XY\"\n    }\n  }\n};\nfunction _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar Polygon = /* @__PURE__ */ _export_sfc(_sfc_main$p, [[\"render\", _sfc_render$p]]);\nconst _sfc_main$o = {\n  name: \"ol-geom-multi-point\",\n  setup(props) {\n    const {\n      geometry\n    } = useGeometry(MultiPoint$2, props);\n    return {\n      geometry\n    };\n  },\n  props: {\n    coordinates: {\n      type: Array\n    },\n    opt_layout: {\n      type: String,\n      default: \"XY\"\n    }\n  }\n};\nfunction _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar MultiPoint = /* @__PURE__ */ _export_sfc(_sfc_main$o, [[\"render\", _sfc_render$o]]);\nconst _sfc_main$n = {\n  name: \"ol-geom-multi-line-string\",\n  setup(props) {\n    const {\n      geometry\n    } = useGeometry(MultiLineString$2, props);\n    return {\n      geometry\n    };\n  },\n  props: {\n    coordinates: {\n      type: Array\n    },\n    opt_layout: {\n      type: String,\n      default: \"XY\"\n    }\n  }\n};\nfunction _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar MultiLineString = /* @__PURE__ */ _export_sfc(_sfc_main$n, [[\"render\", _sfc_render$n]]);\nconst _sfc_main$m = {\n  name: \"ol-geom-multi-polygon\",\n  setup(props) {\n    const {\n      geometry\n    } = useGeometry(MultiPolygon$2, props);\n    return {\n      geometry\n    };\n  },\n  props: {\n    coordinates: {\n      type: Array\n    },\n    opt_layout: {\n      type: String,\n      default: \"XY\"\n    }\n  }\n};\nfunction _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar MultiPolygon = /* @__PURE__ */ _export_sfc(_sfc_main$m, [[\"render\", _sfc_render$m]]);\nfunction install$4(app) {\n  if (install$4.installed) {\n    return;\n  }\n  install$4.installed = true;\n  app.component(Point$1.name, Point$1);\n  app.component(LineString.name, LineString);\n  app.component(Polygon.name, Polygon);\n  app.component(MultiPoint.name, MultiPoint);\n  app.component(MultiLineString.name, MultiLineString);\n  app.component(MultiPolygon.name, MultiPolygon);\n}\nvar Geometries = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": install$4,\n  install: install$4,\n  Point: Point$1,\n  LineString,\n  Polygon,\n  MultiPoint,\n  MultiLineString,\n  MultiPolygon\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst _sfc_main$l = {\n  name: \"ol-style\",\n  setup(props) {\n    const styledObj = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"stylable\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let style2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new Style$2(properties));\n    const setStyle = (val) => {\n      if (styledObj instanceof Draw$1 || styledObj instanceof Modify$1) {\n        styledObj.getOverlay().setStyle(val);\n        styledObj.value.dispatchEvent(\"styleChanged\");\n        return;\n      }\n      try {\n        styledObj.value.setStyle(val);\n        styledObj.value.changed();\n        styledObj.value.dispatchEvent(\"styleChanged\");\n      } catch (error) {\n        styledObj.value.style_ = val;\n        styledObj.value.values_.style = val;\n        styledObj.value.changed();\n        styledObj.value.dispatchEvent(\"styleChanged\");\n      }\n    };\n    const styleFunc = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      return (feature2) => {\n        if (properties.overrideStyleFunction != null) {\n          properties.overrideStyleFunction(feature2, style2.value);\n        }\n        return style2.value;\n      };\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      if (properties.overrideStyleFunction == null) {\n        setStyle(style2.value);\n      } else {\n        setStyle(styleFunc.value);\n      }\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      if (properties.overrideStyleFunction == null) {\n        setStyle(style2.value);\n      } else {\n        setStyle(styleFunc.value);\n      }\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      setStyle(null);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"style\", style2);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"styledObj\", styledObj);\n    return {\n      style: style2\n    };\n  },\n  props: {\n    zIndex: {\n      type: Number\n    },\n    overrideStyleFunction: {\n      type: Function\n    }\n  }\n};\nfunction _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar Style = /* @__PURE__ */ _export_sfc(_sfc_main$l, [[\"render\", _sfc_render$l]]);\nconst _sfc_main$k = {\n  name: \"ol-style-circle\",\n  setup(props) {\n    const style2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"style\", null);\n    const styledObj = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"styledObj\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const createCircleStyle = (properties2) => {\n      return new ol_style_Circle(__spreadProps(__spreadValues({}, properties2), {\n        fill: new Fill$2(),\n        stroke: new Stroke$2()\n      }));\n    };\n    let circle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => createCircleStyle(properties));\n    const applyStyle = () => {\n      style2.value.setImage(null);\n      style2.value.setImage(circle.value);\n      styledObj.value.changed();\n    };\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      applyStyle();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(style2, () => {\n      applyStyle();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      style2.value.setImage(circle.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      style2.value.setImage(null);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"circle\", circle);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"styledObj\", styledObj);\n  },\n  props: {\n    radius: {\n      type: Number\n    },\n    scale: {\n      type: Number\n    }\n  }\n};\nfunction _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar Circle = /* @__PURE__ */ _export_sfc(_sfc_main$k, [[\"render\", _sfc_render$k]]);\nconst _sfc_main$j = {\n  name: \"ol-style-stroke\",\n  setup(props) {\n    const style2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"style\", null);\n    const circle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"circle\", null);\n    const styledObj = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"styledObj\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    if (style2 != null && circle == null) {\n      let stroke = new Stroke$2(properties);\n      style2.value.setStroke(stroke);\n      const applyStroke = () => {\n        style2.value.setStroke(null);\n        stroke = new Stroke$2(properties);\n        style2.value.setStroke(stroke);\n      };\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n        applyStroke();\n      });\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(style2, () => {\n        applyStroke();\n      });\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n        style2.value.setStroke(stroke);\n      });\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n        style2.value.setStroke(null);\n      });\n    } else if (circle != null) {\n      const applyStroketoCircle = (properties2) => {\n        circle.value.getStroke().setColor(properties2.color);\n        circle.value.getStroke().setLineCap(properties2.lineCap);\n        circle.value.getStroke().setLineDash(properties2.lineDash);\n        circle.value.getStroke().setLineDashOffset(properties2.lineDashOffset);\n        circle.value.getStroke().setLineJoin(properties2.lineJoin);\n        circle.value.getStroke().setMiterLimit(properties2.miterLimit);\n        circle.value.getStroke().setWidth(properties2.width);\n        circle.value.setRadius(circle.value.getRadius());\n        try {\n          styledObj.value.changed();\n        } catch (error) {\n          styledObj.changed();\n        }\n      };\n      applyStroketoCircle(properties);\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, (newVal) => {\n        applyStroketoCircle(newVal);\n      });\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(circle, () => {\n        applyStroketoCircle(properties);\n      });\n    }\n  },\n  props: {\n    color: {\n      type: String\n    },\n    lineCap: {\n      type: String,\n      default: \"round\"\n    },\n    lineJoin: {\n      type: String,\n      default: \"round\"\n    },\n    lineDash: {\n      type: Array\n    },\n    lineDashOffset: {\n      type: Number,\n      default: 0\n    },\n    miterLimit: {\n      type: Number,\n      default: 10\n    },\n    width: {\n      type: Number,\n      default: 1\n    }\n  }\n};\nfunction _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar Stroke = /* @__PURE__ */ _export_sfc(_sfc_main$j, [[\"render\", _sfc_render$j]]);\nconst _sfc_main$i = {\n  name: \"ol-style-fill\",\n  setup(props) {\n    const style2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"style\", null);\n    const circle = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"circle\", null);\n    const styledObj = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"styledObj\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    if (style2 != null && circle == null) {\n      let fill = new Fill$2(properties);\n      style2.value.setFill(fill);\n      const applyFill = () => {\n        style2.value.setFill(null);\n        fill = new Fill$2(properties);\n        style2.value.setFill(fill);\n      };\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n        applyFill();\n      });\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(style2, () => {\n        applyFill();\n      });\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n        style2.value.setFill(fill);\n      });\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n        style2.value.setFill(null);\n      });\n    } else if (circle != null) {\n      const applyFilltoCircle = (color2) => {\n        circle.value.getFill().setColor(color2);\n        circle.value.setRadius(circle.value.getRadius());\n        try {\n          styledObj.value.changed();\n        } catch (error) {\n          styledObj.changed();\n        }\n      };\n      applyFilltoCircle(properties.color);\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n        applyFilltoCircle(properties.color);\n      });\n      (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(circle, () => {\n        applyFilltoCircle(properties.color);\n      });\n    }\n  },\n  props: {\n    color: {\n      type: String\n    }\n  }\n};\nfunction _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar Fill = /* @__PURE__ */ _export_sfc(_sfc_main$i, [[\"render\", _sfc_render$i]]);\nconst _sfc_main$h = {\n  name: \"ol-style-icon\",\n  setup(props) {\n    const style2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"style\", null);\n    const styledObj = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"styledObj\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let icon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let ic = new Icon$2(properties);\n      ic.load();\n      return ic;\n    });\n    const applyStyle = () => {\n      style2.value.setImage(null);\n      style2.value.setImage(icon.value);\n      styledObj.value.changed();\n    };\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      applyStyle();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(style2, () => {\n      applyStyle();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      style2.value.setImage(icon.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      style2.value.setImage(null);\n    });\n  },\n  props: {\n    anchor: {\n      type: Array\n    },\n    anchorOrigin: {\n      type: String,\n      default: \"top-left\"\n    },\n    anchorXUnits: {\n      type: String,\n      default: \"fraction\"\n    },\n    color: {\n      type: String\n    },\n    crossOrigin: {\n      type: String\n    },\n    img: {\n      type: [HTMLImageElement, HTMLCanvasElement]\n    },\n    offset: {\n      type: Array,\n      default: () => [0, 0]\n    },\n    displacement: {\n      type: Array,\n      default: () => [0, 0]\n    },\n    offsetOrigin: {\n      type: String,\n      default: \"top-left\"\n    },\n    opacity: {\n      type: Number,\n      default: 1\n    },\n    scale: {\n      type: Number,\n      default: 1\n    },\n    rotateWithView: {\n      type: Boolean,\n      default: false\n    },\n    rotation: {\n      type: Number,\n      default: 0\n    },\n    size: {\n      type: Array\n    },\n    imgSize: {\n      type: Array\n    },\n    src: {\n      type: String\n    }\n  }\n};\nfunction _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"\", true);\n}\nvar Icon = /* @__PURE__ */ _export_sfc(_sfc_main$h, [[\"render\", _sfc_render$h]]);\nconst _sfc_main$g = {\n  name: \"ol-style-text\",\n  setup(props) {\n    const style2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"style\", null);\n    const styledObj = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"styledObj\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    const createText = (properties2) => {\n      return new Text$2(__spreadProps(__spreadValues({}, properties2), {\n        fill: new Fill$2(),\n        stroke: new Stroke$2()\n      }));\n    };\n    let text2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => createText(properties));\n    const applyStyle = () => {\n      style2.value.setText(null);\n      style2.value.setText(text2.value);\n      styledObj.value.changed();\n    };\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      applyStyle();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(style2, () => {\n      applyStyle();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      style2.value.setText(text2.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      style2.value.setText(null);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"style\", text2);\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"styledObj\", styledObj);\n  },\n  props: {\n    font: {\n      type: String\n    },\n    maxAngle: {\n      type: Number,\n      default: Math.PI / 4\n    },\n    offsetX: {\n      type: Number,\n      default: 0\n    },\n    offsetY: {\n      type: Number,\n      default: 0\n    },\n    overflow: {\n      type: Boolean,\n      default: false\n    },\n    placement: {\n      type: String,\n      default: \"point\"\n    },\n    scale: {\n      type: Number\n    },\n    rotateWithView: {\n      type: Boolean,\n      default: false\n    },\n    rotation: {\n      type: Number,\n      default: 0\n    },\n    text: {\n      type: String\n    },\n    textAlign: {\n      type: String\n    },\n    textBaseline: {\n      type: String,\n      default: \"middle\"\n    },\n    padding: {\n      type: Array,\n      default: () => [0, 0, 0, 0]\n    }\n  }\n};\nfunction _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar Text = /* @__PURE__ */ _export_sfc(_sfc_main$g, [[\"render\", _sfc_render$g]]);\nvar ol_coordinate_dist2d = function(p12, p22) {\n  var dx = p12[0] - p22[0];\n  var dy = p12[1] - p22[1];\n  return Math.sqrt(dx * dx + dy * dy);\n};\nvar ol_coordinate_equal = function(p12, p22) {\n  return p12[0] == p22[0] && p12[1] == p22[1];\n};\nvar ol_extent_intersection;\n(function() {\n  function splitX(pts, x2) {\n    var pt2;\n    for (let i2 = pts.length - 1; i2 > 0; i2--) {\n      if (pts[i2][0] > x2 && pts[i2 - 1][0] < x2 || pts[i2][0] < x2 && pts[i2 - 1][0] > x2) {\n        pt2 = [x2, (x2 - pts[i2][0]) / (pts[i2 - 1][0] - pts[i2][0]) * (pts[i2 - 1][1] - pts[i2][1]) + pts[i2][1]];\n        pts.splice(i2, 0, pt2);\n      }\n    }\n  }\n  function splitY(pts, y2) {\n    var pt2;\n    for (let i2 = pts.length - 1; i2 > 0; i2--) {\n      if (pts[i2][1] > y2 && pts[i2 - 1][1] < y2 || pts[i2][1] < y2 && pts[i2 - 1][1] > y2) {\n        pt2 = [(y2 - pts[i2][1]) / (pts[i2 - 1][1] - pts[i2][1]) * (pts[i2 - 1][0] - pts[i2][0]) + pts[i2][0], y2];\n        pts.splice(i2, 0, pt2);\n      }\n    }\n  }\n  ol_extent_intersection = function(extent2, polygon) {\n    var poly2 = polygon.getType() === \"Polygon\";\n    if (!poly2 && polygon.getType() !== \"MultiPolygon\")\n      return null;\n    var geom2 = polygon.getCoordinates();\n    if (poly2)\n      geom2 = [geom2];\n    geom2.forEach(function(g2) {\n      g2.forEach(function(c2) {\n        splitX(c2, extent2[0]);\n        splitX(c2, extent2[2]);\n        splitY(c2, extent2[1]);\n        splitY(c2, extent2[3]);\n      });\n    });\n    geom2.forEach(function(g2) {\n      g2.forEach(function(c2) {\n        c2.forEach(function(p5) {\n          if (p5[0] < extent2[0])\n            p5[0] = extent2[0];\n          else if (p5[0] > extent2[2])\n            p5[0] = extent2[2];\n          if (p5[1] < extent2[1])\n            p5[1] = extent2[1];\n          else if (p5[1] > extent2[3])\n            p5[1] = extent2[3];\n        });\n      });\n    });\n    if (poly2) {\n      return new Polygon$2(geom2[0]);\n    } else {\n      return new MultiPolygon$2(geom2);\n    }\n  };\n})();\nvar ol_coordinate_sampleAt = function(p12, p22, d2, start2) {\n  var pts = [];\n  if (start2 !== false)\n    pts.push(p12);\n  var dl = ol_coordinate_dist2d(p12, p22);\n  if (dl) {\n    var nb = Math.round(dl / d2);\n    if (nb > 1) {\n      var dx = (p22[0] - p12[0]) / nb;\n      var dy = (p22[1] - p12[1]) / nb;\n      for (var i2 = 1; i2 < nb; i2++) {\n        pts.push([p12[0] + dx * i2, p12[1] + dy * i2]);\n      }\n    }\n  }\n  pts.push(p22);\n  return pts;\n};\nLineString$2.prototype.sampleAt = function(d2) {\n  var line = this.getCoordinates();\n  var result = [];\n  for (var i2 = 1; i2 < line.length; i2++) {\n    result = result.concat(ol_coordinate_sampleAt(line[i2 - 1], line[i2], d2, i2 === 1));\n  }\n  return new LineString$2(result);\n};\nMultiLineString$2.prototype.sampleAt = function(d2) {\n  var lines = this.getCoordinates();\n  var result = [];\n  lines.forEach(function(p5) {\n    var l2 = [];\n    for (var i2 = 1; i2 < p5.length; i2++) {\n      l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], d2, i2 === 1));\n    }\n    result.push(l2);\n  });\n  return new MultiLineString$2(result);\n};\nPolygon$2.prototype.sampleAt = function(res) {\n  var poly2 = this.getCoordinates();\n  var result = [];\n  poly2.forEach(function(p5) {\n    var l2 = [];\n    for (var i2 = 1; i2 < p5.length; i2++) {\n      l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], res, i2 === 1));\n    }\n    result.push(l2);\n  });\n  return new Polygon$2(result);\n};\nMultiPolygon$2.prototype.sampleAt = function(res) {\n  var mpoly = this.getCoordinates();\n  var result = [];\n  mpoly.forEach(function(poly2) {\n    var a2 = [];\n    result.push(a2);\n    poly2.forEach(function(p5) {\n      var l2 = [];\n      for (var i2 = 1; i2 < p5.length; i2++) {\n        l2 = l2.concat(ol_coordinate_sampleAt(p5[i2 - 1], p5[i2], res, i2 === 1));\n      }\n      a2.push(l2);\n    });\n  });\n  return new MultiPolygon$2(result);\n};\nol_geom_Circle.prototype.intersection = function(geom2, resolution) {\n  if (geom2.sampleAt) {\n    var ext = buffer$1(this.getCenter().concat(this.getCenter()), this.getRadius());\n    geom2 = ol_extent_intersection(ext, geom2);\n    geom2 = geom2.simplify(resolution);\n    var c2 = this.getCenter();\n    var r2 = this.getRadius();\n    var g2 = geom2.sampleAt(resolution).getCoordinates();\n    switch (geom2.getType()) {\n      case \"Polygon\":\n        g2 = [g2];\n      case \"MultiPolygon\": {\n        var hasout = false;\n        var result = [];\n        g2.forEach(function(poly2) {\n          var a2 = [];\n          result.push(a2);\n          poly2.forEach(function(ring) {\n            var l2 = [];\n            a2.push(l2);\n            ring.forEach(function(p5) {\n              var d2 = ol_coordinate_dist2d(c2, p5);\n              if (d2 > r2) {\n                hasout = true;\n                l2.push([\n                  c2[0] + r2 / d2 * (p5[0] - c2[0]),\n                  c2[1] + r2 / d2 * (p5[1] - c2[1])\n                ]);\n              } else {\n                l2.push(p5);\n              }\n            });\n          });\n        });\n        if (!hasout)\n          return geom2;\n        if (geom2.getType() === \"Polygon\") {\n          return new Polygon$2(result[0]);\n        } else {\n          return new MultiPolygon$2(result);\n        }\n      }\n    }\n  } else {\n    console.warn(\"[ol/geom/Circle~intersection] Unsupported geometry type: \" + geom2.getType());\n  }\n  return geom2;\n};\nLineString$2.prototype.splitAt = function(pt2, tol) {\n  var i2;\n  if (!pt2)\n    return [this];\n  if (!tol)\n    tol = 1e-10;\n  if (pt2.length && pt2[0].length) {\n    var result = [this];\n    for (i2 = 0; i2 < pt2.length; i2++) {\n      var r2 = [];\n      for (var k2 = 0; k2 < result.length; k2++) {\n        var ri = result[k2].splitAt(pt2[i2], tol);\n        r2 = r2.concat(ri);\n      }\n      result = r2;\n    }\n    return result;\n  }\n  if (ol_coordinate_equal(pt2, this.getFirstCoordinate()) || ol_coordinate_equal(pt2, this.getLastCoordinate())) {\n    return [this];\n  }\n  var c0 = this.getCoordinates();\n  var ci = [c0[0]];\n  var c2 = [];\n  for (i2 = 0; i2 < c0.length - 1; i2++) {\n    if (ol_coordinate_equal(c0[i2], c0[i2 + 1]))\n      continue;\n    if (ol_coordinate_equal(pt2, c0[i2 + 1])) {\n      ci.push(c0[i2 + 1]);\n      c2.push(new LineString$2(ci));\n      ci = [];\n    } else if (!ol_coordinate_equal(pt2, c0[i2])) {\n      var d1, d2, split2 = false;\n      if (c0[i2][0] == c0[i2 + 1][0]) {\n        d1 = (c0[i2][1] - pt2[1]) / (c0[i2][1] - c0[i2 + 1][1]);\n        split2 = c0[i2][0] == pt2[0] && (0 < d1 && d1 <= 1);\n      } else if (c0[i2][1] == c0[i2 + 1][1]) {\n        d1 = (c0[i2][0] - pt2[0]) / (c0[i2][0] - c0[i2 + 1][0]);\n        split2 = c0[i2][1] == pt2[1] && (0 < d1 && d1 <= 1);\n      } else {\n        d1 = (c0[i2][0] - pt2[0]) / (c0[i2][0] - c0[i2 + 1][0]);\n        d2 = (c0[i2][1] - pt2[1]) / (c0[i2][1] - c0[i2 + 1][1]);\n        split2 = Math.abs(d1 - d2) <= tol && 0 < d1 && d1 <= 1;\n      }\n      if (split2) {\n        ci.push(pt2);\n        c2.push(new LineString$2(ci));\n        ci = [pt2];\n      }\n    }\n    ci.push(c0[i2 + 1]);\n  }\n  if (ci.length > 1)\n    c2.push(new LineString$2(ci));\n  if (c2.length)\n    return c2;\n  else\n    return [this];\n};\nvar ol_style_FlowLine = function(options) {\n  if (!options)\n    options = {};\n  Style$2.call(this, {\n    renderer: this._render.bind(this),\n    stroke: options.stroke,\n    text: options.text,\n    zIndex: options.zIndex,\n    geometry: options.geometry\n  });\n  this._visible = options.visible !== false;\n  if (typeof options.width === \"function\") {\n    this._widthFn = options.width;\n  } else {\n    this.setWidth(options.width);\n  }\n  this.setWidth2(options.width2);\n  if (typeof options.color === \"function\") {\n    this._colorFn = options.color;\n  } else {\n    this.setColor(options.color);\n  }\n  this.setColor2(options.color2);\n  this.setLineCap(options.lineCap);\n  this.setArrow(options.arrow);\n  this.setArrowSize(options.arrowSize);\n  this.setArrowColor(options.arrowColor);\n  this._offset = [0, 0];\n  this.setOffset(options.offset0, 0);\n  this.setOffset(options.offset1, 1);\n  this._noOverlap = options.noOverlap;\n};\nol_ext_inherits(ol_style_FlowLine, Style$2);\nol_style_FlowLine.prototype.setWidth = function(width) {\n  this._width = width || 0;\n};\nol_style_FlowLine.prototype.setWidth2 = function(width) {\n  this._width2 = width;\n};\nol_style_FlowLine.prototype.getOffset = function(where) {\n  return this._offset[where];\n};\nol_style_FlowLine.prototype.setOffset = function(width, where) {\n  width = Math.max(0, parseFloat(width));\n  switch (where) {\n    case 0: {\n      this._offset[0] = width;\n      break;\n    }\n    case 1: {\n      this._offset[1] = width;\n      break;\n    }\n  }\n};\nol_style_FlowLine.prototype.setLineCap = function(cap) {\n  this._lineCap = cap === \"round\" ? \"round\" : \"butt\";\n};\nol_style_FlowLine.prototype.getWidth = function(feature2, step) {\n  if (this._widthFn)\n    return this._widthFn(feature2, step);\n  var w2 = typeof this._width2 === \"number\" ? this._width2 : this._width;\n  return this._width + (w2 - this._width) * step;\n};\nol_style_FlowLine.prototype.setColor = function(color2) {\n  try {\n    this._color = asArray(color2);\n  } catch (e2) {\n    this._color = [0, 0, 0, 1];\n  }\n};\nol_style_FlowLine.prototype.setColor2 = function(color2) {\n  try {\n    this._color2 = asArray(color2);\n  } catch (e2) {\n    this._color2 = null;\n  }\n};\nol_style_FlowLine.prototype.setArrowColor = function(color2) {\n  try {\n    this._acolor = asString$1(color2);\n  } catch (e2) {\n    this._acolor = null;\n  }\n};\nol_style_FlowLine.prototype.getColor = function(feature2, step) {\n  if (this._colorFn)\n    return asString$1(this._colorFn(feature2, step));\n  var color2 = this._color;\n  var color22 = this._color2 || this._color;\n  return \"rgba(\" + +Math.round(color2[0] + (color22[0] - color2[0]) * step) + \",\" + Math.round(color2[1] + (color22[1] - color2[1]) * step) + \",\" + Math.round(color2[2] + (color22[2] - color2[2]) * step) + \",\" + (color2[3] + (color22[3] - color2[3]) * step) + \")\";\n};\nol_style_FlowLine.prototype.getArrow = function() {\n  return this._arrow;\n};\nol_style_FlowLine.prototype.setArrow = function(n2) {\n  this._arrow = parseInt(n2);\n  if (this._arrow < -1 || this._arrow > 2)\n    this._arrow = 0;\n};\nol_style_FlowLine.prototype.getArrowSize = function() {\n  return this._arrowSize || [16, 16];\n};\nol_style_FlowLine.prototype.setArrowSize = function(size) {\n  if (Array.isArray(size))\n    this._arrowSize = size;\n  else if (typeof size === \"number\")\n    this._arrowSize = [size, size];\n};\nol_style_FlowLine.prototype.drawArrow = function(ctx, p0, p12, width, ratio) {\n  var asize = this.getArrowSize()[0] * ratio;\n  var l2 = ol_coordinate_dist2d(p0, p12);\n  var dx = (p0[0] - p12[0]) / l2;\n  var dy = (p0[1] - p12[1]) / l2;\n  width = Math.max(this.getArrowSize()[1] / 2, width / 2) * ratio;\n  ctx.beginPath();\n  ctx.moveTo(p0[0], p0[1]);\n  ctx.lineTo(p0[0] - asize * dx + width * dy, p0[1] - asize * dy - width * dx);\n  ctx.lineTo(p0[0] - asize * dx - width * dy, p0[1] - asize * dy + width * dx);\n  ctx.lineTo(p0[0], p0[1]);\n  ctx.fill();\n};\nol_style_FlowLine.prototype._render = function(geom2, e2) {\n  if (e2.geometry.getType() === \"LineString\") {\n    var i2, g2, p5, ctx = e2.context;\n    if (!this._visible) {\n      var a2 = e2.pixelRatio / e2.resolution;\n      var cos = Math.cos(e2.rotation);\n      var sin = Math.sin(e2.rotation);\n      g2 = e2.geometry.getCoordinates();\n      var dx = geom2[0][0] - g2[0][0] * a2 * cos - g2[0][1] * a2 * sin;\n      var dy = geom2[0][1] - g2[0][0] * a2 * sin + g2[0][1] * a2 * cos;\n      geom2 = [];\n      for (i2 = 0; p5 = g2[i2]; i2++) {\n        geom2[i2] = [\n          dx + p5[0] * a2 * cos + p5[1] * a2 * sin,\n          dy + p5[0] * a2 * sin - p5[1] * a2 * cos,\n          p5[2]\n        ];\n      }\n    }\n    var asize = this.getArrowSize()[0] * e2.pixelRatio;\n    ctx.save();\n    if (this.getOffset(0))\n      this._splitAsize(geom2, this.getOffset(0) * e2.pixelRatio);\n    if (this.getOffset(1))\n      this._splitAsize(geom2, this.getOffset(1) * e2.pixelRatio, true);\n    if (geom2.length > 1 && (this.getArrow() === -1 || this.getArrow() === 2)) {\n      p5 = this._splitAsize(geom2, asize);\n      if (this._acolor)\n        ctx.fillStyle = this._acolor;\n      else\n        ctx.fillStyle = this.getColor(e2.feature, 0);\n      this.drawArrow(ctx, p5[0], p5[1], this.getWidth(e2.feature, 0), e2.pixelRatio);\n    }\n    if (geom2.length > 1 && this.getArrow() > 0) {\n      p5 = this._splitAsize(geom2, asize, true);\n      if (this._acolor)\n        ctx.fillStyle = this._acolor;\n      else\n        ctx.fillStyle = this.getColor(e2.feature, 1);\n      this.drawArrow(ctx, p5[0], p5[1], this.getWidth(e2.feature, 1), e2.pixelRatio);\n    }\n    var geoms = this._splitInto(geom2, 255, 2);\n    var k2 = 0;\n    var nb = geoms.length;\n    ctx.lineJoin = \"round\";\n    ctx.lineCap = this._lineCap || \"butt\";\n    if (geoms.length > 1) {\n      for (k2 = 0; k2 < geoms.length; k2++) {\n        var step = k2 / nb;\n        g2 = geoms[k2];\n        ctx.lineWidth = this.getWidth(e2.feature, step) * e2.pixelRatio;\n        ctx.strokeStyle = this.getColor(e2.feature, step);\n        ctx.beginPath();\n        ctx.moveTo(g2[0][0], g2[0][1]);\n        for (i2 = 1; p5 = g2[i2]; i2++) {\n          ctx.lineTo(p5[0], p5[1]);\n        }\n        ctx.stroke();\n      }\n    }\n    ctx.restore();\n  }\n};\nol_style_FlowLine.prototype._splitAsize = function(geom2, asize, end) {\n  var p5, p12, p0;\n  var dl, d2 = 0;\n  if (end)\n    p0 = geom2.pop();\n  else\n    p0 = geom2.shift();\n  p5 = p0;\n  while (geom2.length) {\n    if (end)\n      p12 = geom2.pop();\n    else\n      p12 = geom2.shift();\n    dl = ol_coordinate_dist2d(p5, p12);\n    if (d2 + dl > asize) {\n      p5 = [p5[0] + (p12[0] - p5[0]) * (asize - d2) / dl, p5[1] + (p12[1] - p5[1]) * (asize - d2) / dl];\n      dl = ol_coordinate_dist2d(p5, p0);\n      if (end) {\n        geom2.push(p12);\n        geom2.push(p5);\n        geom2.push([p5[0] + (p0[0] - p5[0]) / dl, p5[1] + (p0[1] - p5[1]) / dl]);\n      } else {\n        geom2.unshift(p12);\n        geom2.unshift(p5);\n        geom2.unshift([p5[0] + (p0[0] - p5[0]) / dl, p5[1] + (p0[1] - p5[1]) / dl]);\n      }\n      break;\n    }\n    d2 += dl;\n    p5 = p12;\n  }\n  return [p0, p5];\n};\nol_style_FlowLine.prototype._splitInto = function(geom2, nb, min2) {\n  var i2, p5;\n  var dt2 = this._noOverlap ? 1 : 0.9;\n  var geoms = [];\n  var dl, l2 = 0;\n  for (i2 = 1; p5 = geom2[i2]; i2++) {\n    l2 += ol_coordinate_dist2d(geom2[i2 - 1], p5);\n  }\n  var length = Math.max(min2 || 2, l2 / (nb || 255));\n  var p0 = geom2[0];\n  l2 = 0;\n  var g2 = [p0];\n  i2 = 1;\n  p5 = geom2[1];\n  while (i2 < geom2.length) {\n    var dx = p5[0] - p0[0];\n    var dy = p5[1] - p0[1];\n    dl = Math.sqrt(dx * dx + dy * dy);\n    if (l2 + dl > length) {\n      var d2 = (length - l2) / dl;\n      g2.push([\n        p0[0] + dx * d2,\n        p0[1] + dy * d2\n      ]);\n      geoms.push(g2);\n      p0 = [\n        p0[0] + dx * d2 * dt2,\n        p0[1] + dy * d2 * dt2\n      ];\n      g2 = [p0];\n      l2 = 0;\n    } else {\n      l2 += dl;\n      p0 = p5;\n      g2.push(p0);\n      i2++;\n      p5 = geom2[i2];\n    }\n  }\n  geoms.push(g2);\n  return geoms;\n};\nconst _sfc_main$f = {\n  name: \"ol-style-flowline\",\n  setup(props) {\n    const styledObj = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"stylable\", null);\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let style2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => new ol_style_FlowLine(properties));\n    const setStyle = (val) => {\n      if (styledObj instanceof Draw$1 || styledObj instanceof Modify$1) {\n        styledObj.getOverlay().setStyle(val);\n        styledObj.value.dispatchEvent(\"styleChanged\");\n        return;\n      }\n      try {\n        styledObj.value.setStyle(val);\n        styledObj.value.changed();\n        styledObj.value.dispatchEvent(\"styleChanged\");\n      } catch (error) {\n        styledObj.value.style_ = val;\n        styledObj.value.values_.style = val;\n        styledObj.value.changed();\n        styledObj.value.dispatchEvent(\"styleChanged\");\n      }\n    };\n    const styleFunc = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      return (feature2) => {\n        if (properties.overrideStyleFunction != null) {\n          properties.overrideStyleFunction(feature2, style2.value);\n        }\n        return style2.value;\n      };\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      if (properties.overrideStyleFunction == null) {\n        setStyle(style2.value);\n      } else {\n        setStyle(styleFunc.value);\n      }\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      if (properties.overrideStyleFunction == null) {\n        setStyle(style2.value);\n      } else {\n        setStyle(styleFunc.value);\n      }\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      setStyle(null);\n    });\n    return {\n      style: style2\n    };\n  },\n  props: {\n    color: {\n      type: [String, Function]\n    },\n    color2: {\n      type: String\n    },\n    width: {\n      type: [Number, Function]\n    },\n    width2: {\n      type: Number\n    },\n    arrow: {\n      type: Number\n    },\n    arrowColor: {\n      type: String\n    }\n  }\n};\nfunction _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", null, [\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\")\n  ]);\n}\nvar FlowLine = /* @__PURE__ */ _export_sfc(_sfc_main$f, [[\"render\", _sfc_render$f]]);\nfunction install$3(app) {\n  if (install$3.installed) {\n    return;\n  }\n  install$3.installed = true;\n  app.component(Style.name, Style);\n  app.component(Circle.name, Circle);\n  app.component(Stroke.name, Stroke);\n  app.component(Fill.name, Fill);\n  app.component(Icon.name, Icon);\n  app.component(Text.name, Text);\n  app.component(FlowLine.name, FlowLine);\n}\nvar Styles = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": install$3,\n  install: install$3,\n  Style,\n  Stroke,\n  Fill,\n  Icon,\n  Text,\n  FlowLine,\n  Circle\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst _sfc_main$e = {\n  name: \"ol-interaction-select\",\n  emits: [\"select\"],\n  setup(props, {\n    emit\n  }) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let select = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let s2 = new ol_interaction_Select(__spreadProps(__spreadValues({}, properties), {\n        style: new Style$2()\n      }));\n      s2.on(\"select\", (event) => {\n        emit(\"select\", event);\n      });\n      return s2;\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(select, (newVal, oldVal) => {\n      map.removeInteraction(oldVal);\n      map.addInteraction(newVal);\n      map.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addInteraction(select.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeInteraction(select.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"stylable\", select);\n    return {\n      select\n    };\n  },\n  props: {\n    multi: {\n      type: Boolean,\n      default: false\n    },\n    condition: {\n      type: Function\n    },\n    filter: {\n      type: Function\n    },\n    features: {\n      type: [ol_Collection, Object]\n    }\n  }\n};\nfunction _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar SelectInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$e, [[\"render\", _sfc_render$e]]);\nvar ol_interaction_SelectCluster = function(options) {\n  options = options || {};\n  this.pointRadius = options.pointRadius || 12;\n  this.circleMaxObjects = options.circleMaxObjects || 10;\n  this.maxObjects = options.maxObjects || 60;\n  this.spiral = options.spiral !== false;\n  this.animate = options.animate;\n  this.animationDuration = options.animationDuration || 500;\n  this.selectCluster_ = options.selectCluster !== false;\n  this._autoClose = options.autoClose !== false;\n  var overlay = this.overlayLayer_ = new ol_layer_Vector({\n    source: new ol_source_Vector({\n      features: new ol_Collection(),\n      wrapX: options.wrapX,\n      useSpatialIndex: true\n    }),\n    name: \"Cluster overlay\",\n    updateWhileAnimating: true,\n    updateWhileInteracting: true,\n    displayInLayerSwitcher: false,\n    style: options.featureStyle\n  });\n  if (options.layers) {\n    if (typeof options.layers == \"function\") {\n      var fnLayers = options.layers;\n      options.layers = function(layer) {\n        return layer === overlay || fnLayers(layer);\n      };\n    } else if (options.layers.push) {\n      options.layers.push(this.overlayLayer_);\n    }\n  }\n  if (options.filter) {\n    var fnFilter = options.filter;\n    options.filter = function(f2, l2) {\n      if (!l2 && f2.get(\"selectclusterlink\"))\n        return false;\n      else\n        return fnFilter(f2, l2);\n    };\n  } else\n    options.filter = function(f2, l2) {\n      if (!l2 && f2.get(\"selectclusterlink\"))\n        return false;\n      else\n        return true;\n    };\n  this.filter_ = options.filter;\n  if (!this._autoClose && !options.toggleCondition) {\n    options.toggleCondition = singleClick;\n  }\n  ol_interaction_Select.call(this, options);\n  this.on(\"select\", this.selectCluster.bind(this));\n};\nol_ext_inherits(ol_interaction_SelectCluster, ol_interaction_Select);\nol_interaction_SelectCluster.prototype.setMap = function(map) {\n  if (this.getMap()) {\n    this.getMap().removeLayer(this.overlayLayer_);\n  }\n  if (this._listener)\n    unByKey(this._listener);\n  this._listener = null;\n  ol_interaction_Select.prototype.setMap.call(this, map);\n  this.overlayLayer_.setMap(map);\n  if (map && map.getView()) {\n    this._listener = map.getView().on(\"change:resolution\", this.clear.bind(this));\n  }\n};\nol_interaction_SelectCluster.prototype.clear = function() {\n  this.getFeatures().clear();\n  this.overlayLayer_.getSource().clear();\n};\nol_interaction_SelectCluster.prototype.getLayer = function() {\n  return this.overlayLayer_;\n};\nol_interaction_SelectCluster.prototype.selectCluster = function(e2) {\n  if (e2 instanceof feature) {\n    e2 = { selected: [e2] };\n  }\n  if (!e2.selected.length) {\n    if (this._autoClose) {\n      this.clear();\n    } else {\n      const deselectedFeatures = e2.deselected;\n      deselectedFeatures.forEach((deselectedFeature) => {\n        const selectClusterFeatures = deselectedFeature.get(\"selectcluserfeatures\");\n        selectClusterFeatures.forEach((selectClusterFeature) => {\n          this.overlayLayer_.getSource().removeFeature(selectClusterFeature);\n        });\n      });\n    }\n    return;\n  }\n  var feature$1 = e2.selected[0];\n  if (feature$1.get(\"selectclusterfeature\"))\n    return;\n  var source = this.overlayLayer_.getSource();\n  if (this._autoClose) {\n    source.clear();\n  }\n  var cluster = feature$1.get(\"features\");\n  if (!cluster || cluster.length == 1)\n    return;\n  if (!this.selectCluster_)\n    this.getFeatures().clear();\n  var center = feature$1.getGeometry().getCoordinates();\n  var pix = this.getMap().getView().getResolution();\n  var r2, a2, i2, max2;\n  var p5, cf, lk;\n  var features = [];\n  if (!this.spiral || cluster.length <= this.circleMaxObjects) {\n    max2 = Math.min(cluster.length, this.circleMaxObjects);\n    r2 = pix * this.pointRadius * (0.5 + max2 / 4);\n    for (i2 = 0; i2 < max2; i2++) {\n      a2 = 2 * Math.PI * i2 / max2;\n      if (max2 == 2 || max2 == 4)\n        a2 += Math.PI / 4;\n      p5 = [center[0] + r2 * Math.sin(a2), center[1] + r2 * Math.cos(a2)];\n      cf = new feature({ \"selectclusterfeature\": true, \"features\": [cluster[i2]], geometry: new Point$4(p5) });\n      cf.setStyle(cluster[i2].getStyle());\n      features.push(cf);\n      lk = new feature({ \"selectclusterlink\": true, geometry: new LineString$2([center, p5]) });\n      features.push(lk);\n    }\n  } else {\n    a2 = 0;\n    var d2 = 2 * this.pointRadius;\n    max2 = Math.min(this.maxObjects, cluster.length);\n    for (i2 = 0; i2 < max2; i2++) {\n      r2 = d2 / 2 + d2 * a2 / (2 * Math.PI);\n      a2 = a2 + (d2 + 0.1) / r2;\n      var dx = pix * r2 * Math.sin(a2);\n      var dy = pix * r2 * Math.cos(a2);\n      p5 = [center[0] + dx, center[1] + dy];\n      cf = new feature({ \"selectclusterfeature\": true, \"features\": [cluster[i2]], geometry: new Point$4(p5) });\n      cf.setStyle(cluster[i2].getStyle());\n      features.push(cf);\n      lk = new feature({ \"selectclusterlink\": true, geometry: new LineString$2([center, p5]) });\n      features.push(lk);\n    }\n  }\n  feature$1.set(\"selectcluserfeatures\", features);\n  if (this.animate) {\n    this.animateCluster_(center, features);\n  } else {\n    source.addFeatures(features);\n  }\n};\nol_interaction_SelectCluster.prototype.animateCluster_ = function(center, features) {\n  if (this.listenerKey_) {\n    unByKey(this.listenerKey_);\n  }\n  if (!features.length)\n    return;\n  var style2 = this.overlayLayer_.getStyle();\n  var stylefn = typeof style2 == \"function\" ? style2 : style2.length ? function() {\n    return style2;\n  } : function() {\n    return [style2];\n  };\n  var duration2 = this.animationDuration || 500;\n  var start2 = new Date().getTime();\n  function animate(event) {\n    var vectorContext = event.vectorContext || getVectorContext(event);\n    var ratio = event.frameState.pixelRatio;\n    var res = this.getMap().getView().getResolution();\n    var e2 = easeOut((event.frameState.time - start2) / duration2);\n    for (var i2 = 0, feature2; feature2 = features[i2]; i2++)\n      if (feature2.get(\"features\")) {\n        var pt2 = feature2.getGeometry().getCoordinates();\n        pt2[0] = center[0] + e2 * (pt2[0] - center[0]);\n        pt2[1] = center[1] + e2 * (pt2[1] - center[1]);\n        var geo = new Point$4(pt2);\n        var st2 = stylefn(feature2, res);\n        for (var s2 = 0; s2 < st2.length; s2++) {\n          var sc;\n          var imgs = ol_Map.prototype.getFeaturesAtPixel ? false : st2[s2].getImage();\n          if (imgs) {\n            sc = imgs.getScale();\n            imgs.setScale(ratio);\n          }\n          if (vectorContext.setStyle) {\n            vectorContext.setStyle(st2[s2]);\n            vectorContext.drawGeometry(geo);\n          } else {\n            vectorContext.setImageStyle(imgs);\n            vectorContext.drawPointGeometry(geo);\n          }\n          if (imgs)\n            imgs.setScale(sc);\n        }\n      }\n    if (e2 > 1) {\n      unByKey(this.listenerKey_);\n      this.overlayLayer_.getSource().addFeatures(features);\n      this.overlayLayer_.changed();\n      return;\n    }\n    event.frameState.animate = true;\n  }\n  this.listenerKey_ = this.overlayLayer_.on([\"postcompose\", \"postrender\"], animate.bind(this));\n  var feature$1 = new feature(new Point$4(this.getMap().getView().getCenter()));\n  feature$1.setStyle(new Style$2({ image: new ol_style_Circle({}) }));\n  this.overlayLayer_.getSource().addFeature(feature$1);\n};\nol_interaction_SelectCluster.prototype.getClusterExtent = function(feature2) {\n  if (!feature2.get(\"features\"))\n    return null;\n  var extent2 = createEmpty();\n  feature2.get(\"features\").forEach(function(f2) {\n    extent2 = extend$2(extent2, f2.getGeometry().getExtent());\n  });\n  if (extent2[0] === extent2[2] && extent2[1] === extent2[3])\n    return null;\n  return extent2;\n};\nconst _sfc_main$d = {\n  name: \"ol-interaction-clusterselect\",\n  emits: [\"select\"],\n  setup(props, {\n    emit\n  }) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let select = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let s2 = new ol_interaction_SelectCluster(__spreadProps(__spreadValues({}, properties), {\n        style: new Style$2()\n      }));\n      s2.on(\"select\", (event) => {\n        emit(\"select\", event);\n      });\n      return s2;\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(select, (newVal, oldVal) => {\n      map.removeInteraction(oldVal);\n      map.addInteraction(newVal);\n      map.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addInteraction(select.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeInteraction(select.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"stylable\", select);\n  },\n  props: {\n    multi: {\n      type: Boolean,\n      default: false\n    },\n    condition: {\n      type: Function\n    },\n    filter: {\n      type: Function\n    },\n    pointRadius: {\n      type: Number,\n      default: 7\n    },\n    animate: {\n      type: Boolean,\n      default: true\n    },\n    featureStyle: {\n      type: Function\n    },\n    style: {\n      type: Function\n    }\n  }\n};\nfunction _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar ClusterSelectInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$d, [[\"render\", _sfc_render$d]]);\nconst _sfc_main$c = {\n  name: \"ol-interaction-draw\",\n  emits: [\"drawstart\", \"drawend\"],\n  setup(props, {\n    emit\n  }) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"vectorSource\");\n    const {\n      type,\n      clickTolerance,\n      dragVertexDelay,\n      snapTolerance,\n      stopClick,\n      maxPoints,\n      minPoints,\n      finishCondition,\n      geometryFunction,\n      geometryName,\n      condition,\n      freehand,\n      freehandCondition,\n      wrapX: wrapX2\n    } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(props);\n    let createDraw = () => {\n      let draw2 = new Draw$1({\n        source: source.value,\n        type: type.value,\n        clickTolerance: clickTolerance.value,\n        dragVertexDelay: dragVertexDelay.value,\n        snapTolerance: snapTolerance.value,\n        stopClick: stopClick.value,\n        maxPoints: maxPoints.value,\n        minPoints: minPoints.value,\n        finishCondition: finishCondition.value,\n        geometryFunction: geometryFunction.value,\n        geometryName: geometryName.value,\n        condition: condition.value,\n        freehand: freehand.value,\n        freehandCondition: freehandCondition.value,\n        wrapX: wrapX2.value\n      });\n      draw2.on(\"drawstart\", (event) => {\n        emit(\"drawstart\", event);\n      });\n      draw2.on(\"drawend\", (event) => {\n        emit(\"drawend\", event);\n      });\n      return draw2;\n    };\n    let draw = createDraw();\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)([\n      type,\n      clickTolerance,\n      dragVertexDelay,\n      snapTolerance,\n      stopClick,\n      maxPoints,\n      minPoints,\n      finishCondition,\n      geometryFunction,\n      geometryName,\n      condition,\n      freehand,\n      freehandCondition,\n      wrapX2\n    ], () => {\n      map.removeInteraction(draw);\n      draw = createDraw();\n      map.addInteraction(draw);\n      draw.changed();\n      map.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addInteraction(draw);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeInteraction(draw);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"stylable\", draw);\n  },\n  props: {\n    type: {\n      type: String,\n      required: true\n    },\n    clickTolerance: {\n      type: Number,\n      default: 6\n    },\n    dragVertexDelay: {\n      type: Number,\n      default: 500\n    },\n    snapTolerance: {\n      type: Number,\n      default: 12\n    },\n    stopClick: {\n      type: Boolean,\n      default: false\n    },\n    maxPoints: {\n      type: Number\n    },\n    minPoints: {\n      type: Number\n    },\n    finishCondition: {\n      type: Function\n    },\n    geometryFunction: {\n      type: Function\n    },\n    geometryName: {\n      type: String\n    },\n    condition: {\n      type: Function\n    },\n    freehand: {\n      type: Boolean,\n      default: false\n    },\n    freehandCondition: {\n      type: Function\n    },\n    wrapX: {\n      type: Boolean,\n      default: false\n    }\n  }\n};\nfunction _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar DrawInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$c, [[\"render\", _sfc_render$c]]);\nconst _sfc_main$b = {\n  name: \"ol-interaction-snap\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"vectorSource\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let createSnap = () => {\n      let s2 = new Snap$1(__spreadProps(__spreadValues({}, properties), {\n        source: source.value\n      }));\n      return s2;\n    };\n    let snap2 = createSnap();\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(properties, () => {\n      map.removeInteraction(snap2);\n      snap2 = createSnap();\n      map.addInteraction(snap2);\n      map.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addInteraction(snap2);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeInteraction(snap2);\n    });\n  },\n  props: {\n    vertex: {\n      type: Boolean,\n      default: true\n    },\n    edge: {\n      type: Boolean,\n      default: true\n    },\n    pixelTolerance: {\n      type: Number,\n      default: 10\n    }\n  }\n};\nfunction _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar SnapInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$b, [[\"render\", _sfc_render$b]]);\nconst _sfc_main$a = {\n  name: \"ol-interaction-modify\",\n  emits: [\"modifystart\", \"modifyend\"],\n  setup(props, {\n    emit\n  }) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const source = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"vectorSource\");\n    const {\n      features,\n      condition,\n      deleteCondition,\n      insertVertexCondition,\n      pixelTolerance,\n      wrapX: wrapX2,\n      hitDetection\n    } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(props);\n    let createModify = () => {\n      let modify2 = new Modify$1({\n        source: source.value,\n        features: features.value,\n        condition: condition.value,\n        deleteCondition: deleteCondition.value,\n        insertVertexCondition: insertVertexCondition.value,\n        pixelTolerance: pixelTolerance.value,\n        wrapX: wrapX2.value,\n        hitDetection: hitDetection.value\n      });\n      modify2.on(\"modifystart\", (event) => {\n        emit(\"modifystart\", event);\n      });\n      modify2.on(\"modifyend\", (event) => {\n        emit(\"modifyend\", event);\n      });\n      return modify2;\n    };\n    let modify = createModify();\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)([\n      condition,\n      deleteCondition,\n      insertVertexCondition,\n      pixelTolerance,\n      wrapX2,\n      hitDetection\n    ], () => {\n      map.removeInteraction(modify);\n      modify = createModify();\n      map.addInteraction(modify);\n      modify.changed();\n      map.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addInteraction(modify);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeInteraction(modify);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"stylable\", modify);\n  },\n  props: {\n    condition: {\n      type: Function\n    },\n    deleteCondition: {\n      type: Function\n    },\n    insertVertexCondition: {\n      type: Function\n    },\n    pixelTolerance: {\n      type: Number,\n      default: 10\n    },\n    wrapX: {\n      type: Boolean,\n      default: false\n    },\n    hitDetection: {\n      type: Boolean\n    },\n    features: {\n      type: [ol_Collection, Object]\n    }\n  }\n};\nfunction _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar ModifyInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$a, [[\"render\", _sfc_render$a]]);\nvar ol_interaction_Transform = function(options) {\n  if (!options)\n    options = {};\n  var self2 = this;\n  this.selection_ = new ol_Collection();\n  this.handles_ = new ol_Collection();\n  this.overlayLayer_ = new ol_layer_Vector({\n    source: new ol_source_Vector({\n      features: this.handles_,\n      useSpatialIndex: false,\n      wrapX: false\n    }),\n    name: \"Transform overlay\",\n    displayInLayerSwitcher: false,\n    style: function(feature2) {\n      return self2.style[(feature2.get(\"handle\") || \"default\") + (feature2.get(\"constraint\") || \"\") + (feature2.get(\"option\") || \"\")];\n    }\n  });\n  ol_interaction_Pointer.call(this, {\n    handleDownEvent: this.handleDownEvent_,\n    handleDragEvent: this.handleDragEvent_,\n    handleMoveEvent: this.handleMoveEvent_,\n    handleUpEvent: this.handleUpEvent_\n  });\n  this.features_ = options.features;\n  if (typeof options.filter === \"function\")\n    this._filter = options.filter;\n  this.layers_ = options.layers ? options.layers instanceof Array ? options.layers : [options.layers] : null;\n  this._handleEvent = options.condition || function() {\n    return true;\n  };\n  this.addFn_ = options.addCondition || function() {\n    return false;\n  };\n  this.set(\"translateFeature\", options.translateFeature !== false);\n  this.set(\"translate\", options.translate !== false);\n  this.set(\"translateBBox\", options.translateBBox === true);\n  this.set(\"stretch\", options.stretch !== false);\n  this.set(\"scale\", options.scale !== false);\n  this.set(\"rotate\", options.rotate !== false);\n  this.set(\"keepAspectRatio\", options.keepAspectRatio || function(e2) {\n    return e2.originalEvent.shiftKey;\n  });\n  this.set(\"modifyCenter\", options.modifyCenter || function(e2) {\n    return e2.originalEvent.metaKey || e2.originalEvent.ctrlKey;\n  });\n  this.set(\"noFlip\", options.noFlip || false);\n  this.set(\"selection\", options.selection !== false);\n  this.set(\"hitTolerance\", options.hitTolerance || 0);\n  this.set(\"enableRotatedTransform\", options.enableRotatedTransform || false);\n  this.set(\"keepRectangle\", options.keepRectangle || false);\n  this.on(\"propertychange\", function() {\n    this.drawSketch_();\n  });\n  this.setDefaultStyle();\n};\nol_ext_inherits(ol_interaction_Transform, ol_interaction_Pointer);\nol_interaction_Transform.prototype.Cursors = {\n  \"default\": \"auto\",\n  \"select\": \"pointer\",\n  \"translate\": \"move\",\n  \"rotate\": \"move\",\n  \"rotate0\": \"move\",\n  \"scale\": \"nesw-resize\",\n  \"scale1\": \"nwse-resize\",\n  \"scale2\": \"nesw-resize\",\n  \"scale3\": \"nwse-resize\",\n  \"scalev\": \"ew-resize\",\n  \"scaleh1\": \"ns-resize\",\n  \"scalev2\": \"ew-resize\",\n  \"scaleh3\": \"ns-resize\"\n};\nol_interaction_Transform.prototype.setMap = function(map) {\n  var oldMap = this.getMap();\n  if (oldMap) {\n    var targetElement = oldMap.getTargetElement();\n    oldMap.removeLayer(this.overlayLayer_);\n    if (this.previousCursor_ && targetElement) {\n      targetElement.style.cursor = this.previousCursor_;\n    }\n    this.previousCursor_ = void 0;\n  }\n  ol_interaction_Pointer.prototype.setMap.call(this, map);\n  this.overlayLayer_.setMap(map);\n  if (map === null) {\n    this.select(null);\n  }\n  if (map !== null) {\n    this.isTouch = /touch/.test(map.getViewport().className);\n    this.setDefaultStyle();\n  }\n};\nol_interaction_Transform.prototype.setActive = function(b2) {\n  this.select(null);\n  this.overlayLayer_.setVisible(b2);\n  ol_interaction_Pointer.prototype.setActive.call(this, b2);\n};\nol_interaction_Transform.prototype.setDefaultStyle = function(options) {\n  options = options || {};\n  var stroke = options.pointStroke || new Stroke$2({ color: [255, 0, 0, 1], width: 1 });\n  var strokedash = options.stroke || new Stroke$2({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] });\n  var fill0 = options.fill || new Fill$2({ color: [255, 0, 0, 0.01] });\n  var fill = options.pointFill || new Fill$2({ color: [255, 255, 255, 0.8] });\n  var circle = new ol_style_RegularShape({\n    fill,\n    stroke,\n    radius: this.isTouch ? 12 : 6,\n    displacement: this.isTouch ? [24, -24] : [12, -12],\n    points: 15\n  });\n  if (!circle.setDisplacement)\n    circle.getAnchor()[0] = this.isTouch ? -10 : -5;\n  var bigpt = new ol_style_RegularShape({\n    fill,\n    stroke,\n    radius: this.isTouch ? 16 : 8,\n    points: 4,\n    angle: Math.PI / 4\n  });\n  var smallpt = new ol_style_RegularShape({\n    fill,\n    stroke,\n    radius: this.isTouch ? 12 : 6,\n    points: 4,\n    angle: Math.PI / 4\n  });\n  function createStyle(img, stroke2, fill2) {\n    return [new Style$2({ image: img, stroke: stroke2, fill: fill2 })];\n  }\n  this.style = {\n    \"default\": createStyle(bigpt, strokedash, fill0),\n    \"translate\": createStyle(bigpt, stroke, fill),\n    \"rotate\": createStyle(circle, stroke, fill),\n    \"rotate0\": createStyle(bigpt, stroke, fill),\n    \"scale\": createStyle(bigpt, stroke, fill),\n    \"scale1\": createStyle(bigpt, stroke, fill),\n    \"scale2\": createStyle(bigpt, stroke, fill),\n    \"scale3\": createStyle(bigpt, stroke, fill),\n    \"scalev\": createStyle(smallpt, stroke, fill),\n    \"scaleh1\": createStyle(smallpt, stroke, fill),\n    \"scalev2\": createStyle(smallpt, stroke, fill),\n    \"scaleh3\": createStyle(smallpt, stroke, fill)\n  };\n  this.drawSketch_();\n};\nol_interaction_Transform.prototype.setStyle = function(style2, olstyle) {\n  if (!olstyle)\n    return;\n  if (olstyle instanceof Array)\n    this.style[style2] = olstyle;\n  else\n    this.style[style2] = [olstyle];\n  for (var i2 = 0; i2 < this.style[style2].length; i2++) {\n    var im = this.style[style2][i2].getImage();\n    if (im) {\n      if (style2 == \"rotate\") {\n        im.getAnchor()[0] = -5;\n      }\n      if (this.isTouch)\n        im.setScale(1.8);\n    }\n    var tx = this.style[style2][i2].getText();\n    if (tx) {\n      if (style2 == \"rotate\")\n        tx.setOffsetX(this.isTouch ? 14 : 7);\n      if (this.isTouch)\n        tx.setScale(1.8);\n    }\n  }\n  this.drawSketch_();\n};\nol_interaction_Transform.prototype.getFeatureAtPixel_ = function(pixel) {\n  var self2 = this;\n  return this.getMap().forEachFeatureAtPixel(pixel, function(feature2, layer) {\n    var found = false;\n    if (!layer) {\n      if (feature2 === self2.bbox_) {\n        if (self2.get(\"translateBBox\")) {\n          return { feature: feature2, handle: \"translate\", constraint: \"\", option: \"\" };\n        } else {\n          return false;\n        }\n      }\n      self2.handles_.forEach(function(f2) {\n        if (f2 === feature2)\n          found = true;\n      });\n      if (found)\n        return { feature: feature2, handle: feature2.get(\"handle\"), constraint: feature2.get(\"constraint\"), option: feature2.get(\"option\") };\n    }\n    if (!self2.get(\"selection\")) {\n      if (self2.selection_.getArray().some(function(f2) {\n        return feature2 === f2;\n      })) {\n        return { feature: feature2 };\n      }\n      return null;\n    }\n    if (self2._filter) {\n      if (self2._filter(feature2, layer))\n        return { feature: feature2 };\n      else\n        return null;\n    } else if (self2.layers_) {\n      for (var i2 = 0; i2 < self2.layers_.length; i2++) {\n        if (self2.layers_[i2] === layer)\n          return { feature: feature2 };\n      }\n      return null;\n    } else if (self2.features_) {\n      self2.features_.forEach(function(f2) {\n        if (f2 === feature2)\n          found = true;\n      });\n      if (found)\n        return { feature: feature2 };\n      else\n        return null;\n    } else\n      return { feature: feature2 };\n  }, { hitTolerance: this.get(\"hitTolerance\") }) || {};\n};\nol_interaction_Transform.prototype.getGeometryRotateToZero_ = function(f2, clone2) {\n  var origGeom = f2.getGeometry();\n  var viewRotation = this.getMap().getView().getRotation();\n  if (viewRotation === 0 || !this.get(\"enableRotatedTransform\")) {\n    return clone2 ? origGeom.clone() : origGeom;\n  }\n  var rotGeom = origGeom.clone();\n  rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter());\n  return rotGeom;\n};\nol_interaction_Transform.prototype._isRectangle = function(geom2) {\n  if (this.get(\"keepRectangle\") && geom2.getType() === \"Polygon\") {\n    var coords = geom2.getCoordinates()[0];\n    return coords.length === 5;\n  }\n  return false;\n};\nol_interaction_Transform.prototype.drawSketch_ = function(center) {\n  var i2, f2, geom2;\n  var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry());\n  this.overlayLayer_.getSource().clear();\n  if (!this.selection_.getLength())\n    return;\n  var viewRotation = this.getMap().getView().getRotation();\n  var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent();\n  var coords;\n  if (keepRectangle) {\n    coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4);\n    coords.unshift(coords[3]);\n  }\n  ext = buffer$1(ext, 0);\n  this.selection_.forEach(function(f3) {\n    var extendExt = this.getGeometryRotateToZero_(f3).getExtent();\n    extend$2(ext, extendExt);\n  }.bind(this));\n  if (center === true) {\n    if (!this.ispt_) {\n      this.overlayLayer_.getSource().addFeature(new feature({ geometry: new Point$4(this.center_), handle: \"rotate0\" }));\n      geom2 = fromExtent(ext);\n      if (this.get(\"enableRotatedTransform\") && viewRotation !== 0) {\n        geom2.rotate(viewRotation, this.getMap().getView().getCenter());\n      }\n      f2 = this.bbox_ = new feature(geom2);\n      this.overlayLayer_.getSource().addFeature(f2);\n    }\n  } else {\n    if (this.ispt_) {\n      var p5 = this.getMap().getPixelFromCoordinate([ext[0], ext[1]]);\n      if (p5) {\n        ext = boundingExtent([\n          this.getMap().getCoordinateFromPixel([p5[0] - 10, p5[1] - 10]),\n          this.getMap().getCoordinateFromPixel([p5[0] + 10, p5[1] + 10])\n        ]);\n      }\n    }\n    geom2 = keepRectangle ? new Polygon$2([coords]) : fromExtent(ext);\n    if (this.get(\"enableRotatedTransform\") && viewRotation !== 0) {\n      geom2.rotate(viewRotation, this.getMap().getView().getCenter());\n    }\n    f2 = this.bbox_ = new feature(geom2);\n    var features = [];\n    var g2 = geom2.getCoordinates()[0];\n    if (!this.ispt_) {\n      features.push(f2);\n      if (!this.iscircle_ && this.get(\"stretch\") && this.get(\"scale\"))\n        for (i2 = 0; i2 < g2.length - 1; i2++) {\n          f2 = new feature({ geometry: new Point$4([(g2[i2][0] + g2[i2 + 1][0]) / 2, (g2[i2][1] + g2[i2 + 1][1]) / 2]), handle: \"scale\", constraint: i2 % 2 ? \"h\" : \"v\", option: i2 });\n          features.push(f2);\n        }\n      if (this.get(\"scale\"))\n        for (i2 = 0; i2 < g2.length - 1; i2++) {\n          f2 = new feature({ geometry: new Point$4(g2[i2]), handle: \"scale\", option: i2 });\n          features.push(f2);\n        }\n      if (this.get(\"translate\") && !this.get(\"translateFeature\")) {\n        f2 = new feature({ geometry: new Point$4([(g2[0][0] + g2[2][0]) / 2, (g2[0][1] + g2[2][1]) / 2]), handle: \"translate\" });\n        features.push(f2);\n      }\n    }\n    if (!this.iscircle_ && this.get(\"rotate\")) {\n      f2 = new feature({ geometry: new Point$4(g2[3]), handle: \"rotate\" });\n      features.push(f2);\n    }\n    this.overlayLayer_.getSource().addFeatures(features);\n  }\n};\nol_interaction_Transform.prototype.select = function(feature2, add2) {\n  if (!feature2) {\n    this.selection_.clear();\n    this.drawSketch_();\n    return;\n  }\n  if (!feature2.getGeometry || !feature2.getGeometry())\n    return;\n  if (add2) {\n    this.selection_.push(feature2);\n  } else {\n    var index2 = this.selection_.getArray().indexOf(feature2);\n    this.selection_.removeAt(index2);\n  }\n  this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == \"Point\" : false;\n  this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == \"Circle\" : false;\n  this.drawSketch_();\n  this.watchFeatures_();\n  this.dispatchEvent({ type: \"select\", feature: feature2, features: this.selection_ });\n};\nol_interaction_Transform.prototype.setSelection = function(features) {\n  this.selection_.clear();\n  features.forEach(function(feature2) {\n    this.selection_.push(feature2);\n  }.bind(this));\n  this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == \"Point\" : false;\n  this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == \"Circle\" : false;\n  this.drawSketch_();\n  this.watchFeatures_();\n  this.dispatchEvent({ type: \"select\", features: this.selection_ });\n};\nol_interaction_Transform.prototype.watchFeatures_ = function() {\n  if (this._featureListeners) {\n    this._featureListeners.forEach(function(l2) {\n      unByKey(l2);\n    });\n  }\n  this._featureListeners = [];\n  this.selection_.forEach(function(f2) {\n    this._featureListeners.push(f2.on(\"change\", function() {\n      if (!this.isUpdating_) {\n        this.drawSketch_();\n      }\n    }.bind(this)));\n  }.bind(this));\n};\nol_interaction_Transform.prototype.handleDownEvent_ = function(evt) {\n  if (!this._handleEvent(evt, this.selection_))\n    return;\n  var sel = this.getFeatureAtPixel_(evt.pixel);\n  var feature2 = sel.feature;\n  if (this.selection_.getLength() && this.selection_.getArray().indexOf(feature2) >= 0 && (this.ispt_ && this.get(\"translate\") || this.get(\"translateFeature\"))) {\n    sel.handle = \"translate\";\n  }\n  if (sel.handle) {\n    this.mode_ = sel.handle;\n    this.opt_ = sel.option;\n    this.constraint_ = sel.constraint;\n    var viewRotation = this.getMap().getView().getRotation();\n    this.coordinate_ = evt.coordinate;\n    this.pixel_ = evt.pixel;\n    this.geoms_ = [];\n    this.rotatedGeoms_ = [];\n    var extent2 = createEmpty();\n    var rotExtent = createEmpty();\n    for (var i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {\n      this.geoms_.push(f2.getGeometry().clone());\n      extent2 = extend$2(extent2, f2.getGeometry().getExtent());\n      if (this.get(\"enableRotatedTransform\") && viewRotation !== 0) {\n        var rotGeom = this.getGeometryRotateToZero_(f2, true);\n        this.rotatedGeoms_.push(rotGeom);\n        rotExtent = extend$2(rotExtent, rotGeom.getExtent());\n      }\n    }\n    this.extent_ = fromExtent(extent2).getCoordinates()[0];\n    if (this.get(\"enableRotatedTransform\") && viewRotation !== 0) {\n      this.rotatedExtent_ = fromExtent(rotExtent).getCoordinates()[0];\n    }\n    if (this.mode_ === \"rotate\") {\n      this.center_ = this.getCenter() || getCenter(extent2);\n      var element = evt.map.getTargetElement();\n      element.style.cursor = this.Cursors.rotate0;\n      this.previousCursor_ = element.style.cursor;\n    } else {\n      this.center_ = getCenter(extent2);\n    }\n    this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0]);\n    this.dispatchEvent({\n      type: this.mode_ + \"start\",\n      feature: this.selection_.item(0),\n      features: this.selection_,\n      pixel: evt.pixel,\n      coordinate: evt.coordinate\n    });\n    return true;\n  } else if (this.get(\"selection\")) {\n    if (feature2) {\n      if (!this.addFn_(evt))\n        this.selection_.clear();\n      var index2 = this.selection_.getArray().indexOf(feature2);\n      if (index2 < 0)\n        this.selection_.push(feature2);\n      else\n        this.selection_.removeAt(index2);\n    } else {\n      this.selection_.clear();\n    }\n    this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == \"Point\" : false;\n    this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == \"Circle\" : false;\n    this.drawSketch_();\n    this.watchFeatures_();\n    this.dispatchEvent({ type: \"select\", feature: feature2, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate });\n    return false;\n  }\n};\nol_interaction_Transform.prototype.getFeatures = function() {\n  return this.selection_;\n};\nol_interaction_Transform.prototype.getCenter = function() {\n  return this.get(\"center\");\n};\nol_interaction_Transform.prototype.setCenter = function(c2) {\n  return this.set(\"center\", c2);\n};\nfunction projectVectorOnVector(displacement_vector, base) {\n  var k2 = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);\n  return [base[0] * k2, base[1] * k2];\n}\nfunction countVector(start2, end) {\n  return [end[0] - start2[0], end[1] - start2[1]];\n}\nfunction movePoint(point, displacementVector) {\n  return [point[0] + displacementVector[0], point[1] + displacementVector[1]];\n}\nol_interaction_Transform.prototype.handleDragEvent_ = function(evt) {\n  if (!this._handleEvent(evt, this.features_))\n    return;\n  var viewRotation = this.getMap().getView().getRotation();\n  var i2, j2, f2, geometry;\n  var pt0 = [this.coordinate_[0], this.coordinate_[1]];\n  var pt2 = [evt.coordinate[0], evt.coordinate[1]];\n  this.isUpdating_ = true;\n  switch (this.mode_) {\n    case \"rotate\": {\n      var a2 = Math.atan2(this.center_[1] - pt2[1], this.center_[0] - pt2[0]);\n      if (!this.ispt) {\n        for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {\n          geometry = this.geoms_[i2].clone();\n          geometry.rotate(a2 - this.angle_, this.center_);\n          if (geometry.getType() == \"Circle\")\n            geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());\n          f2.setGeometry(geometry);\n        }\n      }\n      this.drawSketch_(true);\n      this.dispatchEvent({\n        type: \"rotating\",\n        feature: this.selection_.item(0),\n        features: this.selection_,\n        angle: a2 - this.angle_,\n        pixel: evt.pixel,\n        coordinate: evt.coordinate\n      });\n      break;\n    }\n    case \"translate\": {\n      var deltaX = pt2[0] - pt0[0];\n      var deltaY = pt2[1] - pt0[1];\n      for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {\n        f2.getGeometry().translate(deltaX, deltaY);\n      }\n      this.handles_.forEach(function(f3) {\n        f3.getGeometry().translate(deltaX, deltaY);\n      });\n      this.coordinate_ = evt.coordinate;\n      this.dispatchEvent({\n        type: \"translating\",\n        feature: this.selection_.item(0),\n        features: this.selection_,\n        delta: [deltaX, deltaY],\n        pixel: evt.pixel,\n        coordinate: evt.coordinate\n      });\n      break;\n    }\n    case \"scale\": {\n      var center = this.center_;\n      if (this.get(\"modifyCenter\")(evt)) {\n        var extentCoordinates = this.extent_;\n        if (this.get(\"enableRotatedTransform\") && viewRotation !== 0) {\n          extentCoordinates = this.rotatedExtent_;\n        }\n        center = extentCoordinates[(Number(this.opt_) + 2) % 4];\n      }\n      var keepRectangle = this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]);\n      var stretch = this.constraint_;\n      var opt = this.opt_;\n      var downCoordinate = this.coordinate_;\n      var dragCoordinate = evt.coordinate;\n      if (this.get(\"enableRotatedTransform\") && viewRotation !== 0) {\n        var downPoint = new Point$4(this.coordinate_);\n        downPoint.rotate(viewRotation * -1, center);\n        downCoordinate = downPoint.getCoordinates();\n        var dragPoint = new Point$4(evt.coordinate);\n        dragPoint.rotate(viewRotation * -1, center);\n        dragCoordinate = dragPoint.getCoordinates();\n      }\n      var scx = (dragCoordinate[0] - center[0]) / (downCoordinate[0] - center[0]);\n      var scy = (dragCoordinate[1] - center[1]) / (downCoordinate[1] - center[1]);\n      var displacementVector = [dragCoordinate[0] - downCoordinate[0], dragCoordinate[1] - downCoordinate[1]];\n      if (this.get(\"enableRotatedTransform\") && viewRotation !== 0) {\n        var centerPoint = new Point$4(center);\n        centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter());\n        center = centerPoint.getCoordinates();\n      }\n      if (this.get(\"noFlip\")) {\n        if (scx < 0)\n          scx = -scx;\n        if (scy < 0)\n          scy = -scy;\n      }\n      if (this.constraint_) {\n        if (this.constraint_ == \"h\")\n          scx = 1;\n        else\n          scy = 1;\n      } else {\n        if (this.get(\"keepAspectRatio\")(evt)) {\n          scx = scy = Math.min(scx, scy);\n        }\n      }\n      for (i2 = 0, f2; f2 = this.selection_.item(i2); i2++) {\n        geometry = viewRotation === 0 || !this.get(\"enableRotatedTransform\") ? this.geoms_[i2].clone() : this.rotatedGeoms_[i2].clone();\n        geometry.applyTransform(function(g1, g2, dim) {\n          if (dim < 2)\n            return g2;\n          if (!keepRectangle) {\n            for (j2 = 0; j2 < g1.length; j2 += dim) {\n              if (scx != 1)\n                g2[j2] = center[0] + (g1[j2] - center[0]) * scx;\n              if (scy != 1)\n                g2[j2 + 1] = center[1] + (g1[j2 + 1] - center[1]) * scy;\n            }\n          } else {\n            var pointArray = [[6], [0, 8], [2], [4]];\n            var pointA = [g1[0], g1[1]];\n            var pointB = [g1[2], g1[3]];\n            var pointC = [g1[4], g1[5]];\n            var pointD = [g1[6], g1[7]];\n            var pointA1 = [g1[8], g1[9]];\n            if (stretch) {\n              var base = opt % 2 === 0 ? countVector(pointA, pointB) : countVector(pointD, pointA);\n              var projectedVector = projectVectorOnVector(displacementVector, base);\n              var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0;\n              var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]];\n              for (j2 = 0; j2 < g1.length; j2 += dim) {\n                g2[j2] = coordsToChange.includes(j2) ? g1[j2] + projectedVector[0] : g1[j2];\n                g2[j2 + 1] = coordsToChange.includes(j2) ? g1[j2 + 1] + projectedVector[1] : g1[j2 + 1];\n              }\n            } else {\n              var projectedLeft, projectedRight;\n              switch (opt) {\n                case 0:\n                  displacementVector = countVector(pointD, dragCoordinate);\n                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointC, pointD));\n                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointA, pointD));\n                  [g2[0], g2[1]] = movePoint(pointA, projectedLeft);\n                  [g2[4], g2[5]] = movePoint(pointC, projectedRight);\n                  [g2[6], g2[7]] = movePoint(pointD, displacementVector);\n                  [g2[8], g2[9]] = movePoint(pointA1, projectedLeft);\n                  break;\n                case 1:\n                  displacementVector = countVector(pointA, dragCoordinate);\n                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointD, pointA));\n                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointB, pointA));\n                  [g2[0], g2[1]] = movePoint(pointA, displacementVector);\n                  [g2[2], g2[3]] = movePoint(pointB, projectedLeft);\n                  [g2[6], g2[7]] = movePoint(pointD, projectedRight);\n                  [g2[8], g2[9]] = movePoint(pointA1, displacementVector);\n                  break;\n                case 2:\n                  displacementVector = countVector(pointB, dragCoordinate);\n                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointA, pointB));\n                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointC, pointB));\n                  [g2[0], g2[1]] = movePoint(pointA, projectedRight);\n                  [g2[2], g2[3]] = movePoint(pointB, displacementVector);\n                  [g2[4], g2[5]] = movePoint(pointC, projectedLeft);\n                  [g2[8], g2[9]] = movePoint(pointA1, projectedRight);\n                  break;\n                case 3:\n                  displacementVector = countVector(pointC, dragCoordinate);\n                  projectedLeft = projectVectorOnVector(displacementVector, countVector(pointB, pointC));\n                  projectedRight = projectVectorOnVector(displacementVector, countVector(pointD, pointC));\n                  [g2[2], g2[3]] = movePoint(pointB, projectedRight);\n                  [g2[4], g2[5]] = movePoint(pointC, displacementVector);\n                  [g2[6], g2[7]] = movePoint(pointD, projectedLeft);\n                  break;\n              }\n            }\n          }\n          if (geometry.getType() == \"Circle\")\n            geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());\n          return g2;\n        });\n        if (this.get(\"enableRotatedTransform\") && viewRotation !== 0) {\n          geometry.rotate(viewRotation, this.getMap().getView().getCenter());\n        }\n        f2.setGeometry(geometry);\n      }\n      this.drawSketch_();\n      this.dispatchEvent({\n        type: \"scaling\",\n        feature: this.selection_.item(0),\n        features: this.selection_,\n        scale: [scx, scy],\n        pixel: evt.pixel,\n        coordinate: evt.coordinate\n      });\n      break;\n    }\n  }\n  this.isUpdating_ = false;\n};\nol_interaction_Transform.prototype.handleMoveEvent_ = function(evt) {\n  if (!this._handleEvent(evt, this.features_))\n    return;\n  if (!this.mode_) {\n    var sel = this.getFeatureAtPixel_(evt.pixel);\n    var element = evt.map.getTargetElement();\n    if (sel.feature) {\n      var c2 = sel.handle ? this.Cursors[(sel.handle || \"default\") + (sel.constraint || \"\") + (sel.option || \"\")] : this.Cursors.select;\n      if (this.previousCursor_ === void 0) {\n        this.previousCursor_ = element.style.cursor;\n      }\n      element.style.cursor = c2;\n    } else {\n      if (this.previousCursor_ !== void 0)\n        element.style.cursor = this.previousCursor_;\n      this.previousCursor_ = void 0;\n    }\n  }\n};\nol_interaction_Transform.prototype.handleUpEvent_ = function(evt) {\n  if (this.mode_ === \"rotate\") {\n    var element = evt.map.getTargetElement();\n    element.style.cursor = this.Cursors.default;\n    this.previousCursor_ = void 0;\n  }\n  this.dispatchEvent({\n    type: this.mode_ + \"end\",\n    feature: this.selection_.item(0),\n    features: this.selection_,\n    oldgeom: this.geoms_[0],\n    oldgeoms: this.geoms_\n  });\n  this.drawSketch_();\n  this.mode_ = null;\n  return false;\n};\nol_interaction_Transform.prototype.getFeatures = function() {\n  return this.selection_;\n};\nconst _sfc_main$9 = {\n  name: \"ol-interaction-transform\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let transform2 = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let interaction = new ol_interaction_Transform(__spreadValues({}, properties));\n      return interaction;\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(transform2, (newVal, oldVal) => {\n      map.removeInteraction(oldVal);\n      map.addInteraction(newVal);\n      map.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addInteraction(transform2.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeInteraction(transform2.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"stylable\", transform2);\n  },\n  props: {\n    enableRotatedTransform: {\n      type: Boolean,\n      default: false\n    },\n    condition: {\n      type: Function\n    },\n    addCondition: {\n      type: Function\n    },\n    filter: {\n      type: Function\n    },\n    layers: {\n      type: Array\n    },\n    hitTolerance: {\n      type: Number,\n      default: 2\n    },\n    translateFeature: {\n      type: Boolean,\n      default: true\n    },\n    scale: {\n      type: Boolean,\n      default: true\n    },\n    rotate: {\n      type: Boolean,\n      default: true\n    },\n    keepAspectRatio: {\n      type: Boolean,\n      default: false\n    },\n    translate: {\n      type: Boolean,\n      default: true\n    },\n    stretch: {\n      type: Boolean,\n      default: true\n    }\n  }\n};\nfunction _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar TransformInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$9, [[\"render\", _sfc_render$9]]);\nconst _sfc_main$8 = {\n  name: \"ol-interaction-dragrotatezoom\",\n  setup(props) {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const {\n      properties\n    } = usePropsAsObjectProperties(props);\n    let dragrotatezoom = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n      let s2 = new DragRotateAndZoom$1(__spreadValues({}, properties));\n      return s2;\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(dragrotatezoom, (newVal, oldVal) => {\n      map.removeInteraction(oldVal);\n      map.addInteraction(newVal);\n      map.changed();\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n      map.addInteraction(dragrotatezoom.value);\n    });\n    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {\n      map.removeInteraction(dragrotatezoom.value);\n    });\n  },\n  props: {\n    condition: {\n      type: Function\n    },\n    duration: {\n      type: Number,\n      default: 400\n    }\n  }\n};\nfunction _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar DragRotateAndZoomInteraction = /* @__PURE__ */ _export_sfc(_sfc_main$8, [[\"render\", _sfc_render$8]]);\nfunction install$2(app) {\n  if (install$2.installed) {\n    return;\n  }\n  install$2.installed = true;\n  app.component(SelectInteraction.name, SelectInteraction);\n  app.component(ClusterSelectInteraction.name, ClusterSelectInteraction);\n  app.component(DrawInteraction.name, DrawInteraction);\n  app.component(SnapInteraction.name, SnapInteraction);\n  app.component(ModifyInteraction.name, ModifyInteraction);\n  app.component(TransformInteraction.name, TransformInteraction);\n  app.component(DragRotateAndZoomInteraction.name, DragRotateAndZoomInteraction);\n}\nvar Interactions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": install$2,\n  install: install$2,\n  SelectInteraction,\n  ClusterSelectInteraction,\n  DrawInteraction,\n  SnapInteraction,\n  ModifyInteraction,\n  TransformInteraction,\n  DragRotateAndZoomInteraction\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst _sfc_main$7 = {\n  setup() {\n    const map = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"map\");\n    const vectorLayer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(\"vectorLayer\");\n    return {\n      map,\n      vectorLayer\n    };\n  },\n  props: {\n    duration: {\n      type: Number,\n      default: 1e3\n    },\n    revers: {\n      type: Boolean,\n      default: false\n    },\n    repeat: {\n      type: Number,\n      default: 0\n    },\n    fade: {\n      type: Function\n    },\n    easing: {\n      type: Function,\n      default: easeOut\n    }\n  }\n};\nfunction _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar FeatureAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$7, [[\"render\", _sfc_render$7]]);\nvar ol_featureAnimation = function(options) {\n  options = options || {};\n  this.duration_ = typeof options.duration == \"number\" ? options.duration >= 0 ? options.duration : 0 : 1e3;\n  this.fade_ = typeof options.fade == \"function\" ? options.fade : null;\n  this.repeat_ = Number(options.repeat);\n  var easing = typeof options.easing == \"function\" ? options.easing : linear;\n  if (options.revers)\n    this.easing_ = function(t3) {\n      return 1 - easing(t3);\n    };\n  else\n    this.easing_ = easing;\n  this.hiddenStyle = options.hiddenStyle;\n  ol_Object.call(this);\n};\nol_ext_inherits(ol_featureAnimation, ol_Object);\nol_featureAnimation.hiddenStyle = new Style$2({\n  image: new ol_style_Circle({}),\n  stroke: new Stroke$2({\n    color: \"transparent\"\n  })\n});\nol_featureAnimation.prototype.drawGeom_ = function(e2, geom2, shadow) {\n  if (this.fade_) {\n    e2.context.globalAlpha = this.fade_(1 - e2.elapsed);\n  }\n  var style2 = e2.style;\n  for (var i2 = 0; i2 < style2.length; i2++) {\n    try {\n      var vectorContext = e2.vectorContext || getVectorContext(e2);\n      var s2 = ol_ext_getVectorContextStyle(e2, style2[i2]);\n      vectorContext.setStyle(s2);\n      if (s2.getZIndex() < 0)\n        vectorContext.drawGeometry(shadow || geom2);\n      else\n        vectorContext.drawGeometry(geom2);\n    } catch (e3) {\n    }\n  }\n};\nol_featureAnimation.prototype.animate = function() {\n  return false;\n};\nol_Map.prototype.animateFeature = function(feature2, fanim) {\n  var layer = this._featureAnimationLayer;\n  if (!layer) {\n    layer = this._featureAnimationLayer = new ol_layer_Vector({ source: new ol_source_Vector() });\n    layer.setMap(this);\n  }\n  layer.getSource().addFeature(feature2);\n  var listener2 = fanim.on(\"animationend\", function(e2) {\n    if (e2.feature === feature2) {\n      layer.getSource().removeFeature(feature2);\n      unByKey(listener2);\n    }\n  });\n  layer.animateFeature(feature2, fanim);\n};\nol_layer_Base$1.prototype.animateFeature = function(feature2, fanim, useFilter) {\n  var self2 = this;\n  var listenerKey;\n  var style2 = feature2.getStyle();\n  var flashStyle = style2 || (this.getStyleFunction ? this.getStyleFunction()(feature2) : null);\n  if (!flashStyle)\n    flashStyle = [];\n  if (!(flashStyle instanceof Array))\n    flashStyle = [flashStyle];\n  var event = {\n    vectorContext: null,\n    frameState: null,\n    start: 0,\n    time: 0,\n    elapsed: 0,\n    extent: false,\n    feature: feature2,\n    geom: feature2.getGeometry(),\n    typeGeom: feature2.getGeometry().getType(),\n    bbox: feature2.getGeometry().getExtent(),\n    coord: getCenter(feature2.getGeometry().getExtent()),\n    style: flashStyle\n  };\n  if (!(fanim instanceof Array))\n    fanim = [fanim];\n  for (var i2 = fanim.length - 1; i2 >= 0; i2--) {\n    if (fanim[i2].duration_ === 0)\n      fanim.splice(i2, 1);\n  }\n  var nb = 0, step = 0;\n  var filters = useFilter && this.getFilters ? this.getFilters() : [];\n  function animate(e2) {\n    event.type = e2.type;\n    try {\n      event.vectorContext = e2.vectorContext || getVectorContext(e2);\n    } catch (e3) {\n    }\n    event.frameState = e2.frameState;\n    event.inversePixelTransform = e2.inversePixelTransform;\n    if (!event.extent) {\n      event.extent = e2.frameState.extent;\n      event.start = e2.frameState.time;\n      event.context = e2.context;\n    }\n    event.time = e2.frameState.time - event.start;\n    event.elapsed = event.time / fanim[step].duration_;\n    if (event.elapsed > 1)\n      event.elapsed = 1;\n    e2.context.save();\n    filters.forEach(function(f2) {\n      if (f2.get(\"active\"))\n        f2.precompose(e2);\n    });\n    if (this.getOpacity) {\n      e2.context.globalAlpha = this.getOpacity();\n    }\n    if (!fanim[step].animate(event)) {\n      nb++;\n      if (nb < fanim[step].repeat_) {\n        event.extent = false;\n      } else if (step < fanim.length - 1) {\n        fanim[step].dispatchEvent({ type: \"animationend\", feature: feature2 });\n        step++;\n        nb = 0;\n        event.extent = false;\n      } else {\n        stop();\n      }\n    } else {\n      var animEvent = {\n        type: \"animating\",\n        step,\n        start: event.start,\n        time: event.time,\n        elapsed: event.elapsed,\n        rotation: event.rotation || 0,\n        geom: event.geom,\n        coordinate: event.coord,\n        feature: feature2\n      };\n      fanim[step].dispatchEvent(animEvent);\n      self2.dispatchEvent(animEvent);\n    }\n    filters.forEach(function(f2) {\n      if (f2.get(\"active\"))\n        f2.postcompose(e2);\n    });\n    e2.context.restore();\n    e2.frameState.animate = true;\n  }\n  function stop(options) {\n    unByKey(listenerKey);\n    listenerKey = null;\n    feature2.setStyle(style2);\n    var event2 = { type: \"animationend\", feature: feature2 };\n    if (options) {\n      for (var i3 in options)\n        if (options.hasOwnProperty(i3)) {\n          event2[i3] = options[i3];\n        }\n    }\n    fanim[step].dispatchEvent(event2);\n    self2.dispatchEvent(event2);\n  }\n  function start2(options) {\n    if (fanim.length && !listenerKey) {\n      listenerKey = self2.on([\"postcompose\", \"postrender\"], animate.bind(self2));\n      if (self2.renderSync) {\n        try {\n          self2.renderSync();\n        } catch (e2) {\n        }\n      } else {\n        self2.changed();\n      }\n      feature2.setStyle(fanim[step].hiddenStyle || ol_featureAnimation.hiddenStyle);\n      var event2 = { type: \"animationstart\", feature: feature2 };\n      if (options) {\n        for (var i3 in options)\n          if (options.hasOwnProperty(i3)) {\n            event2[i3] = options[i3];\n          }\n      }\n      fanim[step].dispatchEvent(event2);\n      self2.dispatchEvent(event2);\n    }\n  }\n  start2();\n  return {\n    start: start2,\n    stop,\n    isPlaying: function() {\n      return !!listenerKey;\n    }\n  };\n};\nvar ol_featureAnimation_Drop = function(options) {\n  options = options || {};\n  this.speed_ = options.speed || 0;\n  ol_featureAnimation.call(this, options);\n  this.side_ = options.side || \"top\";\n};\nol_ext_inherits(ol_featureAnimation_Drop, ol_featureAnimation);\nol_featureAnimation_Drop.prototype.animate = function(e2) {\n  if (!e2.time) {\n    var angle2 = e2.frameState.viewState.rotation;\n    var s2 = e2.frameState.size[1] * e2.frameState.viewState.resolution;\n    if (this.side_ != \"top\")\n      s2 *= -1;\n    this.dx = -Math.sin(angle2) * s2;\n    this.dy = Math.cos(angle2) * s2;\n    if (this.speed_) {\n      this.duration_ = s2 / this.speed_ / e2.frameState.viewState.resolution;\n    }\n  }\n  var flashGeom = e2.geom.clone();\n  flashGeom.translate(this.dx * (1 - this.easing_(e2.elapsed)), this.dy * (1 - this.easing_(e2.elapsed)));\n  this.drawGeom_(e2, flashGeom, e2.geom);\n  return e2.time <= this.duration_;\n};\nfunction useAnimation(AnimationType, props) {\n  const {\n    map,\n    vectorLayer\n  } = FeatureAnimation.setup();\n  const {\n    properties\n  } = usePropsAsObjectProperties(props);\n  const animation = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {\n    let anim = new AnimationType(__spreadValues({}, properties));\n    return anim;\n  });\n  (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(\"animation\", animation);\n  return {\n    map,\n    vectorLayer,\n    animation,\n    properties\n  };\n}\nconst _sfc_main$6 = {\n  name: \"ol-animation-drop\",\n  extends: FeatureAnimation,\n  setup(props) {\n    const {\n      map,\n      vectorLayer,\n      properties\n    } = useAnimation(ol_featureAnimation_Drop, props);\n    return {\n      map,\n      vectorLayer,\n      properties\n    };\n  },\n  props: {\n    side: {\n      type: Number,\n      default: 0\n    },\n    speed: {\n      type: Number,\n      default: 0\n    }\n  }\n};\nfunction _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar DropAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$6, [[\"render\", _sfc_render$6]]);\nvar ol_featureAnimation_Shake = function(options) {\n  options = options || {};\n  ol_featureAnimation.call(this, options);\n  this.amplitude_ = options.amplitude || 40;\n  this.bounce_ = -Math.PI * (options.bounce || 6);\n  this.horizontal_ = options.horizontal;\n};\nol_ext_inherits(ol_featureAnimation_Shake, ol_featureAnimation);\nol_featureAnimation_Shake.prototype.animate = function(e2) {\n  var flashGeom = e2.geom.clone();\n  var shadow = e2.geom.clone();\n  var t3 = this.easing_(e2.elapsed);\n  t3 = Math.sin(this.bounce_ * t3) * this.amplitude_ * (1 - t3) * e2.frameState.viewState.resolution;\n  if (this.horizontal_) {\n    flashGeom.translate(t3, 0);\n    shadow.translate(t3, 0);\n  } else\n    flashGeom.translate(0, t3);\n  this.drawGeom_(e2, flashGeom, shadow);\n  return e2.time <= this.duration_;\n};\nconst _sfc_main$5 = {\n  name: \"ol-animation-shake\",\n  extends: FeatureAnimation,\n  setup(props) {\n    const {\n      map,\n      vectorLayer,\n      properties,\n      animation\n    } = useAnimation(ol_featureAnimation_Shake, props);\n    return {\n      map,\n      vectorLayer,\n      properties,\n      animation\n    };\n  },\n  props: {\n    bounce: {\n      type: Number,\n      default: 6\n    },\n    amplitude: {\n      type: Number,\n      default: 40\n    },\n    horizontal: {\n      type: Boolean,\n      default: false\n    }\n  }\n};\nfunction _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar ShakeAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$5, [[\"render\", _sfc_render$5]]);\nvar ol_featureAnimation_Zoom = function(options) {\n  options = options || {};\n  ol_featureAnimation.call(this, options);\n  this.set(\"zoomout\", options.zoomOut);\n};\nol_ext_inherits(ol_featureAnimation_Zoom, ol_featureAnimation);\nvar ol_featureAnimation_ZoomOut = function(options) {\n  options = options || {};\n  options.zoomOut = true;\n  ol_featureAnimation_Zoom.call(this, options);\n};\nol_ext_inherits(ol_featureAnimation_ZoomOut, ol_featureAnimation_Zoom);\nol_featureAnimation_Zoom.prototype.animate = function(e2) {\n  var fac = this.easing_(e2.elapsed);\n  if (fac) {\n    if (this.get(\"zoomout\"))\n      fac = 1 / fac;\n    var style2 = e2.style;\n    var i2, imgs, sc = [];\n    for (i2 = 0; i2 < style2.length; i2++) {\n      imgs = style2[i2].getImage();\n      if (imgs) {\n        sc[i2] = imgs.getScale();\n        if (e2.type === \"postrender\")\n          imgs.setScale(sc[i2] * fac / e2.frameState.pixelRatio);\n        else\n          imgs.setScale(sc[i2] * fac);\n      }\n    }\n    this.drawGeom_(e2, e2.geom);\n    for (i2 = 0; i2 < style2.length; i2++) {\n      imgs = style2[i2].getImage();\n      if (imgs)\n        imgs.setScale(sc[i2]);\n    }\n  }\n  return e2.time <= this.duration_;\n};\nconst _sfc_main$4 = {\n  name: \"ol-animation-zoom\",\n  extends: FeatureAnimation,\n  setup(props) {\n    const {\n      map,\n      vectorLayer,\n      properties\n    } = useAnimation(ol_featureAnimation_Zoom, props);\n    return {\n      map,\n      vectorLayer,\n      properties\n    };\n  },\n  props: {\n    zoomOut: {\n      type: Boolean,\n      default: false\n    }\n  }\n};\nfunction _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar ZoomAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$4, [[\"render\", _sfc_render$4]]);\nvar ol_featureAnimation_Teleport = function(options) {\n  ol_featureAnimation.call(this, options);\n};\nol_ext_inherits(ol_featureAnimation_Teleport, ol_featureAnimation);\nol_featureAnimation_Teleport.prototype.animate = function(e2) {\n  var sc = this.easing_(e2.elapsed);\n  if (sc) {\n    e2.context.save();\n    var ratio = e2.frameState.pixelRatio;\n    e2.context.globalAlpha = sc;\n    e2.context.scale(sc, 1 / sc);\n    var m2 = e2.frameState.coordinateToPixelTransform;\n    var dx = (1 / sc - 1) * ratio * (m2[0] * e2.coord[0] + m2[1] * e2.coord[1] + m2[4]);\n    var dy = (sc - 1) * ratio * (m2[2] * e2.coord[0] + m2[3] * e2.coord[1] + m2[5]);\n    e2.context.translate(dx, dy);\n    this.drawGeom_(e2, e2.geom);\n    e2.context.restore();\n  }\n  return e2.time <= this.duration_;\n};\nconst _sfc_main$3 = {\n  name: \"ol-animation-teleport\",\n  extends: FeatureAnimation,\n  setup(props) {\n    const {\n      map,\n      vectorLayer,\n      properties\n    } = useAnimation(ol_featureAnimation_Teleport, props);\n    return {\n      map,\n      vectorLayer,\n      properties\n    };\n  },\n  props: {}\n};\nfunction _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar TeleportAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$3, [[\"render\", _sfc_render$3]]);\nvar ol_featureAnimation_Fade = function(options) {\n  options = options || {};\n  this.speed_ = options.speed || 0;\n  ol_featureAnimation.call(this, options);\n};\nol_ext_inherits(ol_featureAnimation_Fade, ol_featureAnimation);\nol_featureAnimation_Fade.prototype.animate = function(e2) {\n  e2.context.globalAlpha = this.easing_(e2.elapsed);\n  this.drawGeom_(e2, e2.geom);\n  return e2.time <= this.duration_;\n};\nconst _sfc_main$2 = {\n  name: \"ol-animation-fade\",\n  extends: FeatureAnimation,\n  setup(props) {\n    const {\n      map,\n      vectorLayer,\n      properties\n    } = useAnimation(ol_featureAnimation_Fade, props);\n    return {\n      map,\n      vectorLayer,\n      properties\n    };\n  }\n};\nfunction _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar FadeAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$2, [[\"render\", _sfc_render$2]]);\nvar ol_featureAnimation_Slide = function(options) {\n  options = options || {};\n  this.speed_ = options.speed || 0;\n  ol_featureAnimation.call(this, options);\n  this.side_ = options.side || \"left\";\n};\nol_ext_inherits(ol_featureAnimation_Slide, ol_featureAnimation);\nol_featureAnimation_Slide.prototype.animate = function(e2) {\n  if (!e2.time) {\n    if (this.side_ == \"left\")\n      this.dx = e2.extent[0] - e2.bbox[2];\n    else\n      this.dx = e2.extent[2] - e2.bbox[0];\n    if (this.speed_)\n      this.duration_ = Math.abs(this.dx) / this.speed_ / e2.frameState.viewState.resolution;\n  }\n  var flashGeom = e2.geom.clone();\n  flashGeom.translate(this.dx * (1 - this.easing_(e2.elapsed)), 0);\n  this.drawGeom_(e2, flashGeom);\n  return e2.time <= this.duration_;\n};\nconst _sfc_main$1 = {\n  name: \"ol-animation-slide\",\n  extends: FeatureAnimation,\n  setup(props) {\n    const {\n      map,\n      vectorLayer,\n      properties\n    } = useAnimation(ol_featureAnimation_Slide, props);\n    return {\n      map,\n      vectorLayer,\n      properties\n    };\n  },\n  props: {\n    speed: {\n      type: Number,\n      default: 0\n    }\n  }\n};\nfunction _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar SlideAnimation = /* @__PURE__ */ _export_sfc(_sfc_main$1, [[\"render\", _sfc_render$1]]);\nvar ol_featureAnimation_Path = function(options) {\n  options = options || {};\n  ol_featureAnimation.call(this, options);\n  this.speed_ = options.speed || 0;\n  this.path_ = options.path;\n  switch (options.rotate) {\n    case true:\n    case 0:\n      this.rotate_ = 0;\n      break;\n    default:\n      this.rotate_ = options.rotate || false;\n      break;\n  }\n  if (this.path_ && this.path_.getGeometry)\n    this.path_ = this.path_.getGeometry();\n  if (this.path_ && this.path_.getLineString)\n    this.path_ = this.path_.getLineString();\n  if (this.path_.getLength) {\n    this.dist_ = this.path_.getLength();\n    if (this.path_ && this.path_.getCoordinates)\n      this.path_ = this.path_.getCoordinates();\n  } else {\n    this.dist_ = 0;\n  }\n  if (this.speed_ > 0)\n    this.duration_ = this.dist_ / this.speed_;\n};\nol_ext_inherits(ol_featureAnimation_Path, ol_featureAnimation);\nol_featureAnimation_Path.prototype.animate = function(e2) {\n  if (!e2.time) {\n    if (!this.dist_)\n      return false;\n  }\n  var dmax = this.dist_ * this.easing_(e2.elapsed);\n  var p0, p5, s2, dx, dy, dl, d2 = 0;\n  p5 = this.path_[0];\n  for (var i2 = 1; i2 < this.path_.length; i2++) {\n    p0 = p5;\n    p5 = this.path_[i2];\n    dx = p5[0] - p0[0];\n    dy = p5[1] - p0[1];\n    dl = Math.sqrt(dx * dx + dy * dy);\n    if (dl && d2 + dl >= dmax) {\n      s2 = (dmax - d2) / dl;\n      p5 = [p0[0] + (p5[0] - p0[0]) * s2, p0[1] + (p5[1] - p0[1]) * s2];\n      break;\n    }\n    d2 += dl;\n  }\n  var style2 = e2.style;\n  e2.rotation = Math.PI / 2 + Math.atan2(p0[1] - p5[1], p0[0] - p5[0]);\n  if (this.rotate_ !== false) {\n    var st2 = [];\n    var angle2 = this.rotate_ - e2.rotation + e2.frameState.viewState.rotation;\n    e2.rotation = Math.PI / 2 + Math.atan2(p0[1] - p5[1], p0[0] - p5[0]);\n    for (var k2 = 0; s2 = e2.style[k2]; k2++) {\n      if (s2.getImage()) {\n        s2.getImage().setRotation(angle2);\n      }\n      st2.push(s2);\n    }\n    e2.style = st2;\n  }\n  e2.geom.setCoordinates(p5);\n  this.drawGeom_(e2, e2.geom);\n  e2.style = style2;\n  return e2.time <= this.duration_;\n};\nconst _sfc_main = {\n  name: \"ol-animation-path\",\n  extends: FeatureAnimation,\n  setup(props) {\n    const {\n      map,\n      vectorLayer,\n      properties\n    } = useAnimation(ol_featureAnimation_Path, props);\n    return {\n      map,\n      vectorLayer,\n      properties\n    };\n  },\n  props: {\n    rotate: {\n      type: Boolean,\n      default: false\n    },\n    speed: {\n      type: Number,\n      default: 0\n    },\n    path: {\n      type: Object\n    }\n  }\n};\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot)(_ctx.$slots, \"default\");\n}\nvar PathAnimation = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\nfunction install$1(app) {\n  if (install$1.installed) {\n    return;\n  }\n  install$1.installed = true;\n  app.component(FeatureAnimation.name, FeatureAnimation);\n  app.component(DropAnimation.name, DropAnimation);\n  app.component(ShakeAnimation.name, ShakeAnimation);\n  app.component(ZoomAnimation.name, ZoomAnimation);\n  app.component(TeleportAnimation.name, TeleportAnimation);\n  app.component(FadeAnimation.name, FadeAnimation);\n  app.component(SlideAnimation.name, SlideAnimation);\n  app.component(PathAnimation.name, PathAnimation);\n}\nvar Animations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": install$1,\n  install: install$1,\n  FeatureAnimation,\n  DropAnimation,\n  ShakeAnimation,\n  ZoomAnimation,\n  TeleportAnimation,\n  FadeAnimation,\n  PathAnimation,\n  SlideAnimation\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar ol$1 = \"\";\nvar olExt = \"\";\nvar olContextmenu = \"\";\nvar style = \"\";\nvar __extends$q = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar GeometryCollection = function(_super) {\n  __extends$q(GeometryCollection2, _super);\n  function GeometryCollection2(opt_geometries) {\n    var _this = _super.call(this) || this;\n    _this.geometries_ = opt_geometries ? opt_geometries : null;\n    _this.changeEventsKeys_ = [];\n    _this.listenGeometriesChange_();\n    return _this;\n  }\n  GeometryCollection2.prototype.unlistenGeometriesChange_ = function() {\n    this.changeEventsKeys_.forEach(unlistenByKey);\n    this.changeEventsKeys_.length = 0;\n  };\n  GeometryCollection2.prototype.listenGeometriesChange_ = function() {\n    if (!this.geometries_) {\n      return;\n    }\n    for (var i2 = 0, ii = this.geometries_.length; i2 < ii; ++i2) {\n      this.changeEventsKeys_.push(listen(this.geometries_[i2], EventType.CHANGE, this.changed, this));\n    }\n  };\n  GeometryCollection2.prototype.clone = function() {\n    var geometryCollection = new GeometryCollection2(null);\n    geometryCollection.setGeometries(this.geometries_);\n    geometryCollection.applyProperties(this);\n    return geometryCollection;\n  };\n  GeometryCollection2.prototype.closestPointXY = function(x2, y2, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {\n      return minSquaredDistance;\n    }\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      minSquaredDistance = geometries[i2].closestPointXY(x2, y2, closestPoint, minSquaredDistance);\n    }\n    return minSquaredDistance;\n  };\n  GeometryCollection2.prototype.containsXY = function(x2, y2) {\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      if (geometries[i2].containsXY(x2, y2)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  GeometryCollection2.prototype.computeExtent = function(extent2) {\n    createOrUpdateEmpty(extent2);\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      extend$2(extent2, geometries[i2].getExtent());\n    }\n    return extent2;\n  };\n  GeometryCollection2.prototype.getGeometries = function() {\n    return cloneGeometries(this.geometries_);\n  };\n  GeometryCollection2.prototype.getGeometriesArray = function() {\n    return this.geometries_;\n  };\n  GeometryCollection2.prototype.getGeometriesArrayRecursive = function() {\n    var geometriesArray = [];\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      if (geometries[i2].getType() === this.getType()) {\n        geometriesArray = geometriesArray.concat(geometries[i2].getGeometriesArrayRecursive());\n      } else {\n        geometriesArray.push(geometries[i2]);\n      }\n    }\n    return geometriesArray;\n  };\n  GeometryCollection2.prototype.getSimplifiedGeometry = function(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {\n      return this;\n    }\n    var simplifiedGeometries = [];\n    var geometries = this.geometries_;\n    var simplified = false;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      var geometry = geometries[i2];\n      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      var simplifiedGeometryCollection = new GeometryCollection2(null);\n      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n      return simplifiedGeometryCollection;\n    } else {\n      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n      return this;\n    }\n  };\n  GeometryCollection2.prototype.getType = function() {\n    return GeometryType.GEOMETRY_COLLECTION;\n  };\n  GeometryCollection2.prototype.intersectsExtent = function(extent2) {\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      if (geometries[i2].intersectsExtent(extent2)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  GeometryCollection2.prototype.isEmpty = function() {\n    return this.geometries_.length === 0;\n  };\n  GeometryCollection2.prototype.rotate = function(angle2, anchor) {\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      geometries[i2].rotate(angle2, anchor);\n    }\n    this.changed();\n  };\n  GeometryCollection2.prototype.scale = function(sx, opt_sy, opt_anchor) {\n    var anchor = opt_anchor;\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      geometries[i2].scale(sx, opt_sy, anchor);\n    }\n    this.changed();\n  };\n  GeometryCollection2.prototype.setGeometries = function(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  };\n  GeometryCollection2.prototype.setGeometriesArray = function(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  };\n  GeometryCollection2.prototype.applyTransform = function(transformFn) {\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      geometries[i2].applyTransform(transformFn);\n    }\n    this.changed();\n  };\n  GeometryCollection2.prototype.translate = function(deltaX, deltaY) {\n    var geometries = this.geometries_;\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      geometries[i2].translate(deltaX, deltaY);\n    }\n    this.changed();\n  };\n  GeometryCollection2.prototype.disposeInternal = function() {\n    this.unlistenGeometriesChange_();\n    _super.prototype.disposeInternal.call(this);\n  };\n  return GeometryCollection2;\n}(Geometry$1);\nfunction cloneGeometries(geometries) {\n  var clonedGeometries = [];\n  for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n    clonedGeometries.push(geometries[i2].clone());\n  }\n  return clonedGeometries;\n}\nvar GeometryCollection$1 = GeometryCollection;\nvar geom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Circle: ol_geom_Circle,\n  Geometry: Geometry$1,\n  GeometryCollection: GeometryCollection$1,\n  LinearRing: LinearRing$1,\n  LineString: LineString$2,\n  MultiLineString: MultiLineString$2,\n  MultiPoint: MultiPoint$2,\n  MultiPolygon: MultiPolygon$2,\n  Point: Point$4,\n  Polygon: Polygon$2,\n  SimpleGeometry: SimpleGeometry$1\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar FeatureFormat = function() {\n  function FeatureFormat2() {\n    this.dataProjection = void 0;\n    this.defaultFeatureProjection = void 0;\n    this.supportedMediaTypes = null;\n  }\n  FeatureFormat2.prototype.getReadOptions = function(source, opt_options) {\n    var options;\n    if (opt_options) {\n      var dataProjection = opt_options.dataProjection ? get$3(opt_options.dataProjection) : this.readProjection(source);\n      if (opt_options.extent && dataProjection && dataProjection.getUnits() === Units$2.TILE_PIXELS) {\n        dataProjection = get$3(dataProjection);\n        dataProjection.setWorldExtent(opt_options.extent);\n      }\n      options = {\n        dataProjection,\n        featureProjection: opt_options.featureProjection\n      };\n    }\n    return this.adaptOptions(options);\n  };\n  FeatureFormat2.prototype.adaptOptions = function(options) {\n    return assign({\n      dataProjection: this.dataProjection,\n      featureProjection: this.defaultFeatureProjection\n    }, options);\n  };\n  FeatureFormat2.prototype.getType = function() {\n    return abstract();\n  };\n  FeatureFormat2.prototype.readFeature = function(source, opt_options) {\n    return abstract();\n  };\n  FeatureFormat2.prototype.readFeatures = function(source, opt_options) {\n    return abstract();\n  };\n  FeatureFormat2.prototype.readGeometry = function(source, opt_options) {\n    return abstract();\n  };\n  FeatureFormat2.prototype.readProjection = function(source) {\n    return abstract();\n  };\n  FeatureFormat2.prototype.writeFeature = function(feature2, opt_options) {\n    return abstract();\n  };\n  FeatureFormat2.prototype.writeFeatures = function(features, opt_options) {\n    return abstract();\n  };\n  FeatureFormat2.prototype.writeGeometry = function(geometry, opt_options) {\n    return abstract();\n  };\n  return FeatureFormat2;\n}();\nvar FeatureFormat$1 = FeatureFormat;\nfunction transformGeometryWithOptions(geometry, write, opt_options) {\n  var featureProjection = opt_options ? get$3(opt_options.featureProjection) : null;\n  var dataProjection = opt_options ? get$3(opt_options.dataProjection) : null;\n  var transformed;\n  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {\n    transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);\n  } else {\n    transformed = geometry;\n  }\n  if (write && opt_options && opt_options.decimals !== void 0) {\n    var power_1 = Math.pow(10, opt_options.decimals);\n    var transform2 = function(coordinates2) {\n      for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {\n        coordinates2[i2] = Math.round(coordinates2[i2] * power_1) / power_1;\n      }\n      return coordinates2;\n    };\n    if (transformed === geometry) {\n      transformed = geometry.clone();\n    }\n    transformed.applyTransform(transform2);\n  }\n  return transformed;\n}\nfunction transformExtentWithOptions(extent2, opt_options) {\n  var featureProjection = opt_options ? get$3(opt_options.featureProjection) : null;\n  var dataProjection = opt_options ? get$3(opt_options.dataProjection) : null;\n  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {\n    return transformExtent(extent2, dataProjection, featureProjection);\n  } else {\n    return extent2;\n  }\n}\nvar __extends$p = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar JSONFeature = function(_super) {\n  __extends$p(JSONFeature2, _super);\n  function JSONFeature2() {\n    return _super.call(this) || this;\n  }\n  JSONFeature2.prototype.getType = function() {\n    return FormatType.JSON;\n  };\n  JSONFeature2.prototype.readFeature = function(source, opt_options) {\n    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));\n  };\n  JSONFeature2.prototype.readFeatures = function(source, opt_options) {\n    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));\n  };\n  JSONFeature2.prototype.readFeatureFromObject = function(object, opt_options) {\n    return abstract();\n  };\n  JSONFeature2.prototype.readFeaturesFromObject = function(object, opt_options) {\n    return abstract();\n  };\n  JSONFeature2.prototype.readGeometry = function(source, opt_options) {\n    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));\n  };\n  JSONFeature2.prototype.readGeometryFromObject = function(object, opt_options) {\n    return abstract();\n  };\n  JSONFeature2.prototype.readProjection = function(source) {\n    return this.readProjectionFromObject(getObject(source));\n  };\n  JSONFeature2.prototype.readProjectionFromObject = function(object) {\n    return abstract();\n  };\n  JSONFeature2.prototype.writeFeature = function(feature2, opt_options) {\n    return JSON.stringify(this.writeFeatureObject(feature2, opt_options));\n  };\n  JSONFeature2.prototype.writeFeatureObject = function(feature2, opt_options) {\n    return abstract();\n  };\n  JSONFeature2.prototype.writeFeatures = function(features, opt_options) {\n    return JSON.stringify(this.writeFeaturesObject(features, opt_options));\n  };\n  JSONFeature2.prototype.writeFeaturesObject = function(features, opt_options) {\n    return abstract();\n  };\n  JSONFeature2.prototype.writeGeometry = function(geometry, opt_options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));\n  };\n  JSONFeature2.prototype.writeGeometryObject = function(geometry, opt_options) {\n    return abstract();\n  };\n  return JSONFeature2;\n}(FeatureFormat$1);\nfunction getObject(source) {\n  if (typeof source === \"string\") {\n    var object = JSON.parse(source);\n    return object ? object : null;\n  } else if (source !== null) {\n    return source;\n  } else {\n    return null;\n  }\n}\nvar JSONFeature$1 = JSONFeature;\nvar __extends$o = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar GEOMETRY_READERS$1 = {};\nGEOMETRY_READERS$1[GeometryType.POINT] = readPointGeometry$2;\nGEOMETRY_READERS$1[GeometryType.LINE_STRING] = readLineStringGeometry$2;\nGEOMETRY_READERS$1[GeometryType.POLYGON] = readPolygonGeometry$2;\nGEOMETRY_READERS$1[GeometryType.MULTI_POINT] = readMultiPointGeometry$2;\nGEOMETRY_READERS$1[GeometryType.MULTI_LINE_STRING] = readMultiLineStringGeometry$2;\nGEOMETRY_READERS$1[GeometryType.MULTI_POLYGON] = readMultiPolygonGeometry$2;\nvar GEOMETRY_WRITERS = {};\nGEOMETRY_WRITERS[GeometryType.POINT] = writePointGeometry$1;\nGEOMETRY_WRITERS[GeometryType.LINE_STRING] = writeLineStringGeometry$1;\nGEOMETRY_WRITERS[GeometryType.POLYGON] = writePolygonGeometry$1;\nGEOMETRY_WRITERS[GeometryType.MULTI_POINT] = writeMultiPointGeometry$1;\nGEOMETRY_WRITERS[GeometryType.MULTI_LINE_STRING] = writeMultiLineStringGeometry$1;\nGEOMETRY_WRITERS[GeometryType.MULTI_POLYGON] = writeMultiPolygonGeometry$1;\nvar EsriJSON = function(_super) {\n  __extends$o(EsriJSON2, _super);\n  function EsriJSON2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this) || this;\n    _this.geometryName_ = options.geometryName;\n    return _this;\n  }\n  EsriJSON2.prototype.readFeatureFromObject = function(object, opt_options, opt_idField) {\n    var esriJSONFeature = object;\n    var geometry = readGeometry$1(esriJSONFeature.geometry, opt_options);\n    var feature$1 = new feature();\n    if (this.geometryName_) {\n      feature$1.setGeometryName(this.geometryName_);\n    }\n    feature$1.setGeometry(geometry);\n    if (esriJSONFeature.attributes) {\n      feature$1.setProperties(esriJSONFeature.attributes, true);\n      var id = esriJSONFeature.attributes[opt_idField];\n      if (id !== void 0) {\n        feature$1.setId(id);\n      }\n    }\n    return feature$1;\n  };\n  EsriJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {\n    var options = opt_options ? opt_options : {};\n    if (object[\"features\"]) {\n      var esriJSONFeatureSet = object;\n      var features = [];\n      var esriJSONFeatures = esriJSONFeatureSet.features;\n      for (var i2 = 0, ii = esriJSONFeatures.length; i2 < ii; ++i2) {\n        features.push(this.readFeatureFromObject(esriJSONFeatures[i2], options, object.objectIdFieldName));\n      }\n      return features;\n    } else {\n      return [this.readFeatureFromObject(object, options)];\n    }\n  };\n  EsriJSON2.prototype.readGeometryFromObject = function(object, opt_options) {\n    return readGeometry$1(object, opt_options);\n  };\n  EsriJSON2.prototype.readProjectionFromObject = function(object) {\n    if (object[\"spatialReference\"] && object[\"spatialReference\"][\"wkid\"] !== void 0) {\n      var spatialReference = object[\"spatialReference\"];\n      var crs = spatialReference.wkid;\n      return get$3(\"EPSG:\" + crs);\n    } else {\n      return null;\n    }\n  };\n  EsriJSON2.prototype.writeGeometryObject = function(geometry, opt_options) {\n    return writeGeometry$1(geometry, this.adaptOptions(opt_options));\n  };\n  EsriJSON2.prototype.writeFeatureObject = function(feature2, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var object = {};\n    if (!feature2.hasProperties()) {\n      object[\"attributes\"] = {};\n      return object;\n    }\n    var properties = feature2.getProperties();\n    var geometry = feature2.getGeometry();\n    if (geometry) {\n      object[\"geometry\"] = writeGeometry$1(geometry, opt_options);\n      var projection = opt_options && (opt_options.dataProjection || opt_options.featureProjection);\n      if (projection) {\n        object[\"geometry\"][\"spatialReference\"] = {\n          wkid: Number(get$3(projection).getCode().split(\":\").pop())\n        };\n      }\n      delete properties[feature2.getGeometryName()];\n    }\n    if (!isEmpty(properties)) {\n      object[\"attributes\"] = properties;\n    } else {\n      object[\"attributes\"] = {};\n    }\n    return object;\n  };\n  EsriJSON2.prototype.writeFeaturesObject = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var objects = [];\n    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {\n      objects.push(this.writeFeatureObject(features[i2], opt_options));\n    }\n    return {\n      \"features\": objects\n    };\n  };\n  return EsriJSON2;\n}(JSONFeature$1);\nfunction readGeometry$1(object, opt_options) {\n  var _a2, _b2;\n  if (!object) {\n    return null;\n  }\n  var type;\n  if (typeof object[\"x\"] === \"number\" && typeof object[\"y\"] === \"number\") {\n    type = GeometryType.POINT;\n  } else if (object[\"points\"]) {\n    type = GeometryType.MULTI_POINT;\n  } else if (object[\"paths\"]) {\n    var esriJSONPolyline = object;\n    if (esriJSONPolyline.paths.length === 1) {\n      type = GeometryType.LINE_STRING;\n    } else {\n      type = GeometryType.MULTI_LINE_STRING;\n    }\n  } else if (object[\"rings\"]) {\n    var esriJSONPolygon = object;\n    var layout = getGeometryLayout(esriJSONPolygon);\n    var rings = convertRings(esriJSONPolygon.rings, layout);\n    if (rings.length === 1) {\n      type = GeometryType.POLYGON;\n      object = assign({}, object, (_a2 = {}, _a2[\"rings\"] = rings[0], _a2));\n    } else {\n      type = GeometryType.MULTI_POLYGON;\n      object = assign({}, object, (_b2 = {}, _b2[\"rings\"] = rings, _b2));\n    }\n  }\n  var geometryReader = GEOMETRY_READERS$1[type];\n  return transformGeometryWithOptions(geometryReader(object), false, opt_options);\n}\nfunction convertRings(rings, layout) {\n  var flatRing = [];\n  var outerRings = [];\n  var holes = [];\n  var i2, ii;\n  for (i2 = 0, ii = rings.length; i2 < ii; ++i2) {\n    flatRing.length = 0;\n    deflateCoordinates(flatRing, 0, rings[i2], layout.length);\n    var clockwise = linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);\n    if (clockwise) {\n      outerRings.push([rings[i2]]);\n    } else {\n      holes.push(rings[i2]);\n    }\n  }\n  while (holes.length) {\n    var hole = holes.shift();\n    var matched = false;\n    for (i2 = outerRings.length - 1; i2 >= 0; i2--) {\n      var outerRing = outerRings[i2][0];\n      var containsHole = containsExtent(new LinearRing$1(outerRing).getExtent(), new LinearRing$1(hole).getExtent());\n      if (containsHole) {\n        outerRings[i2].push(hole);\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      outerRings.push([hole.reverse()]);\n    }\n  }\n  return outerRings;\n}\nfunction readPointGeometry$2(object) {\n  var point;\n  if (object.m !== void 0 && object.z !== void 0) {\n    point = new Point$4([object.x, object.y, object.z, object.m], GeometryLayout.XYZM);\n  } else if (object.z !== void 0) {\n    point = new Point$4([object.x, object.y, object.z], GeometryLayout.XYZ);\n  } else if (object.m !== void 0) {\n    point = new Point$4([object.x, object.y, object.m], GeometryLayout.XYM);\n  } else {\n    point = new Point$4([object.x, object.y]);\n  }\n  return point;\n}\nfunction readLineStringGeometry$2(object) {\n  var layout = getGeometryLayout(object);\n  return new LineString$2(object.paths[0], layout);\n}\nfunction readMultiLineStringGeometry$2(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiLineString$2(object.paths, layout);\n}\nfunction getGeometryLayout(object) {\n  var layout = GeometryLayout.XY;\n  if (object.hasZ === true && object.hasM === true) {\n    layout = GeometryLayout.XYZM;\n  } else if (object.hasZ === true) {\n    layout = GeometryLayout.XYZ;\n  } else if (object.hasM === true) {\n    layout = GeometryLayout.XYM;\n  }\n  return layout;\n}\nfunction readMultiPointGeometry$2(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiPoint$2(object.points, layout);\n}\nfunction readMultiPolygonGeometry$2(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiPolygon$2(object.rings, layout);\n}\nfunction readPolygonGeometry$2(object) {\n  var layout = getGeometryLayout(object);\n  return new Polygon$2(object.rings, layout);\n}\nfunction writePointGeometry$1(geometry, opt_options) {\n  var coordinates2 = geometry.getCoordinates();\n  var esriJSON;\n  var layout = geometry.getLayout();\n  if (layout === GeometryLayout.XYZ) {\n    esriJSON = {\n      x: coordinates2[0],\n      y: coordinates2[1],\n      z: coordinates2[2]\n    };\n  } else if (layout === GeometryLayout.XYM) {\n    esriJSON = {\n      x: coordinates2[0],\n      y: coordinates2[1],\n      m: coordinates2[2]\n    };\n  } else if (layout === GeometryLayout.XYZM) {\n    esriJSON = {\n      x: coordinates2[0],\n      y: coordinates2[1],\n      z: coordinates2[2],\n      m: coordinates2[3]\n    };\n  } else if (layout === GeometryLayout.XY) {\n    esriJSON = {\n      x: coordinates2[0],\n      y: coordinates2[1]\n    };\n  } else {\n    assert(false, 34);\n  }\n  return esriJSON;\n}\nfunction getHasZM(geometry) {\n  var layout = geometry.getLayout();\n  return {\n    hasZ: layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM,\n    hasM: layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM\n  };\n}\nfunction writeLineStringGeometry$1(lineString, opt_options) {\n  var hasZM = getHasZM(lineString);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    paths: [\n      lineString.getCoordinates()\n    ]\n  };\n}\nfunction writePolygonGeometry$1(polygon, opt_options) {\n  var hasZM = getHasZM(polygon);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    rings: polygon.getCoordinates(false)\n  };\n}\nfunction writeMultiLineStringGeometry$1(multiLineString, opt_options) {\n  var hasZM = getHasZM(multiLineString);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    paths: multiLineString.getCoordinates()\n  };\n}\nfunction writeMultiPointGeometry$1(multiPoint, opt_options) {\n  var hasZM = getHasZM(multiPoint);\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    points: multiPoint.getCoordinates()\n  };\n}\nfunction writeMultiPolygonGeometry$1(geometry, opt_options) {\n  var hasZM = getHasZM(geometry);\n  var coordinates2 = geometry.getCoordinates(false);\n  var output = [];\n  for (var i2 = 0; i2 < coordinates2.length; i2++) {\n    for (var x2 = coordinates2[i2].length - 1; x2 >= 0; x2--) {\n      output.push(coordinates2[i2][x2]);\n    }\n  }\n  return {\n    hasZ: hasZM.hasZ,\n    hasM: hasZM.hasM,\n    rings: output\n  };\n}\nfunction writeGeometry$1(geometry, opt_options) {\n  var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];\n  return geometryWriter(transformGeometryWithOptions(geometry, true, opt_options), opt_options);\n}\nvar EsriJSON$1 = EsriJSON;\nvar __extends$n = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar GeoJSON = function(_super) {\n  __extends$n(GeoJSON2, _super);\n  function GeoJSON2(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this) || this;\n    _this.dataProjection = get$3(options.dataProjection ? options.dataProjection : \"EPSG:4326\");\n    if (options.featureProjection) {\n      _this.defaultFeatureProjection = get$3(options.featureProjection);\n    }\n    _this.geometryName_ = options.geometryName;\n    _this.extractGeometryName_ = options.extractGeometryName;\n    _this.supportedMediaTypes = [\n      \"application/geo+json\",\n      \"application/vnd.geo+json\"\n    ];\n    return _this;\n  }\n  GeoJSON2.prototype.readFeatureFromObject = function(object, opt_options) {\n    var geoJSONFeature = null;\n    if (object[\"type\"] === \"Feature\") {\n      geoJSONFeature = object;\n    } else {\n      geoJSONFeature = {\n        \"type\": \"Feature\",\n        \"geometry\": object,\n        \"properties\": null\n      };\n    }\n    var geometry = readGeometry(geoJSONFeature[\"geometry\"], opt_options);\n    var feature$1 = new feature();\n    if (this.geometryName_) {\n      feature$1.setGeometryName(this.geometryName_);\n    } else if (this.extractGeometryName_ && \"geometry_name\" in geoJSONFeature !== void 0) {\n      feature$1.setGeometryName(geoJSONFeature[\"geometry_name\"]);\n    }\n    feature$1.setGeometry(geometry);\n    if (\"id\" in geoJSONFeature) {\n      feature$1.setId(geoJSONFeature[\"id\"]);\n    }\n    if (geoJSONFeature[\"properties\"]) {\n      feature$1.setProperties(geoJSONFeature[\"properties\"], true);\n    }\n    return feature$1;\n  };\n  GeoJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {\n    var geoJSONObject = object;\n    var features = null;\n    if (geoJSONObject[\"type\"] === \"FeatureCollection\") {\n      var geoJSONFeatureCollection = object;\n      features = [];\n      var geoJSONFeatures = geoJSONFeatureCollection[\"features\"];\n      for (var i2 = 0, ii = geoJSONFeatures.length; i2 < ii; ++i2) {\n        features.push(this.readFeatureFromObject(geoJSONFeatures[i2], opt_options));\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, opt_options)];\n    }\n    return features;\n  };\n  GeoJSON2.prototype.readGeometryFromObject = function(object, opt_options) {\n    return readGeometry(object, opt_options);\n  };\n  GeoJSON2.prototype.readProjectionFromObject = function(object) {\n    var crs = object[\"crs\"];\n    var projection;\n    if (crs) {\n      if (crs[\"type\"] == \"name\") {\n        projection = get$3(crs[\"properties\"][\"name\"]);\n      } else if (crs[\"type\"] === \"EPSG\") {\n        projection = get$3(\"EPSG:\" + crs[\"properties\"][\"code\"]);\n      } else {\n        assert(false, 36);\n      }\n    } else {\n      projection = this.dataProjection;\n    }\n    return projection;\n  };\n  GeoJSON2.prototype.writeFeatureObject = function(feature2, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var object = {\n      \"type\": \"Feature\",\n      geometry: null,\n      properties: null\n    };\n    var id = feature2.getId();\n    if (id !== void 0) {\n      object.id = id;\n    }\n    if (!feature2.hasProperties()) {\n      return object;\n    }\n    var properties = feature2.getProperties();\n    var geometry = feature2.getGeometry();\n    if (geometry) {\n      object.geometry = writeGeometry(geometry, opt_options);\n      delete properties[feature2.getGeometryName()];\n    }\n    if (!isEmpty(properties)) {\n      object.properties = properties;\n    }\n    return object;\n  };\n  GeoJSON2.prototype.writeFeaturesObject = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var objects = [];\n    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {\n      objects.push(this.writeFeatureObject(features[i2], opt_options));\n    }\n    return {\n      type: \"FeatureCollection\",\n      features: objects\n    };\n  };\n  GeoJSON2.prototype.writeGeometryObject = function(geometry, opt_options) {\n    return writeGeometry(geometry, this.adaptOptions(opt_options));\n  };\n  return GeoJSON2;\n}(JSONFeature$1);\nfunction readGeometry(object, opt_options) {\n  if (!object) {\n    return null;\n  }\n  var geometry;\n  switch (object[\"type\"]) {\n    case GeometryType.POINT: {\n      geometry = readPointGeometry$1(object);\n      break;\n    }\n    case GeometryType.LINE_STRING: {\n      geometry = readLineStringGeometry$1(object);\n      break;\n    }\n    case GeometryType.POLYGON: {\n      geometry = readPolygonGeometry$1(object);\n      break;\n    }\n    case GeometryType.MULTI_POINT: {\n      geometry = readMultiPointGeometry$1(object);\n      break;\n    }\n    case GeometryType.MULTI_LINE_STRING: {\n      geometry = readMultiLineStringGeometry$1(object);\n      break;\n    }\n    case GeometryType.MULTI_POLYGON: {\n      geometry = readMultiPolygonGeometry$1(object);\n      break;\n    }\n    case GeometryType.GEOMETRY_COLLECTION: {\n      geometry = readGeometryCollectionGeometry(object);\n      break;\n    }\n    default: {\n      throw new Error(\"Unsupported GeoJSON type: \" + object.type);\n    }\n  }\n  return transformGeometryWithOptions(geometry, false, opt_options);\n}\nfunction readGeometryCollectionGeometry(object, opt_options) {\n  var geometries = object[\"geometries\"].map(function(geometry) {\n    return readGeometry(geometry, opt_options);\n  });\n  return new GeometryCollection$1(geometries);\n}\nfunction readPointGeometry$1(object) {\n  return new Point$4(object[\"coordinates\"]);\n}\nfunction readLineStringGeometry$1(object) {\n  return new LineString$2(object[\"coordinates\"]);\n}\nfunction readMultiLineStringGeometry$1(object) {\n  return new MultiLineString$2(object[\"coordinates\"]);\n}\nfunction readMultiPointGeometry$1(object) {\n  return new MultiPoint$2(object[\"coordinates\"]);\n}\nfunction readMultiPolygonGeometry$1(object) {\n  return new MultiPolygon$2(object[\"coordinates\"]);\n}\nfunction readPolygonGeometry$1(object) {\n  return new Polygon$2(object[\"coordinates\"]);\n}\nfunction writeGeometry(geometry, opt_options) {\n  geometry = transformGeometryWithOptions(geometry, true, opt_options);\n  var type = geometry.getType();\n  var geoJSON;\n  switch (type) {\n    case GeometryType.POINT: {\n      geoJSON = writePointGeometry(geometry);\n      break;\n    }\n    case GeometryType.LINE_STRING: {\n      geoJSON = writeLineStringGeometry(geometry);\n      break;\n    }\n    case GeometryType.POLYGON: {\n      geoJSON = writePolygonGeometry(geometry, opt_options);\n      break;\n    }\n    case GeometryType.MULTI_POINT: {\n      geoJSON = writeMultiPointGeometry(geometry);\n      break;\n    }\n    case GeometryType.MULTI_LINE_STRING: {\n      geoJSON = writeMultiLineStringGeometry(geometry);\n      break;\n    }\n    case GeometryType.MULTI_POLYGON: {\n      geoJSON = writeMultiPolygonGeometry(geometry, opt_options);\n      break;\n    }\n    case GeometryType.GEOMETRY_COLLECTION: {\n      geoJSON = writeGeometryCollectionGeometry(geometry, opt_options);\n      break;\n    }\n    case GeometryType.CIRCLE: {\n      geoJSON = {\n        type: \"GeometryCollection\",\n        geometries: []\n      };\n      break;\n    }\n    default: {\n      throw new Error(\"Unsupported geometry type: \" + type);\n    }\n  }\n  return geoJSON;\n}\nfunction writeGeometryCollectionGeometry(geometry, opt_options) {\n  var geometries = geometry.getGeometriesArray().map(function(geometry2) {\n    var options = assign({}, opt_options);\n    delete options.featureProjection;\n    return writeGeometry(geometry2, options);\n  });\n  return {\n    type: \"GeometryCollection\",\n    geometries\n  };\n}\nfunction writeLineStringGeometry(geometry, opt_options) {\n  return {\n    type: \"LineString\",\n    coordinates: geometry.getCoordinates()\n  };\n}\nfunction writeMultiLineStringGeometry(geometry, opt_options) {\n  return {\n    type: \"MultiLineString\",\n    coordinates: geometry.getCoordinates()\n  };\n}\nfunction writeMultiPointGeometry(geometry, opt_options) {\n  return {\n    type: \"MultiPoint\",\n    coordinates: geometry.getCoordinates()\n  };\n}\nfunction writeMultiPolygonGeometry(geometry, opt_options) {\n  var right;\n  if (opt_options) {\n    right = opt_options.rightHanded;\n  }\n  return {\n    type: \"MultiPolygon\",\n    coordinates: geometry.getCoordinates(right)\n  };\n}\nfunction writePointGeometry(geometry, opt_options) {\n  return {\n    type: \"Point\",\n    coordinates: geometry.getCoordinates()\n  };\n}\nfunction writePolygonGeometry(geometry, opt_options) {\n  var right;\n  if (opt_options) {\n    right = opt_options.rightHanded;\n  }\n  return {\n    type: \"Polygon\",\n    coordinates: geometry.getCoordinates(right)\n  };\n}\nvar GeoJSON$1 = GeoJSON;\nvar XML_SCHEMA_INSTANCE_URI = \"http://www.w3.org/2001/XMLSchema-instance\";\nfunction createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\nfunction getAllTextContent(node2, normalizeWhitespace) {\n  return getAllTextContent_(node2, normalizeWhitespace, []).join(\"\");\n}\nfunction getAllTextContent_(node2, normalizeWhitespace, accumulator) {\n  if (node2.nodeType == Node.CDATA_SECTION_NODE || node2.nodeType == Node.TEXT_NODE) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node2.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, \"\"));\n    } else {\n      accumulator.push(node2.nodeValue);\n    }\n  } else {\n    var n2 = void 0;\n    for (n2 = node2.firstChild; n2; n2 = n2.nextSibling) {\n      getAllTextContent_(n2, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\nfunction isDocument(object) {\n  return \"documentElement\" in object;\n}\nfunction getAttributeNS(node2, namespaceURI, name) {\n  return node2.getAttributeNS(namespaceURI, name) || \"\";\n}\nfunction parse$1(xml2) {\n  return new DOMParser().parseFromString(xml2, \"application/xml\");\n}\nfunction makeArrayExtender(valueReader, opt_this) {\n  return function(node2, objectStack) {\n    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);\n    if (value !== void 0) {\n      var array = objectStack[objectStack.length - 1];\n      extend$3(array, value);\n    }\n  };\n}\nfunction makeArrayPusher(valueReader, opt_this) {\n  return function(node2, objectStack) {\n    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);\n    if (value !== void 0) {\n      var array = objectStack[objectStack.length - 1];\n      array.push(value);\n    }\n  };\n}\nfunction makeReplacer(valueReader, opt_this) {\n  return function(node2, objectStack) {\n    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);\n    if (value !== void 0) {\n      objectStack[objectStack.length - 1] = value;\n    }\n  };\n}\nfunction makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n  return function(node2, objectStack) {\n    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);\n    if (value !== void 0) {\n      var object = objectStack[objectStack.length - 1];\n      var property = opt_property !== void 0 ? opt_property : node2.localName;\n      var array = void 0;\n      if (property in object) {\n        array = object[property];\n      } else {\n        array = [];\n        object[property] = array;\n      }\n      array.push(value);\n    }\n  };\n}\nfunction makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n  return function(node2, objectStack) {\n    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node2, objectStack);\n    if (value !== void 0) {\n      var object = objectStack[objectStack.length - 1];\n      var property = opt_property !== void 0 ? opt_property : node2.localName;\n      object[property] = value;\n    }\n  };\n}\nfunction makeChildAppender(nodeWriter, opt_this) {\n  return function(node2, value, objectStack) {\n    nodeWriter.call(opt_this !== void 0 ? opt_this : this, node2, value, objectStack);\n    var parent = objectStack[objectStack.length - 1];\n    var parentNode = parent.node;\n    parentNode.appendChild(node2);\n  };\n}\nfunction makeArraySerializer(nodeWriter, opt_this) {\n  var serializersNS, nodeFactory;\n  return function(node2, value, objectStack) {\n    if (serializersNS === void 0) {\n      serializersNS = {};\n      var serializers = {};\n      serializers[node2.localName] = nodeWriter;\n      serializersNS[node2.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node2.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\nfunction makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n  var fixedNodeName = opt_nodeName;\n  return function(value, objectStack, opt_nodeName2) {\n    var context = objectStack[objectStack.length - 1];\n    var node2 = context.node;\n    var nodeName = fixedNodeName;\n    if (nodeName === void 0) {\n      nodeName = opt_nodeName2;\n    }\n    var namespaceURI = opt_namespaceURI !== void 0 ? opt_namespaceURI : node2.namespaceURI;\n    return createElementNS(namespaceURI, nodeName);\n  };\n}\nvar OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\nfunction makeSequence(object, orderedKeys) {\n  var length = orderedKeys.length;\n  var sequence = new Array(length);\n  for (var i2 = 0; i2 < length; ++i2) {\n    sequence[i2] = object[orderedKeys[i2]];\n  }\n  return sequence;\n}\nfunction makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n  var structureNS = opt_structureNS !== void 0 ? opt_structureNS : {};\n  var i2, ii;\n  for (i2 = 0, ii = namespaceURIs.length; i2 < ii; ++i2) {\n    structureNS[namespaceURIs[i2]] = structure;\n  }\n  return structureNS;\n}\nfunction parseNode(parsersNS, node2, objectStack, opt_this) {\n  var n2;\n  for (n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n    var parsers = parsersNS[n2.namespaceURI];\n    if (parsers !== void 0) {\n      var parser = parsers[n2.localName];\n      if (parser !== void 0) {\n        parser.call(opt_this, n2, objectStack);\n      }\n    }\n  }\n}\nfunction pushParseAndPop(object, parsersNS, node2, objectStack, opt_this) {\n  objectStack.push(object);\n  parseNode(parsersNS, node2, objectStack, opt_this);\n  return objectStack.pop();\n}\nfunction serialize(serializersNS, nodeFactory, values2, objectStack, opt_keys, opt_this) {\n  var length = (opt_keys !== void 0 ? opt_keys : values2).length;\n  var value, node2;\n  for (var i2 = 0; i2 < length; ++i2) {\n    value = values2[i2];\n    if (value !== void 0) {\n      node2 = nodeFactory.call(opt_this !== void 0 ? opt_this : this, value, objectStack, opt_keys !== void 0 ? opt_keys[i2] : void 0);\n      if (node2 !== void 0) {\n        serializersNS[node2.namespaceURI][node2.localName].call(opt_this, node2, value, objectStack);\n      }\n    }\n  }\n}\nfunction pushSerializeAndPop(object, serializersNS, nodeFactory, values2, objectStack, opt_keys, opt_this) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values2, objectStack, opt_keys, opt_this);\n  return objectStack.pop();\n}\nvar xmlSerializer_ = void 0;\nfunction getXMLSerializer() {\n  if (xmlSerializer_ === void 0 && typeof XMLSerializer !== \"undefined\") {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\nvar document_ = void 0;\nfunction getDocument() {\n  if (document_ === void 0 && typeof document !== \"undefined\") {\n    document_ = document.implementation.createDocument(\"\", \"\", null);\n  }\n  return document_;\n}\nvar __extends$m = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar XMLFeature = function(_super) {\n  __extends$m(XMLFeature2, _super);\n  function XMLFeature2() {\n    var _this = _super.call(this) || this;\n    _this.xmlSerializer_ = getXMLSerializer();\n    return _this;\n  }\n  XMLFeature2.prototype.getType = function() {\n    return FormatType.XML;\n  };\n  XMLFeature2.prototype.readFeature = function(source, opt_options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      return this.readFeatureFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readFeatureFromDocument(source, opt_options);\n    } else {\n      return this.readFeatureFromNode(source, opt_options);\n    }\n  };\n  XMLFeature2.prototype.readFeatureFromDocument = function(doc, opt_options) {\n    var features = this.readFeaturesFromDocument(doc, opt_options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  };\n  XMLFeature2.prototype.readFeatureFromNode = function(node2, opt_options) {\n    return null;\n  };\n  XMLFeature2.prototype.readFeatures = function(source, opt_options) {\n    if (!source) {\n      return [];\n    } else if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      return this.readFeaturesFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readFeaturesFromDocument(source, opt_options);\n    } else {\n      return this.readFeaturesFromNode(source, opt_options);\n    }\n  };\n  XMLFeature2.prototype.readFeaturesFromDocument = function(doc, opt_options) {\n    var features = [];\n    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {\n      if (n2.nodeType == Node.ELEMENT_NODE) {\n        extend$3(features, this.readFeaturesFromNode(n2, opt_options));\n      }\n    }\n    return features;\n  };\n  XMLFeature2.prototype.readFeaturesFromNode = function(node2, opt_options) {\n    return abstract();\n  };\n  XMLFeature2.prototype.readGeometry = function(source, opt_options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      return this.readGeometryFromDocument(doc, opt_options);\n    } else if (isDocument(source)) {\n      return this.readGeometryFromDocument(source, opt_options);\n    } else {\n      return this.readGeometryFromNode(source, opt_options);\n    }\n  };\n  XMLFeature2.prototype.readGeometryFromDocument = function(doc, opt_options) {\n    return null;\n  };\n  XMLFeature2.prototype.readGeometryFromNode = function(node2, opt_options) {\n    return null;\n  };\n  XMLFeature2.prototype.readProjection = function(source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      return this.readProjectionFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readProjectionFromDocument(source);\n    } else {\n      return this.readProjectionFromNode(source);\n    }\n  };\n  XMLFeature2.prototype.readProjectionFromDocument = function(doc) {\n    return this.dataProjection;\n  };\n  XMLFeature2.prototype.readProjectionFromNode = function(node2) {\n    return this.dataProjection;\n  };\n  XMLFeature2.prototype.writeFeature = function(feature2, opt_options) {\n    var node2 = this.writeFeatureNode(feature2, opt_options);\n    return this.xmlSerializer_.serializeToString(node2);\n  };\n  XMLFeature2.prototype.writeFeatureNode = function(feature2, opt_options) {\n    return null;\n  };\n  XMLFeature2.prototype.writeFeatures = function(features, opt_options) {\n    var node2 = this.writeFeaturesNode(features, opt_options);\n    return this.xmlSerializer_.serializeToString(node2);\n  };\n  XMLFeature2.prototype.writeFeaturesNode = function(features, opt_options) {\n    return null;\n  };\n  XMLFeature2.prototype.writeGeometry = function(geometry, opt_options) {\n    var node2 = this.writeGeometryNode(geometry, opt_options);\n    return this.xmlSerializer_.serializeToString(node2);\n  };\n  XMLFeature2.prototype.writeGeometryNode = function(geometry, opt_options) {\n    return null;\n  };\n  return XMLFeature2;\n}(FeatureFormat$1);\nvar XMLFeature$1 = XMLFeature;\nvar __extends$l = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar GMLNS = \"http://www.opengis.net/gml\";\nvar ONLY_WHITESPACE_RE = /^[\\s\\xa0]*$/;\nvar GMLBase = function(_super) {\n  __extends$l(GMLBase2, _super);\n  function GMLBase2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.featureType = options.featureType;\n    _this.featureNS = options.featureNS;\n    _this.srsName = options.srsName;\n    _this.schemaLocation = \"\";\n    _this.FEATURE_COLLECTION_PARSERS = {};\n    _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {\n      \"featureMember\": makeArrayPusher(_this.readFeaturesInternal),\n      \"featureMembers\": makeReplacer(_this.readFeaturesInternal)\n    };\n    _this.supportedMediaTypes = [\"application/gml+xml\"];\n    return _this;\n  }\n  GMLBase2.prototype.readFeaturesInternal = function(node2, objectStack) {\n    var localName = node2.localName;\n    var features = null;\n    if (localName == \"FeatureCollection\") {\n      features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node2, objectStack, this);\n    } else if (localName == \"featureMembers\" || localName == \"featureMember\" || localName == \"member\") {\n      var context = objectStack[0];\n      var featureType = context[\"featureType\"];\n      var featureNS = context[\"featureNS\"];\n      var prefix = \"p\";\n      var defaultPrefix = \"p0\";\n      if (!featureType && node2.childNodes) {\n        featureType = [], featureNS = {};\n        for (var i2 = 0, ii = node2.childNodes.length; i2 < ii; ++i2) {\n          var child = node2.childNodes[i2];\n          if (child.nodeType === 1) {\n            var ft2 = child.nodeName.split(\":\").pop();\n            if (featureType.indexOf(ft2) === -1) {\n              var key = \"\";\n              var count = 0;\n              var uri = child.namespaceURI;\n              for (var candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + \":\" + ft2);\n            }\n          }\n        }\n        if (localName != \"featureMember\") {\n          context[\"featureType\"] = featureType;\n          context[\"featureNS\"] = featureNS;\n        }\n      }\n      if (typeof featureNS === \"string\") {\n        var ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      var parsersNS = {};\n      var featureTypes = Array.isArray(featureType) ? featureType : [featureType];\n      for (var p5 in featureNS) {\n        var parsers = {};\n        for (var i2 = 0, ii = featureTypes.length; i2 < ii; ++i2) {\n          var featurePrefix = featureTypes[i2].indexOf(\":\") === -1 ? defaultPrefix : featureTypes[i2].split(\":\")[0];\n          if (featurePrefix === p5) {\n            parsers[featureTypes[i2].split(\":\").pop()] = localName == \"featureMembers\" ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p5]] = parsers;\n      }\n      if (localName == \"featureMember\" || localName == \"member\") {\n        features = pushParseAndPop(void 0, parsersNS, node2, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node2, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  };\n  GMLBase2.prototype.readGeometryOrExtent = function(node2, objectStack) {\n    var context = objectStack[0];\n    context[\"srsName\"] = node2.firstElementChild.getAttribute(\"srsName\");\n    context[\"srsDimension\"] = node2.firstElementChild.getAttribute(\"srsDimension\");\n    return pushParseAndPop(null, this.GEOMETRY_PARSERS, node2, objectStack, this);\n  };\n  GMLBase2.prototype.readExtentElement = function(node2, objectStack) {\n    var context = objectStack[0];\n    var extent2 = this.readGeometryOrExtent(node2, objectStack);\n    return extent2 ? transformExtentWithOptions(extent2, context) : void 0;\n  };\n  GMLBase2.prototype.readGeometryElement = function(node2, objectStack) {\n    var context = objectStack[0];\n    var geometry = this.readGeometryOrExtent(node2, objectStack);\n    return geometry ? transformGeometryWithOptions(geometry, false, context) : void 0;\n  };\n  GMLBase2.prototype.readFeatureElementInternal = function(node2, objectStack, asFeature) {\n    var geometryName;\n    var values2 = {};\n    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n      var value = void 0;\n      var localName = n2.localName;\n      if (n2.childNodes.length === 0 || n2.childNodes.length === 1 && (n2.firstChild.nodeType === 3 || n2.firstChild.nodeType === 4)) {\n        value = getAllTextContent(n2, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = void 0;\n        }\n      } else {\n        if (asFeature) {\n          value = localName === \"boundedBy\" ? this.readExtentElement(n2, objectStack) : this.readGeometryElement(n2, objectStack);\n        }\n        if (!value) {\n          value = this.readFeatureElementInternal(n2, objectStack, false);\n        } else if (localName !== \"boundedBy\") {\n          geometryName = localName;\n        }\n      }\n      if (values2[localName]) {\n        if (!(values2[localName] instanceof Array)) {\n          values2[localName] = [values2[localName]];\n        }\n        values2[localName].push(value);\n      } else {\n        values2[localName] = value;\n      }\n      var len = n2.attributes.length;\n      if (len > 0) {\n        values2[localName] = { _content_: values2[localName] };\n        for (var i2 = 0; i2 < len; i2++) {\n          var attName = n2.attributes[i2].name;\n          values2[localName][attName] = n2.attributes[i2].value;\n        }\n      }\n    }\n    if (!asFeature) {\n      return values2;\n    } else {\n      var feature$1 = new feature(values2);\n      if (geometryName) {\n        feature$1.setGeometryName(geometryName);\n      }\n      var fid = node2.getAttribute(\"fid\") || getAttributeNS(node2, this.namespace, \"id\");\n      if (fid) {\n        feature$1.setId(fid);\n      }\n      return feature$1;\n    }\n  };\n  GMLBase2.prototype.readFeatureElement = function(node2, objectStack) {\n    return this.readFeatureElementInternal(node2, objectStack, true);\n  };\n  GMLBase2.prototype.readPoint = function(node2, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);\n    if (flatCoordinates) {\n      return new Point$4(flatCoordinates, GeometryLayout.XYZ);\n    }\n  };\n  GMLBase2.prototype.readMultiPoint = function(node2, objectStack) {\n    var coordinates2 = pushParseAndPop([], this.MULTIPOINT_PARSERS, node2, objectStack, this);\n    if (coordinates2) {\n      return new MultiPoint$2(coordinates2);\n    } else {\n      return void 0;\n    }\n  };\n  GMLBase2.prototype.readMultiLineString = function(node2, objectStack) {\n    var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node2, objectStack, this);\n    if (lineStrings) {\n      return new MultiLineString$2(lineStrings);\n    }\n  };\n  GMLBase2.prototype.readMultiPolygon = function(node2, objectStack) {\n    var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node2, objectStack, this);\n    if (polygons) {\n      return new MultiPolygon$2(polygons);\n    }\n  };\n  GMLBase2.prototype.pointMemberParser = function(node2, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node2, objectStack, this);\n  };\n  GMLBase2.prototype.lineStringMemberParser = function(node2, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node2, objectStack, this);\n  };\n  GMLBase2.prototype.polygonMemberParser = function(node2, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node2, objectStack, this);\n  };\n  GMLBase2.prototype.readLineString = function(node2, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);\n    if (flatCoordinates) {\n      var lineString = new LineString$2(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return void 0;\n    }\n  };\n  GMLBase2.prototype.readFlatLinearRing = function(node2, objectStack) {\n    var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);\n    if (ring) {\n      return ring;\n    } else {\n      return void 0;\n    }\n  };\n  GMLBase2.prototype.readLinearRing = function(node2, objectStack) {\n    var flatCoordinates = this.readFlatCoordinatesFromNode(node2, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing$1(flatCoordinates, GeometryLayout.XYZ);\n    }\n  };\n  GMLBase2.prototype.readPolygon = function(node2, objectStack) {\n    var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node2, objectStack, this);\n    if (flatLinearRings && flatLinearRings[0]) {\n      var flatCoordinates = flatLinearRings[0];\n      var ends = [flatCoordinates.length];\n      var i2 = void 0, ii = void 0;\n      for (i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {\n        extend$3(flatCoordinates, flatLinearRings[i2]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon$2(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return void 0;\n    }\n  };\n  GMLBase2.prototype.readFlatCoordinatesFromNode = function(node2, objectStack) {\n    return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);\n  };\n  GMLBase2.prototype.readGeometryFromNode = function(node2, opt_options) {\n    var geometry = this.readGeometryElement(node2, [\n      this.getReadOptions(node2, opt_options ? opt_options : {})\n    ]);\n    return geometry ? geometry : null;\n  };\n  GMLBase2.prototype.readFeaturesFromNode = function(node2, opt_options) {\n    var options = {\n      featureType: this.featureType,\n      featureNS: this.featureNS\n    };\n    if (opt_options) {\n      assign(options, this.getReadOptions(node2, opt_options));\n    }\n    var features = this.readFeaturesInternal(node2, [options]);\n    return features || [];\n  };\n  GMLBase2.prototype.readProjectionFromNode = function(node2) {\n    return get$3(this.srsName ? this.srsName : node2.firstElementChild.getAttribute(\"srsName\"));\n  };\n  return GMLBase2;\n}(XMLFeature$1);\nGMLBase.prototype.namespace = GMLNS;\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  \"http://www.opengis.net/gml\": {}\n};\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  \"http://www.opengis.net/gml\": {}\n};\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  \"http://www.opengis.net/gml\": {}\n};\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"pointMember\": makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    \"pointMembers\": makeArrayPusher(GMLBase.prototype.pointMemberParser)\n  }\n};\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"lineStringMember\": makeArrayPusher(GMLBase.prototype.lineStringMemberParser),\n    \"lineStringMembers\": makeArrayPusher(GMLBase.prototype.lineStringMemberParser)\n  }\n};\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"polygonMember\": makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    \"polygonMembers\": makeArrayPusher(GMLBase.prototype.polygonMemberParser)\n  }\n};\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"Point\": makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)\n  }\n};\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"LineString\": makeArrayPusher(GMLBase.prototype.readLineString)\n  }\n};\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"Polygon\": makeArrayPusher(GMLBase.prototype.readPolygon)\n  }\n};\nGMLBase.prototype.RING_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"LinearRing\": makeReplacer(GMLBase.prototype.readFlatLinearRing)\n  }\n};\nvar GMLBase$1 = GMLBase;\nfunction readBoolean(node2) {\n  var s2 = getAllTextContent(node2, false);\n  return readBooleanString(s2);\n}\nfunction readBooleanString(string) {\n  var m2 = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m2) {\n    return m2[1] !== void 0 || false;\n  } else {\n    return void 0;\n  }\n}\nfunction readDateTime(node2) {\n  var s2 = getAllTextContent(node2, false);\n  var dateTime = Date.parse(s2);\n  return isNaN(dateTime) ? void 0 : dateTime / 1e3;\n}\nfunction readDecimal(node2) {\n  var s2 = getAllTextContent(node2, false);\n  return readDecimalString(s2);\n}\nfunction readDecimalString(string) {\n  var m2 = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m2) {\n    return parseFloat(m2[1]);\n  } else {\n    return void 0;\n  }\n}\nfunction readPositiveInteger(node2) {\n  var s2 = getAllTextContent(node2, false);\n  return readNonNegativeIntegerString(s2);\n}\nfunction readNonNegativeIntegerString(string) {\n  var m2 = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m2) {\n    return parseInt(m2[1], 10);\n  } else {\n    return void 0;\n  }\n}\nfunction readString(node2) {\n  return getAllTextContent(node2, false).trim();\n}\nfunction writeBooleanTextNode(node2, bool) {\n  writeStringTextNode(node2, bool ? \"1\" : \"0\");\n}\nfunction writeCDATASection(node2, string) {\n  node2.appendChild(getDocument().createCDATASection(string));\n}\nfunction writeDateTimeTextNode(node2, dateTime) {\n  var date = new Date(dateTime * 1e3);\n  var string = date.getUTCFullYear() + \"-\" + padNumber(date.getUTCMonth() + 1, 2) + \"-\" + padNumber(date.getUTCDate(), 2) + \"T\" + padNumber(date.getUTCHours(), 2) + \":\" + padNumber(date.getUTCMinutes(), 2) + \":\" + padNumber(date.getUTCSeconds(), 2) + \"Z\";\n  node2.appendChild(getDocument().createTextNode(string));\n}\nfunction writeDecimalTextNode(node2, decimal) {\n  var string = decimal.toPrecision();\n  node2.appendChild(getDocument().createTextNode(string));\n}\nfunction writeNonNegativeIntegerTextNode(node2, nonNegativeInteger) {\n  var string = nonNegativeInteger.toString();\n  node2.appendChild(getDocument().createTextNode(string));\n}\nfunction writeStringTextNode(node2, string) {\n  node2.appendChild(getDocument().createTextNode(string));\n}\nvar __extends$k = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar schemaLocation$1 = GMLNS + \" http://schemas.opengis.net/gml/2.1.2/feature.xsd\";\nvar MULTIGEOMETRY_TO_MEMBER_NODENAME$1 = {\n  \"MultiLineString\": \"lineStringMember\",\n  \"MultiCurve\": \"curveMember\",\n  \"MultiPolygon\": \"polygonMember\",\n  \"MultiSurface\": \"surfaceMember\"\n};\nvar GML2 = function(_super) {\n  __extends$k(GML22, _super);\n  function GML22(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, options) || this;\n    _this.FEATURE_COLLECTION_PARSERS[GMLNS][\"featureMember\"] = makeArrayPusher(_this.readFeaturesInternal);\n    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation$1;\n    return _this;\n  }\n  GML22.prototype.readFlatCoordinates = function(node2, objectStack) {\n    var s2 = getAllTextContent(node2, false).replace(/^\\s*|\\s*$/g, \"\");\n    var context = objectStack[0];\n    var containerSrs = context[\"srsName\"];\n    var axisOrientation = \"enu\";\n    if (containerSrs) {\n      var proj = get$3(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    var coordsGroups = s2.trim().split(/\\s+/);\n    var flatCoordinates = [];\n    for (var i2 = 0, ii = coordsGroups.length; i2 < ii; i2++) {\n      var coords = coordsGroups[i2].split(/,+/);\n      var x2 = parseFloat(coords[0]);\n      var y2 = parseFloat(coords[1]);\n      var z2 = coords.length === 3 ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.substr(0, 2) === \"en\") {\n        flatCoordinates.push(x2, y2, z2);\n      } else {\n        flatCoordinates.push(y2, x2, z2);\n      }\n    }\n    return flatCoordinates;\n  };\n  GML22.prototype.readBox = function(node2, objectStack) {\n    var flatCoordinates = pushParseAndPop([null], this.BOX_PARSERS_, node2, objectStack, this);\n    return createOrUpdate$2(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);\n  };\n  GML22.prototype.innerBoundaryIsParser = function(node2, objectStack) {\n    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);\n    if (flatLinearRing) {\n      var flatLinearRings = objectStack[objectStack.length - 1];\n      flatLinearRings.push(flatLinearRing);\n    }\n  };\n  GML22.prototype.outerBoundaryIsParser = function(node2, objectStack) {\n    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);\n    if (flatLinearRing) {\n      var flatLinearRings = objectStack[objectStack.length - 1];\n      flatLinearRings[0] = flatLinearRing;\n    }\n  };\n  GML22.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var multiSurface = context[\"multiSurface\"];\n    var surface = context[\"surface\"];\n    var multiCurve = context[\"multiCurve\"];\n    var nodeName;\n    if (!Array.isArray(value)) {\n      nodeName = value.getType();\n      if (nodeName === \"MultiPolygon\" && multiSurface === true) {\n        nodeName = \"MultiSurface\";\n      } else if (nodeName === \"Polygon\" && surface === true) {\n        nodeName = \"Surface\";\n      } else if (nodeName === \"MultiLineString\" && multiCurve === true) {\n        nodeName = \"MultiCurve\";\n      }\n    } else {\n      nodeName = \"Envelope\";\n    }\n    return createElementNS(\"http://www.opengis.net/gml\", nodeName);\n  };\n  GML22.prototype.writeFeatureElement = function(node2, feature2, objectStack) {\n    var fid = feature2.getId();\n    if (fid) {\n      node2.setAttribute(\"fid\", fid);\n    }\n    var context = objectStack[objectStack.length - 1];\n    var featureNS = context[\"featureNS\"];\n    var geometryName = feature2.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    var keys3 = [];\n    var values2 = [];\n    if (feature2.hasProperties()) {\n      var properties = feature2.getProperties();\n      for (var key in properties) {\n        var value = properties[key];\n        if (value !== null) {\n          keys3.push(key);\n          values2.push(value);\n          if (key == geometryName || typeof value.getSimplifiedGeometry === \"function\") {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    var item = assign({}, context);\n    item.node = node2;\n    pushSerializeAndPop(item, context.serializers, makeSimpleNodeFactory(void 0, featureNS), values2, objectStack, keys3);\n  };\n  GML22.prototype.writeCurveOrLineString = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context[\"srsName\"];\n    if (node2.nodeName !== \"LineStringSegment\" && srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    if (node2.nodeName === \"LineString\" || node2.nodeName === \"LineStringSegment\") {\n      var coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);\n      node2.appendChild(coordinates2);\n      this.writeCoordinates_(coordinates2, geometry, objectStack);\n    } else if (node2.nodeName === \"Curve\") {\n      var segments = createElementNS(node2.namespaceURI, \"segments\");\n      node2.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  };\n  GML22.prototype.writeLineStringOrCurveMember = function(node2, line, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node2.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  };\n  GML22.prototype.writeMultiCurveOrLineString = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    var curve = context[\"curve\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var lines = geometry.getLineStrings();\n    pushSerializeAndPop({ node: node2, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);\n  };\n  GML22.prototype.writeGeometryElement = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var item = assign({}, context);\n    item[\"node\"] = node2;\n    var value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(geometry, context);\n    } else {\n      value = transformGeometryWithOptions(geometry, true, context);\n    }\n    pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);\n  };\n  GML22.prototype.createCoordinatesNode_ = function(namespaceURI) {\n    var coordinates2 = createElementNS(namespaceURI, \"coordinates\");\n    coordinates2.setAttribute(\"decimal\", \".\");\n    coordinates2.setAttribute(\"cs\", \",\");\n    coordinates2.setAttribute(\"ts\", \" \");\n    return coordinates2;\n  };\n  GML22.prototype.writeCoordinates_ = function(node2, value, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    var points = value.getCoordinates();\n    var len = points.length;\n    var parts = new Array(len);\n    for (var i2 = 0; i2 < len; ++i2) {\n      var point = points[i2];\n      parts[i2] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node2, parts.join(\" \"));\n  };\n  GML22.prototype.writeCurveSegments_ = function(node2, line, objectStack) {\n    var child = createElementNS(node2.namespaceURI, \"LineStringSegment\");\n    node2.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  };\n  GML22.prototype.writeSurfaceOrPolygon = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    if (node2.nodeName !== \"PolygonPatch\" && srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    if (node2.nodeName === \"Polygon\" || node2.nodeName === \"PolygonPatch\") {\n      var rings = geometry.getLinearRings();\n      pushSerializeAndPop({ node: node2, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);\n    } else if (node2.nodeName === \"Surface\") {\n      var patches = createElementNS(node2.namespaceURI, \"patches\");\n      node2.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  };\n  GML22.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var parentNode = context.node;\n    var exteriorWritten = context[\"exteriorWritten\"];\n    if (exteriorWritten === void 0) {\n      context[\"exteriorWritten\"] = true;\n    }\n    return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? \"innerBoundaryIs\" : \"outerBoundaryIs\");\n  };\n  GML22.prototype.writeSurfacePatches_ = function(node2, polygon, objectStack) {\n    var child = createElementNS(node2.namespaceURI, \"PolygonPatch\");\n    node2.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  };\n  GML22.prototype.writeRing = function(node2, ring, objectStack) {\n    var linearRing2 = createElementNS(node2.namespaceURI, \"LinearRing\");\n    node2.appendChild(linearRing2);\n    this.writeLinearRing(linearRing2, ring, objectStack);\n  };\n  GML22.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {\n    var axisOrientation = \"enu\";\n    if (opt_srsName) {\n      axisOrientation = get$3(opt_srsName).getAxisOrientation();\n    }\n    var coords = axisOrientation.substr(0, 2) === \"en\" ? point[0] + \",\" + point[1] : point[1] + \",\" + point[0];\n    if (opt_hasZ) {\n      var z2 = point[2] || 0;\n      coords += \",\" + z2;\n    }\n    return coords;\n  };\n  GML22.prototype.writePoint = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);\n    node2.appendChild(coordinates2);\n    var point = geometry.getCoordinates();\n    var coord = this.getCoords_(point, srsName, hasZ);\n    writeStringTextNode(coordinates2, coord);\n  };\n  GML22.prototype.writeMultiPoint = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var points = geometry.getPoints();\n    pushSerializeAndPop({ node: node2, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory(\"pointMember\"), points, objectStack, void 0, this);\n  };\n  GML22.prototype.writePointMember = function(node2, point, objectStack) {\n    var child = createElementNS(node2.namespaceURI, \"Point\");\n    node2.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  };\n  GML22.prototype.writeLinearRing = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context[\"srsName\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var coordinates2 = this.createCoordinatesNode_(node2.namespaceURI);\n    node2.appendChild(coordinates2);\n    this.writeCoordinates_(coordinates2, geometry, objectStack);\n  };\n  GML22.prototype.writeMultiSurfaceOrPolygon = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    var surface = context[\"surface\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var polygons = geometry.getPolygons();\n    pushSerializeAndPop({ node: node2, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);\n  };\n  GML22.prototype.writeSurfaceOrPolygonMember = function(node2, polygon, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node2.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  };\n  GML22.prototype.writeEnvelope = function(node2, extent2, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context[\"srsName\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var keys3 = [\"lowerCorner\", \"upperCorner\"];\n    var values2 = [extent2[0] + \" \" + extent2[1], extent2[2] + \" \" + extent2[3]];\n    pushSerializeAndPop({ node: node2 }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, keys3, this);\n  };\n  GML22.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\"http://www.opengis.net/gml\", MULTIGEOMETRY_TO_MEMBER_NODENAME$1[parentNode.nodeName]);\n  };\n  return GML22;\n}(GMLBase$1);\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"coordinates\": makeReplacer(GML2.prototype.readFlatCoordinates)\n  }\n};\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"innerBoundaryIs\": GML2.prototype.innerBoundaryIsParser,\n    \"outerBoundaryIs\": GML2.prototype.outerBoundaryIsParser\n  }\n};\nGML2.prototype.BOX_PARSERS_ = {\n  \"http://www.opengis.net/gml\": {\n    \"coordinates\": makeArrayPusher(GML2.prototype.readFlatCoordinates)\n  }\n};\nGML2.prototype.GEOMETRY_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"Point\": makeReplacer(GMLBase$1.prototype.readPoint),\n    \"MultiPoint\": makeReplacer(GMLBase$1.prototype.readMultiPoint),\n    \"LineString\": makeReplacer(GMLBase$1.prototype.readLineString),\n    \"MultiLineString\": makeReplacer(GMLBase$1.prototype.readMultiLineString),\n    \"LinearRing\": makeReplacer(GMLBase$1.prototype.readLinearRing),\n    \"Polygon\": makeReplacer(GMLBase$1.prototype.readPolygon),\n    \"MultiPolygon\": makeReplacer(GMLBase$1.prototype.readMultiPolygon),\n    \"Box\": makeReplacer(GML2.prototype.readBox)\n  }\n};\nGML2.prototype.GEOMETRY_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"Curve\": makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    \"MultiCurve\": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    \"Point\": makeChildAppender(GML2.prototype.writePoint),\n    \"MultiPoint\": makeChildAppender(GML2.prototype.writeMultiPoint),\n    \"LineString\": makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    \"MultiLineString\": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    \"LinearRing\": makeChildAppender(GML2.prototype.writeLinearRing),\n    \"Polygon\": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    \"MultiPolygon\": makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),\n    \"Surface\": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    \"MultiSurface\": makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),\n    \"Envelope\": makeChildAppender(GML2.prototype.writeEnvelope)\n  }\n};\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"lineStringMember\": makeChildAppender(GML2.prototype.writeLineStringOrCurveMember),\n    \"curveMember\": makeChildAppender(GML2.prototype.writeLineStringOrCurveMember)\n  }\n};\nGML2.prototype.RING_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"outerBoundaryIs\": makeChildAppender(GML2.prototype.writeRing),\n    \"innerBoundaryIs\": makeChildAppender(GML2.prototype.writeRing)\n  }\n};\nGML2.prototype.POINTMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"pointMember\": makeChildAppender(GML2.prototype.writePointMember)\n  }\n};\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"surfaceMember\": makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember),\n    \"polygonMember\": makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember)\n  }\n};\nGML2.prototype.ENVELOPE_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"lowerCorner\": makeChildAppender(writeStringTextNode),\n    \"upperCorner\": makeChildAppender(writeStringTextNode)\n  }\n};\nvar GML2$1 = GML2;\nvar __extends$j = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar schemaLocation = GMLNS + \" http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd\";\nvar MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  \"MultiLineString\": \"lineStringMember\",\n  \"MultiCurve\": \"curveMember\",\n  \"MultiPolygon\": \"polygonMember\",\n  \"MultiSurface\": \"surfaceMember\"\n};\nvar GML3 = function(_super) {\n  __extends$j(GML33, _super);\n  function GML33(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, options) || this;\n    _this.surface_ = options.surface !== void 0 ? options.surface : false;\n    _this.curve_ = options.curve !== void 0 ? options.curve : false;\n    _this.multiCurve_ = options.multiCurve !== void 0 ? options.multiCurve : true;\n    _this.multiSurface_ = options.multiSurface !== void 0 ? options.multiSurface : true;\n    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;\n    _this.hasZ = options.hasZ !== void 0 ? options.hasZ : false;\n    return _this;\n  }\n  GML33.prototype.readMultiCurve = function(node2, objectStack) {\n    var lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node2, objectStack, this);\n    if (lineStrings) {\n      var multiLineString = new MultiLineString$2(lineStrings);\n      return multiLineString;\n    } else {\n      return void 0;\n    }\n  };\n  GML33.prototype.readMultiSurface = function(node2, objectStack) {\n    var polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS, node2, objectStack, this);\n    if (polygons) {\n      return new MultiPolygon$2(polygons);\n    }\n  };\n  GML33.prototype.curveMemberParser = function(node2, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node2, objectStack, this);\n  };\n  GML33.prototype.surfaceMemberParser = function(node2, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node2, objectStack, this);\n  };\n  GML33.prototype.readPatch = function(node2, objectStack) {\n    return pushParseAndPop([null], this.PATCHES_PARSERS, node2, objectStack, this);\n  };\n  GML33.prototype.readSegment = function(node2, objectStack) {\n    return pushParseAndPop([null], this.SEGMENTS_PARSERS, node2, objectStack, this);\n  };\n  GML33.prototype.readPolygonPatch = function(node2, objectStack) {\n    return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node2, objectStack, this);\n  };\n  GML33.prototype.readLineStringSegment = function(node2, objectStack) {\n    return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack, this);\n  };\n  GML33.prototype.interiorParser = function(node2, objectStack) {\n    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);\n    if (flatLinearRing) {\n      var flatLinearRings = objectStack[objectStack.length - 1];\n      flatLinearRings.push(flatLinearRing);\n    }\n  };\n  GML33.prototype.exteriorParser = function(node2, objectStack) {\n    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node2, objectStack, this);\n    if (flatLinearRing) {\n      var flatLinearRings = objectStack[objectStack.length - 1];\n      flatLinearRings[0] = flatLinearRing;\n    }\n  };\n  GML33.prototype.readSurface = function(node2, objectStack) {\n    var flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS, node2, objectStack, this);\n    if (flatLinearRings && flatLinearRings[0]) {\n      var flatCoordinates = flatLinearRings[0];\n      var ends = [flatCoordinates.length];\n      var i2 = void 0, ii = void 0;\n      for (i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {\n        extend$3(flatCoordinates, flatLinearRings[i2]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon$2(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return void 0;\n    }\n  };\n  GML33.prototype.readCurve = function(node2, objectStack) {\n    var flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS, node2, objectStack, this);\n    if (flatCoordinates) {\n      var lineString = new LineString$2(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return void 0;\n    }\n  };\n  GML33.prototype.readEnvelope = function(node2, objectStack) {\n    var flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS, node2, objectStack, this);\n    return createOrUpdate$2(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);\n  };\n  GML33.prototype.readFlatPos = function(node2, objectStack) {\n    var s2 = getAllTextContent(node2, false);\n    var re2 = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    var flatCoordinates = [];\n    var m2;\n    while (m2 = re2.exec(s2)) {\n      flatCoordinates.push(parseFloat(m2[1]));\n      s2 = s2.substr(m2[0].length);\n    }\n    if (s2 !== \"\") {\n      return void 0;\n    }\n    var context = objectStack[0];\n    var containerSrs = context[\"srsName\"];\n    var axisOrientation = \"enu\";\n    if (containerSrs) {\n      var proj = get$3(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === \"neu\") {\n      var i2 = void 0, ii = void 0;\n      for (i2 = 0, ii = flatCoordinates.length; i2 < ii; i2 += 3) {\n        var y2 = flatCoordinates[i2];\n        var x2 = flatCoordinates[i2 + 1];\n        flatCoordinates[i2] = x2;\n        flatCoordinates[i2 + 1] = y2;\n      }\n    }\n    var len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return void 0;\n    }\n    return flatCoordinates;\n  };\n  GML33.prototype.readFlatPosList = function(node2, objectStack) {\n    var s2 = getAllTextContent(node2, false).replace(/^\\s*|\\s*$/g, \"\");\n    var context = objectStack[0];\n    var containerSrs = context[\"srsName\"];\n    var contextDimension = context[\"srsDimension\"];\n    var axisOrientation = \"enu\";\n    if (containerSrs) {\n      var proj = get$3(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    var coords = s2.split(/\\s+/);\n    var dim = 2;\n    if (node2.getAttribute(\"srsDimension\")) {\n      dim = readNonNegativeIntegerString(node2.getAttribute(\"srsDimension\"));\n    } else if (node2.getAttribute(\"dimension\")) {\n      dim = readNonNegativeIntegerString(node2.getAttribute(\"dimension\"));\n    } else if (node2.parentNode.getAttribute(\"srsDimension\")) {\n      dim = readNonNegativeIntegerString(node2.parentNode.getAttribute(\"srsDimension\"));\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    var x2, y2, z2;\n    var flatCoordinates = [];\n    for (var i2 = 0, ii = coords.length; i2 < ii; i2 += dim) {\n      x2 = parseFloat(coords[i2]);\n      y2 = parseFloat(coords[i2 + 1]);\n      z2 = dim === 3 ? parseFloat(coords[i2 + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === \"en\") {\n        flatCoordinates.push(x2, y2, z2);\n      } else {\n        flatCoordinates.push(y2, x2, z2);\n      }\n    }\n    return flatCoordinates;\n  };\n  GML33.prototype.writePos_ = function(node2, value, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsDimension = hasZ ? \"3\" : \"2\";\n    node2.setAttribute(\"srsDimension\", srsDimension);\n    var srsName = context[\"srsName\"];\n    var axisOrientation = \"enu\";\n    if (srsName) {\n      axisOrientation = get$3(srsName).getAxisOrientation();\n    }\n    var point = value.getCoordinates();\n    var coords;\n    if (axisOrientation.substr(0, 2) === \"en\") {\n      coords = point[0] + \" \" + point[1];\n    } else {\n      coords = point[1] + \" \" + point[0];\n    }\n    if (hasZ) {\n      var z2 = point[2] || 0;\n      coords += \" \" + z2;\n    }\n    writeStringTextNode(node2, coords);\n  };\n  GML33.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {\n    var axisOrientation = \"enu\";\n    if (opt_srsName) {\n      axisOrientation = get$3(opt_srsName).getAxisOrientation();\n    }\n    var coords = axisOrientation.substr(0, 2) === \"en\" ? point[0] + \" \" + point[1] : point[1] + \" \" + point[0];\n    if (opt_hasZ) {\n      var z2 = point[2] || 0;\n      coords += \" \" + z2;\n    }\n    return coords;\n  };\n  GML33.prototype.writePosList_ = function(node2, value, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsDimension = hasZ ? \"3\" : \"2\";\n    node2.setAttribute(\"srsDimension\", srsDimension);\n    var srsName = context[\"srsName\"];\n    var points = value.getCoordinates();\n    var len = points.length;\n    var parts = new Array(len);\n    var point;\n    for (var i2 = 0; i2 < len; ++i2) {\n      point = points[i2];\n      parts[i2] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node2, parts.join(\" \"));\n  };\n  GML33.prototype.writePoint = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context[\"srsName\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var pos = createElementNS(node2.namespaceURI, \"pos\");\n    node2.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  };\n  GML33.prototype.writeEnvelope = function(node2, extent2, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context[\"srsName\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var keys3 = [\"lowerCorner\", \"upperCorner\"];\n    var values2 = [extent2[0] + \" \" + extent2[1], extent2[2] + \" \" + extent2[3]];\n    pushSerializeAndPop({ node: node2 }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, keys3, this);\n  };\n  GML33.prototype.writeLinearRing = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context[\"srsName\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var posList = createElementNS(node2.namespaceURI, \"posList\");\n    node2.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  };\n  GML33.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var parentNode = context.node;\n    var exteriorWritten = context[\"exteriorWritten\"];\n    if (exteriorWritten === void 0) {\n      context[\"exteriorWritten\"] = true;\n    }\n    return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? \"interior\" : \"exterior\");\n  };\n  GML33.prototype.writeSurfaceOrPolygon = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    if (node2.nodeName !== \"PolygonPatch\" && srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    if (node2.nodeName === \"Polygon\" || node2.nodeName === \"PolygonPatch\") {\n      var rings = geometry.getLinearRings();\n      pushSerializeAndPop({ node: node2, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);\n    } else if (node2.nodeName === \"Surface\") {\n      var patches = createElementNS(node2.namespaceURI, \"patches\");\n      node2.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  };\n  GML33.prototype.writeCurveOrLineString = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context[\"srsName\"];\n    if (node2.nodeName !== \"LineStringSegment\" && srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    if (node2.nodeName === \"LineString\" || node2.nodeName === \"LineStringSegment\") {\n      var posList = createElementNS(node2.namespaceURI, \"posList\");\n      node2.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node2.nodeName === \"Curve\") {\n      var segments = createElementNS(node2.namespaceURI, \"segments\");\n      node2.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  };\n  GML33.prototype.writeMultiSurfaceOrPolygon = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    var surface = context[\"surface\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var polygons = geometry.getPolygons();\n    pushSerializeAndPop({ node: node2, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);\n  };\n  GML33.prototype.writeMultiPoint = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var srsName = context[\"srsName\"];\n    var hasZ = context[\"hasZ\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var points = geometry.getPoints();\n    pushSerializeAndPop({ node: node2, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory(\"pointMember\"), points, objectStack, void 0, this);\n  };\n  GML33.prototype.writeMultiCurveOrLineString = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var hasZ = context[\"hasZ\"];\n    var srsName = context[\"srsName\"];\n    var curve = context[\"curve\"];\n    if (srsName) {\n      node2.setAttribute(\"srsName\", srsName);\n    }\n    var lines = geometry.getLineStrings();\n    pushSerializeAndPop({ node: node2, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);\n  };\n  GML33.prototype.writeRing = function(node2, ring, objectStack) {\n    var linearRing2 = createElementNS(node2.namespaceURI, \"LinearRing\");\n    node2.appendChild(linearRing2);\n    this.writeLinearRing(linearRing2, ring, objectStack);\n  };\n  GML33.prototype.writeSurfaceOrPolygonMember = function(node2, polygon, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node2.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  };\n  GML33.prototype.writePointMember = function(node2, point, objectStack) {\n    var child = createElementNS(node2.namespaceURI, \"Point\");\n    node2.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  };\n  GML33.prototype.writeLineStringOrCurveMember = function(node2, line, objectStack) {\n    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node2.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  };\n  GML33.prototype.writeSurfacePatches_ = function(node2, polygon, objectStack) {\n    var child = createElementNS(node2.namespaceURI, \"PolygonPatch\");\n    node2.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  };\n  GML33.prototype.writeCurveSegments_ = function(node2, line, objectStack) {\n    var child = createElementNS(node2.namespaceURI, \"LineStringSegment\");\n    node2.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  };\n  GML33.prototype.writeGeometryElement = function(node2, geometry, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var item = assign({}, context);\n    item[\"node\"] = node2;\n    var value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(geometry, context);\n    } else {\n      value = transformGeometryWithOptions(geometry, true, context);\n    }\n    pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);\n  };\n  GML33.prototype.writeFeatureElement = function(node2, feature2, objectStack) {\n    var fid = feature2.getId();\n    if (fid) {\n      node2.setAttribute(\"fid\", fid);\n    }\n    var context = objectStack[objectStack.length - 1];\n    var featureNS = context[\"featureNS\"];\n    var geometryName = feature2.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    var keys3 = [];\n    var values2 = [];\n    if (feature2.hasProperties()) {\n      var properties = feature2.getProperties();\n      for (var key in properties) {\n        var value = properties[key];\n        if (value !== null) {\n          keys3.push(key);\n          values2.push(value);\n          if (key == geometryName || typeof value.getSimplifiedGeometry === \"function\") {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    var item = assign({}, context);\n    item.node = node2;\n    pushSerializeAndPop(item, context.serializers, makeSimpleNodeFactory(void 0, featureNS), values2, objectStack, keys3);\n  };\n  GML33.prototype.writeFeatureMembers_ = function(node2, features, objectStack) {\n    var context = objectStack[objectStack.length - 1];\n    var featureType = context[\"featureType\"];\n    var featureNS = context[\"featureNS\"];\n    var serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);\n    var item = assign({}, context);\n    item.node = node2;\n    pushSerializeAndPop(item, serializers, makeSimpleNodeFactory(featureType, featureNS), features, objectStack);\n  };\n  GML33.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n  };\n  GML33.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n    var context = objectStack[objectStack.length - 1];\n    var multiSurface = context[\"multiSurface\"];\n    var surface = context[\"surface\"];\n    var curve = context[\"curve\"];\n    var multiCurve = context[\"multiCurve\"];\n    var nodeName;\n    if (!Array.isArray(value)) {\n      nodeName = value.getType();\n      if (nodeName === \"MultiPolygon\" && multiSurface === true) {\n        nodeName = \"MultiSurface\";\n      } else if (nodeName === \"Polygon\" && surface === true) {\n        nodeName = \"Surface\";\n      } else if (nodeName === \"LineString\" && curve === true) {\n        nodeName = \"Curve\";\n      } else if (nodeName === \"MultiLineString\" && multiCurve === true) {\n        nodeName = \"MultiCurve\";\n      }\n    } else {\n      nodeName = \"Envelope\";\n    }\n    return createElementNS(this.namespace, nodeName);\n  };\n  GML33.prototype.writeGeometryNode = function(geometry, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var geom2 = createElementNS(this.namespace, \"geom\");\n    var context = {\n      node: geom2,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_\n    };\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeGeometryElement(geom2, geometry, [context]);\n    return geom2;\n  };\n  GML33.prototype.writeFeaturesNode = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var node2 = createElementNS(this.namespace, \"featureMembers\");\n    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, \"xsi:schemaLocation\", this.schemaLocation);\n    var context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType\n    };\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeFeatureMembers_(node2, features, [context]);\n    return node2;\n  };\n  return GML33;\n}(GMLBase$1);\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"pos\": makeReplacer(GML3.prototype.readFlatPos),\n    \"posList\": makeReplacer(GML3.prototype.readFlatPosList),\n    \"coordinates\": makeReplacer(GML2$1.prototype.readFlatCoordinates)\n  }\n};\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"interior\": GML3.prototype.interiorParser,\n    \"exterior\": GML3.prototype.exteriorParser\n  }\n};\nGML3.prototype.GEOMETRY_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"Point\": makeReplacer(GMLBase$1.prototype.readPoint),\n    \"MultiPoint\": makeReplacer(GMLBase$1.prototype.readMultiPoint),\n    \"LineString\": makeReplacer(GMLBase$1.prototype.readLineString),\n    \"MultiLineString\": makeReplacer(GMLBase$1.prototype.readMultiLineString),\n    \"LinearRing\": makeReplacer(GMLBase$1.prototype.readLinearRing),\n    \"Polygon\": makeReplacer(GMLBase$1.prototype.readPolygon),\n    \"MultiPolygon\": makeReplacer(GMLBase$1.prototype.readMultiPolygon),\n    \"Surface\": makeReplacer(GML3.prototype.readSurface),\n    \"MultiSurface\": makeReplacer(GML3.prototype.readMultiSurface),\n    \"Curve\": makeReplacer(GML3.prototype.readCurve),\n    \"MultiCurve\": makeReplacer(GML3.prototype.readMultiCurve),\n    \"Envelope\": makeReplacer(GML3.prototype.readEnvelope)\n  }\n};\nGML3.prototype.MULTICURVE_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"curveMember\": makeArrayPusher(GML3.prototype.curveMemberParser),\n    \"curveMembers\": makeArrayPusher(GML3.prototype.curveMemberParser)\n  }\n};\nGML3.prototype.MULTISURFACE_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"surfaceMember\": makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    \"surfaceMembers\": makeArrayPusher(GML3.prototype.surfaceMemberParser)\n  }\n};\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"LineString\": makeArrayPusher(GMLBase$1.prototype.readLineString),\n    \"Curve\": makeArrayPusher(GML3.prototype.readCurve)\n  }\n};\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"Polygon\": makeArrayPusher(GMLBase$1.prototype.readPolygon),\n    \"Surface\": makeArrayPusher(GML3.prototype.readSurface)\n  }\n};\nGML3.prototype.SURFACE_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"patches\": makeReplacer(GML3.prototype.readPatch)\n  }\n};\nGML3.prototype.CURVE_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"segments\": makeReplacer(GML3.prototype.readSegment)\n  }\n};\nGML3.prototype.ENVELOPE_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"lowerCorner\": makeArrayPusher(GML3.prototype.readFlatPosList),\n    \"upperCorner\": makeArrayPusher(GML3.prototype.readFlatPosList)\n  }\n};\nGML3.prototype.PATCHES_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"PolygonPatch\": makeReplacer(GML3.prototype.readPolygonPatch)\n  }\n};\nGML3.prototype.SEGMENTS_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"LineStringSegment\": makeReplacer(GML3.prototype.readLineStringSegment)\n  }\n};\nGML3.prototype.writeFeatures;\nGML3.prototype.RING_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"exterior\": makeChildAppender(GML3.prototype.writeRing),\n    \"interior\": makeChildAppender(GML3.prototype.writeRing)\n  }\n};\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"lowerCorner\": makeChildAppender(writeStringTextNode),\n    \"upperCorner\": makeChildAppender(writeStringTextNode)\n  }\n};\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"surfaceMember\": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember),\n    \"polygonMember\": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember)\n  }\n};\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"pointMember\": makeChildAppender(GML3.prototype.writePointMember)\n  }\n};\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"lineStringMember\": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember),\n    \"curveMember\": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember)\n  }\n};\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  \"http://www.opengis.net/gml\": {\n    \"Curve\": makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    \"MultiCurve\": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    \"Point\": makeChildAppender(GML3.prototype.writePoint),\n    \"MultiPoint\": makeChildAppender(GML3.prototype.writeMultiPoint),\n    \"LineString\": makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    \"MultiLineString\": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    \"LinearRing\": makeChildAppender(GML3.prototype.writeLinearRing),\n    \"Polygon\": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    \"MultiPolygon\": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),\n    \"Surface\": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    \"MultiSurface\": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),\n    \"Envelope\": makeChildAppender(GML3.prototype.writeEnvelope)\n  }\n};\nvar GML3$1 = GML3;\nvar GML = GML3$1;\nGML.prototype.writeFeatures;\nGML.prototype.writeFeaturesNode;\nvar GML$1 = GML;\nvar __extends$i = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar NAMESPACE_URIS$4 = [\n  null,\n  \"http://www.topografix.com/GPX/1/0\",\n  \"http://www.topografix.com/GPX/1/1\"\n];\nvar SCHEMA_LOCATION$1 = \"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd\";\nvar FEATURE_READER = {\n  \"rte\": readRte,\n  \"trk\": readTrk,\n  \"wpt\": readWpt\n};\nvar GPX_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"rte\": makeArrayPusher(readRte),\n  \"trk\": makeArrayPusher(readTrk),\n  \"wpt\": makeArrayPusher(readWpt)\n});\nvar LINK_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$4, {\n  \"text\": makeObjectPropertySetter(readString, \"linkText\"),\n  \"type\": makeObjectPropertySetter(readString, \"linkType\")\n});\nvar GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"rte\": makeChildAppender(writeRte),\n  \"trk\": makeChildAppender(writeTrk),\n  \"wpt\": makeChildAppender(writeWpt)\n});\nvar GPX = function(_super) {\n  __extends$i(GPX2, _super);\n  function GPX2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.dataProjection = get$3(\"EPSG:4326\");\n    _this.readExtensions_ = options.readExtensions;\n    return _this;\n  }\n  GPX2.prototype.handleReadExtensions_ = function(features) {\n    if (!features) {\n      features = [];\n    }\n    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {\n      var feature2 = features[i2];\n      if (this.readExtensions_) {\n        var extensionsNode = feature2.get(\"extensionsNode_\") || null;\n        this.readExtensions_(feature2, extensionsNode);\n      }\n      feature2.set(\"extensionsNode_\", void 0);\n    }\n  };\n  GPX2.prototype.readFeatureFromNode = function(node2, opt_options) {\n    if (!includes(NAMESPACE_URIS$4, node2.namespaceURI)) {\n      return null;\n    }\n    var featureReader = FEATURE_READER[node2.localName];\n    if (!featureReader) {\n      return null;\n    }\n    var feature2 = featureReader(node2, [\n      this.getReadOptions(node2, opt_options)\n    ]);\n    if (!feature2) {\n      return null;\n    }\n    this.handleReadExtensions_([feature2]);\n    return feature2;\n  };\n  GPX2.prototype.readFeaturesFromNode = function(node2, opt_options) {\n    if (!includes(NAMESPACE_URIS$4, node2.namespaceURI)) {\n      return [];\n    }\n    if (node2.localName == \"gpx\") {\n      var features = pushParseAndPop([], GPX_PARSERS, node2, [\n        this.getReadOptions(node2, opt_options)\n      ]);\n      if (features) {\n        this.handleReadExtensions_(features);\n        return features;\n      } else {\n        return [];\n      }\n    }\n    return [];\n  };\n  GPX2.prototype.writeFeaturesNode = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var gpx = createElementNS(\"http://www.topografix.com/GPX/1/1\", \"gpx\");\n    var xmlnsUri = \"http://www.w3.org/2000/xmlns/\";\n    gpx.setAttributeNS(xmlnsUri, \"xmlns:xsi\", XML_SCHEMA_INSTANCE_URI);\n    gpx.setAttributeNS(XML_SCHEMA_INSTANCE_URI, \"xsi:schemaLocation\", SCHEMA_LOCATION$1);\n    gpx.setAttribute(\"version\", \"1.1\");\n    gpx.setAttribute(\"creator\", \"OpenLayers\");\n    pushSerializeAndPop({ node: gpx }, GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);\n    return gpx;\n  };\n  return GPX2;\n}(XMLFeature$1);\nvar RTE_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"name\": makeObjectPropertySetter(readString),\n  \"cmt\": makeObjectPropertySetter(readString),\n  \"desc\": makeObjectPropertySetter(readString),\n  \"src\": makeObjectPropertySetter(readString),\n  \"link\": parseLink,\n  \"number\": makeObjectPropertySetter(readPositiveInteger),\n  \"extensions\": parseExtensions,\n  \"type\": makeObjectPropertySetter(readString),\n  \"rtept\": parseRtePt\n});\nvar RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"ele\": makeObjectPropertySetter(readDecimal),\n  \"time\": makeObjectPropertySetter(readDateTime)\n});\nvar TRK_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"name\": makeObjectPropertySetter(readString),\n  \"cmt\": makeObjectPropertySetter(readString),\n  \"desc\": makeObjectPropertySetter(readString),\n  \"src\": makeObjectPropertySetter(readString),\n  \"link\": parseLink,\n  \"number\": makeObjectPropertySetter(readPositiveInteger),\n  \"type\": makeObjectPropertySetter(readString),\n  \"extensions\": parseExtensions,\n  \"trkseg\": parseTrkSeg\n});\nvar TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"trkpt\": parseTrkPt\n});\nvar TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"ele\": makeObjectPropertySetter(readDecimal),\n  \"time\": makeObjectPropertySetter(readDateTime)\n});\nvar WPT_PARSERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"ele\": makeObjectPropertySetter(readDecimal),\n  \"time\": makeObjectPropertySetter(readDateTime),\n  \"magvar\": makeObjectPropertySetter(readDecimal),\n  \"geoidheight\": makeObjectPropertySetter(readDecimal),\n  \"name\": makeObjectPropertySetter(readString),\n  \"cmt\": makeObjectPropertySetter(readString),\n  \"desc\": makeObjectPropertySetter(readString),\n  \"src\": makeObjectPropertySetter(readString),\n  \"link\": parseLink,\n  \"sym\": makeObjectPropertySetter(readString),\n  \"type\": makeObjectPropertySetter(readString),\n  \"fix\": makeObjectPropertySetter(readString),\n  \"sat\": makeObjectPropertySetter(readPositiveInteger),\n  \"hdop\": makeObjectPropertySetter(readDecimal),\n  \"vdop\": makeObjectPropertySetter(readDecimal),\n  \"pdop\": makeObjectPropertySetter(readDecimal),\n  \"ageofdgpsdata\": makeObjectPropertySetter(readDecimal),\n  \"dgpsid\": makeObjectPropertySetter(readPositiveInteger),\n  \"extensions\": parseExtensions\n});\nvar LINK_SEQUENCE = [\"text\", \"type\"];\nvar LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"text\": makeChildAppender(writeStringTextNode),\n  \"type\": makeChildAppender(writeStringTextNode)\n});\nvar RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [\n  \"name\",\n  \"cmt\",\n  \"desc\",\n  \"src\",\n  \"link\",\n  \"number\",\n  \"type\",\n  \"rtept\"\n]);\nvar RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"name\": makeChildAppender(writeStringTextNode),\n  \"cmt\": makeChildAppender(writeStringTextNode),\n  \"desc\": makeChildAppender(writeStringTextNode),\n  \"src\": makeChildAppender(writeStringTextNode),\n  \"link\": makeChildAppender(writeLink),\n  \"number\": makeChildAppender(writeNonNegativeIntegerTextNode),\n  \"type\": makeChildAppender(writeStringTextNode),\n  \"rtept\": makeArraySerializer(makeChildAppender(writeWptType))\n});\nvar RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [\"ele\", \"time\"]);\nvar TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [\n  \"name\",\n  \"cmt\",\n  \"desc\",\n  \"src\",\n  \"link\",\n  \"number\",\n  \"type\",\n  \"trkseg\"\n]);\nvar TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"name\": makeChildAppender(writeStringTextNode),\n  \"cmt\": makeChildAppender(writeStringTextNode),\n  \"desc\": makeChildAppender(writeStringTextNode),\n  \"src\": makeChildAppender(writeStringTextNode),\n  \"link\": makeChildAppender(writeLink),\n  \"number\": makeChildAppender(writeNonNegativeIntegerTextNode),\n  \"type\": makeChildAppender(writeStringTextNode),\n  \"trkseg\": makeArraySerializer(makeChildAppender(writeTrkSeg))\n});\nvar TRKSEG_NODE_FACTORY = makeSimpleNodeFactory(\"trkpt\");\nvar TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"trkpt\": makeChildAppender(writeWptType)\n});\nvar WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$4, [\n  \"ele\",\n  \"time\",\n  \"magvar\",\n  \"geoidheight\",\n  \"name\",\n  \"cmt\",\n  \"desc\",\n  \"src\",\n  \"link\",\n  \"sym\",\n  \"type\",\n  \"fix\",\n  \"sat\",\n  \"hdop\",\n  \"vdop\",\n  \"pdop\",\n  \"ageofdgpsdata\",\n  \"dgpsid\"\n]);\nvar WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$4, {\n  \"ele\": makeChildAppender(writeDecimalTextNode),\n  \"time\": makeChildAppender(writeDateTimeTextNode),\n  \"magvar\": makeChildAppender(writeDecimalTextNode),\n  \"geoidheight\": makeChildAppender(writeDecimalTextNode),\n  \"name\": makeChildAppender(writeStringTextNode),\n  \"cmt\": makeChildAppender(writeStringTextNode),\n  \"desc\": makeChildAppender(writeStringTextNode),\n  \"src\": makeChildAppender(writeStringTextNode),\n  \"link\": makeChildAppender(writeLink),\n  \"sym\": makeChildAppender(writeStringTextNode),\n  \"type\": makeChildAppender(writeStringTextNode),\n  \"fix\": makeChildAppender(writeStringTextNode),\n  \"sat\": makeChildAppender(writeNonNegativeIntegerTextNode),\n  \"hdop\": makeChildAppender(writeDecimalTextNode),\n  \"vdop\": makeChildAppender(writeDecimalTextNode),\n  \"pdop\": makeChildAppender(writeDecimalTextNode),\n  \"ageofdgpsdata\": makeChildAppender(writeDecimalTextNode),\n  \"dgpsid\": makeChildAppender(writeNonNegativeIntegerTextNode)\n});\nvar GEOMETRY_TYPE_TO_NODENAME$1 = {\n  \"Point\": \"wpt\",\n  \"LineString\": \"rte\",\n  \"MultiLineString\": \"trk\"\n};\nfunction GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {\n  var geometry = value.getGeometry();\n  if (geometry) {\n    var nodeName = GEOMETRY_TYPE_TO_NODENAME$1[geometry.getType()];\n    if (nodeName) {\n      var parentNode = objectStack[objectStack.length - 1].node;\n      return createElementNS(parentNode.namespaceURI, nodeName);\n    }\n  }\n}\nfunction appendCoordinate(flatCoordinates, layoutOptions, node2, values2) {\n  flatCoordinates.push(parseFloat(node2.getAttribute(\"lon\")), parseFloat(node2.getAttribute(\"lat\")));\n  if (\"ele\" in values2) {\n    flatCoordinates.push(values2[\"ele\"]);\n    delete values2[\"ele\"];\n    layoutOptions.hasZ = true;\n  } else {\n    flatCoordinates.push(0);\n  }\n  if (\"time\" in values2) {\n    flatCoordinates.push(values2[\"time\"]);\n    delete values2[\"time\"];\n    layoutOptions.hasM = true;\n  } else {\n    flatCoordinates.push(0);\n  }\n  return flatCoordinates;\n}\nfunction applyLayoutOptions(layoutOptions, flatCoordinates, ends) {\n  var layout = GeometryLayout.XY;\n  var stride = 2;\n  if (layoutOptions.hasZ && layoutOptions.hasM) {\n    layout = GeometryLayout.XYZM;\n    stride = 4;\n  } else if (layoutOptions.hasZ) {\n    layout = GeometryLayout.XYZ;\n    stride = 3;\n  } else if (layoutOptions.hasM) {\n    layout = GeometryLayout.XYM;\n    stride = 3;\n  }\n  if (stride !== 4) {\n    for (var i2 = 0, ii = flatCoordinates.length / 4; i2 < ii; i2++) {\n      flatCoordinates[i2 * stride] = flatCoordinates[i2 * 4];\n      flatCoordinates[i2 * stride + 1] = flatCoordinates[i2 * 4 + 1];\n      if (layoutOptions.hasZ) {\n        flatCoordinates[i2 * stride + 2] = flatCoordinates[i2 * 4 + 2];\n      }\n      if (layoutOptions.hasM) {\n        flatCoordinates[i2 * stride + 2] = flatCoordinates[i2 * 4 + 3];\n      }\n    }\n    flatCoordinates.length = flatCoordinates.length / 4 * stride;\n    if (ends) {\n      for (var i2 = 0, ii = ends.length; i2 < ii; i2++) {\n        ends[i2] = ends[i2] / 4 * stride;\n      }\n    }\n  }\n  return layout;\n}\nfunction parseLink(node2, objectStack) {\n  var values2 = objectStack[objectStack.length - 1];\n  var href = node2.getAttribute(\"href\");\n  if (href !== null) {\n    values2[\"link\"] = href;\n  }\n  parseNode(LINK_PARSERS$1, node2, objectStack);\n}\nfunction parseExtensions(node2, objectStack) {\n  var values2 = objectStack[objectStack.length - 1];\n  values2[\"extensionsNode_\"] = node2;\n}\nfunction parseRtePt(node2, objectStack) {\n  var values2 = pushParseAndPop({}, RTEPT_PARSERS, node2, objectStack);\n  if (values2) {\n    var rteValues = objectStack[objectStack.length - 1];\n    var flatCoordinates = rteValues[\"flatCoordinates\"];\n    var layoutOptions = rteValues[\"layoutOptions\"];\n    appendCoordinate(flatCoordinates, layoutOptions, node2, values2);\n  }\n}\nfunction parseTrkPt(node2, objectStack) {\n  var values2 = pushParseAndPop({}, TRKPT_PARSERS, node2, objectStack);\n  if (values2) {\n    var trkValues = objectStack[objectStack.length - 1];\n    var flatCoordinates = trkValues[\"flatCoordinates\"];\n    var layoutOptions = trkValues[\"layoutOptions\"];\n    appendCoordinate(flatCoordinates, layoutOptions, node2, values2);\n  }\n}\nfunction parseTrkSeg(node2, objectStack) {\n  var values2 = objectStack[objectStack.length - 1];\n  parseNode(TRKSEG_PARSERS, node2, objectStack);\n  var flatCoordinates = values2[\"flatCoordinates\"];\n  var ends = values2[\"ends\"];\n  ends.push(flatCoordinates.length);\n}\nfunction readRte(node2, objectStack) {\n  var options = objectStack[0];\n  var values2 = pushParseAndPop({\n    \"flatCoordinates\": [],\n    \"layoutOptions\": {}\n  }, RTE_PARSERS, node2, objectStack);\n  if (!values2) {\n    return void 0;\n  }\n  var flatCoordinates = values2[\"flatCoordinates\"];\n  delete values2[\"flatCoordinates\"];\n  var layoutOptions = values2[\"layoutOptions\"];\n  delete values2[\"layoutOptions\"];\n  var layout = applyLayoutOptions(layoutOptions, flatCoordinates);\n  var geometry = new LineString$2(flatCoordinates, layout);\n  transformGeometryWithOptions(geometry, false, options);\n  var feature$1 = new feature(geometry);\n  feature$1.setProperties(values2, true);\n  return feature$1;\n}\nfunction readTrk(node2, objectStack) {\n  var options = objectStack[0];\n  var values2 = pushParseAndPop({\n    \"flatCoordinates\": [],\n    \"ends\": [],\n    \"layoutOptions\": {}\n  }, TRK_PARSERS, node2, objectStack);\n  if (!values2) {\n    return void 0;\n  }\n  var flatCoordinates = values2[\"flatCoordinates\"];\n  delete values2[\"flatCoordinates\"];\n  var ends = values2[\"ends\"];\n  delete values2[\"ends\"];\n  var layoutOptions = values2[\"layoutOptions\"];\n  delete values2[\"layoutOptions\"];\n  var layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);\n  var geometry = new MultiLineString$2(flatCoordinates, layout, ends);\n  transformGeometryWithOptions(geometry, false, options);\n  var feature$1 = new feature(geometry);\n  feature$1.setProperties(values2, true);\n  return feature$1;\n}\nfunction readWpt(node2, objectStack) {\n  var options = objectStack[0];\n  var values2 = pushParseAndPop({}, WPT_PARSERS, node2, objectStack);\n  if (!values2) {\n    return void 0;\n  }\n  var layoutOptions = {};\n  var coordinates2 = appendCoordinate([], layoutOptions, node2, values2);\n  var layout = applyLayoutOptions(layoutOptions, coordinates2);\n  var geometry = new Point$4(coordinates2, layout);\n  transformGeometryWithOptions(geometry, false, options);\n  var feature$1 = new feature(geometry);\n  feature$1.setProperties(values2, true);\n  return feature$1;\n}\nfunction writeLink(node2, value, objectStack) {\n  node2.setAttribute(\"href\", value);\n  var context = objectStack[objectStack.length - 1];\n  var properties = context[\"properties\"];\n  var link = [properties[\"linkText\"], properties[\"linkType\"]];\n  pushSerializeAndPop({ node: node2 }, LINK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, link, objectStack, LINK_SEQUENCE);\n}\nfunction writeWptType(node2, coordinate, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var parentNode = context.node;\n  var namespaceURI = parentNode.namespaceURI;\n  var properties = context[\"properties\"];\n  node2.setAttributeNS(null, \"lat\", String(coordinate[1]));\n  node2.setAttributeNS(null, \"lon\", String(coordinate[0]));\n  var geometryLayout = context[\"geometryLayout\"];\n  switch (geometryLayout) {\n    case GeometryLayout.XYZM:\n      if (coordinate[3] !== 0) {\n        properties[\"time\"] = coordinate[3];\n      }\n    case GeometryLayout.XYZ:\n      if (coordinate[2] !== 0) {\n        properties[\"ele\"] = coordinate[2];\n      }\n      break;\n    case GeometryLayout.XYM:\n      if (coordinate[2] !== 0) {\n        properties[\"time\"] = coordinate[2];\n      }\n      break;\n  }\n  var orderedKeys = node2.nodeName == \"rtept\" ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop({ node: node2, \"properties\": properties }, WPT_TYPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nfunction writeRte(node2, feature2, objectStack) {\n  var options = objectStack[0];\n  var properties = feature2.getProperties();\n  var context = { node: node2 };\n  context[\"properties\"] = properties;\n  var geometry = feature2.getGeometry();\n  if (geometry.getType() == GeometryType.LINE_STRING) {\n    var lineString = transformGeometryWithOptions(geometry, true, options);\n    context[\"geometryLayout\"] = lineString.getLayout();\n    properties[\"rtept\"] = lineString.getCoordinates();\n  }\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, RTE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nfunction writeTrk(node2, feature2, objectStack) {\n  var options = objectStack[0];\n  var properties = feature2.getProperties();\n  var context = { node: node2 };\n  context[\"properties\"] = properties;\n  var geometry = feature2.getGeometry();\n  if (geometry.getType() == GeometryType.MULTI_LINE_STRING) {\n    var multiLineString = transformGeometryWithOptions(geometry, true, options);\n    properties[\"trkseg\"] = multiLineString.getLineStrings();\n  }\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, TRK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nfunction writeTrkSeg(node2, lineString, objectStack) {\n  var context = { node: node2 };\n  context[\"geometryLayout\"] = lineString.getLayout();\n  context[\"properties\"] = {};\n  pushSerializeAndPop(context, TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY, lineString.getCoordinates(), objectStack);\n}\nfunction writeWpt(node2, feature2, objectStack) {\n  var options = objectStack[0];\n  var context = objectStack[objectStack.length - 1];\n  context[\"properties\"] = feature2.getProperties();\n  var geometry = feature2.getGeometry();\n  if (geometry.getType() == GeometryType.POINT) {\n    var point = transformGeometryWithOptions(geometry, true, options);\n    context[\"geometryLayout\"] = point.getLayout();\n    writeWptType(node2, point.getCoordinates(), objectStack);\n  }\n}\nvar GPX$1 = GPX;\nvar __extends$h = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TextFeature = function(_super) {\n  __extends$h(TextFeature2, _super);\n  function TextFeature2() {\n    return _super.call(this) || this;\n  }\n  TextFeature2.prototype.getType = function() {\n    return FormatType.TEXT;\n  };\n  TextFeature2.prototype.readFeature = function(source, opt_options) {\n    return this.readFeatureFromText(getText(source), this.adaptOptions(opt_options));\n  };\n  TextFeature2.prototype.readFeatureFromText = function(text2, opt_options) {\n    return abstract();\n  };\n  TextFeature2.prototype.readFeatures = function(source, opt_options) {\n    return this.readFeaturesFromText(getText(source), this.adaptOptions(opt_options));\n  };\n  TextFeature2.prototype.readFeaturesFromText = function(text2, opt_options) {\n    return abstract();\n  };\n  TextFeature2.prototype.readGeometry = function(source, opt_options) {\n    return this.readGeometryFromText(getText(source), this.adaptOptions(opt_options));\n  };\n  TextFeature2.prototype.readGeometryFromText = function(text2, opt_options) {\n    return abstract();\n  };\n  TextFeature2.prototype.readProjection = function(source) {\n    return this.readProjectionFromText(getText(source));\n  };\n  TextFeature2.prototype.readProjectionFromText = function(text2) {\n    return this.dataProjection;\n  };\n  TextFeature2.prototype.writeFeature = function(feature2, opt_options) {\n    return this.writeFeatureText(feature2, this.adaptOptions(opt_options));\n  };\n  TextFeature2.prototype.writeFeatureText = function(feature2, opt_options) {\n    return abstract();\n  };\n  TextFeature2.prototype.writeFeatures = function(features, opt_options) {\n    return this.writeFeaturesText(features, this.adaptOptions(opt_options));\n  };\n  TextFeature2.prototype.writeFeaturesText = function(features, opt_options) {\n    return abstract();\n  };\n  TextFeature2.prototype.writeGeometry = function(geometry, opt_options) {\n    return this.writeGeometryText(geometry, this.adaptOptions(opt_options));\n  };\n  TextFeature2.prototype.writeGeometryText = function(geometry, opt_options) {\n    return abstract();\n  };\n  return TextFeature2;\n}(FeatureFormat$1);\nfunction getText(source) {\n  if (typeof source === \"string\") {\n    return source;\n  } else {\n    return \"\";\n  }\n}\nvar TextFeature$1 = TextFeature;\nvar __extends$g = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar IGCZ = {\n  BAROMETRIC: \"barometric\",\n  GPS: \"gps\",\n  NONE: \"none\"\n};\nvar B_RECORD_RE = /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\nvar H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\nvar HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\nvar NEWLINE_RE = /\\r\\n|\\r|\\n/;\nvar IGC = function(_super) {\n  __extends$g(IGC2, _super);\n  function IGC2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.dataProjection = get$3(\"EPSG:4326\");\n    _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : IGCZ.NONE;\n    return _this;\n  }\n  IGC2.prototype.readFeatureFromText = function(text2, opt_options) {\n    var altitudeMode = this.altitudeMode_;\n    var lines = text2.split(NEWLINE_RE);\n    var properties = {};\n    var flatCoordinates = [];\n    var year = 2e3;\n    var month = 0;\n    var day = 1;\n    var lastDateTime = -1;\n    var i2, ii;\n    for (i2 = 0, ii = lines.length; i2 < ii; ++i2) {\n      var line = lines[i2];\n      var m2 = void 0;\n      if (line.charAt(0) == \"B\") {\n        m2 = B_RECORD_RE.exec(line);\n        if (m2) {\n          var hour = parseInt(m2[1], 10);\n          var minute = parseInt(m2[2], 10);\n          var second = parseInt(m2[3], 10);\n          var y2 = parseInt(m2[4], 10) + parseInt(m2[5], 10) / 6e4;\n          if (m2[6] == \"S\") {\n            y2 = -y2;\n          }\n          var x2 = parseInt(m2[7], 10) + parseInt(m2[8], 10) / 6e4;\n          if (m2[9] == \"W\") {\n            x2 = -x2;\n          }\n          flatCoordinates.push(x2, y2);\n          if (altitudeMode != IGCZ.NONE) {\n            var z2 = void 0;\n            if (altitudeMode == IGCZ.GPS) {\n              z2 = parseInt(m2[11], 10);\n            } else if (altitudeMode == IGCZ.BAROMETRIC) {\n              z2 = parseInt(m2[12], 10);\n            } else {\n              z2 = 0;\n            }\n            flatCoordinates.push(z2);\n          }\n          var dateTime = Date.UTC(year, month, day, hour, minute, second);\n          if (dateTime < lastDateTime) {\n            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n          }\n          flatCoordinates.push(dateTime / 1e3);\n          lastDateTime = dateTime;\n        }\n      } else if (line.charAt(0) == \"H\") {\n        m2 = HFDTE_RECORD_RE.exec(line);\n        if (m2) {\n          day = parseInt(m2[1], 10);\n          month = parseInt(m2[2], 10) - 1;\n          year = 2e3 + parseInt(m2[3], 10);\n        } else {\n          m2 = H_RECORD_RE.exec(line);\n          if (m2) {\n            properties[m2[1]] = m2[2].trim();\n          }\n        }\n      }\n    }\n    if (flatCoordinates.length === 0) {\n      return null;\n    }\n    var layout = altitudeMode == IGCZ.NONE ? GeometryLayout.XYM : GeometryLayout.XYZM;\n    var lineString = new LineString$2(flatCoordinates, layout);\n    var feature$1 = new feature(transformGeometryWithOptions(lineString, false, opt_options));\n    feature$1.setProperties(properties, true);\n    return feature$1;\n  };\n  IGC2.prototype.readFeaturesFromText = function(text2, opt_options) {\n    var feature2 = this.readFeatureFromText(text2, opt_options);\n    if (feature2) {\n      return [feature2];\n    } else {\n      return [];\n    }\n  };\n  return IGC2;\n}(TextFeature$1);\nvar IGC$1 = IGC;\nvar __extends$f = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar GX_NAMESPACE_URIS = [\"http://www.google.com/kml/ext/2.2\"];\nvar NAMESPACE_URIS$3 = [\n  null,\n  \"http://earth.google.com/kml/2.0\",\n  \"http://earth.google.com/kml/2.1\",\n  \"http://earth.google.com/kml/2.2\",\n  \"http://www.opengis.net/kml/2.2\"\n];\nvar SCHEMA_LOCATION = \"http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd\";\nvar ICON_ANCHOR_UNITS_MAP = {\n  \"fraction\": IconAnchorUnits.FRACTION,\n  \"pixels\": IconAnchorUnits.PIXELS,\n  \"insetPixels\": IconAnchorUnits.PIXELS\n};\nvar PLACEMARK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"ExtendedData\": extendedDataParser,\n  \"Region\": regionParser,\n  \"MultiGeometry\": makeObjectPropertySetter(readMultiGeometry, \"geometry\"),\n  \"LineString\": makeObjectPropertySetter(readLineString, \"geometry\"),\n  \"LinearRing\": makeObjectPropertySetter(readLinearRing, \"geometry\"),\n  \"Point\": makeObjectPropertySetter(readPoint, \"geometry\"),\n  \"Polygon\": makeObjectPropertySetter(readPolygon, \"geometry\"),\n  \"Style\": makeObjectPropertySetter(readStyle$2),\n  \"StyleMap\": placemarkStyleMapParser,\n  \"address\": makeObjectPropertySetter(readString),\n  \"description\": makeObjectPropertySetter(readString),\n  \"name\": makeObjectPropertySetter(readString),\n  \"open\": makeObjectPropertySetter(readBoolean),\n  \"phoneNumber\": makeObjectPropertySetter(readString),\n  \"styleUrl\": makeObjectPropertySetter(readStyleURL),\n  \"visibility\": makeObjectPropertySetter(readBoolean)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  \"MultiTrack\": makeObjectPropertySetter(readGxMultiTrack, \"geometry\"),\n  \"Track\": makeObjectPropertySetter(readGxTrack, \"geometry\")\n}));\nvar NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"ExtendedData\": extendedDataParser,\n  \"Region\": regionParser,\n  \"Link\": linkParser,\n  \"address\": makeObjectPropertySetter(readString),\n  \"description\": makeObjectPropertySetter(readString),\n  \"name\": makeObjectPropertySetter(readString),\n  \"open\": makeObjectPropertySetter(readBoolean),\n  \"phoneNumber\": makeObjectPropertySetter(readString),\n  \"visibility\": makeObjectPropertySetter(readBoolean)\n});\nvar LINK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"href\": makeObjectPropertySetter(readURI)\n});\nvar REGION_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"LatLonAltBox\": latLonAltBoxParser,\n  \"Lod\": lodParser\n});\nvar KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\"Document\", \"Placemark\"]);\nvar KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"Document\": makeChildAppender(writeDocument),\n  \"Placemark\": makeChildAppender(writePlacemark)\n});\nvar DEFAULT_COLOR;\nvar DEFAULT_FILL_STYLE = null;\nvar DEFAULT_IMAGE_STYLE_ANCHOR;\nvar DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\nvar DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\nvar DEFAULT_IMAGE_STYLE_SIZE;\nvar DEFAULT_IMAGE_STYLE_SRC;\nvar DEFAULT_IMAGE_STYLE = null;\nvar DEFAULT_NO_IMAGE_STYLE;\nvar DEFAULT_STROKE_STYLE = null;\nvar DEFAULT_TEXT_STROKE_STYLE;\nvar DEFAULT_TEXT_STYLE = null;\nvar DEFAULT_STYLE = null;\nvar DEFAULT_STYLE_ARRAY = null;\nfunction scaleForSize(size) {\n  return 32 / Math.min(size[0], size[1]);\n}\nfunction createStyleDefaults() {\n  DEFAULT_COLOR = [255, 255, 255, 1];\n  DEFAULT_FILL_STYLE = new Fill$2({\n    color: DEFAULT_COLOR\n  });\n  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];\n  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = IconAnchorUnits.PIXELS;\n  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = IconAnchorUnits.PIXELS;\n  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];\n  DEFAULT_IMAGE_STYLE_SRC = \"https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png\";\n  DEFAULT_IMAGE_STYLE = new Icon$2({\n    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,\n    anchorOrigin: IconOrigin.BOTTOM_LEFT,\n    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,\n    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,\n    crossOrigin: \"anonymous\",\n    rotation: 0,\n    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),\n    size: DEFAULT_IMAGE_STYLE_SIZE,\n    src: DEFAULT_IMAGE_STYLE_SRC\n  });\n  DEFAULT_NO_IMAGE_STYLE = \"NO_IMAGE\";\n  DEFAULT_STROKE_STYLE = new Stroke$2({\n    color: DEFAULT_COLOR,\n    width: 1\n  });\n  DEFAULT_TEXT_STROKE_STYLE = new Stroke$2({\n    color: [51, 51, 51, 1],\n    width: 2\n  });\n  DEFAULT_TEXT_STYLE = new Text$2({\n    font: \"bold 16px Helvetica\",\n    fill: DEFAULT_FILL_STYLE,\n    stroke: DEFAULT_TEXT_STROKE_STYLE,\n    scale: 0.8\n  });\n  DEFAULT_STYLE = new Style$2({\n    fill: DEFAULT_FILL_STYLE,\n    image: DEFAULT_IMAGE_STYLE,\n    text: DEFAULT_TEXT_STYLE,\n    stroke: DEFAULT_STROKE_STYLE,\n    zIndex: 0\n  });\n  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];\n}\nvar TEXTAREA;\nfunction defaultIconUrlFunction(href) {\n  return href;\n}\nvar KML = function(_super) {\n  __extends$f(KML2, _super);\n  function KML2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    if (!DEFAULT_STYLE_ARRAY) {\n      createStyleDefaults();\n    }\n    _this.dataProjection = get$3(\"EPSG:4326\");\n    _this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;\n    _this.extractStyles_ = options.extractStyles !== void 0 ? options.extractStyles : true;\n    _this.writeStyles_ = options.writeStyles !== void 0 ? options.writeStyles : true;\n    _this.sharedStyles_ = {};\n    _this.showPointNames_ = options.showPointNames !== void 0 ? options.showPointNames : true;\n    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : \"anonymous\";\n    _this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;\n    _this.supportedMediaTypes = [\"application/vnd.google-earth.kml+xml\"];\n    return _this;\n  }\n  KML2.prototype.readDocumentOrFolder_ = function(node2, objectStack) {\n    var parsersNS = makeStructureNS(NAMESPACE_URIS$3, {\n      \"Document\": makeArrayExtender(this.readDocumentOrFolder_, this),\n      \"Folder\": makeArrayExtender(this.readDocumentOrFolder_, this),\n      \"Placemark\": makeArrayPusher(this.readPlacemark_, this),\n      \"Style\": this.readSharedStyle_.bind(this),\n      \"StyleMap\": this.readSharedStyleMap_.bind(this)\n    });\n    var features = pushParseAndPop([], parsersNS, node2, objectStack, this);\n    if (features) {\n      return features;\n    } else {\n      return void 0;\n    }\n  };\n  KML2.prototype.readPlacemark_ = function(node2, objectStack) {\n    var object = pushParseAndPop({ \"geometry\": null }, PLACEMARK_PARSERS, node2, objectStack, this);\n    if (!object) {\n      return void 0;\n    }\n    var feature$1 = new feature();\n    var id = node2.getAttribute(\"id\");\n    if (id !== null) {\n      feature$1.setId(id);\n    }\n    var options = objectStack[0];\n    var geometry = object[\"geometry\"];\n    if (geometry) {\n      transformGeometryWithOptions(geometry, false, options);\n    }\n    feature$1.setGeometry(geometry);\n    delete object[\"geometry\"];\n    if (this.extractStyles_) {\n      var style2 = object[\"Style\"];\n      var styleUrl = object[\"styleUrl\"];\n      var styleFunction = createFeatureStyleFunction(style2, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);\n      feature$1.setStyle(styleFunction);\n    }\n    delete object[\"Style\"];\n    feature$1.setProperties(object, true);\n    return feature$1;\n  };\n  KML2.prototype.readSharedStyle_ = function(node2, objectStack) {\n    var id = node2.getAttribute(\"id\");\n    if (id !== null) {\n      var style2 = readStyle$2.call(this, node2, objectStack);\n      if (style2) {\n        var styleUri = void 0;\n        var baseURI = node2.baseURI;\n        if (!baseURI || baseURI == \"about:blank\") {\n          baseURI = window.location.href;\n        }\n        if (baseURI) {\n          var url = new URL(\"#\" + id, baseURI);\n          styleUri = url.href;\n        } else {\n          styleUri = \"#\" + id;\n        }\n        this.sharedStyles_[styleUri] = style2;\n      }\n    }\n  };\n  KML2.prototype.readSharedStyleMap_ = function(node2, objectStack) {\n    var id = node2.getAttribute(\"id\");\n    if (id === null) {\n      return;\n    }\n    var styleMapValue = readStyleMapValue.call(this, node2, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    var styleUri;\n    var baseURI = node2.baseURI;\n    if (!baseURI || baseURI == \"about:blank\") {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      var url = new URL(\"#\" + id, baseURI);\n      styleUri = url.href;\n    } else {\n      styleUri = \"#\" + id;\n    }\n    this.sharedStyles_[styleUri] = styleMapValue;\n  };\n  KML2.prototype.readFeatureFromNode = function(node2, opt_options) {\n    if (!includes(NAMESPACE_URIS$3, node2.namespaceURI)) {\n      return null;\n    }\n    var feature2 = this.readPlacemark_(node2, [\n      this.getReadOptions(node2, opt_options)\n    ]);\n    if (feature2) {\n      return feature2;\n    } else {\n      return null;\n    }\n  };\n  KML2.prototype.readFeaturesFromNode = function(node2, opt_options) {\n    if (!includes(NAMESPACE_URIS$3, node2.namespaceURI)) {\n      return [];\n    }\n    var features;\n    var localName = node2.localName;\n    if (localName == \"Document\" || localName == \"Folder\") {\n      features = this.readDocumentOrFolder_(node2, [\n        this.getReadOptions(node2, opt_options)\n      ]);\n      if (features) {\n        return features;\n      } else {\n        return [];\n      }\n    } else if (localName == \"Placemark\") {\n      var feature2 = this.readPlacemark_(node2, [\n        this.getReadOptions(node2, opt_options)\n      ]);\n      if (feature2) {\n        return [feature2];\n      } else {\n        return [];\n      }\n    } else if (localName == \"kml\") {\n      features = [];\n      for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n        var fs = this.readFeaturesFromNode(n2, opt_options);\n        if (fs) {\n          extend$3(features, fs);\n        }\n      }\n      return features;\n    } else {\n      return [];\n    }\n  };\n  KML2.prototype.readName = function(source) {\n    if (!source) {\n      return void 0;\n    } else if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      return this.readNameFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readNameFromDocument(source);\n    } else {\n      return this.readNameFromNode(source);\n    }\n  };\n  KML2.prototype.readNameFromDocument = function(doc) {\n    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {\n      if (n2.nodeType == Node.ELEMENT_NODE) {\n        var name_1 = this.readNameFromNode(n2);\n        if (name_1) {\n          return name_1;\n        }\n      }\n    }\n    return void 0;\n  };\n  KML2.prototype.readNameFromNode = function(node2) {\n    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && n2.localName == \"name\") {\n        return readString(n2);\n      }\n    }\n    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n      var localName = n2.localName;\n      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && (localName == \"Document\" || localName == \"Folder\" || localName == \"Placemark\" || localName == \"kml\")) {\n        var name_2 = this.readNameFromNode(n2);\n        if (name_2) {\n          return name_2;\n        }\n      }\n    }\n    return void 0;\n  };\n  KML2.prototype.readNetworkLinks = function(source) {\n    var networkLinks = [];\n    if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      extend$3(networkLinks, this.readNetworkLinksFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend$3(networkLinks, this.readNetworkLinksFromDocument(source));\n    } else {\n      extend$3(networkLinks, this.readNetworkLinksFromNode(source));\n    }\n    return networkLinks;\n  };\n  KML2.prototype.readNetworkLinksFromDocument = function(doc) {\n    var networkLinks = [];\n    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {\n      if (n2.nodeType == Node.ELEMENT_NODE) {\n        extend$3(networkLinks, this.readNetworkLinksFromNode(n2));\n      }\n    }\n    return networkLinks;\n  };\n  KML2.prototype.readNetworkLinksFromNode = function(node2) {\n    var networkLinks = [];\n    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && n2.localName == \"NetworkLink\") {\n        var obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n2, []);\n        networkLinks.push(obj);\n      }\n    }\n    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n      var localName = n2.localName;\n      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && (localName == \"Document\" || localName == \"Folder\" || localName == \"kml\")) {\n        extend$3(networkLinks, this.readNetworkLinksFromNode(n2));\n      }\n    }\n    return networkLinks;\n  };\n  KML2.prototype.readRegion = function(source) {\n    var regions = [];\n    if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      extend$3(regions, this.readRegionFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend$3(regions, this.readRegionFromDocument(source));\n    } else {\n      extend$3(regions, this.readRegionFromNode(source));\n    }\n    return regions;\n  };\n  KML2.prototype.readRegionFromDocument = function(doc) {\n    var regions = [];\n    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {\n      if (n2.nodeType == Node.ELEMENT_NODE) {\n        extend$3(regions, this.readRegionFromNode(n2));\n      }\n    }\n    return regions;\n  };\n  KML2.prototype.readRegionFromNode = function(node2) {\n    var regions = [];\n    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && n2.localName == \"Region\") {\n        var obj = pushParseAndPop({}, REGION_PARSERS, n2, []);\n        regions.push(obj);\n      }\n    }\n    for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n      var localName = n2.localName;\n      if (includes(NAMESPACE_URIS$3, n2.namespaceURI) && (localName == \"Document\" || localName == \"Folder\" || localName == \"kml\")) {\n        extend$3(regions, this.readRegionFromNode(n2));\n      }\n    }\n    return regions;\n  };\n  KML2.prototype.writeFeaturesNode = function(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var kml = createElementNS(NAMESPACE_URIS$3[4], \"kml\");\n    var xmlnsUri = \"http://www.w3.org/2000/xmlns/\";\n    kml.setAttributeNS(xmlnsUri, \"xmlns:gx\", GX_NAMESPACE_URIS[0]);\n    kml.setAttributeNS(xmlnsUri, \"xmlns:xsi\", XML_SCHEMA_INSTANCE_URI);\n    kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, \"xsi:schemaLocation\", SCHEMA_LOCATION);\n    var context = {\n      node: kml\n    };\n    var properties = {};\n    if (features.length > 1) {\n      properties[\"Document\"] = features;\n    } else if (features.length == 1) {\n      properties[\"Placemark\"] = features[0];\n    }\n    var orderedKeys = KML_SEQUENCE[kml.namespaceURI];\n    var values2 = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(context, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, [opt_options], orderedKeys, this);\n    return kml;\n  };\n  return KML2;\n}(XMLFeature$1);\nfunction createNameStyleFunction(foundStyle, name) {\n  var textOffset = [0, 0];\n  var textAlign2 = \"start\";\n  var imageStyle = foundStyle.getImage();\n  if (imageStyle) {\n    var imageSize = imageStyle.getSize();\n    if (imageSize && imageSize.length == 2) {\n      var imageScale = imageStyle.getScaleArray();\n      var anchor = imageStyle.getAnchor();\n      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);\n      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);\n      textAlign2 = \"left\";\n    }\n  }\n  var textStyle = foundStyle.getText();\n  if (textStyle) {\n    textStyle = textStyle.clone();\n    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());\n    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());\n    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());\n    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);\n  } else {\n    textStyle = DEFAULT_TEXT_STYLE.clone();\n  }\n  textStyle.setText(name);\n  textStyle.setOffsetX(textOffset[0]);\n  textStyle.setOffsetY(textOffset[1]);\n  textStyle.setTextAlign(textAlign2);\n  var nameStyle = new Style$2({\n    image: imageStyle,\n    text: textStyle\n  });\n  return nameStyle;\n}\nfunction createFeatureStyleFunction(style2, styleUrl, defaultStyle, sharedStyles, showPointNames) {\n  return function(feature2, resolution) {\n    var drawName = showPointNames;\n    var name = \"\";\n    var multiGeometryPoints = [];\n    if (drawName) {\n      var geometry = feature2.getGeometry();\n      if (geometry) {\n        if (geometry instanceof GeometryCollection$1) {\n          multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function(geometry2) {\n            var type2 = geometry2.getType();\n            return type2 === GeometryType.POINT || type2 === GeometryType.MULTI_POINT;\n          });\n          drawName = multiGeometryPoints.length > 0;\n        } else {\n          var type = geometry.getType();\n          drawName = type === GeometryType.POINT || type === GeometryType.MULTI_POINT;\n        }\n      }\n    }\n    if (drawName) {\n      name = feature2.get(\"name\");\n      drawName = drawName && !!name;\n      if (drawName && name.search(/&[^&]+;/) > -1) {\n        if (!TEXTAREA) {\n          TEXTAREA = document.createElement(\"textarea\");\n        }\n        TEXTAREA.innerHTML = name;\n        name = TEXTAREA.value;\n      }\n    }\n    var featureStyle = defaultStyle;\n    if (style2) {\n      featureStyle = style2;\n    } else if (styleUrl) {\n      featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);\n    }\n    if (drawName) {\n      var nameStyle = createNameStyleFunction(featureStyle[0], name);\n      if (multiGeometryPoints.length > 0) {\n        nameStyle.setGeometry(new GeometryCollection$1(multiGeometryPoints));\n        var baseStyle = new Style$2({\n          geometry: featureStyle[0].getGeometry(),\n          image: null,\n          fill: featureStyle[0].getFill(),\n          stroke: featureStyle[0].getStroke(),\n          text: null\n        });\n        return [nameStyle, baseStyle].concat(featureStyle.slice(1));\n      }\n      return nameStyle;\n    }\n    return featureStyle;\n  };\n}\nfunction findStyle(styleValue, defaultStyle, sharedStyles) {\n  if (Array.isArray(styleValue)) {\n    return styleValue;\n  } else if (typeof styleValue === \"string\") {\n    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);\n  } else {\n    return defaultStyle;\n  }\n}\nfunction readColor(node2) {\n  var s2 = getAllTextContent(node2, false);\n  var m2 = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s2);\n  if (m2) {\n    var hexColor = m2[1];\n    return [\n      parseInt(hexColor.substr(6, 2), 16),\n      parseInt(hexColor.substr(4, 2), 16),\n      parseInt(hexColor.substr(2, 2), 16),\n      parseInt(hexColor.substr(0, 2), 16) / 255\n    ];\n  } else {\n    return void 0;\n  }\n}\nfunction readFlatCoordinates(node2) {\n  var s2 = getAllTextContent(node2, false);\n  var flatCoordinates = [];\n  s2 = s2.replace(/\\s*,\\s*/g, \",\");\n  var re2 = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?),([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|,|$)(?:([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|$))?\\s*/i;\n  var m2;\n  while (m2 = re2.exec(s2)) {\n    var x2 = parseFloat(m2[1]);\n    var y2 = parseFloat(m2[2]);\n    var z2 = m2[3] ? parseFloat(m2[3]) : 0;\n    flatCoordinates.push(x2, y2, z2);\n    s2 = s2.substr(m2[0].length);\n  }\n  if (s2 !== \"\") {\n    return void 0;\n  }\n  return flatCoordinates;\n}\nfunction readURI(node2) {\n  var s2 = getAllTextContent(node2, false).trim();\n  var baseURI = node2.baseURI;\n  if (!baseURI || baseURI == \"about:blank\") {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    var url = new URL(s2, baseURI);\n    return url.href;\n  } else {\n    return s2;\n  }\n}\nfunction readStyleURL(node2) {\n  var s2 = getAllTextContent(node2, false).trim().replace(/^(?!.*#)/, \"#\");\n  var baseURI = node2.baseURI;\n  if (!baseURI || baseURI == \"about:blank\") {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    var url = new URL(s2, baseURI);\n    return url.href;\n  } else {\n    return s2;\n  }\n}\nfunction readVec2(node2) {\n  var xunits = node2.getAttribute(\"xunits\");\n  var yunits = node2.getAttribute(\"yunits\");\n  var origin;\n  if (xunits !== \"insetPixels\") {\n    if (yunits !== \"insetPixels\") {\n      origin = IconOrigin.BOTTOM_LEFT;\n    } else {\n      origin = IconOrigin.TOP_LEFT;\n    }\n  } else {\n    if (yunits !== \"insetPixels\") {\n      origin = IconOrigin.BOTTOM_RIGHT;\n    } else {\n      origin = IconOrigin.TOP_RIGHT;\n    }\n  }\n  return {\n    x: parseFloat(node2.getAttribute(\"x\")),\n    xunits: ICON_ANCHOR_UNITS_MAP[xunits],\n    y: parseFloat(node2.getAttribute(\"y\")),\n    yunits: ICON_ANCHOR_UNITS_MAP[yunits],\n    origin\n  };\n}\nfunction readScale(node2) {\n  return readDecimal(node2);\n}\nvar STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"Pair\": pairDataParser\n});\nfunction readStyleMapValue(node2, objectStack) {\n  return pushParseAndPop(void 0, STYLE_MAP_PARSERS, node2, objectStack, this);\n}\nvar ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"Icon\": makeObjectPropertySetter(readIcon),\n  \"color\": makeObjectPropertySetter(readColor),\n  \"heading\": makeObjectPropertySetter(readDecimal),\n  \"hotSpot\": makeObjectPropertySetter(readVec2),\n  \"scale\": makeObjectPropertySetter(readScale)\n});\nfunction iconStyleParser(node2, objectStack) {\n  var object = pushParseAndPop({}, ICON_STYLE_PARSERS, node2, objectStack);\n  if (!object) {\n    return;\n  }\n  var styleObject = objectStack[objectStack.length - 1];\n  var IconObject = \"Icon\" in object ? object[\"Icon\"] : {};\n  var drawIcon = !(\"Icon\" in object) || Object.keys(IconObject).length > 0;\n  var src;\n  var href = IconObject[\"href\"];\n  if (href) {\n    src = href;\n  } else if (drawIcon) {\n    src = DEFAULT_IMAGE_STYLE_SRC;\n  }\n  var anchor, anchorXUnits, anchorYUnits;\n  var anchorOrigin = IconOrigin.BOTTOM_LEFT;\n  var hotSpot = object[\"hotSpot\"];\n  if (hotSpot) {\n    anchor = [hotSpot.x, hotSpot.y];\n    anchorXUnits = hotSpot.xunits;\n    anchorYUnits = hotSpot.yunits;\n    anchorOrigin = hotSpot.origin;\n  } else if (/^http:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\n    if (/pushpin/.test(src)) {\n      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (/arrow-reverse/.test(src)) {\n      anchor = [54, 42];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (/paddle/.test(src)) {\n      anchor = [32, 1];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    }\n  }\n  var offset2;\n  var x2 = IconObject[\"x\"];\n  var y2 = IconObject[\"y\"];\n  if (x2 !== void 0 && y2 !== void 0) {\n    offset2 = [x2, y2];\n  }\n  var size;\n  var w2 = IconObject[\"w\"];\n  var h2 = IconObject[\"h\"];\n  if (w2 !== void 0 && h2 !== void 0) {\n    size = [w2, h2];\n  }\n  var rotation;\n  var heading = object[\"heading\"];\n  if (heading !== void 0) {\n    rotation = toRadians(heading);\n  }\n  var scale2 = object[\"scale\"];\n  var color2 = object[\"color\"];\n  if (drawIcon) {\n    if (src == DEFAULT_IMAGE_STYLE_SRC) {\n      size = DEFAULT_IMAGE_STYLE_SIZE;\n    }\n    var imageStyle_1 = new Icon$2({\n      anchor,\n      anchorOrigin,\n      anchorXUnits,\n      anchorYUnits,\n      crossOrigin: this.crossOrigin_,\n      offset: offset2,\n      offsetOrigin: IconOrigin.BOTTOM_LEFT,\n      rotation,\n      scale: scale2,\n      size,\n      src: this.iconUrlFunction_(src),\n      color: color2\n    });\n    var imageScale_1 = imageStyle_1.getScaleArray()[0];\n    var imageSize = imageStyle_1.getSize();\n    if (imageSize === null) {\n      var imageState = imageStyle_1.getImageState();\n      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {\n        var listener_1 = function() {\n          var imageState2 = imageStyle_1.getImageState();\n          if (!(imageState2 === ImageState.IDLE || imageState2 === ImageState.LOADING)) {\n            var imageSize_1 = imageStyle_1.getSize();\n            if (imageSize_1 && imageSize_1.length == 2) {\n              var resizeScale2 = scaleForSize(imageSize_1);\n              imageStyle_1.setScale(imageScale_1 * resizeScale2);\n            }\n            imageStyle_1.unlistenImageChange(listener_1);\n          }\n        };\n        imageStyle_1.listenImageChange(listener_1);\n        if (imageState === ImageState.IDLE) {\n          imageStyle_1.load();\n        }\n      }\n    } else if (imageSize.length == 2) {\n      var resizeScale = scaleForSize(imageSize);\n      imageStyle_1.setScale(imageScale_1 * resizeScale);\n    }\n    styleObject[\"imageStyle\"] = imageStyle_1;\n  } else {\n    styleObject[\"imageStyle\"] = DEFAULT_NO_IMAGE_STYLE;\n  }\n}\nvar LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"color\": makeObjectPropertySetter(readColor),\n  \"scale\": makeObjectPropertySetter(readScale)\n});\nfunction labelStyleParser(node2, objectStack) {\n  var object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node2, objectStack);\n  if (!object) {\n    return;\n  }\n  var styleObject = objectStack[objectStack.length - 1];\n  var textStyle = new Text$2({\n    fill: new Fill$2({\n      color: \"color\" in object ? object[\"color\"] : DEFAULT_COLOR\n    }),\n    scale: object[\"scale\"]\n  });\n  styleObject[\"textStyle\"] = textStyle;\n}\nvar LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"color\": makeObjectPropertySetter(readColor),\n  \"width\": makeObjectPropertySetter(readDecimal)\n});\nfunction lineStyleParser(node2, objectStack) {\n  var object = pushParseAndPop({}, LINE_STYLE_PARSERS, node2, objectStack);\n  if (!object) {\n    return;\n  }\n  var styleObject = objectStack[objectStack.length - 1];\n  var strokeStyle = new Stroke$2({\n    color: \"color\" in object ? object[\"color\"] : DEFAULT_COLOR,\n    width: \"width\" in object ? object[\"width\"] : 1\n  });\n  styleObject[\"strokeStyle\"] = strokeStyle;\n}\nvar POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"color\": makeObjectPropertySetter(readColor),\n  \"fill\": makeObjectPropertySetter(readBoolean),\n  \"outline\": makeObjectPropertySetter(readBoolean)\n});\nfunction polyStyleParser(node2, objectStack) {\n  var object = pushParseAndPop({}, POLY_STYLE_PARSERS, node2, objectStack);\n  if (!object) {\n    return;\n  }\n  var styleObject = objectStack[objectStack.length - 1];\n  var fillStyle = new Fill$2({\n    color: \"color\" in object ? object[\"color\"] : DEFAULT_COLOR\n  });\n  styleObject[\"fillStyle\"] = fillStyle;\n  var fill = object[\"fill\"];\n  if (fill !== void 0) {\n    styleObject[\"fill\"] = fill;\n  }\n  var outline = object[\"outline\"];\n  if (outline !== void 0) {\n    styleObject[\"outline\"] = outline;\n  }\n}\nvar FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"coordinates\": makeReplacer(readFlatCoordinates)\n});\nfunction readFlatLinearRing(node2, objectStack) {\n  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node2, objectStack);\n}\nfunction gxCoordParser(node2, objectStack) {\n  var gxTrackObject = objectStack[objectStack.length - 1];\n  var coordinates2 = gxTrackObject.coordinates;\n  var s2 = getAllTextContent(node2, false);\n  var re2 = /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\n  var m2 = re2.exec(s2);\n  if (m2) {\n    var x2 = parseFloat(m2[1]);\n    var y2 = parseFloat(m2[2]);\n    var z2 = parseFloat(m2[3]);\n    coordinates2.push([x2, y2, z2]);\n  } else {\n    coordinates2.push([]);\n  }\n}\nvar GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {\n  \"Track\": makeArrayPusher(readGxTrack)\n});\nfunction readGxMultiTrack(node2, objectStack) {\n  var lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node2, objectStack);\n  if (!lineStrings) {\n    return void 0;\n  }\n  return new MultiLineString$2(lineStrings);\n}\nvar GX_TRACK_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"when\": whenParser\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  \"coord\": gxCoordParser\n}));\nfunction readGxTrack(node2, objectStack) {\n  var gxTrackObject = pushParseAndPop({\n    coordinates: [],\n    whens: []\n  }, GX_TRACK_PARSERS, node2, objectStack);\n  if (!gxTrackObject) {\n    return void 0;\n  }\n  var flatCoordinates = [];\n  var coordinates2 = gxTrackObject.coordinates;\n  var whens = gxTrackObject.whens;\n  for (var i2 = 0, ii = Math.min(coordinates2.length, whens.length); i2 < ii; ++i2) {\n    if (coordinates2[i2].length == 3) {\n      flatCoordinates.push(coordinates2[i2][0], coordinates2[i2][1], coordinates2[i2][2], whens[i2]);\n    }\n  }\n  return new LineString$2(flatCoordinates, GeometryLayout.XYZM);\n}\nvar ICON_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"href\": makeObjectPropertySetter(readURI)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  \"x\": makeObjectPropertySetter(readDecimal),\n  \"y\": makeObjectPropertySetter(readDecimal),\n  \"w\": makeObjectPropertySetter(readDecimal),\n  \"h\": makeObjectPropertySetter(readDecimal)\n}));\nfunction readIcon(node2, objectStack) {\n  var iconObject = pushParseAndPop({}, ICON_PARSERS, node2, objectStack);\n  if (iconObject) {\n    return iconObject;\n  } else {\n    return null;\n  }\n}\nvar GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"coordinates\": makeReplacer(readFlatCoordinates)\n});\nfunction readFlatCoordinatesFromNode(node2, objectStack) {\n  return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node2, objectStack);\n}\nvar EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"extrude\": makeObjectPropertySetter(readBoolean),\n  \"tessellate\": makeObjectPropertySetter(readBoolean),\n  \"altitudeMode\": makeObjectPropertySetter(readString)\n});\nfunction readLineString(node2, objectStack) {\n  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);\n  var flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);\n  if (flatCoordinates) {\n    var lineString = new LineString$2(flatCoordinates, GeometryLayout.XYZ);\n    lineString.setProperties(properties, true);\n    return lineString;\n  } else {\n    return void 0;\n  }\n}\nfunction readLinearRing(node2, objectStack) {\n  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);\n  var flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);\n  if (flatCoordinates) {\n    var polygon = new Polygon$2(flatCoordinates, GeometryLayout.XYZ, [\n      flatCoordinates.length\n    ]);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return void 0;\n  }\n}\nvar MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"LineString\": makeArrayPusher(readLineString),\n  \"LinearRing\": makeArrayPusher(readLinearRing),\n  \"MultiGeometry\": makeArrayPusher(readMultiGeometry),\n  \"Point\": makeArrayPusher(readPoint),\n  \"Polygon\": makeArrayPusher(readPolygon)\n});\nfunction readMultiGeometry(node2, objectStack) {\n  var geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node2, objectStack);\n  if (!geometries) {\n    return null;\n  }\n  if (geometries.length === 0) {\n    return new GeometryCollection$1(geometries);\n  }\n  var multiGeometry;\n  var homogeneous = true;\n  var type = geometries[0].getType();\n  var geometry;\n  for (var i2 = 1, ii = geometries.length; i2 < ii; ++i2) {\n    geometry = geometries[i2];\n    if (geometry.getType() != type) {\n      homogeneous = false;\n      break;\n    }\n  }\n  if (homogeneous) {\n    var layout = void 0;\n    var flatCoordinates = void 0;\n    if (type == GeometryType.POINT) {\n      var point = geometries[0];\n      layout = point.getLayout();\n      flatCoordinates = point.getFlatCoordinates();\n      for (var i2 = 1, ii = geometries.length; i2 < ii; ++i2) {\n        geometry = geometries[i2];\n        extend$3(flatCoordinates, geometry.getFlatCoordinates());\n      }\n      multiGeometry = new MultiPoint$2(flatCoordinates, layout);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == GeometryType.LINE_STRING) {\n      multiGeometry = new MultiLineString$2(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == GeometryType.POLYGON) {\n      multiGeometry = new MultiPolygon$2(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == GeometryType.GEOMETRY_COLLECTION) {\n      multiGeometry = new GeometryCollection$1(geometries);\n    } else {\n      assert(false, 37);\n    }\n  } else {\n    multiGeometry = new GeometryCollection$1(geometries);\n  }\n  return multiGeometry;\n}\nfunction readPoint(node2, objectStack) {\n  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);\n  var flatCoordinates = readFlatCoordinatesFromNode(node2, objectStack);\n  if (flatCoordinates) {\n    var point = new Point$4(flatCoordinates, GeometryLayout.XYZ);\n    point.setProperties(properties, true);\n    return point;\n  } else {\n    return void 0;\n  }\n}\nvar FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"innerBoundaryIs\": innerBoundaryIsParser,\n  \"outerBoundaryIs\": outerBoundaryIsParser\n});\nfunction readPolygon(node2, objectStack) {\n  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node2, objectStack);\n  var flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node2, objectStack);\n  if (flatLinearRings && flatLinearRings[0]) {\n    var flatCoordinates = flatLinearRings[0];\n    var ends = [flatCoordinates.length];\n    for (var i2 = 1, ii = flatLinearRings.length; i2 < ii; ++i2) {\n      extend$3(flatCoordinates, flatLinearRings[i2]);\n      ends.push(flatCoordinates.length);\n    }\n    var polygon = new Polygon$2(flatCoordinates, GeometryLayout.XYZ, ends);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return void 0;\n  }\n}\nvar STYLE_PARSERS$2 = makeStructureNS(NAMESPACE_URIS$3, {\n  \"IconStyle\": iconStyleParser,\n  \"LabelStyle\": labelStyleParser,\n  \"LineStyle\": lineStyleParser,\n  \"PolyStyle\": polyStyleParser\n});\nfunction readStyle$2(node2, objectStack) {\n  var styleObject = pushParseAndPop({}, STYLE_PARSERS$2, node2, objectStack, this);\n  if (!styleObject) {\n    return null;\n  }\n  var fillStyle = \"fillStyle\" in styleObject ? styleObject[\"fillStyle\"] : DEFAULT_FILL_STYLE;\n  var fill = styleObject[\"fill\"];\n  if (fill !== void 0 && !fill) {\n    fillStyle = null;\n  }\n  var imageStyle;\n  if (\"imageStyle\" in styleObject) {\n    if (styleObject[\"imageStyle\"] != DEFAULT_NO_IMAGE_STYLE) {\n      imageStyle = styleObject[\"imageStyle\"];\n    }\n  } else {\n    imageStyle = DEFAULT_IMAGE_STYLE;\n  }\n  var textStyle = \"textStyle\" in styleObject ? styleObject[\"textStyle\"] : DEFAULT_TEXT_STYLE;\n  var strokeStyle = \"strokeStyle\" in styleObject ? styleObject[\"strokeStyle\"] : DEFAULT_STROKE_STYLE;\n  var outline = styleObject[\"outline\"];\n  if (outline !== void 0 && !outline) {\n    return [\n      new Style$2({\n        geometry: function(feature2) {\n          var geometry = feature2.getGeometry();\n          var type = geometry.getType();\n          if (type === GeometryType.GEOMETRY_COLLECTION) {\n            var collection = geometry;\n            return new GeometryCollection$1(collection.getGeometriesArrayRecursive().filter(function(geometry2) {\n              var type2 = geometry2.getType();\n              return type2 !== GeometryType.POLYGON && type2 !== GeometryType.MULTI_POLYGON;\n            }));\n          } else if (type !== GeometryType.POLYGON && type !== GeometryType.MULTI_POLYGON) {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        image: imageStyle,\n        stroke: strokeStyle,\n        text: textStyle,\n        zIndex: void 0\n      }),\n      new Style$2({\n        geometry: function(feature2) {\n          var geometry = feature2.getGeometry();\n          var type = geometry.getType();\n          if (type === GeometryType.GEOMETRY_COLLECTION) {\n            var collection = geometry;\n            return new GeometryCollection$1(collection.getGeometriesArrayRecursive().filter(function(geometry2) {\n              var type2 = geometry2.getType();\n              return type2 === GeometryType.POLYGON || type2 === GeometryType.MULTI_POLYGON;\n            }));\n          } else if (type === GeometryType.POLYGON || type === GeometryType.MULTI_POLYGON) {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        stroke: null,\n        zIndex: void 0\n      })\n    ];\n  }\n  return [\n    new Style$2({\n      fill: fillStyle,\n      image: imageStyle,\n      stroke: strokeStyle,\n      text: textStyle,\n      zIndex: void 0\n    })\n  ];\n}\nfunction setCommonGeometryProperties(multiGeometry, geometries) {\n  var ii = geometries.length;\n  var extrudes = new Array(geometries.length);\n  var tessellates = new Array(geometries.length);\n  var altitudeModes = new Array(geometries.length);\n  var hasExtrude, hasTessellate, hasAltitudeMode;\n  hasExtrude = false;\n  hasTessellate = false;\n  hasAltitudeMode = false;\n  for (var i2 = 0; i2 < ii; ++i2) {\n    var geometry = geometries[i2];\n    extrudes[i2] = geometry.get(\"extrude\");\n    tessellates[i2] = geometry.get(\"tessellate\");\n    altitudeModes[i2] = geometry.get(\"altitudeMode\");\n    hasExtrude = hasExtrude || extrudes[i2] !== void 0;\n    hasTessellate = hasTessellate || tessellates[i2] !== void 0;\n    hasAltitudeMode = hasAltitudeMode || altitudeModes[i2];\n  }\n  if (hasExtrude) {\n    multiGeometry.set(\"extrude\", extrudes);\n  }\n  if (hasTessellate) {\n    multiGeometry.set(\"tessellate\", tessellates);\n  }\n  if (hasAltitudeMode) {\n    multiGeometry.set(\"altitudeMode\", altitudeModes);\n  }\n}\nvar DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"displayName\": makeObjectPropertySetter(readString),\n  \"value\": makeObjectPropertySetter(readString)\n});\nfunction dataParser(node2, objectStack) {\n  var name = node2.getAttribute(\"name\");\n  parseNode(DATA_PARSERS, node2, objectStack);\n  var featureObject = objectStack[objectStack.length - 1];\n  if (name && featureObject.displayName) {\n    featureObject[name] = {\n      value: featureObject.value,\n      displayName: featureObject.displayName,\n      toString: function() {\n        return featureObject.value;\n      }\n    };\n  } else if (name !== null) {\n    featureObject[name] = featureObject.value;\n  } else if (featureObject.displayName !== null) {\n    featureObject[featureObject.displayName] = featureObject.value;\n  }\n  delete featureObject[\"value\"];\n}\nvar EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"Data\": dataParser,\n  \"SchemaData\": schemaDataParser\n});\nfunction extendedDataParser(node2, objectStack) {\n  parseNode(EXTENDED_DATA_PARSERS, node2, objectStack);\n}\nfunction regionParser(node2, objectStack) {\n  parseNode(REGION_PARSERS, node2, objectStack);\n}\nvar PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"Style\": makeObjectPropertySetter(readStyle$2),\n  \"key\": makeObjectPropertySetter(readString),\n  \"styleUrl\": makeObjectPropertySetter(readStyleURL)\n});\nfunction pairDataParser(node2, objectStack) {\n  var pairObject = pushParseAndPop({}, PAIR_PARSERS, node2, objectStack, this);\n  if (!pairObject) {\n    return;\n  }\n  var key = pairObject[\"key\"];\n  if (key && key == \"normal\") {\n    var styleUrl = pairObject[\"styleUrl\"];\n    if (styleUrl) {\n      objectStack[objectStack.length - 1] = styleUrl;\n    }\n    var style2 = pairObject[\"Style\"];\n    if (style2) {\n      objectStack[objectStack.length - 1] = style2;\n    }\n  }\n}\nfunction placemarkStyleMapParser(node2, objectStack) {\n  var styleMapValue = readStyleMapValue.call(this, node2, objectStack);\n  if (!styleMapValue) {\n    return;\n  }\n  var placemarkObject = objectStack[objectStack.length - 1];\n  if (Array.isArray(styleMapValue)) {\n    placemarkObject[\"Style\"] = styleMapValue;\n  } else if (typeof styleMapValue === \"string\") {\n    placemarkObject[\"styleUrl\"] = styleMapValue;\n  } else {\n    assert(false, 38);\n  }\n}\nvar SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"SimpleData\": simpleDataParser\n});\nfunction schemaDataParser(node2, objectStack) {\n  parseNode(SCHEMA_DATA_PARSERS, node2, objectStack);\n}\nfunction simpleDataParser(node2, objectStack) {\n  var name = node2.getAttribute(\"name\");\n  if (name !== null) {\n    var data2 = readString(node2);\n    var featureObject = objectStack[objectStack.length - 1];\n    featureObject[name] = data2;\n  }\n}\nvar LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"altitudeMode\": makeObjectPropertySetter(readString),\n  \"minAltitude\": makeObjectPropertySetter(readDecimal),\n  \"maxAltitude\": makeObjectPropertySetter(readDecimal),\n  \"north\": makeObjectPropertySetter(readDecimal),\n  \"south\": makeObjectPropertySetter(readDecimal),\n  \"east\": makeObjectPropertySetter(readDecimal),\n  \"west\": makeObjectPropertySetter(readDecimal)\n});\nfunction latLonAltBoxParser(node2, objectStack) {\n  var object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node2, objectStack);\n  if (!object) {\n    return;\n  }\n  var regionObject = objectStack[objectStack.length - 1];\n  var extent2 = [\n    parseFloat(object[\"west\"]),\n    parseFloat(object[\"south\"]),\n    parseFloat(object[\"east\"]),\n    parseFloat(object[\"north\"])\n  ];\n  regionObject[\"extent\"] = extent2;\n  regionObject[\"altitudeMode\"] = object[\"altitudeMode\"];\n  regionObject[\"minAltitude\"] = parseFloat(object[\"minAltitude\"]);\n  regionObject[\"maxAltitude\"] = parseFloat(object[\"maxAltitude\"]);\n}\nvar LOD_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"minLodPixels\": makeObjectPropertySetter(readDecimal),\n  \"maxLodPixels\": makeObjectPropertySetter(readDecimal),\n  \"minFadeExtent\": makeObjectPropertySetter(readDecimal),\n  \"maxFadeExtent\": makeObjectPropertySetter(readDecimal)\n});\nfunction lodParser(node2, objectStack) {\n  var object = pushParseAndPop({}, LOD_PARSERS, node2, objectStack);\n  if (!object) {\n    return;\n  }\n  var lodObject = objectStack[objectStack.length - 1];\n  lodObject[\"minLodPixels\"] = parseFloat(object[\"minLodPixels\"]);\n  lodObject[\"maxLodPixels\"] = parseFloat(object[\"maxLodPixels\"]);\n  lodObject[\"minFadeExtent\"] = parseFloat(object[\"minFadeExtent\"]);\n  lodObject[\"maxFadeExtent\"] = parseFloat(object[\"maxFadeExtent\"]);\n}\nvar INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"LinearRing\": makeArrayPusher(readFlatLinearRing)\n});\nfunction innerBoundaryIsParser(node2, objectStack) {\n  var innerBoundaryFlatLinearRings = pushParseAndPop([], INNER_BOUNDARY_IS_PARSERS, node2, objectStack);\n  if (innerBoundaryFlatLinearRings.length > 0) {\n    var flatLinearRings = objectStack[objectStack.length - 1];\n    flatLinearRings.push.apply(flatLinearRings, innerBoundaryFlatLinearRings);\n  }\n}\nvar OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"LinearRing\": makeReplacer(readFlatLinearRing)\n});\nfunction outerBoundaryIsParser(node2, objectStack) {\n  var flatLinearRing = pushParseAndPop(void 0, OUTER_BOUNDARY_IS_PARSERS, node2, objectStack);\n  if (flatLinearRing) {\n    var flatLinearRings = objectStack[objectStack.length - 1];\n    flatLinearRings[0] = flatLinearRing;\n  }\n}\nfunction linkParser(node2, objectStack) {\n  parseNode(LINK_PARSERS, node2, objectStack);\n}\nfunction whenParser(node2, objectStack) {\n  var gxTrackObject = objectStack[objectStack.length - 1];\n  var whens = gxTrackObject.whens;\n  var s2 = getAllTextContent(node2, false);\n  var when = Date.parse(s2);\n  whens.push(isNaN(when) ? 0 : when);\n}\nfunction writeColorTextNode(node2, color2) {\n  var rgba = asArray(color2);\n  var opacity2 = rgba.length == 4 ? rgba[3] : 1;\n  var abgr = [opacity2 * 255, rgba[2], rgba[1], rgba[0]];\n  for (var i2 = 0; i2 < 4; ++i2) {\n    var hex = Math.floor(abgr[i2]).toString(16);\n    abgr[i2] = hex.length == 1 ? \"0\" + hex : hex;\n  }\n  writeStringTextNode(node2, abgr.join(\"\"));\n}\nfunction writeCoordinatesTextNode(node2, coordinates2, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var layout = context[\"layout\"];\n  var stride = context[\"stride\"];\n  var dimension;\n  if (layout == GeometryLayout.XY || layout == GeometryLayout.XYM) {\n    dimension = 2;\n  } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYZM) {\n    dimension = 3;\n  } else {\n    assert(false, 34);\n  }\n  var ii = coordinates2.length;\n  var text2 = \"\";\n  if (ii > 0) {\n    text2 += coordinates2[0];\n    for (var d2 = 1; d2 < dimension; ++d2) {\n      text2 += \",\" + coordinates2[d2];\n    }\n    for (var i2 = stride; i2 < ii; i2 += stride) {\n      text2 += \" \" + coordinates2[i2];\n      for (var d2 = 1; d2 < dimension; ++d2) {\n        text2 += \",\" + coordinates2[i2 + d2];\n      }\n    }\n  }\n  writeStringTextNode(node2, text2);\n}\nvar EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"Data\": makeChildAppender(writeDataNode),\n  \"value\": makeChildAppender(writeDataNodeValue),\n  \"displayName\": makeChildAppender(writeDataNodeName)\n});\nfunction writeDataNode(node2, pair, objectStack) {\n  node2.setAttribute(\"name\", pair.name);\n  var context = { node: node2 };\n  var value = pair.value;\n  if (typeof value == \"object\") {\n    if (value !== null && value.displayName) {\n      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, [\"displayName\"]);\n    }\n    if (value !== null && value.value) {\n      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, [\"value\"]);\n    }\n  } else {\n    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, [\"value\"]);\n  }\n}\nfunction writeDataNodeName(node2, name) {\n  writeCDATASection(node2, name);\n}\nfunction writeDataNodeValue(node2, value) {\n  writeStringTextNode(node2, value);\n}\nvar DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"Placemark\": makeChildAppender(writePlacemark)\n});\nvar DOCUMENT_NODE_FACTORY = function(value, objectStack, opt_nodeName) {\n  var parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS(parentNode.namespaceURI, \"Placemark\");\n};\nfunction writeDocument(node2, features, objectStack) {\n  var context = { node: node2 };\n  pushSerializeAndPop(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, void 0, this);\n}\nvar DATA_NODE_FACTORY = makeSimpleNodeFactory(\"Data\");\nfunction writeExtendedData(node2, namesAndValues, objectStack) {\n  var context = { node: node2 };\n  var names2 = namesAndValues.names;\n  var values2 = namesAndValues.values;\n  var length = names2.length;\n  for (var i2 = 0; i2 < length; i2++) {\n    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{ name: names2[i2], value: values2[i2] }], objectStack);\n  }\n}\nvar ICON_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\"href\"], makeStructureNS(GX_NAMESPACE_URIS, [\"x\", \"y\", \"w\", \"h\"]));\nvar ICON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"href\": makeChildAppender(writeStringTextNode)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  \"x\": makeChildAppender(writeDecimalTextNode),\n  \"y\": makeChildAppender(writeDecimalTextNode),\n  \"w\": makeChildAppender(writeDecimalTextNode),\n  \"h\": makeChildAppender(writeDecimalTextNode)\n}));\nvar GX_NODE_FACTORY = function(value, objectStack, opt_nodeName) {\n  return createElementNS(GX_NAMESPACE_URIS[0], \"gx:\" + opt_nodeName);\n};\nfunction writeIcon(node2, icon, objectStack) {\n  var context = { node: node2 };\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(context, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];\n  values2 = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nvar ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\n  \"scale\",\n  \"heading\",\n  \"Icon\",\n  \"color\",\n  \"hotSpot\"\n]);\nvar ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"Icon\": makeChildAppender(writeIcon),\n  \"color\": makeChildAppender(writeColorTextNode),\n  \"heading\": makeChildAppender(writeDecimalTextNode),\n  \"hotSpot\": makeChildAppender(writeVec2),\n  \"scale\": makeChildAppender(writeScaleTextNode)\n});\nfunction writeIconStyle(node2, style2, objectStack) {\n  var context = { node: node2 };\n  var properties = {};\n  var src = style2.getSrc();\n  var size = style2.getSize();\n  var iconImageSize = style2.getImageSize();\n  var iconProperties = {\n    \"href\": src\n  };\n  if (size) {\n    iconProperties[\"w\"] = size[0];\n    iconProperties[\"h\"] = size[1];\n    var anchor = style2.getAnchor();\n    var origin_1 = style2.getOrigin();\n    if (origin_1 && iconImageSize && origin_1[0] !== 0 && origin_1[1] !== size[1]) {\n      iconProperties[\"x\"] = origin_1[0];\n      iconProperties[\"y\"] = iconImageSize[1] - (origin_1[1] + size[1]);\n    }\n    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\n      var hotSpot = {\n        x: anchor[0],\n        xunits: IconAnchorUnits.PIXELS,\n        y: size[1] - anchor[1],\n        yunits: IconAnchorUnits.PIXELS\n      };\n      properties[\"hotSpot\"] = hotSpot;\n    }\n  }\n  properties[\"Icon\"] = iconProperties;\n  var scale2 = style2.getScaleArray()[0];\n  var imageSize = size;\n  if (imageSize === null) {\n    imageSize = DEFAULT_IMAGE_STYLE_SIZE;\n  }\n  if (imageSize.length == 2) {\n    var resizeScale = scaleForSize(imageSize);\n    scale2 = scale2 / resizeScale;\n  }\n  if (scale2 !== 1) {\n    properties[\"scale\"] = scale2;\n  }\n  var rotation = style2.getRotation();\n  if (rotation !== 0) {\n    properties[\"heading\"] = rotation;\n  }\n  var color2 = style2.getColor();\n  if (color2) {\n    properties[\"color\"] = color2;\n  }\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nvar LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\n  \"color\",\n  \"scale\"\n]);\nvar LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"color\": makeChildAppender(writeColorTextNode),\n  \"scale\": makeChildAppender(writeScaleTextNode)\n});\nfunction writeLabelStyle(node2, style2, objectStack) {\n  var context = { node: node2 };\n  var properties = {};\n  var fill = style2.getFill();\n  if (fill) {\n    properties[\"color\"] = fill.getColor();\n  }\n  var scale2 = style2.getScale();\n  if (scale2 && scale2 !== 1) {\n    properties[\"scale\"] = scale2;\n  }\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nvar LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\"color\", \"width\"]);\nvar LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"color\": makeChildAppender(writeColorTextNode),\n  \"width\": makeChildAppender(writeDecimalTextNode)\n});\nfunction writeLineStyle(node2, style2, objectStack) {\n  var context = { node: node2 };\n  var properties = {\n    \"color\": style2.getColor(),\n    \"width\": Number(style2.getWidth()) || 1\n  };\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nvar GEOMETRY_TYPE_TO_NODENAME = {\n  \"Point\": \"Point\",\n  \"LineString\": \"LineString\",\n  \"LinearRing\": \"LinearRing\",\n  \"Polygon\": \"Polygon\",\n  \"MultiPoint\": \"MultiGeometry\",\n  \"MultiLineString\": \"MultiGeometry\",\n  \"MultiPolygon\": \"MultiGeometry\",\n  \"GeometryCollection\": \"MultiGeometry\"\n};\nvar GEOMETRY_NODE_FACTORY = function(value, objectStack, opt_nodeName) {\n  if (value) {\n    var parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(parentNode.namespaceURI, GEOMETRY_TYPE_TO_NODENAME[value.getType()]);\n  }\n};\nvar POINT_NODE_FACTORY = makeSimpleNodeFactory(\"Point\");\nvar LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory(\"LineString\");\nvar LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory(\"LinearRing\");\nvar POLYGON_NODE_FACTORY = makeSimpleNodeFactory(\"Polygon\");\nvar MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"LineString\": makeChildAppender(writePrimitiveGeometry),\n  \"Point\": makeChildAppender(writePrimitiveGeometry),\n  \"Polygon\": makeChildAppender(writePolygon),\n  \"GeometryCollection\": makeChildAppender(writeMultiGeometry)\n});\nfunction writeMultiGeometry(node2, geometry, objectStack) {\n  var context = { node: node2 };\n  var type = geometry.getType();\n  var geometries = [];\n  var factory;\n  if (type === GeometryType.GEOMETRY_COLLECTION) {\n    geometry.getGeometriesArrayRecursive().forEach(function(geometry2) {\n      var type2 = geometry2.getType();\n      if (type2 === GeometryType.MULTI_POINT) {\n        geometries = geometries.concat(geometry2.getPoints());\n      } else if (type2 === GeometryType.MULTI_LINE_STRING) {\n        geometries = geometries.concat(geometry2.getLineStrings());\n      } else if (type2 === GeometryType.MULTI_POLYGON) {\n        geometries = geometries.concat(geometry2.getPolygons());\n      } else if (type2 === GeometryType.POINT || type2 === GeometryType.LINE_STRING || type2 === GeometryType.POLYGON) {\n        geometries.push(geometry2);\n      } else {\n        assert(false, 39);\n      }\n    });\n    factory = GEOMETRY_NODE_FACTORY;\n  } else if (type === GeometryType.MULTI_POINT) {\n    geometries = geometry.getPoints();\n    factory = POINT_NODE_FACTORY;\n  } else if (type === GeometryType.MULTI_LINE_STRING) {\n    geometries = geometry.getLineStrings();\n    factory = LINE_STRING_NODE_FACTORY;\n  } else if (type === GeometryType.MULTI_POLYGON) {\n    geometries = geometry.getPolygons();\n    factory = POLYGON_NODE_FACTORY;\n  } else {\n    assert(false, 39);\n  }\n  pushSerializeAndPop(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);\n}\nvar BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"LinearRing\": makeChildAppender(writePrimitiveGeometry)\n});\nfunction writeBoundaryIs(node2, linearRing2, objectStack) {\n  var context = { node: node2 };\n  pushSerializeAndPop(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing2], objectStack);\n}\nvar PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"ExtendedData\": makeChildAppender(writeExtendedData),\n  \"MultiGeometry\": makeChildAppender(writeMultiGeometry),\n  \"LineString\": makeChildAppender(writePrimitiveGeometry),\n  \"LinearRing\": makeChildAppender(writePrimitiveGeometry),\n  \"Point\": makeChildAppender(writePrimitiveGeometry),\n  \"Polygon\": makeChildAppender(writePolygon),\n  \"Style\": makeChildAppender(writeStyle),\n  \"address\": makeChildAppender(writeStringTextNode),\n  \"description\": makeChildAppender(writeStringTextNode),\n  \"name\": makeChildAppender(writeStringTextNode),\n  \"open\": makeChildAppender(writeBooleanTextNode),\n  \"phoneNumber\": makeChildAppender(writeStringTextNode),\n  \"styleUrl\": makeChildAppender(writeStringTextNode),\n  \"visibility\": makeChildAppender(writeBooleanTextNode)\n});\nvar PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\n  \"name\",\n  \"open\",\n  \"visibility\",\n  \"address\",\n  \"phoneNumber\",\n  \"description\",\n  \"styleUrl\",\n  \"Style\"\n]);\nvar EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory(\"ExtendedData\");\nfunction writePlacemark(node2, feature2, objectStack) {\n  var context = { node: node2 };\n  if (feature2.getId()) {\n    node2.setAttribute(\"id\", feature2.getId());\n  }\n  var properties = feature2.getProperties();\n  var filter = {\n    \"address\": 1,\n    \"description\": 1,\n    \"name\": 1,\n    \"open\": 1,\n    \"phoneNumber\": 1,\n    \"styleUrl\": 1,\n    \"visibility\": 1\n  };\n  filter[feature2.getGeometryName()] = 1;\n  var keys3 = Object.keys(properties || {}).sort().filter(function(v2) {\n    return !filter[v2];\n  });\n  var styleFunction = feature2.getStyleFunction();\n  if (styleFunction) {\n    var styles = styleFunction(feature2, 0);\n    if (styles) {\n      var styleArray = Array.isArray(styles) ? styles : [styles];\n      var pointStyles = styleArray;\n      if (feature2.getGeometry()) {\n        pointStyles = styleArray.filter(function(style2) {\n          var geometry2 = style2.getGeometryFunction()(feature2);\n          if (geometry2) {\n            var type = geometry2.getType();\n            if (type === GeometryType.GEOMETRY_COLLECTION) {\n              return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {\n                var type2 = geometry3.getType();\n                return type2 === GeometryType.POINT || type2 === GeometryType.MULTI_POINT;\n              }).length;\n            }\n            return type === GeometryType.POINT || type === GeometryType.MULTI_POINT;\n          }\n        });\n      }\n      if (this.writeStyles_) {\n        var lineStyles = styleArray;\n        var polyStyles = styleArray;\n        if (feature2.getGeometry()) {\n          lineStyles = styleArray.filter(function(style2) {\n            var geometry2 = style2.getGeometryFunction()(feature2);\n            if (geometry2) {\n              var type = geometry2.getType();\n              if (type === GeometryType.GEOMETRY_COLLECTION) {\n                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {\n                  var type2 = geometry3.getType();\n                  return type2 === GeometryType.LINE_STRING || type2 === GeometryType.MULTI_LINE_STRING;\n                }).length;\n              }\n              return type === GeometryType.LINE_STRING || type === GeometryType.MULTI_LINE_STRING;\n            }\n          });\n          polyStyles = styleArray.filter(function(style2) {\n            var geometry2 = style2.getGeometryFunction()(feature2);\n            if (geometry2) {\n              var type = geometry2.getType();\n              if (type === GeometryType.GEOMETRY_COLLECTION) {\n                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {\n                  var type2 = geometry3.getType();\n                  return type2 === GeometryType.POLYGON || type2 === GeometryType.MULTI_POLYGON;\n                }).length;\n              }\n              return type === GeometryType.POLYGON || type === GeometryType.MULTI_POLYGON;\n            }\n          });\n        }\n        properties[\"Style\"] = {\n          pointStyles,\n          lineStyles,\n          polyStyles\n        };\n      }\n      if (pointStyles.length && properties[\"name\"] === void 0) {\n        var textStyle = pointStyles[0].getText();\n        if (textStyle) {\n          properties[\"name\"] = textStyle.getText();\n        }\n      }\n    }\n  }\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n  if (keys3.length > 0) {\n    var sequence = makeSequence(properties, keys3);\n    var namesAndValues = { names: keys3, values: sequence };\n    pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);\n  }\n  var options = objectStack[0];\n  var geometry = feature2.getGeometry();\n  if (geometry) {\n    geometry = transformGeometryWithOptions(geometry, true, options);\n  }\n  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);\n}\nvar PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\n  \"extrude\",\n  \"tessellate\",\n  \"altitudeMode\",\n  \"coordinates\"\n]);\nvar PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"extrude\": makeChildAppender(writeBooleanTextNode),\n  \"tessellate\": makeChildAppender(writeBooleanTextNode),\n  \"altitudeMode\": makeChildAppender(writeStringTextNode),\n  \"coordinates\": makeChildAppender(writeCoordinatesTextNode)\n});\nfunction writePrimitiveGeometry(node2, geometry, objectStack) {\n  var flatCoordinates = geometry.getFlatCoordinates();\n  var context = { node: node2 };\n  context[\"layout\"] = geometry.getLayout();\n  context[\"stride\"] = geometry.getStride();\n  var properties = geometry.getProperties();\n  properties.coordinates = flatCoordinates;\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nvar POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\n  \"color\",\n  \"fill\",\n  \"outline\"\n]);\nvar POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"outerBoundaryIs\": makeChildAppender(writeBoundaryIs),\n  \"innerBoundaryIs\": makeChildAppender(writeBoundaryIs)\n});\nvar INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory(\"innerBoundaryIs\");\nvar OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory(\"outerBoundaryIs\");\nfunction writePolygon(node2, polygon, objectStack) {\n  var linearRings2 = polygon.getLinearRings();\n  var outerRing = linearRings2.shift();\n  var context = { node: node2 };\n  pushSerializeAndPop(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings2, objectStack);\n  pushSerializeAndPop(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);\n}\nvar POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"color\": makeChildAppender(writeColorTextNode),\n  \"fill\": makeChildAppender(writeBooleanTextNode),\n  \"outline\": makeChildAppender(writeBooleanTextNode)\n});\nfunction writePolyStyle(node2, style2, objectStack) {\n  var context = { node: node2 };\n  var fill = style2.getFill();\n  var stroke = style2.getStroke();\n  var properties = {\n    \"color\": fill ? fill.getColor() : void 0,\n    \"fill\": fill ? void 0 : false,\n    \"outline\": stroke ? void 0 : false\n  };\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nfunction writeScaleTextNode(node2, scale2) {\n  writeDecimalTextNode(node2, Math.round(scale2 * 1e6) / 1e6);\n}\nvar STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS$3, [\n  \"IconStyle\",\n  \"LabelStyle\",\n  \"LineStyle\",\n  \"PolyStyle\"\n]);\nvar STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS$3, {\n  \"IconStyle\": makeChildAppender(writeIconStyle),\n  \"LabelStyle\": makeChildAppender(writeLabelStyle),\n  \"LineStyle\": makeChildAppender(writeLineStyle),\n  \"PolyStyle\": makeChildAppender(writePolyStyle)\n});\nfunction writeStyle(node2, styles, objectStack) {\n  var context = { node: node2 };\n  var properties = {};\n  if (styles.pointStyles.length) {\n    var textStyle = styles.pointStyles[0].getText();\n    if (textStyle) {\n      properties[\"LabelStyle\"] = textStyle;\n    }\n    var imageStyle = styles.pointStyles[0].getImage();\n    if (imageStyle && typeof imageStyle.getSrc === \"function\") {\n      properties[\"IconStyle\"] = imageStyle;\n    }\n  }\n  if (styles.lineStyles.length) {\n    var strokeStyle = styles.lineStyles[0].getStroke();\n    if (strokeStyle) {\n      properties[\"LineStyle\"] = strokeStyle;\n    }\n  }\n  if (styles.polyStyles.length) {\n    var strokeStyle = styles.polyStyles[0].getStroke();\n    if (strokeStyle && !properties[\"LineStyle\"]) {\n      properties[\"LineStyle\"] = strokeStyle;\n    }\n    properties[\"PolyStyle\"] = styles.polyStyles[0];\n  }\n  var parentNode = objectStack[objectStack.length - 1].node;\n  var orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];\n  var values2 = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values2, objectStack, orderedKeys);\n}\nfunction writeVec2(node2, vec2) {\n  node2.setAttribute(\"x\", String(vec2.x));\n  node2.setAttribute(\"y\", String(vec2.y));\n  node2.setAttribute(\"xunits\", vec2.xunits);\n  node2.setAttribute(\"yunits\", vec2.yunits);\n}\nvar KML$1 = KML;\nvar ieee754$1 = {};\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nieee754$1.read = function(buffer2, offset2, isLE, mLen, nBytes) {\n  var e2, m2;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i2 = isLE ? nBytes - 1 : 0;\n  var d2 = isLE ? -1 : 1;\n  var s2 = buffer2[offset2 + i2];\n  i2 += d2;\n  e2 = s2 & (1 << -nBits) - 1;\n  s2 >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {\n  }\n  m2 = e2 & (1 << -nBits) - 1;\n  e2 >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i2], i2 += d2, nBits -= 8) {\n  }\n  if (e2 === 0) {\n    e2 = 1 - eBias;\n  } else if (e2 === eMax) {\n    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;\n  } else {\n    m2 = m2 + Math.pow(2, mLen);\n    e2 = e2 - eBias;\n  }\n  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);\n};\nieee754$1.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {\n  var e2, m2, c2;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i2 = isLE ? 0 : nBytes - 1;\n  var d2 = isLE ? 1 : -1;\n  var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n  if (isNaN(value) || value === Infinity) {\n    m2 = isNaN(value) ? 1 : 0;\n    e2 = eMax;\n  } else {\n    e2 = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c2 = Math.pow(2, -e2)) < 1) {\n      e2--;\n      c2 *= 2;\n    }\n    if (e2 + eBias >= 1) {\n      value += rt2 / c2;\n    } else {\n      value += rt2 * Math.pow(2, 1 - eBias);\n    }\n    if (value * c2 >= 2) {\n      e2++;\n      c2 /= 2;\n    }\n    if (e2 + eBias >= eMax) {\n      m2 = 0;\n      e2 = eMax;\n    } else if (e2 + eBias >= 1) {\n      m2 = (value * c2 - 1) * Math.pow(2, mLen);\n      e2 = e2 + eBias;\n    } else {\n      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e2 = 0;\n    }\n  }\n  for (; mLen >= 8; buffer2[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {\n  }\n  e2 = e2 << mLen | m2;\n  eLen += mLen;\n  for (; eLen > 0; buffer2[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {\n  }\n  buffer2[offset2 + i2 - d2] |= s2 * 128;\n};\nvar pbf = Pbf;\nvar ieee754 = ieee754$1;\nfunction Pbf(buf) {\n  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n  this.pos = 0;\n  this.type = 0;\n  this.length = this.buf.length;\n}\nPbf.Varint = 0;\nPbf.Fixed64 = 1;\nPbf.Bytes = 2;\nPbf.Fixed32 = 5;\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16), SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nvar TEXT_DECODER_MIN_LENGTH = 12;\nvar utf8TextDecoder = typeof TextDecoder === \"undefined\" ? null : new TextDecoder(\"utf8\");\nPbf.prototype = {\n  destroy: function() {\n    this.buf = null;\n  },\n  readFields: function(readField, result, end) {\n    end = end || this.length;\n    while (this.pos < end) {\n      var val = this.readVarint(), tag = val >> 3, startPos = this.pos;\n      this.type = val & 7;\n      readField(tag, result, this);\n      if (this.pos === startPos)\n        this.skip(val);\n    }\n    return result;\n  },\n  readMessage: function(readField, result) {\n    return this.readFields(readField, result, this.readVarint() + this.pos);\n  },\n  readFixed32: function() {\n    var val = readUInt32(this.buf, this.pos);\n    this.pos += 4;\n    return val;\n  },\n  readSFixed32: function() {\n    var val = readInt32(this.buf, this.pos);\n    this.pos += 4;\n    return val;\n  },\n  readFixed64: function() {\n    var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n    this.pos += 8;\n    return val;\n  },\n  readSFixed64: function() {\n    var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n    this.pos += 8;\n    return val;\n  },\n  readFloat: function() {\n    var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n    this.pos += 4;\n    return val;\n  },\n  readDouble: function() {\n    var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n    this.pos += 8;\n    return val;\n  },\n  readVarint: function(isSigned) {\n    var buf = this.buf, val, b2;\n    b2 = buf[this.pos++];\n    val = b2 & 127;\n    if (b2 < 128)\n      return val;\n    b2 = buf[this.pos++];\n    val |= (b2 & 127) << 7;\n    if (b2 < 128)\n      return val;\n    b2 = buf[this.pos++];\n    val |= (b2 & 127) << 14;\n    if (b2 < 128)\n      return val;\n    b2 = buf[this.pos++];\n    val |= (b2 & 127) << 21;\n    if (b2 < 128)\n      return val;\n    b2 = buf[this.pos];\n    val |= (b2 & 15) << 28;\n    return readVarintRemainder(val, isSigned, this);\n  },\n  readVarint64: function() {\n    return this.readVarint(true);\n  },\n  readSVarint: function() {\n    var num = this.readVarint();\n    return num % 2 === 1 ? (num + 1) / -2 : num / 2;\n  },\n  readBoolean: function() {\n    return Boolean(this.readVarint());\n  },\n  readString: function() {\n    var end = this.readVarint() + this.pos;\n    var pos = this.pos;\n    this.pos = end;\n    if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {\n      return readUtf8TextDecoder(this.buf, pos, end);\n    }\n    return readUtf8(this.buf, pos, end);\n  },\n  readBytes: function() {\n    var end = this.readVarint() + this.pos, buffer2 = this.buf.subarray(this.pos, end);\n    this.pos = end;\n    return buffer2;\n  },\n  readPackedVarint: function(arr, isSigned) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readVarint(isSigned));\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readVarint(isSigned));\n    return arr;\n  },\n  readPackedSVarint: function(arr) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readSVarint());\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readSVarint());\n    return arr;\n  },\n  readPackedBoolean: function(arr) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readBoolean());\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readBoolean());\n    return arr;\n  },\n  readPackedFloat: function(arr) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readFloat());\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readFloat());\n    return arr;\n  },\n  readPackedDouble: function(arr) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readDouble());\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readDouble());\n    return arr;\n  },\n  readPackedFixed32: function(arr) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readFixed32());\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readFixed32());\n    return arr;\n  },\n  readPackedSFixed32: function(arr) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readSFixed32());\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readSFixed32());\n    return arr;\n  },\n  readPackedFixed64: function(arr) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readFixed64());\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readFixed64());\n    return arr;\n  },\n  readPackedSFixed64: function(arr) {\n    if (this.type !== Pbf.Bytes)\n      return arr.push(this.readSFixed64());\n    var end = readPackedEnd(this);\n    arr = arr || [];\n    while (this.pos < end)\n      arr.push(this.readSFixed64());\n    return arr;\n  },\n  skip: function(val) {\n    var type = val & 7;\n    if (type === Pbf.Varint)\n      while (this.buf[this.pos++] > 127) {\n      }\n    else if (type === Pbf.Bytes)\n      this.pos = this.readVarint() + this.pos;\n    else if (type === Pbf.Fixed32)\n      this.pos += 4;\n    else if (type === Pbf.Fixed64)\n      this.pos += 8;\n    else\n      throw new Error(\"Unimplemented type: \" + type);\n  },\n  writeTag: function(tag, type) {\n    this.writeVarint(tag << 3 | type);\n  },\n  realloc: function(min2) {\n    var length = this.length || 16;\n    while (length < this.pos + min2)\n      length *= 2;\n    if (length !== this.length) {\n      var buf = new Uint8Array(length);\n      buf.set(this.buf);\n      this.buf = buf;\n      this.length = length;\n    }\n  },\n  finish: function() {\n    this.length = this.pos;\n    this.pos = 0;\n    return this.buf.subarray(0, this.length);\n  },\n  writeFixed32: function(val) {\n    this.realloc(4);\n    writeInt32(this.buf, val, this.pos);\n    this.pos += 4;\n  },\n  writeSFixed32: function(val) {\n    this.realloc(4);\n    writeInt32(this.buf, val, this.pos);\n    this.pos += 4;\n  },\n  writeFixed64: function(val) {\n    this.realloc(8);\n    writeInt32(this.buf, val & -1, this.pos);\n    writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n    this.pos += 8;\n  },\n  writeSFixed64: function(val) {\n    this.realloc(8);\n    writeInt32(this.buf, val & -1, this.pos);\n    writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n    this.pos += 8;\n  },\n  writeVarint: function(val) {\n    val = +val || 0;\n    if (val > 268435455 || val < 0) {\n      writeBigVarint(val, this);\n      return;\n    }\n    this.realloc(4);\n    this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);\n    if (val <= 127)\n      return;\n    this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);\n    if (val <= 127)\n      return;\n    this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);\n    if (val <= 127)\n      return;\n    this.buf[this.pos++] = val >>> 7 & 127;\n  },\n  writeSVarint: function(val) {\n    this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n  },\n  writeBoolean: function(val) {\n    this.writeVarint(Boolean(val));\n  },\n  writeString: function(str) {\n    str = String(str);\n    this.realloc(str.length * 4);\n    this.pos++;\n    var startPos = this.pos;\n    this.pos = writeUtf8(this.buf, str, this.pos);\n    var len = this.pos - startPos;\n    if (len >= 128)\n      makeRoomForExtraLength(startPos, len, this);\n    this.pos = startPos - 1;\n    this.writeVarint(len);\n    this.pos += len;\n  },\n  writeFloat: function(val) {\n    this.realloc(4);\n    ieee754.write(this.buf, val, this.pos, true, 23, 4);\n    this.pos += 4;\n  },\n  writeDouble: function(val) {\n    this.realloc(8);\n    ieee754.write(this.buf, val, this.pos, true, 52, 8);\n    this.pos += 8;\n  },\n  writeBytes: function(buffer2) {\n    var len = buffer2.length;\n    this.writeVarint(len);\n    this.realloc(len);\n    for (var i2 = 0; i2 < len; i2++)\n      this.buf[this.pos++] = buffer2[i2];\n  },\n  writeRawMessage: function(fn, obj) {\n    this.pos++;\n    var startPos = this.pos;\n    fn(obj, this);\n    var len = this.pos - startPos;\n    if (len >= 128)\n      makeRoomForExtraLength(startPos, len, this);\n    this.pos = startPos - 1;\n    this.writeVarint(len);\n    this.pos += len;\n  },\n  writeMessage: function(tag, fn, obj) {\n    this.writeTag(tag, Pbf.Bytes);\n    this.writeRawMessage(fn, obj);\n  },\n  writePackedVarint: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedVarint, arr);\n  },\n  writePackedSVarint: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedSVarint, arr);\n  },\n  writePackedBoolean: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedBoolean, arr);\n  },\n  writePackedFloat: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedFloat, arr);\n  },\n  writePackedDouble: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedDouble, arr);\n  },\n  writePackedFixed32: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedFixed32, arr);\n  },\n  writePackedSFixed32: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedSFixed32, arr);\n  },\n  writePackedFixed64: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedFixed64, arr);\n  },\n  writePackedSFixed64: function(tag, arr) {\n    if (arr.length)\n      this.writeMessage(tag, writePackedSFixed64, arr);\n  },\n  writeBytesField: function(tag, buffer2) {\n    this.writeTag(tag, Pbf.Bytes);\n    this.writeBytes(buffer2);\n  },\n  writeFixed32Field: function(tag, val) {\n    this.writeTag(tag, Pbf.Fixed32);\n    this.writeFixed32(val);\n  },\n  writeSFixed32Field: function(tag, val) {\n    this.writeTag(tag, Pbf.Fixed32);\n    this.writeSFixed32(val);\n  },\n  writeFixed64Field: function(tag, val) {\n    this.writeTag(tag, Pbf.Fixed64);\n    this.writeFixed64(val);\n  },\n  writeSFixed64Field: function(tag, val) {\n    this.writeTag(tag, Pbf.Fixed64);\n    this.writeSFixed64(val);\n  },\n  writeVarintField: function(tag, val) {\n    this.writeTag(tag, Pbf.Varint);\n    this.writeVarint(val);\n  },\n  writeSVarintField: function(tag, val) {\n    this.writeTag(tag, Pbf.Varint);\n    this.writeSVarint(val);\n  },\n  writeStringField: function(tag, str) {\n    this.writeTag(tag, Pbf.Bytes);\n    this.writeString(str);\n  },\n  writeFloatField: function(tag, val) {\n    this.writeTag(tag, Pbf.Fixed32);\n    this.writeFloat(val);\n  },\n  writeDoubleField: function(tag, val) {\n    this.writeTag(tag, Pbf.Fixed64);\n    this.writeDouble(val);\n  },\n  writeBooleanField: function(tag, val) {\n    this.writeVarintField(tag, Boolean(val));\n  }\n};\nfunction readVarintRemainder(l2, s2, p5) {\n  var buf = p5.buf, h2, b2;\n  b2 = buf[p5.pos++];\n  h2 = (b2 & 112) >> 4;\n  if (b2 < 128)\n    return toNum(l2, h2, s2);\n  b2 = buf[p5.pos++];\n  h2 |= (b2 & 127) << 3;\n  if (b2 < 128)\n    return toNum(l2, h2, s2);\n  b2 = buf[p5.pos++];\n  h2 |= (b2 & 127) << 10;\n  if (b2 < 128)\n    return toNum(l2, h2, s2);\n  b2 = buf[p5.pos++];\n  h2 |= (b2 & 127) << 17;\n  if (b2 < 128)\n    return toNum(l2, h2, s2);\n  b2 = buf[p5.pos++];\n  h2 |= (b2 & 127) << 24;\n  if (b2 < 128)\n    return toNum(l2, h2, s2);\n  b2 = buf[p5.pos++];\n  h2 |= (b2 & 1) << 31;\n  if (b2 < 128)\n    return toNum(l2, h2, s2);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\nfunction readPackedEnd(pbf2) {\n  return pbf2.type === Pbf.Bytes ? pbf2.readVarint() + pbf2.pos : pbf2.pos + 1;\n}\nfunction toNum(low, high, isSigned) {\n  if (isSigned) {\n    return high * 4294967296 + (low >>> 0);\n  }\n  return (high >>> 0) * 4294967296 + (low >>> 0);\n}\nfunction writeBigVarint(val, pbf2) {\n  var low, high;\n  if (val >= 0) {\n    low = val % 4294967296 | 0;\n    high = val / 4294967296 | 0;\n  } else {\n    low = ~(-val % 4294967296);\n    high = ~(-val / 4294967296);\n    if (low ^ 4294967295) {\n      low = low + 1 | 0;\n    } else {\n      low = 0;\n      high = high + 1 | 0;\n    }\n  }\n  if (val >= 18446744073709552e3 || val < -18446744073709552e3) {\n    throw new Error(\"Given varint doesn't fit into 10 bytes\");\n  }\n  pbf2.realloc(10);\n  writeBigVarintLow(low, high, pbf2);\n  writeBigVarintHigh(high, pbf2);\n}\nfunction writeBigVarintLow(low, high, pbf2) {\n  pbf2.buf[pbf2.pos++] = low & 127 | 128;\n  low >>>= 7;\n  pbf2.buf[pbf2.pos++] = low & 127 | 128;\n  low >>>= 7;\n  pbf2.buf[pbf2.pos++] = low & 127 | 128;\n  low >>>= 7;\n  pbf2.buf[pbf2.pos++] = low & 127 | 128;\n  low >>>= 7;\n  pbf2.buf[pbf2.pos] = low & 127;\n}\nfunction writeBigVarintHigh(high, pbf2) {\n  var lsb = (high & 7) << 4;\n  pbf2.buf[pbf2.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);\n  if (!high)\n    return;\n  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);\n  if (!high)\n    return;\n  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);\n  if (!high)\n    return;\n  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);\n  if (!high)\n    return;\n  pbf2.buf[pbf2.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);\n  if (!high)\n    return;\n  pbf2.buf[pbf2.pos++] = high & 127;\n}\nfunction makeRoomForExtraLength(startPos, len, pbf2) {\n  var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n  pbf2.realloc(extraLen);\n  for (var i2 = pbf2.pos - 1; i2 >= startPos; i2--)\n    pbf2.buf[i2 + extraLen] = pbf2.buf[i2];\n}\nfunction writePackedVarint(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeVarint(arr[i2]);\n}\nfunction writePackedSVarint(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeSVarint(arr[i2]);\n}\nfunction writePackedFloat(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeFloat(arr[i2]);\n}\nfunction writePackedDouble(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeDouble(arr[i2]);\n}\nfunction writePackedBoolean(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeBoolean(arr[i2]);\n}\nfunction writePackedFixed32(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeFixed32(arr[i2]);\n}\nfunction writePackedSFixed32(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeSFixed32(arr[i2]);\n}\nfunction writePackedFixed64(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeFixed64(arr[i2]);\n}\nfunction writePackedSFixed64(arr, pbf2) {\n  for (var i2 = 0; i2 < arr.length; i2++)\n    pbf2.writeSFixed64(arr[i2]);\n}\nfunction readUInt32(buf, pos) {\n  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;\n}\nfunction writeInt32(buf, val, pos) {\n  buf[pos] = val;\n  buf[pos + 1] = val >>> 8;\n  buf[pos + 2] = val >>> 16;\n  buf[pos + 3] = val >>> 24;\n}\nfunction readInt32(buf, pos) {\n  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);\n}\nfunction readUtf8(buf, pos, end) {\n  var str = \"\";\n  var i2 = pos;\n  while (i2 < end) {\n    var b0 = buf[i2];\n    var c2 = null;\n    var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;\n    if (i2 + bytesPerSequence > end)\n      break;\n    var b1, b2, b3;\n    if (bytesPerSequence === 1) {\n      if (b0 < 128) {\n        c2 = b0;\n      }\n    } else if (bytesPerSequence === 2) {\n      b1 = buf[i2 + 1];\n      if ((b1 & 192) === 128) {\n        c2 = (b0 & 31) << 6 | b1 & 63;\n        if (c2 <= 127) {\n          c2 = null;\n        }\n      }\n    } else if (bytesPerSequence === 3) {\n      b1 = buf[i2 + 1];\n      b2 = buf[i2 + 2];\n      if ((b1 & 192) === 128 && (b2 & 192) === 128) {\n        c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;\n        if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {\n          c2 = null;\n        }\n      }\n    } else if (bytesPerSequence === 4) {\n      b1 = buf[i2 + 1];\n      b2 = buf[i2 + 2];\n      b3 = buf[i2 + 3];\n      if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {\n        c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;\n        if (c2 <= 65535 || c2 >= 1114112) {\n          c2 = null;\n        }\n      }\n    }\n    if (c2 === null) {\n      c2 = 65533;\n      bytesPerSequence = 1;\n    } else if (c2 > 65535) {\n      c2 -= 65536;\n      str += String.fromCharCode(c2 >>> 10 & 1023 | 55296);\n      c2 = 56320 | c2 & 1023;\n    }\n    str += String.fromCharCode(c2);\n    i2 += bytesPerSequence;\n  }\n  return str;\n}\nfunction readUtf8TextDecoder(buf, pos, end) {\n  return utf8TextDecoder.decode(buf.subarray(pos, end));\n}\nfunction writeUtf8(buf, str, pos) {\n  for (var i2 = 0, c2, lead; i2 < str.length; i2++) {\n    c2 = str.charCodeAt(i2);\n    if (c2 > 55295 && c2 < 57344) {\n      if (lead) {\n        if (c2 < 56320) {\n          buf[pos++] = 239;\n          buf[pos++] = 191;\n          buf[pos++] = 189;\n          lead = c2;\n          continue;\n        } else {\n          c2 = lead - 55296 << 10 | c2 - 56320 | 65536;\n          lead = null;\n        }\n      } else {\n        if (c2 > 56319 || i2 + 1 === str.length) {\n          buf[pos++] = 239;\n          buf[pos++] = 191;\n          buf[pos++] = 189;\n        } else {\n          lead = c2;\n        }\n        continue;\n      }\n    } else if (lead) {\n      buf[pos++] = 239;\n      buf[pos++] = 191;\n      buf[pos++] = 189;\n      lead = null;\n    }\n    if (c2 < 128) {\n      buf[pos++] = c2;\n    } else {\n      if (c2 < 2048) {\n        buf[pos++] = c2 >> 6 | 192;\n      } else {\n        if (c2 < 65536) {\n          buf[pos++] = c2 >> 12 | 224;\n        } else {\n          buf[pos++] = c2 >> 18 | 240;\n          buf[pos++] = c2 >> 12 & 63 | 128;\n        }\n        buf[pos++] = c2 >> 6 & 63 | 128;\n      }\n      buf[pos++] = c2 & 63 | 128;\n    }\n  }\n  return pos;\n}\nvar tmpTransform = create$6();\nvar RenderFeature = function() {\n  function RenderFeature2(type, flatCoordinates, ends, properties, id) {\n    this.styleFunction;\n    this.extent_;\n    this.id_ = id;\n    this.type_ = type;\n    this.flatCoordinates_ = flatCoordinates;\n    this.flatInteriorPoints_ = null;\n    this.flatMidpoints_ = null;\n    this.ends_ = ends;\n    this.properties_ = properties;\n  }\n  RenderFeature2.prototype.get = function(key) {\n    return this.properties_[key];\n  };\n  RenderFeature2.prototype.getExtent = function() {\n    if (!this.extent_) {\n      this.extent_ = this.type_ === GeometryType.POINT ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);\n    }\n    return this.extent_;\n  };\n  RenderFeature2.prototype.getFlatInteriorPoint = function() {\n    if (!this.flatInteriorPoints_) {\n      var flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);\n    }\n    return this.flatInteriorPoints_;\n  };\n  RenderFeature2.prototype.getFlatInteriorPoints = function() {\n    if (!this.flatInteriorPoints_) {\n      var flatCenters = linearRingss(this.flatCoordinates_, 0, this.ends_, 2);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenters);\n    }\n    return this.flatInteriorPoints_;\n  };\n  RenderFeature2.prototype.getFlatMidpoint = function() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);\n    }\n    return this.flatMidpoints_;\n  };\n  RenderFeature2.prototype.getFlatMidpoints = function() {\n    if (!this.flatMidpoints_) {\n      this.flatMidpoints_ = [];\n      var flatCoordinates = this.flatCoordinates_;\n      var offset2 = 0;\n      var ends = this.ends_;\n      for (var i2 = 0, ii = ends.length; i2 < ii; ++i2) {\n        var end = ends[i2];\n        var midpoint = interpolatePoint(flatCoordinates, offset2, end, 2, 0.5);\n        extend$3(this.flatMidpoints_, midpoint);\n        offset2 = end;\n      }\n    }\n    return this.flatMidpoints_;\n  };\n  RenderFeature2.prototype.getId = function() {\n    return this.id_;\n  };\n  RenderFeature2.prototype.getOrientedFlatCoordinates = function() {\n    return this.flatCoordinates_;\n  };\n  RenderFeature2.prototype.getGeometry = function() {\n    return this;\n  };\n  RenderFeature2.prototype.getSimplifiedGeometry = function(squaredTolerance) {\n    return this;\n  };\n  RenderFeature2.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {\n    return this;\n  };\n  RenderFeature2.prototype.getProperties = function() {\n    return this.properties_;\n  };\n  RenderFeature2.prototype.getStride = function() {\n    return 2;\n  };\n  RenderFeature2.prototype.getStyleFunction = function() {\n    return this.styleFunction;\n  };\n  RenderFeature2.prototype.getType = function() {\n    return this.type_;\n  };\n  RenderFeature2.prototype.transform = function(projection) {\n    projection = get$3(projection);\n    var pixelExtent = projection.getExtent();\n    var projectedExtent = projection.getWorldExtent();\n    if (pixelExtent && projectedExtent) {\n      var scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);\n      compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale2, -scale2, 0, 0, 0);\n      transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);\n    }\n  };\n  RenderFeature2.prototype.getEnds = function() {\n    return this.ends_;\n  };\n  return RenderFeature2;\n}();\nRenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;\nRenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;\nvar RenderFeature$1 = RenderFeature;\nvar __extends$e = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar MVT = function(_super) {\n  __extends$e(MVT2, _super);\n  function MVT2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.dataProjection = new Projection$3({\n      code: \"\",\n      units: Units$2.TILE_PIXELS\n    });\n    _this.featureClass_ = options.featureClass ? options.featureClass : RenderFeature$1;\n    _this.geometryName_ = options.geometryName;\n    _this.layerName_ = options.layerName ? options.layerName : \"layer\";\n    _this.layers_ = options.layers ? options.layers : null;\n    _this.idProperty_ = options.idProperty;\n    _this.supportedMediaTypes = [\n      \"application/vnd.mapbox-vector-tile\",\n      \"application/x-protobuf\"\n    ];\n    return _this;\n  }\n  MVT2.prototype.readRawGeometry_ = function(pbf2, feature2, flatCoordinates, ends) {\n    pbf2.pos = feature2.geometry;\n    var end = pbf2.readVarint() + pbf2.pos;\n    var cmd = 1;\n    var length = 0;\n    var x2 = 0;\n    var y2 = 0;\n    var coordsLen = 0;\n    var currentEnd = 0;\n    while (pbf2.pos < end) {\n      if (!length) {\n        var cmdLen = pbf2.readVarint();\n        cmd = cmdLen & 7;\n        length = cmdLen >> 3;\n      }\n      length--;\n      if (cmd === 1 || cmd === 2) {\n        x2 += pbf2.readSVarint();\n        y2 += pbf2.readSVarint();\n        if (cmd === 1) {\n          if (coordsLen > currentEnd) {\n            ends.push(coordsLen);\n            currentEnd = coordsLen;\n          }\n        }\n        flatCoordinates.push(x2, y2);\n        coordsLen += 2;\n      } else if (cmd === 7) {\n        if (coordsLen > currentEnd) {\n          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);\n          coordsLen += 2;\n        }\n      } else {\n        assert(false, 59);\n      }\n    }\n    if (coordsLen > currentEnd) {\n      ends.push(coordsLen);\n      currentEnd = coordsLen;\n    }\n  };\n  MVT2.prototype.createFeature_ = function(pbf2, rawFeature, options) {\n    var type = rawFeature.type;\n    if (type === 0) {\n      return null;\n    }\n    var feature2;\n    var values2 = rawFeature.properties;\n    var id;\n    if (!this.idProperty_) {\n      id = rawFeature.id;\n    } else {\n      id = values2[this.idProperty_];\n      delete values2[this.idProperty_];\n    }\n    values2[this.layerName_] = rawFeature.layer.name;\n    var flatCoordinates = [];\n    var ends = [];\n    this.readRawGeometry_(pbf2, rawFeature, flatCoordinates, ends);\n    var geometryType = getGeometryType(type, ends.length);\n    if (this.featureClass_ === RenderFeature$1) {\n      feature2 = new this.featureClass_(geometryType, flatCoordinates, ends, values2, id);\n      feature2.transform(options.dataProjection);\n    } else {\n      var geom2 = void 0;\n      if (geometryType == GeometryType.POLYGON) {\n        var endss = inflateEnds(flatCoordinates, ends);\n        geom2 = endss.length > 1 ? new MultiPolygon$2(flatCoordinates, GeometryLayout.XY, endss) : new Polygon$2(flatCoordinates, GeometryLayout.XY, ends);\n      } else {\n        geom2 = geometryType === GeometryType.POINT ? new Point$4(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.LINE_STRING ? new LineString$2(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.POLYGON ? new Polygon$2(flatCoordinates, GeometryLayout.XY, ends) : geometryType === GeometryType.MULTI_POINT ? new MultiPoint$2(flatCoordinates, GeometryLayout.XY) : geometryType === GeometryType.MULTI_LINE_STRING ? new MultiLineString$2(flatCoordinates, GeometryLayout.XY, ends) : null;\n      }\n      var ctor = this.featureClass_;\n      feature2 = new ctor();\n      if (this.geometryName_) {\n        feature2.setGeometryName(this.geometryName_);\n      }\n      var geometry = transformGeometryWithOptions(geom2, false, options);\n      feature2.setGeometry(geometry);\n      if (id !== void 0) {\n        feature2.setId(id);\n      }\n      feature2.setProperties(values2, true);\n    }\n    return feature2;\n  };\n  MVT2.prototype.getType = function() {\n    return FormatType.ARRAY_BUFFER;\n  };\n  MVT2.prototype.readFeatures = function(source, opt_options) {\n    var layers = this.layers_;\n    var options = this.adaptOptions(opt_options);\n    var dataProjection = get$3(options.dataProjection);\n    dataProjection.setWorldExtent(options.extent);\n    options.dataProjection = dataProjection;\n    var pbf$1 = new pbf(source);\n    var pbfLayers = pbf$1.readFields(layersPBFReader, {});\n    var features = [];\n    for (var name_1 in pbfLayers) {\n      if (layers && layers.indexOf(name_1) == -1) {\n        continue;\n      }\n      var pbfLayer = pbfLayers[name_1];\n      var extent2 = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;\n      dataProjection.setExtent(extent2);\n      for (var i2 = 0, ii = pbfLayer.length; i2 < ii; ++i2) {\n        var rawFeature = readRawFeature(pbf$1, pbfLayer, i2);\n        var feature2 = this.createFeature_(pbf$1, rawFeature, options);\n        if (feature2 !== null) {\n          features.push(feature2);\n        }\n      }\n    }\n    return features;\n  };\n  MVT2.prototype.readProjection = function(source) {\n    return this.dataProjection;\n  };\n  MVT2.prototype.setLayers = function(layers) {\n    this.layers_ = layers;\n  };\n  return MVT2;\n}(FeatureFormat$1);\nfunction layersPBFReader(tag, layers, pbf2) {\n  if (tag === 3) {\n    var layer = {\n      keys: [],\n      values: [],\n      features: []\n    };\n    var end = pbf2.readVarint() + pbf2.pos;\n    pbf2.readFields(layerPBFReader, layer, end);\n    layer.length = layer.features.length;\n    if (layer.length) {\n      layers[layer.name] = layer;\n    }\n  }\n}\nfunction layerPBFReader(tag, layer, pbf2) {\n  if (tag === 15) {\n    layer.version = pbf2.readVarint();\n  } else if (tag === 1) {\n    layer.name = pbf2.readString();\n  } else if (tag === 5) {\n    layer.extent = pbf2.readVarint();\n  } else if (tag === 2) {\n    layer.features.push(pbf2.pos);\n  } else if (tag === 3) {\n    layer.keys.push(pbf2.readString());\n  } else if (tag === 4) {\n    var value = null;\n    var end = pbf2.readVarint() + pbf2.pos;\n    while (pbf2.pos < end) {\n      tag = pbf2.readVarint() >> 3;\n      value = tag === 1 ? pbf2.readString() : tag === 2 ? pbf2.readFloat() : tag === 3 ? pbf2.readDouble() : tag === 4 ? pbf2.readVarint64() : tag === 5 ? pbf2.readVarint() : tag === 6 ? pbf2.readSVarint() : tag === 7 ? pbf2.readBoolean() : null;\n    }\n    layer.values.push(value);\n  }\n}\nfunction featurePBFReader(tag, feature2, pbf2) {\n  if (tag == 1) {\n    feature2.id = pbf2.readVarint();\n  } else if (tag == 2) {\n    var end = pbf2.readVarint() + pbf2.pos;\n    while (pbf2.pos < end) {\n      var key = feature2.layer.keys[pbf2.readVarint()];\n      var value = feature2.layer.values[pbf2.readVarint()];\n      feature2.properties[key] = value;\n    }\n  } else if (tag == 3) {\n    feature2.type = pbf2.readVarint();\n  } else if (tag == 4) {\n    feature2.geometry = pbf2.pos;\n  }\n}\nfunction readRawFeature(pbf2, layer, i2) {\n  pbf2.pos = layer.features[i2];\n  var end = pbf2.readVarint() + pbf2.pos;\n  var feature2 = {\n    layer,\n    type: 0,\n    properties: {}\n  };\n  pbf2.readFields(featurePBFReader, feature2, end);\n  return feature2;\n}\nfunction getGeometryType(type, numEnds) {\n  var geometryType;\n  if (type === 1) {\n    geometryType = numEnds === 1 ? GeometryType.POINT : GeometryType.MULTI_POINT;\n  } else if (type === 2) {\n    geometryType = numEnds === 1 ? GeometryType.LINE_STRING : GeometryType.MULTI_LINE_STRING;\n  } else if (type === 3) {\n    geometryType = GeometryType.POLYGON;\n  }\n  return geometryType;\n}\nvar MVT$1 = MVT;\nvar XML = function() {\n  function XML2() {\n  }\n  XML2.prototype.read = function(source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      return this.readFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFromDocument(source);\n    } else {\n      return this.readFromNode(source);\n    }\n  };\n  XML2.prototype.readFromDocument = function(doc) {\n    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {\n      if (n2.nodeType == Node.ELEMENT_NODE) {\n        return this.readFromNode(n2);\n      }\n    }\n    return null;\n  };\n  XML2.prototype.readFromNode = function(node2) {\n  };\n  return XML2;\n}();\nvar XML$1 = XML;\nvar NAMESPACE_URI = \"http://www.w3.org/1999/xlink\";\nfunction readHref(node2) {\n  return node2.getAttributeNS(NAMESPACE_URI, \"href\");\n}\nvar __extends$d = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar NAMESPACE_URIS$2 = [null, \"http://www.opengis.net/ows/1.1\"];\nvar PARSERS$2 = makeStructureNS(NAMESPACE_URIS$2, {\n  \"ServiceIdentification\": makeObjectPropertySetter(readServiceIdentification),\n  \"ServiceProvider\": makeObjectPropertySetter(readServiceProvider),\n  \"OperationsMetadata\": makeObjectPropertySetter(readOperationsMetadata)\n});\nvar OWS = function(_super) {\n  __extends$d(OWS2, _super);\n  function OWS2() {\n    return _super.call(this) || this;\n  }\n  OWS2.prototype.readFromNode = function(node2) {\n    var owsObject = pushParseAndPop({}, PARSERS$2, node2, []);\n    return owsObject ? owsObject : null;\n  };\n  return OWS2;\n}(XML$1);\nvar ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"DeliveryPoint\": makeObjectPropertySetter(readString),\n  \"City\": makeObjectPropertySetter(readString),\n  \"AdministrativeArea\": makeObjectPropertySetter(readString),\n  \"PostalCode\": makeObjectPropertySetter(readString),\n  \"Country\": makeObjectPropertySetter(readString),\n  \"ElectronicMailAddress\": makeObjectPropertySetter(readString)\n});\nvar ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"Value\": makeObjectPropertyPusher(readValue)\n});\nvar CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"AllowedValues\": makeObjectPropertySetter(readAllowedValues)\n});\nvar CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"Phone\": makeObjectPropertySetter(readPhone),\n  \"Address\": makeObjectPropertySetter(readAddress)\n});\nvar DCP_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"HTTP\": makeObjectPropertySetter(readHttp)\n});\nvar HTTP_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$2, {\n  \"Get\": makeObjectPropertyPusher(readGet),\n  \"Post\": void 0\n});\nvar OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"DCP\": makeObjectPropertySetter(readDcp)\n});\nvar OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"Operation\": readOperation\n});\nvar PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"Voice\": makeObjectPropertySetter(readString),\n  \"Facsimile\": makeObjectPropertySetter(readString)\n});\nvar REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"Constraint\": makeObjectPropertyPusher(readConstraint)\n});\nvar SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"IndividualName\": makeObjectPropertySetter(readString),\n  \"PositionName\": makeObjectPropertySetter(readString),\n  \"ContactInfo\": makeObjectPropertySetter(readContactInfo)\n});\nvar SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"Abstract\": makeObjectPropertySetter(readString),\n  \"AccessConstraints\": makeObjectPropertySetter(readString),\n  \"Fees\": makeObjectPropertySetter(readString),\n  \"Title\": makeObjectPropertySetter(readString),\n  \"ServiceTypeVersion\": makeObjectPropertySetter(readString),\n  \"ServiceType\": makeObjectPropertySetter(readString)\n});\nvar SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS$2, {\n  \"ProviderName\": makeObjectPropertySetter(readString),\n  \"ProviderSite\": makeObjectPropertySetter(readHref),\n  \"ServiceContact\": makeObjectPropertySetter(readServiceContact)\n});\nfunction readAddress(node2, objectStack) {\n  return pushParseAndPop({}, ADDRESS_PARSERS, node2, objectStack);\n}\nfunction readAllowedValues(node2, objectStack) {\n  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node2, objectStack);\n}\nfunction readConstraint(node2, objectStack) {\n  var name = node2.getAttribute(\"name\");\n  if (!name) {\n    return void 0;\n  }\n  return pushParseAndPop({ \"name\": name }, CONSTRAINT_PARSERS, node2, objectStack);\n}\nfunction readContactInfo(node2, objectStack) {\n  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node2, objectStack);\n}\nfunction readDcp(node2, objectStack) {\n  return pushParseAndPop({}, DCP_PARSERS, node2, objectStack);\n}\nfunction readGet(node2, objectStack) {\n  var href = readHref(node2);\n  if (!href) {\n    return void 0;\n  }\n  return pushParseAndPop({ \"href\": href }, REQUEST_METHOD_PARSERS, node2, objectStack);\n}\nfunction readHttp(node2, objectStack) {\n  return pushParseAndPop({}, HTTP_PARSERS$1, node2, objectStack);\n}\nfunction readOperation(node2, objectStack) {\n  var name = node2.getAttribute(\"name\");\n  var value = pushParseAndPop({}, OPERATION_PARSERS, node2, objectStack);\n  if (!value) {\n    return void 0;\n  }\n  var object = objectStack[objectStack.length - 1];\n  object[name] = value;\n}\nfunction readOperationsMetadata(node2, objectStack) {\n  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node2, objectStack);\n}\nfunction readPhone(node2, objectStack) {\n  return pushParseAndPop({}, PHONE_PARSERS, node2, objectStack);\n}\nfunction readServiceIdentification(node2, objectStack) {\n  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node2, objectStack);\n}\nfunction readServiceContact(node2, objectStack) {\n  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node2, objectStack);\n}\nfunction readServiceProvider(node2, objectStack) {\n  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node2, objectStack);\n}\nfunction readValue(node2, objectStack) {\n  return readString(node2);\n}\nvar OWS$1 = OWS;\nfunction flipXY(flatCoordinates, offset2, end, stride, opt_dest, opt_destOffset) {\n  var dest, destOffset;\n  if (opt_dest !== void 0) {\n    dest = opt_dest;\n    destOffset = opt_destOffset !== void 0 ? opt_destOffset : 0;\n  } else {\n    dest = [];\n    destOffset = 0;\n  }\n  var j2 = offset2;\n  while (j2 < end) {\n    var x2 = flatCoordinates[j2++];\n    dest[destOffset++] = flatCoordinates[j2++];\n    dest[destOffset++] = x2;\n    for (var k2 = 2; k2 < stride; ++k2) {\n      dest[destOffset++] = flatCoordinates[j2++];\n    }\n  }\n  dest.length = destOffset;\n  return dest;\n}\nvar __extends$c = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Polyline = function(_super) {\n  __extends$c(Polyline2, _super);\n  function Polyline2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.dataProjection = get$3(\"EPSG:4326\");\n    _this.factor_ = options.factor ? options.factor : 1e5;\n    _this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : GeometryLayout.XY;\n    return _this;\n  }\n  Polyline2.prototype.readFeatureFromText = function(text2, opt_options) {\n    var geometry = this.readGeometryFromText(text2, opt_options);\n    return new feature(geometry);\n  };\n  Polyline2.prototype.readFeaturesFromText = function(text2, opt_options) {\n    var feature2 = this.readFeatureFromText(text2, opt_options);\n    return [feature2];\n  };\n  Polyline2.prototype.readGeometryFromText = function(text2, opt_options) {\n    var stride = getStrideForLayout(this.geometryLayout_);\n    var flatCoordinates = decodeDeltas(text2, stride, this.factor_);\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    var coordinates2 = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);\n    var lineString = new LineString$2(coordinates2, this.geometryLayout_);\n    return transformGeometryWithOptions(lineString, false, this.adaptOptions(opt_options));\n  };\n  Polyline2.prototype.writeFeatureText = function(feature2, opt_options) {\n    var geometry = feature2.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, opt_options);\n    } else {\n      assert(false, 40);\n      return \"\";\n    }\n  };\n  Polyline2.prototype.writeFeaturesText = function(features, opt_options) {\n    return this.writeFeatureText(features[0], opt_options);\n  };\n  Polyline2.prototype.writeGeometryText = function(geometry, opt_options) {\n    geometry = transformGeometryWithOptions(geometry, true, this.adaptOptions(opt_options));\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);\n    return encodeDeltas(flatCoordinates, stride, this.factor_);\n  };\n  return Polyline2;\n}(TextFeature$1);\nfunction encodeDeltas(numbers, stride, opt_factor) {\n  var factor = opt_factor ? opt_factor : 1e5;\n  var d2;\n  var lastNumbers = new Array(stride);\n  for (d2 = 0; d2 < stride; ++d2) {\n    lastNumbers[d2] = 0;\n  }\n  for (var i2 = 0, ii = numbers.length; i2 < ii; ) {\n    for (d2 = 0; d2 < stride; ++d2, ++i2) {\n      var num = numbers[i2];\n      var delta = num - lastNumbers[d2];\n      lastNumbers[d2] = num;\n      numbers[i2] = delta;\n    }\n  }\n  return encodeFloats(numbers, factor);\n}\nfunction decodeDeltas(encoded, stride, opt_factor) {\n  var factor = opt_factor ? opt_factor : 1e5;\n  var d2;\n  var lastNumbers = new Array(stride);\n  for (d2 = 0; d2 < stride; ++d2) {\n    lastNumbers[d2] = 0;\n  }\n  var numbers = decodeFloats(encoded, factor);\n  for (var i2 = 0, ii = numbers.length; i2 < ii; ) {\n    for (d2 = 0; d2 < stride; ++d2, ++i2) {\n      lastNumbers[d2] += numbers[i2];\n      numbers[i2] = lastNumbers[d2];\n    }\n  }\n  return numbers;\n}\nfunction encodeFloats(numbers, opt_factor) {\n  var factor = opt_factor ? opt_factor : 1e5;\n  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {\n    numbers[i2] = Math.round(numbers[i2] * factor);\n  }\n  return encodeSignedIntegers(numbers);\n}\nfunction decodeFloats(encoded, opt_factor) {\n  var factor = opt_factor ? opt_factor : 1e5;\n  var numbers = decodeSignedIntegers(encoded);\n  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {\n    numbers[i2] /= factor;\n  }\n  return numbers;\n}\nfunction encodeSignedIntegers(numbers) {\n  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {\n    var num = numbers[i2];\n    numbers[i2] = num < 0 ? ~(num << 1) : num << 1;\n  }\n  return encodeUnsignedIntegers(numbers);\n}\nfunction decodeSignedIntegers(encoded) {\n  var numbers = decodeUnsignedIntegers(encoded);\n  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {\n    var num = numbers[i2];\n    numbers[i2] = num & 1 ? ~(num >> 1) : num >> 1;\n  }\n  return numbers;\n}\nfunction encodeUnsignedIntegers(numbers) {\n  var encoded = \"\";\n  for (var i2 = 0, ii = numbers.length; i2 < ii; ++i2) {\n    encoded += encodeUnsignedInteger(numbers[i2]);\n  }\n  return encoded;\n}\nfunction decodeUnsignedIntegers(encoded) {\n  var numbers = [];\n  var current = 0;\n  var shift = 0;\n  for (var i2 = 0, ii = encoded.length; i2 < ii; ++i2) {\n    var b2 = encoded.charCodeAt(i2) - 63;\n    current |= (b2 & 31) << shift;\n    if (b2 < 32) {\n      numbers.push(current);\n      current = 0;\n      shift = 0;\n    } else {\n      shift += 5;\n    }\n  }\n  return numbers;\n}\nfunction encodeUnsignedInteger(num) {\n  var value, encoded = \"\";\n  while (num >= 32) {\n    value = (32 | num & 31) + 63;\n    encoded += String.fromCharCode(value);\n    num >>= 5;\n  }\n  value = num + 63;\n  encoded += String.fromCharCode(value);\n  return encoded;\n}\nvar Polyline$1 = Polyline;\nvar __extends$b = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar TopoJSON = function(_super) {\n  __extends$b(TopoJSON2, _super);\n  function TopoJSON2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.layerName_ = options.layerName;\n    _this.layers_ = options.layers ? options.layers : null;\n    _this.dataProjection = get$3(options.dataProjection ? options.dataProjection : \"EPSG:4326\");\n    return _this;\n  }\n  TopoJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {\n    if (object.type == \"Topology\") {\n      var topoJSONTopology = object;\n      var transform2 = void 0, scale2 = null, translate2 = null;\n      if (topoJSONTopology[\"transform\"]) {\n        transform2 = topoJSONTopology[\"transform\"];\n        scale2 = transform2[\"scale\"];\n        translate2 = transform2[\"translate\"];\n      }\n      var arcs = topoJSONTopology[\"arcs\"];\n      if (transform2) {\n        transformArcs(arcs, scale2, translate2);\n      }\n      var features = [];\n      var topoJSONFeatures = topoJSONTopology[\"objects\"];\n      var property = this.layerName_;\n      var feature2 = void 0;\n      for (var objectName in topoJSONFeatures) {\n        if (this.layers_ && this.layers_.indexOf(objectName) == -1) {\n          continue;\n        }\n        if (topoJSONFeatures[objectName].type === \"GeometryCollection\") {\n          feature2 = topoJSONFeatures[objectName];\n          features.push.apply(features, readFeaturesFromGeometryCollection(feature2, arcs, scale2, translate2, property, objectName, opt_options));\n        } else {\n          feature2 = topoJSONFeatures[objectName];\n          features.push(readFeatureFromGeometry(feature2, arcs, scale2, translate2, property, objectName, opt_options));\n        }\n      }\n      return features;\n    } else {\n      return [];\n    }\n  };\n  TopoJSON2.prototype.readProjectionFromObject = function(object) {\n    return this.dataProjection;\n  };\n  return TopoJSON2;\n}(JSONFeature$1);\nvar GEOMETRY_READERS = {\n  \"Point\": readPointGeometry,\n  \"LineString\": readLineStringGeometry,\n  \"Polygon\": readPolygonGeometry,\n  \"MultiPoint\": readMultiPointGeometry,\n  \"MultiLineString\": readMultiLineStringGeometry,\n  \"MultiPolygon\": readMultiPolygonGeometry\n};\nfunction concatenateArcs(indices, arcs) {\n  var coordinates2 = [];\n  var index2;\n  for (var i2 = 0, ii = indices.length; i2 < ii; ++i2) {\n    index2 = indices[i2];\n    if (i2 > 0) {\n      coordinates2.pop();\n    }\n    if (index2 >= 0) {\n      var arc = arcs[index2];\n      for (var j2 = 0, jj = arc.length; j2 < jj; ++j2) {\n        coordinates2.push(arc[j2].slice(0));\n      }\n    } else {\n      var arc = arcs[~index2];\n      for (var j2 = arc.length - 1; j2 >= 0; --j2) {\n        coordinates2.push(arc[j2].slice(0));\n      }\n    }\n  }\n  return coordinates2;\n}\nfunction readPointGeometry(object, scale2, translate2) {\n  var coordinates2 = object[\"coordinates\"];\n  if (scale2 && translate2) {\n    transformVertex(coordinates2, scale2, translate2);\n  }\n  return new Point$4(coordinates2);\n}\nfunction readMultiPointGeometry(object, scale2, translate2) {\n  var coordinates2 = object[\"coordinates\"];\n  if (scale2 && translate2) {\n    for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {\n      transformVertex(coordinates2[i2], scale2, translate2);\n    }\n  }\n  return new MultiPoint$2(coordinates2);\n}\nfunction readLineStringGeometry(object, arcs) {\n  var coordinates2 = concatenateArcs(object[\"arcs\"], arcs);\n  return new LineString$2(coordinates2);\n}\nfunction readMultiLineStringGeometry(object, arcs) {\n  var coordinates2 = [];\n  for (var i2 = 0, ii = object[\"arcs\"].length; i2 < ii; ++i2) {\n    coordinates2[i2] = concatenateArcs(object[\"arcs\"][i2], arcs);\n  }\n  return new MultiLineString$2(coordinates2);\n}\nfunction readPolygonGeometry(object, arcs) {\n  var coordinates2 = [];\n  for (var i2 = 0, ii = object[\"arcs\"].length; i2 < ii; ++i2) {\n    coordinates2[i2] = concatenateArcs(object[\"arcs\"][i2], arcs);\n  }\n  return new Polygon$2(coordinates2);\n}\nfunction readMultiPolygonGeometry(object, arcs) {\n  var coordinates2 = [];\n  for (var i2 = 0, ii = object[\"arcs\"].length; i2 < ii; ++i2) {\n    var polyArray = object[\"arcs\"][i2];\n    var ringCoords = [];\n    for (var j2 = 0, jj = polyArray.length; j2 < jj; ++j2) {\n      ringCoords[j2] = concatenateArcs(polyArray[j2], arcs);\n    }\n    coordinates2[i2] = ringCoords;\n  }\n  return new MultiPolygon$2(coordinates2);\n}\nfunction readFeaturesFromGeometryCollection(collection, arcs, scale2, translate2, property, name, opt_options) {\n  var geometries = collection[\"geometries\"];\n  var features = [];\n  for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n    features[i2] = readFeatureFromGeometry(geometries[i2], arcs, scale2, translate2, property, name, opt_options);\n  }\n  return features;\n}\nfunction readFeatureFromGeometry(object, arcs, scale2, translate2, property, name, opt_options) {\n  var geometry = null;\n  var type = object.type;\n  if (type) {\n    var geometryReader = GEOMETRY_READERS[type];\n    if (type === \"Point\" || type === \"MultiPoint\") {\n      geometry = geometryReader(object, scale2, translate2);\n    } else {\n      geometry = geometryReader(object, arcs);\n    }\n    geometry = transformGeometryWithOptions(geometry, false, opt_options);\n  }\n  var feature$1 = new feature({ geometry });\n  if (object.id !== void 0) {\n    feature$1.setId(object.id);\n  }\n  var properties = object.properties;\n  if (property) {\n    if (!properties) {\n      properties = {};\n    }\n    properties[property] = name;\n  }\n  if (properties) {\n    feature$1.setProperties(properties, true);\n  }\n  return feature$1;\n}\nfunction transformArcs(arcs, scale2, translate2) {\n  for (var i2 = 0, ii = arcs.length; i2 < ii; ++i2) {\n    transformArc(arcs[i2], scale2, translate2);\n  }\n}\nfunction transformArc(arc, scale2, translate2) {\n  var x2 = 0;\n  var y2 = 0;\n  for (var i2 = 0, ii = arc.length; i2 < ii; ++i2) {\n    var vertex = arc[i2];\n    x2 += vertex[0];\n    y2 += vertex[1];\n    vertex[0] = x2;\n    vertex[1] = y2;\n    transformVertex(vertex, scale2, translate2);\n  }\n}\nfunction transformVertex(vertex, scale2, translate2) {\n  vertex[0] = vertex[0] * scale2[0] + translate2[0];\n  vertex[1] = vertex[1] * scale2[1] + translate2[1];\n}\nvar TopoJSON$1 = TopoJSON;\nvar __extends$a = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar GML32 = function(_super) {\n  __extends$a(GML322, _super);\n  function GML322(opt_options) {\n    var _this = this;\n    var options = opt_options ? opt_options : {};\n    _this = _super.call(this, options) || this;\n    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : _this.namespace + \" http://schemas.opengis.net/gml/3.2.1/gml.xsd\";\n    return _this;\n  }\n  return GML322;\n}(GML3$1);\nGML32.prototype.namespace = \"http://www.opengis.net/gml/3.2\";\nGML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"pos\": makeReplacer(GML3$1.prototype.readFlatPos),\n    \"posList\": makeReplacer(GML3$1.prototype.readFlatPosList),\n    \"coordinates\": makeReplacer(GML2$1.prototype.readFlatCoordinates)\n  }\n};\nGML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"interior\": GML3$1.prototype.interiorParser,\n    \"exterior\": GML3$1.prototype.exteriorParser\n  }\n};\nGML32.prototype.GEOMETRY_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"Point\": makeReplacer(GMLBase$1.prototype.readPoint),\n    \"MultiPoint\": makeReplacer(GMLBase$1.prototype.readMultiPoint),\n    \"LineString\": makeReplacer(GMLBase$1.prototype.readLineString),\n    \"MultiLineString\": makeReplacer(GMLBase$1.prototype.readMultiLineString),\n    \"LinearRing\": makeReplacer(GMLBase$1.prototype.readLinearRing),\n    \"Polygon\": makeReplacer(GMLBase$1.prototype.readPolygon),\n    \"MultiPolygon\": makeReplacer(GMLBase$1.prototype.readMultiPolygon),\n    \"Surface\": makeReplacer(GML32.prototype.readSurface),\n    \"MultiSurface\": makeReplacer(GML3$1.prototype.readMultiSurface),\n    \"Curve\": makeReplacer(GML32.prototype.readCurve),\n    \"MultiCurve\": makeReplacer(GML3$1.prototype.readMultiCurve),\n    \"Envelope\": makeReplacer(GML32.prototype.readEnvelope)\n  }\n};\nGML32.prototype.MULTICURVE_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"curveMember\": makeArrayPusher(GML3$1.prototype.curveMemberParser),\n    \"curveMembers\": makeArrayPusher(GML3$1.prototype.curveMemberParser)\n  }\n};\nGML32.prototype.MULTISURFACE_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"surfaceMember\": makeArrayPusher(GML3$1.prototype.surfaceMemberParser),\n    \"surfaceMembers\": makeArrayPusher(GML3$1.prototype.surfaceMemberParser)\n  }\n};\nGML32.prototype.CURVEMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"LineString\": makeArrayPusher(GMLBase$1.prototype.readLineString),\n    \"Curve\": makeArrayPusher(GML3$1.prototype.readCurve)\n  }\n};\nGML32.prototype.SURFACEMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"Polygon\": makeArrayPusher(GMLBase$1.prototype.readPolygon),\n    \"Surface\": makeArrayPusher(GML3$1.prototype.readSurface)\n  }\n};\nGML32.prototype.SURFACE_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"patches\": makeReplacer(GML3$1.prototype.readPatch)\n  }\n};\nGML32.prototype.CURVE_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"segments\": makeReplacer(GML3$1.prototype.readSegment)\n  }\n};\nGML32.prototype.ENVELOPE_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"lowerCorner\": makeArrayPusher(GML3$1.prototype.readFlatPosList),\n    \"upperCorner\": makeArrayPusher(GML3$1.prototype.readFlatPosList)\n  }\n};\nGML32.prototype.PATCHES_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"PolygonPatch\": makeReplacer(GML3$1.prototype.readPolygonPatch)\n  }\n};\nGML32.prototype.SEGMENTS_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"LineStringSegment\": makeReplacer(GML3$1.prototype.readLineStringSegment)\n  }\n};\nGML32.prototype.MULTIPOINT_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"pointMember\": makeArrayPusher(GMLBase$1.prototype.pointMemberParser),\n    \"pointMembers\": makeArrayPusher(GMLBase$1.prototype.pointMemberParser)\n  }\n};\nGML32.prototype.MULTILINESTRING_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"lineStringMember\": makeArrayPusher(GMLBase$1.prototype.lineStringMemberParser),\n    \"lineStringMembers\": makeArrayPusher(GMLBase$1.prototype.lineStringMemberParser)\n  }\n};\nGML32.prototype.MULTIPOLYGON_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"polygonMember\": makeArrayPusher(GMLBase$1.prototype.polygonMemberParser),\n    \"polygonMembers\": makeArrayPusher(GMLBase$1.prototype.polygonMemberParser)\n  }\n};\nGML32.prototype.POINTMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"Point\": makeArrayPusher(GMLBase$1.prototype.readFlatCoordinatesFromNode)\n  }\n};\nGML32.prototype.LINESTRINGMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"LineString\": makeArrayPusher(GMLBase$1.prototype.readLineString)\n  }\n};\nGML32.prototype.POLYGONMEMBER_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"Polygon\": makeArrayPusher(GMLBase$1.prototype.readPolygon)\n  }\n};\nGML32.prototype.RING_PARSERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"LinearRing\": makeReplacer(GMLBase$1.prototype.readFlatLinearRing)\n  }\n};\nGML32.prototype.RING_SERIALIZERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"exterior\": makeChildAppender(GML3$1.prototype.writeRing),\n    \"interior\": makeChildAppender(GML3$1.prototype.writeRing)\n  }\n};\nGML32.prototype.ENVELOPE_SERIALIZERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"lowerCorner\": makeChildAppender(writeStringTextNode),\n    \"upperCorner\": makeChildAppender(writeStringTextNode)\n  }\n};\nGML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"surfaceMember\": makeChildAppender(GML3$1.prototype.writeSurfaceOrPolygonMember),\n    \"polygonMember\": makeChildAppender(GML3$1.prototype.writeSurfaceOrPolygonMember)\n  }\n};\nGML32.prototype.POINTMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"pointMember\": makeChildAppender(GML3$1.prototype.writePointMember)\n  }\n};\nGML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"lineStringMember\": makeChildAppender(GML3$1.prototype.writeLineStringOrCurveMember),\n    \"curveMember\": makeChildAppender(GML3$1.prototype.writeLineStringOrCurveMember)\n  }\n};\nGML32.prototype.GEOMETRY_SERIALIZERS = {\n  \"http://www.opengis.net/gml/3.2\": {\n    \"Curve\": makeChildAppender(GML3$1.prototype.writeCurveOrLineString),\n    \"MultiCurve\": makeChildAppender(GML3$1.prototype.writeMultiCurveOrLineString),\n    \"Point\": makeChildAppender(GML32.prototype.writePoint),\n    \"MultiPoint\": makeChildAppender(GML3$1.prototype.writeMultiPoint),\n    \"LineString\": makeChildAppender(GML3$1.prototype.writeCurveOrLineString),\n    \"MultiLineString\": makeChildAppender(GML3$1.prototype.writeMultiCurveOrLineString),\n    \"LinearRing\": makeChildAppender(GML3$1.prototype.writeLinearRing),\n    \"Polygon\": makeChildAppender(GML3$1.prototype.writeSurfaceOrPolygon),\n    \"MultiPolygon\": makeChildAppender(GML3$1.prototype.writeMultiSurfaceOrPolygon),\n    \"Surface\": makeChildAppender(GML3$1.prototype.writeSurfaceOrPolygon),\n    \"MultiSurface\": makeChildAppender(GML3$1.prototype.writeMultiSurfaceOrPolygon),\n    \"Envelope\": makeChildAppender(GML3$1.prototype.writeEnvelope)\n  }\n};\nvar GML32$1 = GML32;\nvar Filter = function() {\n  function Filter2(tagName) {\n    this.tagName_ = tagName;\n  }\n  Filter2.prototype.getTagName = function() {\n    return this.tagName_;\n  };\n  return Filter2;\n}();\nvar Filter$1 = Filter;\nvar __extends$9 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar LogicalNary = function(_super) {\n  __extends$9(LogicalNary2, _super);\n  function LogicalNary2(tagName, conditions) {\n    var _this = _super.call(this, tagName) || this;\n    _this.conditions = conditions;\n    assert(_this.conditions.length >= 2, 57);\n    return _this;\n  }\n  return LogicalNary2;\n}(Filter$1);\nvar LogicalNary$1 = LogicalNary;\nvar __extends$8 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar And = function(_super) {\n  __extends$8(And2, _super);\n  function And2(conditions) {\n    return _super.call(this, \"And\", Array.prototype.slice.call(arguments)) || this;\n  }\n  return And2;\n}(LogicalNary$1);\nvar And$1 = And;\nvar __extends$7 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar Bbox = function(_super) {\n  __extends$7(Bbox2, _super);\n  function Bbox2(geometryName, extent2, opt_srsName) {\n    var _this = _super.call(this, \"BBOX\") || this;\n    _this.geometryName = geometryName;\n    _this.extent = extent2;\n    if (extent2.length !== 4) {\n      throw new Error(\"Expected an extent with four values ([minX, minY, maxX, maxY])\");\n    }\n    _this.srsName = opt_srsName;\n    return _this;\n  }\n  return Bbox2;\n}(Filter$1);\nvar Bbox$1 = Bbox;\nfunction and(conditions) {\n  var params2 = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And$1, params2))();\n}\nfunction bbox(geometryName, extent2, opt_srsName) {\n  return new Bbox$1(geometryName, extent2, opt_srsName);\n}\nvar __extends$6 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar FEATURE_COLLECTION_PARSERS = {\n  \"http://www.opengis.net/gml\": {\n    \"boundedBy\": makeObjectPropertySetter(GMLBase$1.prototype.readExtentElement, \"bounds\")\n  },\n  \"http://www.opengis.net/wfs/2.0\": {\n    \"member\": makeArrayPusher(GMLBase$1.prototype.readFeaturesInternal)\n  }\n};\nvar TRANSACTION_SUMMARY_PARSERS = {\n  \"http://www.opengis.net/wfs\": {\n    \"totalInserted\": makeObjectPropertySetter(readPositiveInteger),\n    \"totalUpdated\": makeObjectPropertySetter(readPositiveInteger),\n    \"totalDeleted\": makeObjectPropertySetter(readPositiveInteger)\n  },\n  \"http://www.opengis.net/wfs/2.0\": {\n    \"totalInserted\": makeObjectPropertySetter(readPositiveInteger),\n    \"totalUpdated\": makeObjectPropertySetter(readPositiveInteger),\n    \"totalDeleted\": makeObjectPropertySetter(readPositiveInteger)\n  }\n};\nvar TRANSACTION_RESPONSE_PARSERS = {\n  \"http://www.opengis.net/wfs\": {\n    \"TransactionSummary\": makeObjectPropertySetter(readTransactionSummary, \"transactionSummary\"),\n    \"InsertResults\": makeObjectPropertySetter(readInsertResults, \"insertIds\")\n  },\n  \"http://www.opengis.net/wfs/2.0\": {\n    \"TransactionSummary\": makeObjectPropertySetter(readTransactionSummary, \"transactionSummary\"),\n    \"InsertResults\": makeObjectPropertySetter(readInsertResults, \"insertIds\")\n  }\n};\nvar QUERY_SERIALIZERS = {\n  \"http://www.opengis.net/wfs\": {\n    \"PropertyName\": makeChildAppender(writeStringTextNode)\n  },\n  \"http://www.opengis.net/wfs/2.0\": {\n    \"PropertyName\": makeChildAppender(writeStringTextNode)\n  }\n};\nvar TRANSACTION_SERIALIZERS = {\n  \"http://www.opengis.net/wfs\": {\n    \"Insert\": makeChildAppender(writeFeature),\n    \"Update\": makeChildAppender(writeUpdate),\n    \"Delete\": makeChildAppender(writeDelete),\n    \"Property\": makeChildAppender(writeProperty),\n    \"Native\": makeChildAppender(writeNative)\n  },\n  \"http://www.opengis.net/wfs/2.0\": {\n    \"Insert\": makeChildAppender(writeFeature),\n    \"Update\": makeChildAppender(writeUpdate),\n    \"Delete\": makeChildAppender(writeDelete),\n    \"Property\": makeChildAppender(writeProperty),\n    \"Native\": makeChildAppender(writeNative)\n  }\n};\nvar FEATURE_PREFIX = \"feature\";\nvar XMLNS = \"http://www.w3.org/2000/xmlns/\";\nvar OGCNS = {\n  \"2.0.0\": \"http://www.opengis.net/ogc/1.1\",\n  \"1.1.0\": \"http://www.opengis.net/ogc\",\n  \"1.0.0\": \"http://www.opengis.net/ogc\"\n};\nvar WFSNS = {\n  \"2.0.0\": \"http://www.opengis.net/wfs/2.0\",\n  \"1.1.0\": \"http://www.opengis.net/wfs\",\n  \"1.0.0\": \"http://www.opengis.net/wfs\"\n};\nvar FESNS = {\n  \"2.0.0\": \"http://www.opengis.net/fes/2.0\",\n  \"1.1.0\": \"http://www.opengis.net/fes\",\n  \"1.0.0\": \"http://www.opengis.net/fes\"\n};\nvar SCHEMA_LOCATIONS = {\n  \"2.0.0\": \"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd\",\n  \"1.1.0\": \"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd\",\n  \"1.0.0\": \"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd\"\n};\nvar GML_FORMATS = {\n  \"2.0.0\": GML32$1,\n  \"1.1.0\": GML3$1,\n  \"1.0.0\": GML2$1\n};\nvar DEFAULT_VERSION = \"1.1.0\";\nvar WFS = function(_super) {\n  __extends$6(WFS2, _super);\n  function WFS2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.version_ = options.version ? options.version : DEFAULT_VERSION;\n    _this.featureType_ = options.featureType;\n    _this.featureNS_ = options.featureNS;\n    _this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[_this.version_]();\n    _this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[_this.version_];\n    return _this;\n  }\n  WFS2.prototype.getFeatureType = function() {\n    return this.featureType_;\n  };\n  WFS2.prototype.setFeatureType = function(featureType) {\n    this.featureType_ = featureType;\n  };\n  WFS2.prototype.readFeaturesFromNode = function(node2, opt_options) {\n    var context = {\n      node: node2\n    };\n    assign(context, {\n      \"featureType\": this.featureType_,\n      \"featureNS\": this.featureNS_\n    });\n    assign(context, this.getReadOptions(node2, opt_options ? opt_options : {}));\n    var objectStack = [context];\n    var featuresNS;\n    if (this.version_ === \"2.0.0\") {\n      featuresNS = FEATURE_COLLECTION_PARSERS;\n    } else {\n      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;\n    }\n    var features = pushParseAndPop([], featuresNS, node2, objectStack, this.gmlFormat_);\n    if (!features) {\n      features = [];\n    }\n    return features;\n  };\n  WFS2.prototype.readTransactionResponse = function(source) {\n    if (!source) {\n      return void 0;\n    } else if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(source);\n    } else {\n      return this.readTransactionResponseFromNode(source);\n    }\n  };\n  WFS2.prototype.readFeatureCollectionMetadata = function(source) {\n    if (!source) {\n      return void 0;\n    } else if (typeof source === \"string\") {\n      var doc = parse$1(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(source);\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(source);\n    }\n  };\n  WFS2.prototype.readFeatureCollectionMetadataFromDocument = function(doc) {\n    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {\n      if (n2.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(n2);\n      }\n    }\n    return void 0;\n  };\n  WFS2.prototype.readFeatureCollectionMetadataFromNode = function(node2) {\n    var result = {};\n    var value = readNonNegativeIntegerString(node2.getAttribute(\"numberOfFeatures\"));\n    result[\"numberOfFeatures\"] = value;\n    return pushParseAndPop(result, FEATURE_COLLECTION_PARSERS, node2, [], this.gmlFormat_);\n  };\n  WFS2.prototype.readTransactionResponseFromDocument = function(doc) {\n    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {\n      if (n2.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(n2);\n      }\n    }\n    return void 0;\n  };\n  WFS2.prototype.readTransactionResponseFromNode = function(node2) {\n    return pushParseAndPop({}, TRANSACTION_RESPONSE_PARSERS, node2, []);\n  };\n  WFS2.prototype.writeGetFeature = function(options) {\n    var _this = this;\n    var node2 = createElementNS(WFSNS[this.version_], \"GetFeature\");\n    node2.setAttribute(\"service\", \"WFS\");\n    node2.setAttribute(\"version\", this.version_);\n    if (options.handle) {\n      node2.setAttribute(\"handle\", options.handle);\n    }\n    if (options.outputFormat) {\n      node2.setAttribute(\"outputFormat\", options.outputFormat);\n    }\n    if (options.maxFeatures !== void 0) {\n      node2.setAttribute(\"maxFeatures\", String(options.maxFeatures));\n    }\n    if (options.resultType) {\n      node2.setAttribute(\"resultType\", options.resultType);\n    }\n    if (options.startIndex !== void 0) {\n      node2.setAttribute(\"startIndex\", String(options.startIndex));\n    }\n    if (options.count !== void 0) {\n      node2.setAttribute(\"count\", String(options.count));\n    }\n    if (options.viewParams !== void 0) {\n      node2.setAttribute(\"viewParams\", options.viewParams);\n    }\n    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, \"xsi:schemaLocation\", this.schemaLocation_);\n    var context = {\n      node: node2\n    };\n    assign(context, {\n      \"version\": this.version_,\n      \"srsName\": options.srsName,\n      \"featureNS\": options.featureNS ? options.featureNS : this.featureNS_,\n      \"featurePrefix\": options.featurePrefix,\n      \"propertyNames\": options.propertyNames ? options.propertyNames : []\n    });\n    assert(Array.isArray(options.featureTypes), 11);\n    if (typeof options.featureTypes[0] === \"string\") {\n      var filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName, 12);\n        filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);\n      }\n      assign(context, {\n        \"geometryName\": options.geometryName,\n        \"filter\": filter\n      });\n      writeGetFeature(node2, options.featureTypes, [context]);\n    } else {\n      options.featureTypes.forEach(function(featureType) {\n        var completeFilter = _this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);\n        assign(context, {\n          \"geometryName\": featureType.geometryName,\n          \"filter\": completeFilter\n        });\n        writeGetFeature(node2, [featureType.name], [context]);\n      });\n    }\n    return node2;\n  };\n  WFS2.prototype.combineBboxAndFilter = function(geometryName, extent2, opt_srsName, opt_filter) {\n    var bboxFilter = bbox(geometryName, extent2, opt_srsName);\n    if (opt_filter) {\n      return and(opt_filter, bboxFilter);\n    }\n    return bboxFilter;\n  };\n  WFS2.prototype.writeTransaction = function(inserts, updates, deletes, options) {\n    var objectStack = [];\n    var version2 = options.version ? options.version : this.version_;\n    var node2 = createElementNS(WFSNS[version2], \"Transaction\");\n    node2.setAttribute(\"service\", \"WFS\");\n    node2.setAttribute(\"version\", version2);\n    var baseObj;\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node2.setAttribute(\"handle\", options.handle);\n      }\n    }\n    node2.setAttributeNS(XML_SCHEMA_INSTANCE_URI, \"xsi:schemaLocation\", SCHEMA_LOCATIONS[version2]);\n    var request = createTransactionRequest(node2, baseObj, version2, options);\n    if (inserts) {\n      serializeTransactionRequest(\"Insert\", inserts, objectStack, request);\n    }\n    if (updates) {\n      serializeTransactionRequest(\"Update\", updates, objectStack, request);\n    }\n    if (deletes) {\n      serializeTransactionRequest(\"Delete\", deletes, objectStack, request);\n    }\n    if (options.nativeElements) {\n      serializeTransactionRequest(\"Native\", options.nativeElements, objectStack, request);\n    }\n    return node2;\n  };\n  WFS2.prototype.readProjectionFromDocument = function(doc) {\n    for (var n2 = doc.firstChild; n2; n2 = n2.nextSibling) {\n      if (n2.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(n2);\n      }\n    }\n    return null;\n  };\n  WFS2.prototype.readProjectionFromNode = function(node2) {\n    if (node2.firstElementChild && node2.firstElementChild.firstElementChild) {\n      node2 = node2.firstElementChild.firstElementChild;\n      for (var n2 = node2.firstElementChild; n2; n2 = n2.nextElementSibling) {\n        if (!(n2.childNodes.length === 0 || n2.childNodes.length === 1 && n2.firstChild.nodeType === 3)) {\n          var objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n2, objectStack);\n          return get$3(objectStack.pop().srsName);\n        }\n      }\n    }\n    return null;\n  };\n  return WFS2;\n}(XMLFeature$1);\nfunction createTransactionRequest(node2, baseObj, version2, options) {\n  var featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n  var gmlVersion;\n  if (version2 === \"1.0.0\") {\n    gmlVersion = 2;\n  } else if (version2 === \"1.1.0\") {\n    gmlVersion = 3;\n  } else if (version2 === \"2.0.0\") {\n    gmlVersion = 3.2;\n  }\n  var obj = assign({ node: node2 }, {\n    version: version2,\n    \"featureNS\": options.featureNS,\n    \"featureType\": options.featureType,\n    \"featurePrefix\": featurePrefix,\n    \"gmlVersion\": gmlVersion,\n    \"hasZ\": options.hasZ,\n    \"srsName\": options.srsName\n  }, baseObj);\n  return obj;\n}\nfunction serializeTransactionRequest(type, features, objectStack, request) {\n  pushSerializeAndPop(request, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory(type), features, objectStack);\n}\nfunction readTransactionSummary(node2, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node2, objectStack);\n}\nvar OGC_FID_PARSERS = {\n  \"http://www.opengis.net/ogc\": {\n    \"FeatureId\": makeArrayPusher(function(node2, objectStack) {\n      return node2.getAttribute(\"fid\");\n    })\n  },\n  \"http://www.opengis.net/ogc/1.1\": {\n    \"FeatureId\": makeArrayPusher(function(node2, objectStack) {\n      return node2.getAttribute(\"fid\");\n    })\n  }\n};\nfunction fidParser(node2, objectStack) {\n  parseNode(OGC_FID_PARSERS, node2, objectStack);\n}\nvar INSERT_RESULTS_PARSERS = {\n  \"http://www.opengis.net/wfs\": {\n    \"Feature\": fidParser\n  },\n  \"http://www.opengis.net/wfs/2.0\": {\n    \"Feature\": fidParser\n  }\n};\nfunction readInsertResults(node2, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node2, objectStack);\n}\nfunction writeFeature(node2, feature2, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var featureType = context[\"featureType\"];\n  var featureNS = context[\"featureNS\"];\n  var gmlVersion = context[\"gmlVersion\"];\n  var child = createElementNS(featureNS, featureType);\n  node2.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2$1.prototype.writeFeatureElement(child, feature2, objectStack);\n  } else if (gmlVersion === 3) {\n    GML3$1.prototype.writeFeatureElement(child, feature2, objectStack);\n  } else {\n    GML32$1.prototype.writeFeatureElement(child, feature2, objectStack);\n  }\n}\nfunction writeOgcFidFilter(node2, fid, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var version2 = context[\"version\"];\n  var ns = OGCNS[version2];\n  var filter = createElementNS(ns, \"Filter\");\n  var child = createElementNS(ns, \"FeatureId\");\n  filter.appendChild(child);\n  child.setAttribute(\"fid\", fid);\n  node2.appendChild(filter);\n}\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  var prefix = featurePrefix + \":\";\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\nfunction writeDelete(node2, feature2, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  assert(feature2.getId() !== void 0, 26);\n  var featureType = context[\"featureType\"];\n  var featurePrefix = context[\"featurePrefix\"];\n  var featureNS = context[\"featureNS\"];\n  var typeName = getTypeName(featurePrefix, featureType);\n  node2.setAttribute(\"typeName\", typeName);\n  node2.setAttributeNS(XMLNS, \"xmlns:\" + featurePrefix, featureNS);\n  var fid = feature2.getId();\n  if (fid !== void 0) {\n    writeOgcFidFilter(node2, fid, objectStack);\n  }\n}\nfunction writeUpdate(node2, feature2, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  assert(feature2.getId() !== void 0, 27);\n  var version2 = context[\"version\"];\n  var featureType = context[\"featureType\"];\n  var featurePrefix = context[\"featurePrefix\"];\n  var featureNS = context[\"featureNS\"];\n  var typeName = getTypeName(featurePrefix, featureType);\n  var geometryName = feature2.getGeometryName();\n  node2.setAttribute(\"typeName\", typeName);\n  node2.setAttributeNS(XMLNS, \"xmlns:\" + featurePrefix, featureNS);\n  var fid = feature2.getId();\n  if (fid !== void 0) {\n    var keys3 = feature2.getKeys();\n    var values2 = [];\n    for (var i2 = 0, ii = keys3.length; i2 < ii; i2++) {\n      var value = feature2.get(keys3[i2]);\n      if (value !== void 0) {\n        var name_1 = keys3[i2];\n        if (value && typeof value.getSimplifiedGeometry === \"function\") {\n          name_1 = geometryName;\n        }\n        values2.push({ name: name_1, value });\n      }\n    }\n    pushSerializeAndPop({\n      version: version2,\n      \"gmlVersion\": context[\"gmlVersion\"],\n      node: node2,\n      \"hasZ\": context[\"hasZ\"],\n      \"srsName\": context[\"srsName\"]\n    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory(\"Property\"), values2, objectStack);\n    writeOgcFidFilter(node2, fid, objectStack);\n  }\n}\nfunction writeProperty(node2, pair, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var version2 = context[\"version\"];\n  var ns = WFSNS[version2];\n  var name = createElementNS(ns, \"Name\");\n  var gmlVersion = context[\"gmlVersion\"];\n  node2.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== void 0 && pair.value !== null) {\n    var value = createElementNS(ns, \"Value\");\n    node2.appendChild(value);\n    if (pair.value && typeof pair.value.getSimplifiedGeometry === \"function\") {\n      if (gmlVersion === 2) {\n        GML2$1.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else if (gmlVersion === 3) {\n        GML3$1.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML32$1.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\nfunction writeNative(node2, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node2.setAttribute(\"vendorId\", nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== void 0) {\n    node2.setAttribute(\"safeToIgnore\", String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== void 0) {\n    writeStringTextNode(node2, nativeElement.value);\n  }\n}\nvar GETFEATURE_SERIALIZERS = {\n  \"http://www.opengis.net/wfs\": {\n    \"Query\": makeChildAppender(writeQuery)\n  },\n  \"http://www.opengis.net/wfs/2.0\": {\n    \"Query\": makeChildAppender(writeQuery)\n  },\n  \"http://www.opengis.net/ogc\": {\n    \"During\": makeChildAppender(writeDuringFilter),\n    \"And\": makeChildAppender(writeLogicalFilter),\n    \"Or\": makeChildAppender(writeLogicalFilter),\n    \"Not\": makeChildAppender(writeNotFilter),\n    \"BBOX\": makeChildAppender(writeBboxFilter),\n    \"Contains\": makeChildAppender(writeSpatialFilter),\n    \"Intersects\": makeChildAppender(writeSpatialFilter),\n    \"Within\": makeChildAppender(writeSpatialFilter),\n    \"DWithin\": makeChildAppender(writeDWithinFilter),\n    \"PropertyIsEqualTo\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsNotEqualTo\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsLessThan\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsLessThanOrEqualTo\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsGreaterThan\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsGreaterThanOrEqualTo\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsNull\": makeChildAppender(writeIsNullFilter),\n    \"PropertyIsBetween\": makeChildAppender(writeIsBetweenFilter),\n    \"PropertyIsLike\": makeChildAppender(writeIsLikeFilter)\n  },\n  \"http://www.opengis.net/fes/2.0\": {\n    \"During\": makeChildAppender(writeDuringFilter),\n    \"And\": makeChildAppender(writeLogicalFilter),\n    \"Or\": makeChildAppender(writeLogicalFilter),\n    \"Not\": makeChildAppender(writeNotFilter),\n    \"BBOX\": makeChildAppender(writeBboxFilter),\n    \"Contains\": makeChildAppender(writeSpatialFilter),\n    \"Disjoint\": makeChildAppender(writeSpatialFilter),\n    \"Intersects\": makeChildAppender(writeSpatialFilter),\n    \"ResourceId\": makeChildAppender(writeResourceIdFilter),\n    \"Within\": makeChildAppender(writeSpatialFilter),\n    \"DWithin\": makeChildAppender(writeDWithinFilter),\n    \"PropertyIsEqualTo\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsNotEqualTo\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsLessThan\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsLessThanOrEqualTo\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsGreaterThan\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsGreaterThanOrEqualTo\": makeChildAppender(writeComparisonFilter),\n    \"PropertyIsNull\": makeChildAppender(writeIsNullFilter),\n    \"PropertyIsBetween\": makeChildAppender(writeIsBetweenFilter),\n    \"PropertyIsLike\": makeChildAppender(writeIsLikeFilter)\n  }\n};\nfunction writeQuery(node2, featureType, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var version2 = context[\"version\"];\n  var featurePrefix = context[\"featurePrefix\"];\n  var featureNS = context[\"featureNS\"];\n  var propertyNames = context[\"propertyNames\"];\n  var srsName = context[\"srsName\"];\n  var typeName;\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  var typeNameAttr;\n  if (version2 === \"2.0.0\") {\n    typeNameAttr = \"typeNames\";\n  } else {\n    typeNameAttr = \"typeName\";\n  }\n  node2.setAttribute(typeNameAttr, typeName);\n  if (srsName) {\n    node2.setAttribute(\"srsName\", srsName);\n  }\n  if (featureNS) {\n    node2.setAttributeNS(XMLNS, \"xmlns:\" + featurePrefix, featureNS);\n  }\n  var item = assign({}, context);\n  item.node = node2;\n  pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory(\"PropertyName\"), propertyNames, objectStack);\n  var filter = context[\"filter\"];\n  if (filter) {\n    var child = createElementNS(getFilterNS(version2), \"Filter\");\n    node2.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\nfunction writeFilterCondition(node2, filter, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var item = { node: node2 };\n  assign(item, { context });\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);\n}\nfunction writeBboxFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var version2 = context[\"version\"];\n  parent[\"srsName\"] = filter.srsName;\n  var format2 = GML_FORMATS[version2];\n  writePropertyName(version2, node2, filter.geometryName);\n  format2.prototype.writeGeometryElement(node2, filter.extent, objectStack);\n}\nfunction writeResourceIdFilter(node2, filter, objectStack) {\n  node2.setAttribute(\"rid\", filter.rid);\n}\nfunction writeSpatialFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var version2 = context[\"version\"];\n  parent[\"srsName\"] = filter.srsName;\n  var format2 = GML_FORMATS[version2];\n  writePropertyName(version2, node2, filter.geometryName);\n  format2.prototype.writeGeometryElement(node2, filter.geometry, objectStack);\n}\nfunction writeDWithinFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var version2 = context[\"version\"];\n  writeSpatialFilter(node2, filter, objectStack);\n  var distance2 = createElementNS(getFilterNS(version2), \"Distance\");\n  writeStringTextNode(distance2, filter.distance.toString());\n  if (version2 === \"2.0.0\") {\n    distance2.setAttribute(\"uom\", filter.unit);\n  } else {\n    distance2.setAttribute(\"units\", filter.unit);\n  }\n  node2.appendChild(distance2);\n}\nfunction writeDuringFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var version2 = context[\"version\"];\n  writeExpression(FESNS[version2], \"ValueReference\", node2, filter.propertyName);\n  var timePeriod = createElementNS(GMLNS, \"TimePeriod\");\n  node2.appendChild(timePeriod);\n  var begin = createElementNS(GMLNS, \"begin\");\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n  var end = createElementNS(GMLNS, \"end\");\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\nfunction writeLogicalFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var item = { node: node2 };\n  assign(item, { context });\n  var conditions = filter.conditions;\n  for (var i2 = 0, ii = conditions.length; i2 < ii; ++i2) {\n    var condition = conditions[i2];\n    pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n  }\n}\nfunction writeNotFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var item = { node: node2 };\n  assign(item, { context });\n  var condition = filter.condition;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n}\nfunction writeComparisonFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var version2 = context[\"version\"];\n  if (filter.matchCase !== void 0) {\n    node2.setAttribute(\"matchCase\", filter.matchCase.toString());\n  }\n  writePropertyName(version2, node2, filter.propertyName);\n  writeLiteral(version2, node2, \"\" + filter.expression);\n}\nfunction writeIsNullFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var version2 = context[\"version\"];\n  writePropertyName(version2, node2, filter.propertyName);\n}\nfunction writeIsBetweenFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var version2 = context[\"version\"];\n  var ns = getFilterNS(version2);\n  writePropertyName(version2, node2, filter.propertyName);\n  var lowerBoundary = createElementNS(ns, \"LowerBoundary\");\n  node2.appendChild(lowerBoundary);\n  writeLiteral(version2, lowerBoundary, \"\" + filter.lowerBoundary);\n  var upperBoundary = createElementNS(ns, \"UpperBoundary\");\n  node2.appendChild(upperBoundary);\n  writeLiteral(version2, upperBoundary, \"\" + filter.upperBoundary);\n}\nfunction writeIsLikeFilter(node2, filter, objectStack) {\n  var parent = objectStack[objectStack.length - 1];\n  var context = parent[\"context\"];\n  var version2 = context[\"version\"];\n  node2.setAttribute(\"wildCard\", filter.wildCard);\n  node2.setAttribute(\"singleChar\", filter.singleChar);\n  node2.setAttribute(\"escapeChar\", filter.escapeChar);\n  if (filter.matchCase !== void 0) {\n    node2.setAttribute(\"matchCase\", filter.matchCase.toString());\n  }\n  writePropertyName(version2, node2, filter.propertyName);\n  writeLiteral(version2, node2, \"\" + filter.pattern);\n}\nfunction writeExpression(ns, tagName, node2, value) {\n  var property = createElementNS(ns, tagName);\n  writeStringTextNode(property, value);\n  node2.appendChild(property);\n}\nfunction writeLiteral(version2, node2, value) {\n  writeExpression(getFilterNS(version2), \"Literal\", node2, value);\n}\nfunction writePropertyName(version2, node2, value) {\n  if (version2 === \"2.0.0\") {\n    writeExpression(FESNS[version2], \"ValueReference\", node2, value);\n  } else {\n    writeExpression(OGCNS[version2], \"PropertyName\", node2, value);\n  }\n}\nfunction writeTimeInstant(node2, time2) {\n  var timeInstant = createElementNS(GMLNS, \"TimeInstant\");\n  node2.appendChild(timeInstant);\n  var timePosition = createElementNS(GMLNS, \"timePosition\");\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time2);\n}\nfunction writeGetFeature(node2, featureTypes, objectStack) {\n  var context = objectStack[objectStack.length - 1];\n  var item = assign({}, context);\n  item.node = node2;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(\"Query\"), featureTypes, objectStack);\n}\nfunction getFilterNS(version2) {\n  var ns;\n  if (version2 === \"2.0.0\") {\n    ns = FESNS[version2];\n  } else {\n    ns = OGCNS[version2];\n  }\n  return ns;\n}\nvar WFS$1 = WFS;\nvar __extends$5 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17\n};\nvar WkbReader = function() {\n  function WkbReader2(view) {\n    this.view_ = view;\n    this.pos_ = 0;\n    this.initialized_ = false;\n    this.isLittleEndian_ = false;\n    this.hasZ_ = false;\n    this.hasM_ = false;\n    this.srid_ = null;\n    this.layout_ = GeometryLayout.XY;\n  }\n  WkbReader2.prototype.readUint8 = function() {\n    return this.view_.getUint8(this.pos_++);\n  };\n  WkbReader2.prototype.readUint32 = function(isLittleEndian) {\n    return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);\n  };\n  WkbReader2.prototype.readDouble = function(isLittleEndian) {\n    return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);\n  };\n  WkbReader2.prototype.readPoint = function() {\n    var coords = [];\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n    return coords;\n  };\n  WkbReader2.prototype.readLineString = function() {\n    var numPoints = this.readUint32();\n    var coords = [];\n    for (var i2 = 0; i2 < numPoints; i2++) {\n      coords.push(this.readPoint());\n    }\n    return coords;\n  };\n  WkbReader2.prototype.readPolygon = function() {\n    var numRings = this.readUint32();\n    var rings = [];\n    for (var i2 = 0; i2 < numRings; i2++) {\n      rings.push(this.readLineString());\n    }\n    return rings;\n  };\n  WkbReader2.prototype.readWkbHeader = function(expectedTypeId) {\n    var byteOrder = this.readUint8();\n    var isLittleEndian = byteOrder > 0;\n    var wkbType = this.readUint32(isLittleEndian);\n    var wkbTypeThousandth = Math.floor((wkbType & 268435455) / 1e3);\n    var hasZ = Boolean(wkbType & 2147483648) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;\n    var hasM = Boolean(wkbType & 1073741824) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;\n    var hasSRID = Boolean(wkbType & 536870912);\n    var typeId = (wkbType & 268435455) % 1e3;\n    var layout = [\"XY\", hasZ ? \"Z\" : \"\", hasM ? \"M\" : \"\"].join(\"\");\n    var srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n    if (expectedTypeId !== void 0 && expectedTypeId !== typeId) {\n      throw new Error(\"Unexpected WKB geometry type \" + typeId);\n    }\n    if (this.initialized_) {\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error(\"Inconsistent endian\");\n      }\n      if (this.layout_ !== layout) {\n        throw new Error(\"Inconsistent geometry layout\");\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error(\"Inconsistent coordinate system (SRID)\");\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n    return typeId;\n  };\n  WkbReader2.prototype.readWkbPayload = function(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n      default:\n        throw new Error(\"Unsupported WKB geometry type \" + typeId + \" is found\");\n    }\n  };\n  WkbReader2.prototype.readWkbBlock = function(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  };\n  WkbReader2.prototype.readWkbCollection = function(reader, expectedTypeId) {\n    var num = this.readUint32();\n    var items = [];\n    for (var i2 = 0; i2 < num; i2++) {\n      var result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n    return items;\n  };\n  WkbReader2.prototype.readMultiPoint = function() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  };\n  WkbReader2.prototype.readMultiLineString = function() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);\n  };\n  WkbReader2.prototype.readMultiPolygon = function() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  };\n  WkbReader2.prototype.readGeometryCollection = function() {\n    return this.readWkbCollection(this.readGeometry);\n  };\n  WkbReader2.prototype.readGeometry = function() {\n    var typeId = this.readWkbHeader();\n    var result = this.readWkbPayload(typeId);\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point$4(result, this.layout_);\n      case WKBGeometryType.LINE_STRING:\n        return new LineString$2(result, this.layout_);\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon$2(result, this.layout_);\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint$2(result, this.layout_);\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString$2(result, this.layout_);\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon$2(result, this.layout_);\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection$1(result);\n      default:\n        return null;\n    }\n  };\n  WkbReader2.prototype.getSrid = function() {\n    return this.srid_;\n  };\n  return WkbReader2;\n}();\nvar WkbWriter = function() {\n  function WkbWriter2(opts) {\n    opts = opts || {};\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n    this.isEWKB_ = opts.ewkb !== false;\n    this.writeQueue_ = [];\n    this.nodata_ = assign({ X: 0, Y: 0, Z: 0, M: 0 }, opts.nodata);\n  }\n  WkbWriter2.prototype.writeUint8 = function(value) {\n    this.writeQueue_.push([1, value]);\n  };\n  WkbWriter2.prototype.writeUint32 = function(value) {\n    this.writeQueue_.push([4, value]);\n  };\n  WkbWriter2.prototype.writeDouble = function(value) {\n    this.writeQueue_.push([8, value]);\n  };\n  WkbWriter2.prototype.writePoint = function(coords, layout) {\n    var coordsObj = assign.apply(null, layout.split(\"\").map(function(axis2, idx) {\n      var _a3;\n      return _a3 = {}, _a3[axis2] = coords[idx], _a3;\n    }));\n    for (var _i = 0, _a2 = this.layout_; _i < _a2.length; _i++) {\n      var axis = _a2[_i];\n      this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);\n    }\n  };\n  WkbWriter2.prototype.writeLineString = function(coords, layout) {\n    this.writeUint32(coords.length);\n    for (var i2 = 0; i2 < coords.length; i2++) {\n      this.writePoint(coords[i2], layout);\n    }\n  };\n  WkbWriter2.prototype.writePolygon = function(rings, layout) {\n    this.writeUint32(rings.length);\n    for (var i2 = 0; i2 < rings.length; i2++) {\n      this.writeLineString(rings[i2], layout);\n    }\n  };\n  WkbWriter2.prototype.writeWkbHeader = function(wkbType, srid) {\n    wkbType %= 1e3;\n    if (this.layout_.indexOf(\"Z\") >= 0) {\n      wkbType += this.isEWKB_ ? 2147483648 : 1e3;\n    }\n    if (this.layout_.indexOf(\"M\") >= 0) {\n      wkbType += this.isEWKB_ ? 1073741824 : 2e3;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 536870912;\n    }\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  };\n  WkbWriter2.prototype.writeMultiPoint = function(coords, layout) {\n    this.writeUint32(coords.length);\n    for (var i2 = 0; i2 < coords.length; i2++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i2], layout);\n    }\n  };\n  WkbWriter2.prototype.writeMultiLineString = function(coords, layout) {\n    this.writeUint32(coords.length);\n    for (var i2 = 0; i2 < coords.length; i2++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i2], layout);\n    }\n  };\n  WkbWriter2.prototype.writeMultiPolygon = function(coords, layout) {\n    this.writeUint32(coords.length);\n    for (var i2 = 0; i2 < coords.length; i2++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i2], layout);\n    }\n  };\n  WkbWriter2.prototype.writeGeometryCollection = function(geometries) {\n    this.writeUint32(geometries.length);\n    for (var i2 = 0; i2 < geometries.length; i2++) {\n      this.writeGeometry(geometries[i2]);\n    }\n  };\n  WkbWriter2.prototype.findMinimumLayout = function(geom2, layout) {\n    if (layout === void 0) {\n      layout = GeometryLayout.XYZM;\n    }\n    var GeometryLayout_min = function(a2, b2) {\n      if (a2 === b2) {\n        return a2;\n      }\n      if (a2 === GeometryLayout.XYZM) {\n        return b2;\n      }\n      if (b2 === GeometryLayout.XYZM) {\n        return a2;\n      }\n      return GeometryLayout.XY;\n    };\n    if (geom2 instanceof SimpleGeometry$1) {\n      return GeometryLayout_min(geom2.getLayout(), layout);\n    }\n    if (geom2 instanceof GeometryCollection$1) {\n      var geoms = geom2.getGeometriesArray();\n      for (var i2 = 0; i2 < geoms.length && layout !== GeometryLayout.XY; i2++) {\n        layout = this.findMinimumLayout(geoms[i2], layout);\n      }\n    }\n    return layout;\n  };\n  WkbWriter2.prototype.writeGeometry = function(geom2, srid) {\n    var _a2, _b2;\n    var wkblut = (_a2 = {}, _a2[GeometryType.POINT] = WKBGeometryType.POINT, _a2[GeometryType.LINE_STRING] = WKBGeometryType.LINE_STRING, _a2[GeometryType.POLYGON] = WKBGeometryType.POLYGON, _a2[GeometryType.MULTI_POINT] = WKBGeometryType.MULTI_POINT, _a2[GeometryType.MULTI_LINE_STRING] = WKBGeometryType.MULTI_LINE_STRING, _a2[GeometryType.MULTI_POLYGON] = WKBGeometryType.MULTI_POLYGON, _a2[GeometryType.GEOMETRY_COLLECTION] = WKBGeometryType.GEOMETRY_COLLECTION, _a2);\n    var geomType = geom2.getType();\n    var typeId = wkblut[geomType];\n    if (!typeId) {\n      throw new Error(\"GeometryType \" + geomType + \" is not supported\");\n    }\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom2);\n    }\n    this.writeWkbHeader(typeId, srid);\n    if (geom2 instanceof SimpleGeometry$1) {\n      var writerLUT = (_b2 = {}, _b2[GeometryType.POINT] = this.writePoint, _b2[GeometryType.LINE_STRING] = this.writeLineString, _b2[GeometryType.POLYGON] = this.writePolygon, _b2[GeometryType.MULTI_POINT] = this.writeMultiPoint, _b2[GeometryType.MULTI_LINE_STRING] = this.writeMultiLineString, _b2[GeometryType.MULTI_POLYGON] = this.writeMultiPolygon, _b2);\n      writerLUT[geomType].call(this, geom2.getCoordinates(), geom2.getLayout());\n    } else if (geom2 instanceof GeometryCollection$1) {\n      this.writeGeometryCollection(geom2.getGeometriesArray());\n    }\n  };\n  WkbWriter2.prototype.getBuffer = function() {\n    var _this = this;\n    var byteLength = this.writeQueue_.reduce(function(acc, item) {\n      return acc + item[0];\n    }, 0);\n    var buffer2 = new ArrayBuffer(byteLength);\n    var view = new DataView(buffer2);\n    var pos = 0;\n    this.writeQueue_.forEach(function(item) {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], _this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], _this.isLittleEndian_);\n          break;\n      }\n      pos += item[0];\n    });\n    return buffer2;\n  };\n  return WkbWriter2;\n}();\nvar WKB = function(_super) {\n  __extends$5(WKB2, _super);\n  function WKB2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.splitCollection = Boolean(options.splitCollection);\n    _this.viewCache_ = null;\n    _this.hex_ = options.hex !== false;\n    _this.littleEndian_ = options.littleEndian !== false;\n    _this.ewkb_ = options.ewkb !== false;\n    _this.layout_ = options.geometryLayout;\n    _this.nodataZ_ = options.nodataZ || 0;\n    _this.nodataM_ = options.nodataM || 0;\n    _this.srid_ = options.srid;\n    return _this;\n  }\n  WKB2.prototype.getType = function() {\n    return this.hex_ ? FormatType.TEXT : FormatType.ARRAY_BUFFER;\n  };\n  WKB2.prototype.readFeature = function(source, opt_options) {\n    return new feature({\n      geometry: this.readGeometry(source, opt_options)\n    });\n  };\n  WKB2.prototype.readFeatures = function(source, opt_options) {\n    var geometries = [];\n    var geometry = this.readGeometry(source, opt_options);\n    if (this.splitCollection && geometry instanceof GeometryCollection$1) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map(function(geometry2) {\n      return new feature({ geometry: geometry2 });\n    });\n  };\n  WKB2.prototype.readGeometry = function(source, opt_options) {\n    var view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n    var reader = new WkbReader(view);\n    var geometry = reader.readGeometry();\n    this.viewCache_ = view;\n    var options = this.getReadOptions(source, opt_options);\n    this.viewCache_ = null;\n    return transformGeometryWithOptions(geometry, false, options);\n  };\n  WKB2.prototype.readProjection = function(source) {\n    var view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return void 0;\n    }\n    var reader = new WkbReader(view);\n    reader.readWkbHeader();\n    return reader.getSrid() && get$3(\"EPSG:\" + reader.getSrid()) || void 0;\n  };\n  WKB2.prototype.writeFeature = function(feature2, opt_options) {\n    return this.writeGeometry(feature2.getGeometry(), opt_options);\n  };\n  WKB2.prototype.writeFeatures = function(features, opt_options) {\n    return this.writeGeometry(new GeometryCollection$1(features.map(function(f2) {\n      return f2.getGeometry();\n    })), opt_options);\n  };\n  WKB2.prototype.writeGeometry = function(geometry, opt_options) {\n    var options = this.adaptOptions(opt_options);\n    var writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_\n      }\n    });\n    var srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      var dataProjection = options.dataProjection && get$3(options.dataProjection);\n      if (dataProjection) {\n        var code = dataProjection.getCode();\n        if (code.indexOf(\"EPSG:\") === 0) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n    writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);\n    var buffer2 = writer.getBuffer();\n    return this.hex_ ? encodeHexString(buffer2) : buffer2;\n  };\n  return WKB2;\n}(FeatureFormat$1);\nfunction encodeHexString(buffer2) {\n  var view = new Uint8Array(buffer2);\n  return Array.from(view.values()).map(function(x2) {\n    return (x2 < 16 ? \"0\" : \"\") + Number(x2).toString(16).toUpperCase();\n  }).join(\"\");\n}\nfunction decodeHexString(text2) {\n  var buffer2 = new Uint8Array(text2.length / 2);\n  for (var i2 = 0; i2 < text2.length / 2; i2++) {\n    buffer2[i2] = parseInt(text2.substr(i2 * 2, 2), 16);\n  }\n  return new DataView(buffer2.buffer);\n}\nfunction getDataView(source) {\n  if (typeof source === \"string\") {\n    return decodeHexString(source);\n  } else if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  } else if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  } else {\n    return null;\n  }\n}\nvar WKB$1 = WKB;\nvar __extends$4 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar GeometryConstructor = {\n  \"POINT\": Point$4,\n  \"LINESTRING\": LineString$2,\n  \"POLYGON\": Polygon$2,\n  \"MULTIPOINT\": MultiPoint$2,\n  \"MULTILINESTRING\": MultiLineString$2,\n  \"MULTIPOLYGON\": MultiPolygon$2\n};\nvar EMPTY = \"EMPTY\";\nvar Z$1 = \"Z\";\nvar M = \"M\";\nvar ZM = \"ZM\";\nvar TokenType = {\n  START: 0,\n  TEXT: 1,\n  LEFT_PAREN: 2,\n  RIGHT_PAREN: 3,\n  NUMBER: 4,\n  COMMA: 5,\n  EOF: 6\n};\nfor (var type in GeometryType) {\n  GeometryType[type].toUpperCase();\n}\nvar Lexer = function() {\n  function Lexer2(wkt2) {\n    this.wkt = wkt2;\n    this.index_ = -1;\n  }\n  Lexer2.prototype.isAlpha_ = function(c2) {\n    return c2 >= \"a\" && c2 <= \"z\" || c2 >= \"A\" && c2 <= \"Z\";\n  };\n  Lexer2.prototype.isNumeric_ = function(c2, opt_decimal) {\n    var decimal = opt_decimal !== void 0 ? opt_decimal : false;\n    return c2 >= \"0\" && c2 <= \"9\" || c2 == \".\" && !decimal;\n  };\n  Lexer2.prototype.isWhiteSpace_ = function(c2) {\n    return c2 == \" \" || c2 == \"\t\" || c2 == \"\\r\" || c2 == \"\\n\";\n  };\n  Lexer2.prototype.nextChar_ = function() {\n    return this.wkt.charAt(++this.index_);\n  };\n  Lexer2.prototype.nextToken = function() {\n    var c2 = this.nextChar_();\n    var position2 = this.index_;\n    var value = c2;\n    var type;\n    if (c2 == \"(\") {\n      type = TokenType.LEFT_PAREN;\n    } else if (c2 == \",\") {\n      type = TokenType.COMMA;\n    } else if (c2 == \")\") {\n      type = TokenType.RIGHT_PAREN;\n    } else if (this.isNumeric_(c2) || c2 == \"-\") {\n      type = TokenType.NUMBER;\n      value = this.readNumber_();\n    } else if (this.isAlpha_(c2)) {\n      type = TokenType.TEXT;\n      value = this.readText_();\n    } else if (this.isWhiteSpace_(c2)) {\n      return this.nextToken();\n    } else if (c2 === \"\") {\n      type = TokenType.EOF;\n    } else {\n      throw new Error(\"Unexpected character: \" + c2);\n    }\n    return { position: position2, value, type };\n  };\n  Lexer2.prototype.readNumber_ = function() {\n    var c2;\n    var index2 = this.index_;\n    var decimal = false;\n    var scientificNotation = false;\n    do {\n      if (c2 == \".\") {\n        decimal = true;\n      } else if (c2 == \"e\" || c2 == \"E\") {\n        scientificNotation = true;\n      }\n      c2 = this.nextChar_();\n    } while (this.isNumeric_(c2, decimal) || !scientificNotation && (c2 == \"e\" || c2 == \"E\") || scientificNotation && (c2 == \"-\" || c2 == \"+\"));\n    return parseFloat(this.wkt.substring(index2, this.index_--));\n  };\n  Lexer2.prototype.readText_ = function() {\n    var c2;\n    var index2 = this.index_;\n    do {\n      c2 = this.nextChar_();\n    } while (this.isAlpha_(c2));\n    return this.wkt.substring(index2, this.index_--).toUpperCase();\n  };\n  return Lexer2;\n}();\nvar Parser$2 = function() {\n  function Parser2(lexer) {\n    this.lexer_ = lexer;\n    this.token_ = {\n      position: 0,\n      type: TokenType.START\n    };\n    this.layout_ = GeometryLayout.XY;\n  }\n  Parser2.prototype.consume_ = function() {\n    this.token_ = this.lexer_.nextToken();\n  };\n  Parser2.prototype.isTokenType = function(type) {\n    return this.token_.type == type;\n  };\n  Parser2.prototype.match = function(type) {\n    var isMatch = this.isTokenType(type);\n    if (isMatch) {\n      this.consume_();\n    }\n    return isMatch;\n  };\n  Parser2.prototype.parse = function() {\n    this.consume_();\n    return this.parseGeometry_();\n  };\n  Parser2.prototype.parseGeometryLayout_ = function() {\n    var layout = GeometryLayout.XY;\n    var dimToken = this.token_;\n    if (this.isTokenType(TokenType.TEXT)) {\n      var dimInfo = dimToken.value;\n      if (dimInfo === Z$1) {\n        layout = GeometryLayout.XYZ;\n      } else if (dimInfo === M) {\n        layout = GeometryLayout.XYM;\n      } else if (dimInfo === ZM) {\n        layout = GeometryLayout.XYZM;\n      }\n      if (layout !== GeometryLayout.XY) {\n        this.consume_();\n      }\n    }\n    return layout;\n  };\n  Parser2.prototype.parseGeometryCollectionText_ = function() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var geometries = [];\n      do {\n        geometries.push(this.parseGeometry_());\n      } while (this.match(TokenType.COMMA));\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return geometries;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  Parser2.prototype.parsePointText_ = function() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates2 = this.parsePoint_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates2;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  Parser2.prototype.parseLineStringText_ = function() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates2 = this.parsePointList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates2;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  Parser2.prototype.parsePolygonText_ = function() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates2 = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates2;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  Parser2.prototype.parseMultiPointText_ = function() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates2 = void 0;\n      if (this.token_.type == TokenType.LEFT_PAREN) {\n        coordinates2 = this.parsePointTextList_();\n      } else {\n        coordinates2 = this.parsePointList_();\n      }\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates2;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  Parser2.prototype.parseMultiLineStringText_ = function() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates2 = this.parseLineStringTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates2;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  Parser2.prototype.parseMultiPolygonText_ = function() {\n    if (this.match(TokenType.LEFT_PAREN)) {\n      var coordinates2 = this.parsePolygonTextList_();\n      if (this.match(TokenType.RIGHT_PAREN)) {\n        return coordinates2;\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  Parser2.prototype.parsePoint_ = function() {\n    var coordinates2 = [];\n    var dimensions = this.layout_.length;\n    for (var i2 = 0; i2 < dimensions; ++i2) {\n      var token = this.token_;\n      if (this.match(TokenType.NUMBER)) {\n        coordinates2.push(token.value);\n      } else {\n        break;\n      }\n    }\n    if (coordinates2.length == dimensions) {\n      return coordinates2;\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  Parser2.prototype.parsePointList_ = function() {\n    var coordinates2 = [this.parsePoint_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates2.push(this.parsePoint_());\n    }\n    return coordinates2;\n  };\n  Parser2.prototype.parsePointTextList_ = function() {\n    var coordinates2 = [this.parsePointText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates2.push(this.parsePointText_());\n    }\n    return coordinates2;\n  };\n  Parser2.prototype.parseLineStringTextList_ = function() {\n    var coordinates2 = [this.parseLineStringText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates2.push(this.parseLineStringText_());\n    }\n    return coordinates2;\n  };\n  Parser2.prototype.parsePolygonTextList_ = function() {\n    var coordinates2 = [this.parsePolygonText_()];\n    while (this.match(TokenType.COMMA)) {\n      coordinates2.push(this.parsePolygonText_());\n    }\n    return coordinates2;\n  };\n  Parser2.prototype.isEmptyGeometry_ = function() {\n    var isEmpty2 = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n    if (isEmpty2) {\n      this.consume_();\n    }\n    return isEmpty2;\n  };\n  Parser2.prototype.formatErrorMessage_ = function() {\n    return \"Unexpected `\" + this.token_.value + \"` at position \" + this.token_.position + \" in `\" + this.lexer_.wkt + \"`\";\n  };\n  Parser2.prototype.parseGeometry_ = function() {\n    var token = this.token_;\n    if (this.match(TokenType.TEXT)) {\n      var geomType = token.value;\n      this.layout_ = this.parseGeometryLayout_();\n      var isEmpty2 = this.isEmptyGeometry_();\n      if (geomType == \"GEOMETRYCOLLECTION\") {\n        if (isEmpty2) {\n          return new GeometryCollection$1([]);\n        }\n        var geometries = this.parseGeometryCollectionText_();\n        return new GeometryCollection$1(geometries);\n      } else {\n        var ctor = GeometryConstructor[geomType];\n        if (!ctor) {\n          throw new Error(\"Invalid geometry type: \" + geomType);\n        }\n        var coordinates2 = void 0;\n        if (isEmpty2) {\n          if (geomType == \"POINT\") {\n            coordinates2 = [NaN, NaN];\n          } else {\n            coordinates2 = [];\n          }\n        } else {\n          switch (geomType) {\n            case \"POINT\": {\n              coordinates2 = this.parsePointText_();\n              break;\n            }\n            case \"LINESTRING\": {\n              coordinates2 = this.parseLineStringText_();\n              break;\n            }\n            case \"POLYGON\": {\n              coordinates2 = this.parsePolygonText_();\n              break;\n            }\n            case \"MULTIPOINT\": {\n              coordinates2 = this.parseMultiPointText_();\n              break;\n            }\n            case \"MULTILINESTRING\": {\n              coordinates2 = this.parseMultiLineStringText_();\n              break;\n            }\n            case \"MULTIPOLYGON\": {\n              coordinates2 = this.parseMultiPolygonText_();\n              break;\n            }\n          }\n        }\n        return new ctor(coordinates2, this.layout_);\n      }\n    }\n    throw new Error(this.formatErrorMessage_());\n  };\n  return Parser2;\n}();\nvar WKT = function(_super) {\n  __extends$4(WKT2, _super);\n  function WKT2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.splitCollection_ = options.splitCollection !== void 0 ? options.splitCollection : false;\n    return _this;\n  }\n  WKT2.prototype.parse_ = function(wkt2) {\n    var lexer = new Lexer(wkt2);\n    var parser = new Parser$2(lexer);\n    return parser.parse();\n  };\n  WKT2.prototype.readFeatureFromText = function(text2, opt_options) {\n    var geom2 = this.readGeometryFromText(text2, opt_options);\n    var feature$1 = new feature();\n    feature$1.setGeometry(geom2);\n    return feature$1;\n  };\n  WKT2.prototype.readFeaturesFromText = function(text2, opt_options) {\n    var geometries = [];\n    var geometry = this.readGeometryFromText(text2, opt_options);\n    if (this.splitCollection_ && geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    var features = [];\n    for (var i2 = 0, ii = geometries.length; i2 < ii; ++i2) {\n      var feature$1 = new feature();\n      feature$1.setGeometry(geometries[i2]);\n      features.push(feature$1);\n    }\n    return features;\n  };\n  WKT2.prototype.readGeometryFromText = function(text2, opt_options) {\n    var geometry = this.parse_(text2);\n    return transformGeometryWithOptions(geometry, false, opt_options);\n  };\n  WKT2.prototype.writeFeatureText = function(feature2, opt_options) {\n    var geometry = feature2.getGeometry();\n    if (geometry) {\n      return this.writeGeometryText(geometry, opt_options);\n    }\n    return \"\";\n  };\n  WKT2.prototype.writeFeaturesText = function(features, opt_options) {\n    if (features.length == 1) {\n      return this.writeFeatureText(features[0], opt_options);\n    }\n    var geometries = [];\n    for (var i2 = 0, ii = features.length; i2 < ii; ++i2) {\n      geometries.push(features[i2].getGeometry());\n    }\n    var collection = new GeometryCollection$1(geometries);\n    return this.writeGeometryText(collection, opt_options);\n  };\n  WKT2.prototype.writeGeometryText = function(geometry, opt_options) {\n    return encode(transformGeometryWithOptions(geometry, true, opt_options));\n  };\n  return WKT2;\n}(TextFeature$1);\nfunction encodePointGeometry(geom2) {\n  var coordinates2 = geom2.getCoordinates();\n  if (coordinates2.length === 0) {\n    return \"\";\n  }\n  return coordinates2.join(\" \");\n}\nfunction encodeMultiPointGeometry(geom2) {\n  var array = [];\n  var components = geom2.getPoints();\n  for (var i2 = 0, ii = components.length; i2 < ii; ++i2) {\n    array.push(\"(\" + encodePointGeometry(components[i2]) + \")\");\n  }\n  return array.join(\",\");\n}\nfunction encodeGeometryCollectionGeometry(geom2) {\n  var array = [];\n  var geoms = geom2.getGeometries();\n  for (var i2 = 0, ii = geoms.length; i2 < ii; ++i2) {\n    array.push(encode(geoms[i2]));\n  }\n  return array.join(\",\");\n}\nfunction encodeLineStringGeometry(geom2) {\n  var coordinates2 = geom2.getCoordinates();\n  var array = [];\n  for (var i2 = 0, ii = coordinates2.length; i2 < ii; ++i2) {\n    array.push(coordinates2[i2].join(\" \"));\n  }\n  return array.join(\",\");\n}\nfunction encodeMultiLineStringGeometry(geom2) {\n  var array = [];\n  var components = geom2.getLineStrings();\n  for (var i2 = 0, ii = components.length; i2 < ii; ++i2) {\n    array.push(\"(\" + encodeLineStringGeometry(components[i2]) + \")\");\n  }\n  return array.join(\",\");\n}\nfunction encodePolygonGeometry(geom2) {\n  var array = [];\n  var rings = geom2.getLinearRings();\n  for (var i2 = 0, ii = rings.length; i2 < ii; ++i2) {\n    array.push(\"(\" + encodeLineStringGeometry(rings[i2]) + \")\");\n  }\n  return array.join(\",\");\n}\nfunction encodeMultiPolygonGeometry(geom2) {\n  var array = [];\n  var components = geom2.getPolygons();\n  for (var i2 = 0, ii = components.length; i2 < ii; ++i2) {\n    array.push(\"(\" + encodePolygonGeometry(components[i2]) + \")\");\n  }\n  return array.join(\",\");\n}\nfunction encodeGeometryLayout(geom2) {\n  var layout = geom2.getLayout();\n  var dimInfo = \"\";\n  if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {\n    dimInfo += Z$1;\n  }\n  if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {\n    dimInfo += M;\n  }\n  return dimInfo;\n}\nvar GeometryEncoder = {\n  \"Point\": encodePointGeometry,\n  \"LineString\": encodeLineStringGeometry,\n  \"Polygon\": encodePolygonGeometry,\n  \"MultiPoint\": encodeMultiPointGeometry,\n  \"MultiLineString\": encodeMultiLineStringGeometry,\n  \"MultiPolygon\": encodeMultiPolygonGeometry,\n  \"GeometryCollection\": encodeGeometryCollectionGeometry\n};\nfunction encode(geom2) {\n  var type = geom2.getType();\n  var geometryEncoder = GeometryEncoder[type];\n  var enc = geometryEncoder(geom2);\n  type = type.toUpperCase();\n  if (typeof geom2.getFlatCoordinates === \"function\") {\n    var dimInfo = encodeGeometryLayout(geom2);\n    if (dimInfo.length > 0) {\n      type += \" \" + dimInfo;\n    }\n  }\n  if (enc.length === 0) {\n    return type + \" \" + EMPTY;\n  }\n  return type + \"(\" + enc + \")\";\n}\nvar WKT$1 = WKT;\nvar __extends$3 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar NAMESPACE_URIS$1 = [null, \"http://www.opengis.net/wms\"];\nvar PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Service\": makeObjectPropertySetter(readService),\n  \"Capability\": makeObjectPropertySetter(readCapability)\n});\nvar CAPABILITY_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Request\": makeObjectPropertySetter(readRequest),\n  \"Exception\": makeObjectPropertySetter(readException),\n  \"Layer\": makeObjectPropertySetter(readCapabilityLayer)\n});\nvar WMSCapabilities = function(_super) {\n  __extends$3(WMSCapabilities2, _super);\n  function WMSCapabilities2() {\n    var _this = _super.call(this) || this;\n    _this.version = void 0;\n    return _this;\n  }\n  WMSCapabilities2.prototype.readFromNode = function(node2) {\n    this.version = node2.getAttribute(\"version\").trim();\n    var wmsCapabilityObject = pushParseAndPop({\n      \"version\": this.version\n    }, PARSERS$1, node2, []);\n    return wmsCapabilityObject ? wmsCapabilityObject : null;\n  };\n  return WMSCapabilities2;\n}(XML$1);\nvar SERVICE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Name\": makeObjectPropertySetter(readString),\n  \"Title\": makeObjectPropertySetter(readString),\n  \"Abstract\": makeObjectPropertySetter(readString),\n  \"KeywordList\": makeObjectPropertySetter(readKeywordList),\n  \"OnlineResource\": makeObjectPropertySetter(readHref),\n  \"ContactInformation\": makeObjectPropertySetter(readContactInformation),\n  \"Fees\": makeObjectPropertySetter(readString),\n  \"AccessConstraints\": makeObjectPropertySetter(readString),\n  \"LayerLimit\": makeObjectPropertySetter(readPositiveInteger),\n  \"MaxWidth\": makeObjectPropertySetter(readPositiveInteger),\n  \"MaxHeight\": makeObjectPropertySetter(readPositiveInteger)\n});\nvar CONTACT_INFORMATION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"ContactPersonPrimary\": makeObjectPropertySetter(readContactPersonPrimary),\n  \"ContactPosition\": makeObjectPropertySetter(readString),\n  \"ContactAddress\": makeObjectPropertySetter(readContactAddress),\n  \"ContactVoiceTelephone\": makeObjectPropertySetter(readString),\n  \"ContactFacsimileTelephone\": makeObjectPropertySetter(readString),\n  \"ContactElectronicMailAddress\": makeObjectPropertySetter(readString)\n});\nvar CONTACT_PERSON_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"ContactPerson\": makeObjectPropertySetter(readString),\n  \"ContactOrganization\": makeObjectPropertySetter(readString)\n});\nvar CONTACT_ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"AddressType\": makeObjectPropertySetter(readString),\n  \"Address\": makeObjectPropertySetter(readString),\n  \"City\": makeObjectPropertySetter(readString),\n  \"StateOrProvince\": makeObjectPropertySetter(readString),\n  \"PostCode\": makeObjectPropertySetter(readString),\n  \"Country\": makeObjectPropertySetter(readString)\n});\nvar EXCEPTION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Format\": makeArrayPusher(readString)\n});\nvar LAYER_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Name\": makeObjectPropertySetter(readString),\n  \"Title\": makeObjectPropertySetter(readString),\n  \"Abstract\": makeObjectPropertySetter(readString),\n  \"KeywordList\": makeObjectPropertySetter(readKeywordList),\n  \"CRS\": makeObjectPropertyPusher(readString),\n  \"EX_GeographicBoundingBox\": makeObjectPropertySetter(readEXGeographicBoundingBox),\n  \"BoundingBox\": makeObjectPropertyPusher(readBoundingBox$1),\n  \"Dimension\": makeObjectPropertyPusher(readDimension),\n  \"Attribution\": makeObjectPropertySetter(readAttribution),\n  \"AuthorityURL\": makeObjectPropertyPusher(readAuthorityURL),\n  \"Identifier\": makeObjectPropertyPusher(readString),\n  \"MetadataURL\": makeObjectPropertyPusher(readMetadataURL),\n  \"DataURL\": makeObjectPropertyPusher(readFormatOnlineresource),\n  \"FeatureListURL\": makeObjectPropertyPusher(readFormatOnlineresource),\n  \"Style\": makeObjectPropertyPusher(readStyle$1),\n  \"MinScaleDenominator\": makeObjectPropertySetter(readDecimal),\n  \"MaxScaleDenominator\": makeObjectPropertySetter(readDecimal),\n  \"Layer\": makeObjectPropertyPusher(readLayer$1)\n});\nvar ATTRIBUTION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Title\": makeObjectPropertySetter(readString),\n  \"OnlineResource\": makeObjectPropertySetter(readHref),\n  \"LogoURL\": makeObjectPropertySetter(readSizedFormatOnlineresource)\n});\nvar EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"westBoundLongitude\": makeObjectPropertySetter(readDecimal),\n  \"eastBoundLongitude\": makeObjectPropertySetter(readDecimal),\n  \"southBoundLatitude\": makeObjectPropertySetter(readDecimal),\n  \"northBoundLatitude\": makeObjectPropertySetter(readDecimal)\n});\nvar REQUEST_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"GetCapabilities\": makeObjectPropertySetter(readOperationType),\n  \"GetMap\": makeObjectPropertySetter(readOperationType),\n  \"GetFeatureInfo\": makeObjectPropertySetter(readOperationType)\n});\nvar OPERATIONTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Format\": makeObjectPropertyPusher(readString),\n  \"DCPType\": makeObjectPropertyPusher(readDCPType)\n});\nvar DCPTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"HTTP\": makeObjectPropertySetter(readHTTP)\n});\nvar HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Get\": makeObjectPropertySetter(readFormatOnlineresource),\n  \"Post\": makeObjectPropertySetter(readFormatOnlineresource)\n});\nvar STYLE_PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Name\": makeObjectPropertySetter(readString),\n  \"Title\": makeObjectPropertySetter(readString),\n  \"Abstract\": makeObjectPropertySetter(readString),\n  \"LegendURL\": makeObjectPropertyPusher(readSizedFormatOnlineresource),\n  \"StyleSheetURL\": makeObjectPropertySetter(readFormatOnlineresource),\n  \"StyleURL\": makeObjectPropertySetter(readFormatOnlineresource)\n});\nvar FORMAT_ONLINERESOURCE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Format\": makeObjectPropertySetter(readString),\n  \"OnlineResource\": makeObjectPropertySetter(readHref)\n});\nvar KEYWORDLIST_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {\n  \"Keyword\": makeArrayPusher(readString)\n});\nfunction readAttribution(node2, objectStack) {\n  return pushParseAndPop({}, ATTRIBUTION_PARSERS, node2, objectStack);\n}\nfunction readBoundingBox$1(node2, objectStack) {\n  var extent2 = [\n    readDecimalString(node2.getAttribute(\"minx\")),\n    readDecimalString(node2.getAttribute(\"miny\")),\n    readDecimalString(node2.getAttribute(\"maxx\")),\n    readDecimalString(node2.getAttribute(\"maxy\"))\n  ];\n  var resolutions = [\n    readDecimalString(node2.getAttribute(\"resx\")),\n    readDecimalString(node2.getAttribute(\"resy\"))\n  ];\n  return {\n    \"crs\": node2.getAttribute(\"CRS\"),\n    \"extent\": extent2,\n    \"res\": resolutions\n  };\n}\nfunction readEXGeographicBoundingBox(node2, objectStack) {\n  var geographicBoundingBox = pushParseAndPop({}, EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS, node2, objectStack);\n  if (!geographicBoundingBox) {\n    return void 0;\n  }\n  var westBoundLongitude = geographicBoundingBox[\"westBoundLongitude\"];\n  var southBoundLatitude = geographicBoundingBox[\"southBoundLatitude\"];\n  var eastBoundLongitude = geographicBoundingBox[\"eastBoundLongitude\"];\n  var northBoundLatitude = geographicBoundingBox[\"northBoundLatitude\"];\n  if (westBoundLongitude === void 0 || southBoundLatitude === void 0 || eastBoundLongitude === void 0 || northBoundLatitude === void 0) {\n    return void 0;\n  }\n  return [\n    westBoundLongitude,\n    southBoundLatitude,\n    eastBoundLongitude,\n    northBoundLatitude\n  ];\n}\nfunction readCapability(node2, objectStack) {\n  return pushParseAndPop({}, CAPABILITY_PARSERS, node2, objectStack);\n}\nfunction readService(node2, objectStack) {\n  return pushParseAndPop({}, SERVICE_PARSERS, node2, objectStack);\n}\nfunction readContactInformation(node2, objectStack) {\n  return pushParseAndPop({}, CONTACT_INFORMATION_PARSERS, node2, objectStack);\n}\nfunction readContactPersonPrimary(node2, objectStack) {\n  return pushParseAndPop({}, CONTACT_PERSON_PARSERS, node2, objectStack);\n}\nfunction readContactAddress(node2, objectStack) {\n  return pushParseAndPop({}, CONTACT_ADDRESS_PARSERS, node2, objectStack);\n}\nfunction readException(node2, objectStack) {\n  return pushParseAndPop([], EXCEPTION_PARSERS, node2, objectStack);\n}\nfunction readCapabilityLayer(node2, objectStack) {\n  var layerObject = pushParseAndPop({}, LAYER_PARSERS$1, node2, objectStack);\n  if (layerObject[\"Layer\"] === void 0) {\n    return Object.assign(layerObject, readLayer$1(node2, objectStack));\n  }\n  return layerObject;\n}\nfunction readLayer$1(node2, objectStack) {\n  var parentLayerObject = objectStack[objectStack.length - 1];\n  var layerObject = pushParseAndPop({}, LAYER_PARSERS$1, node2, objectStack);\n  if (!layerObject) {\n    return void 0;\n  }\n  var queryable = readBooleanString(node2.getAttribute(\"queryable\"));\n  if (queryable === void 0) {\n    queryable = parentLayerObject[\"queryable\"];\n  }\n  layerObject[\"queryable\"] = queryable !== void 0 ? queryable : false;\n  var cascaded = readNonNegativeIntegerString(node2.getAttribute(\"cascaded\"));\n  if (cascaded === void 0) {\n    cascaded = parentLayerObject[\"cascaded\"];\n  }\n  layerObject[\"cascaded\"] = cascaded;\n  var opaque = readBooleanString(node2.getAttribute(\"opaque\"));\n  if (opaque === void 0) {\n    opaque = parentLayerObject[\"opaque\"];\n  }\n  layerObject[\"opaque\"] = opaque !== void 0 ? opaque : false;\n  var noSubsets = readBooleanString(node2.getAttribute(\"noSubsets\"));\n  if (noSubsets === void 0) {\n    noSubsets = parentLayerObject[\"noSubsets\"];\n  }\n  layerObject[\"noSubsets\"] = noSubsets !== void 0 ? noSubsets : false;\n  var fixedWidth = readDecimalString(node2.getAttribute(\"fixedWidth\"));\n  if (!fixedWidth) {\n    fixedWidth = parentLayerObject[\"fixedWidth\"];\n  }\n  layerObject[\"fixedWidth\"] = fixedWidth;\n  var fixedHeight = readDecimalString(node2.getAttribute(\"fixedHeight\"));\n  if (!fixedHeight) {\n    fixedHeight = parentLayerObject[\"fixedHeight\"];\n  }\n  layerObject[\"fixedHeight\"] = fixedHeight;\n  var addKeys = [\"Style\", \"CRS\", \"AuthorityURL\"];\n  addKeys.forEach(function(key) {\n    if (key in parentLayerObject) {\n      var childValue = layerObject[key] || [];\n      layerObject[key] = childValue.concat(parentLayerObject[key]);\n    }\n  });\n  var replaceKeys = [\n    \"EX_GeographicBoundingBox\",\n    \"BoundingBox\",\n    \"Dimension\",\n    \"Attribution\",\n    \"MinScaleDenominator\",\n    \"MaxScaleDenominator\"\n  ];\n  replaceKeys.forEach(function(key) {\n    if (!(key in layerObject)) {\n      var parentValue = parentLayerObject[key];\n      layerObject[key] = parentValue;\n    }\n  });\n  return layerObject;\n}\nfunction readDimension(node2, objectStack) {\n  var dimensionObject = {\n    \"name\": node2.getAttribute(\"name\"),\n    \"units\": node2.getAttribute(\"units\"),\n    \"unitSymbol\": node2.getAttribute(\"unitSymbol\"),\n    \"default\": node2.getAttribute(\"default\"),\n    \"multipleValues\": readBooleanString(node2.getAttribute(\"multipleValues\")),\n    \"nearestValue\": readBooleanString(node2.getAttribute(\"nearestValue\")),\n    \"current\": readBooleanString(node2.getAttribute(\"current\")),\n    \"values\": readString(node2)\n  };\n  return dimensionObject;\n}\nfunction readFormatOnlineresource(node2, objectStack) {\n  return pushParseAndPop({}, FORMAT_ONLINERESOURCE_PARSERS, node2, objectStack);\n}\nfunction readRequest(node2, objectStack) {\n  return pushParseAndPop({}, REQUEST_PARSERS, node2, objectStack);\n}\nfunction readDCPType(node2, objectStack) {\n  return pushParseAndPop({}, DCPTYPE_PARSERS, node2, objectStack);\n}\nfunction readHTTP(node2, objectStack) {\n  return pushParseAndPop({}, HTTP_PARSERS, node2, objectStack);\n}\nfunction readOperationType(node2, objectStack) {\n  return pushParseAndPop({}, OPERATIONTYPE_PARSERS, node2, objectStack);\n}\nfunction readSizedFormatOnlineresource(node2, objectStack) {\n  var formatOnlineresource = readFormatOnlineresource(node2, objectStack);\n  if (formatOnlineresource) {\n    var size = [\n      readNonNegativeIntegerString(node2.getAttribute(\"width\")),\n      readNonNegativeIntegerString(node2.getAttribute(\"height\"))\n    ];\n    formatOnlineresource[\"size\"] = size;\n    return formatOnlineresource;\n  }\n  return void 0;\n}\nfunction readAuthorityURL(node2, objectStack) {\n  var authorityObject = readFormatOnlineresource(node2, objectStack);\n  if (authorityObject) {\n    authorityObject[\"name\"] = node2.getAttribute(\"name\");\n    return authorityObject;\n  }\n  return void 0;\n}\nfunction readMetadataURL(node2, objectStack) {\n  var metadataObject = readFormatOnlineresource(node2, objectStack);\n  if (metadataObject) {\n    metadataObject[\"type\"] = node2.getAttribute(\"type\");\n    return metadataObject;\n  }\n  return void 0;\n}\nfunction readStyle$1(node2, objectStack) {\n  return pushParseAndPop({}, STYLE_PARSERS$1, node2, objectStack);\n}\nfunction readKeywordList(node2, objectStack) {\n  return pushParseAndPop([], KEYWORDLIST_PARSERS, node2, objectStack);\n}\nvar WMSCapabilities$1 = WMSCapabilities;\nvar __extends$2 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar featureIdentifier = \"_feature\";\nvar layerIdentifier = \"_layer\";\nvar WMSGetFeatureInfo = function(_super) {\n  __extends$2(WMSGetFeatureInfo2, _super);\n  function WMSGetFeatureInfo2(opt_options) {\n    var _this = _super.call(this) || this;\n    var options = opt_options ? opt_options : {};\n    _this.featureNS_ = \"http://mapserver.gis.umn.edu/mapserver\";\n    _this.gmlFormat_ = new GML2$1();\n    _this.layers_ = options.layers ? options.layers : null;\n    return _this;\n  }\n  WMSGetFeatureInfo2.prototype.getLayers = function() {\n    return this.layers_;\n  };\n  WMSGetFeatureInfo2.prototype.setLayers = function(layers) {\n    this.layers_ = layers;\n  };\n  WMSGetFeatureInfo2.prototype.readFeatures_ = function(node2, objectStack) {\n    node2.setAttribute(\"namespaceURI\", this.featureNS_);\n    var localName = node2.localName;\n    var features = [];\n    if (node2.childNodes.length === 0) {\n      return features;\n    }\n    if (localName == \"msGMLOutput\") {\n      for (var i2 = 0, ii = node2.childNodes.length; i2 < ii; i2++) {\n        var layer = node2.childNodes[i2];\n        if (layer.nodeType !== Node.ELEMENT_NODE) {\n          continue;\n        }\n        var layerElement = layer;\n        var context = objectStack[0];\n        var toRemove = layerIdentifier;\n        var layerName = layerElement.localName.replace(toRemove, \"\");\n        if (this.layers_ && !includes(this.layers_, layerName)) {\n          continue;\n        }\n        var featureType = layerName + featureIdentifier;\n        context[\"featureType\"] = featureType;\n        context[\"featureNS\"] = this.featureNS_;\n        var parsers = {};\n        parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);\n        var parsersNS = makeStructureNS([context[\"featureNS\"], null], parsers);\n        layerElement.setAttribute(\"namespaceURI\", this.featureNS_);\n        var layerFeatures = pushParseAndPop([], parsersNS, layerElement, objectStack, this.gmlFormat_);\n        if (layerFeatures) {\n          extend$3(features, layerFeatures);\n        }\n      }\n    }\n    if (localName == \"FeatureCollection\") {\n      var gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node2, [{}], this.gmlFormat_);\n      if (gmlFeatures) {\n        features = gmlFeatures;\n      }\n    }\n    return features;\n  };\n  WMSGetFeatureInfo2.prototype.readFeaturesFromNode = function(node2, opt_options) {\n    var options = {};\n    if (opt_options) {\n      assign(options, this.getReadOptions(node2, opt_options));\n    }\n    return this.readFeatures_(node2, [options]);\n  };\n  return WMSGetFeatureInfo2;\n}(XMLFeature$1);\nvar WMSGetFeatureInfo$1 = WMSGetFeatureInfo;\nvar __extends$1 = globalThis && globalThis.__extends || function() {\n  var extendStatics2 = function(d2, b2) {\n    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p5 in b3)\n        if (Object.prototype.hasOwnProperty.call(b3, p5))\n          d3[p5] = b3[p5];\n    };\n    return extendStatics2(d2, b2);\n  };\n  return function(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics2(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  };\n}();\nvar NAMESPACE_URIS = [null, \"http://www.opengis.net/wmts/1.0\"];\nvar OWS_NAMESPACE_URIS = [null, \"http://www.opengis.net/ows/1.1\"];\nvar PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"Contents\": makeObjectPropertySetter(readContents)\n});\nvar WMTSCapabilities = function(_super) {\n  __extends$1(WMTSCapabilities2, _super);\n  function WMTSCapabilities2() {\n    var _this = _super.call(this) || this;\n    _this.owsParser_ = new OWS$1();\n    return _this;\n  }\n  WMTSCapabilities2.prototype.readFromNode = function(node2) {\n    var version2 = node2.getAttribute(\"version\");\n    if (version2) {\n      version2 = version2.trim();\n    }\n    var WMTSCapabilityObject = this.owsParser_.readFromNode(node2);\n    if (!WMTSCapabilityObject) {\n      return null;\n    }\n    WMTSCapabilityObject[\"version\"] = version2;\n    WMTSCapabilityObject = pushParseAndPop(WMTSCapabilityObject, PARSERS, node2, []);\n    return WMTSCapabilityObject ? WMTSCapabilityObject : null;\n  };\n  return WMTSCapabilities2;\n}(XML$1);\nvar CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"Layer\": makeObjectPropertyPusher(readLayer),\n  \"TileMatrixSet\": makeObjectPropertyPusher(readTileMatrixSet)\n});\nvar LAYER_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"Style\": makeObjectPropertyPusher(readStyle),\n  \"Format\": makeObjectPropertyPusher(readString),\n  \"TileMatrixSetLink\": makeObjectPropertyPusher(readTileMatrixSetLink),\n  \"Dimension\": makeObjectPropertyPusher(readDimensions),\n  \"ResourceURL\": makeObjectPropertyPusher(readResourceUrl)\n}, makeStructureNS(OWS_NAMESPACE_URIS, {\n  \"Title\": makeObjectPropertySetter(readString),\n  \"Abstract\": makeObjectPropertySetter(readString),\n  \"WGS84BoundingBox\": makeObjectPropertySetter(readBoundingBox),\n  \"Identifier\": makeObjectPropertySetter(readString)\n}));\nvar STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"LegendURL\": makeObjectPropertyPusher(readLegendUrl)\n}, makeStructureNS(OWS_NAMESPACE_URIS, {\n  \"Title\": makeObjectPropertySetter(readString),\n  \"Identifier\": makeObjectPropertySetter(readString)\n}));\nvar TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"TileMatrixSet\": makeObjectPropertySetter(readString),\n  \"TileMatrixSetLimits\": makeObjectPropertySetter(readTileMatrixLimitsList)\n});\nvar TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"TileMatrixLimits\": makeArrayPusher(readTileMatrixLimits)\n});\nvar TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"TileMatrix\": makeObjectPropertySetter(readString),\n  \"MinTileRow\": makeObjectPropertySetter(readPositiveInteger),\n  \"MaxTileRow\": makeObjectPropertySetter(readPositiveInteger),\n  \"MinTileCol\": makeObjectPropertySetter(readPositiveInteger),\n  \"MaxTileCol\": makeObjectPropertySetter(readPositiveInteger)\n});\nvar DIMENSION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"Default\": makeObjectPropertySetter(readString),\n  \"Value\": makeObjectPropertyPusher(readString)\n}, makeStructureNS(OWS_NAMESPACE_URIS, {\n  \"Identifier\": makeObjectPropertySetter(readString)\n}));\nvar WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {\n  \"LowerCorner\": makeArrayPusher(readCoordinates),\n  \"UpperCorner\": makeArrayPusher(readCoordinates)\n});\nvar TMS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"WellKnownScaleSet\": makeObjectPropertySetter(readString),\n  \"TileMatrix\": makeObjectPropertyPusher(readTileMatrix)\n}, makeStructureNS(OWS_NAMESPACE_URIS, {\n  \"SupportedCRS\": makeObjectPropertySetter(readString),\n  \"Identifier\": makeObjectPropertySetter(readString),\n  \"BoundingBox\": makeObjectPropertySetter(readBoundingBox)\n}));\nvar TM_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  \"TopLeftCorner\": makeObjectPropertySetter(readCoordinates),\n  \"ScaleDenominator\": makeObjectPropertySetter(readDecimal),\n  \"TileWidth\": makeObjectPropertySetter(readPositiveInteger),\n  \"TileHeight\": makeObjectPropertySetter(readPositiveInteger),\n  \"MatrixWidth\": makeObjectPropertySetter(readPositiveInteger),\n  \"MatrixHeight\": makeObjectPropertySetter(readPositiveInteger)\n}, makeStructureNS(OWS_NAMESPACE_URIS, {\n  \"Identifier\": makeObjectPropertySetter(readString)\n}));\nfunction readContents(node2, objectStack) {\n  return pushParseAndPop({}, CONTENTS_PARSERS, node2, objectStack);\n}\nfunction readLayer(node2, objectStack) {\n  return pushParseAndPop({}, LAYER_PARSERS, node2, objectStack);\n}\nfunction readTileMatrixSet(node2, objectStack) {\n  return pushParseAndPop({}, TMS_PARSERS, node2, objectStack);\n}\nfunction readStyle(node2, objectStack) {\n  var style2 = pushParseAndPop({}, STYLE_PARSERS, node2, objectStack);\n  if (!style2) {\n    return void 0;\n  }\n  var isDefault = node2.getAttribute(\"isDefault\") === \"true\";\n  style2[\"isDefault\"] = isDefault;\n  return style2;\n}\nfunction readTileMatrixSetLink(node2, objectStack) {\n  return pushParseAndPop({}, TMS_LINKS_PARSERS, node2, objectStack);\n}\nfunction readDimensions(node2, objectStack) {\n  return pushParseAndPop({}, DIMENSION_PARSERS, node2, objectStack);\n}\nfunction readResourceUrl(node2, objectStack) {\n  var format2 = node2.getAttribute(\"format\");\n  var template = node2.getAttribute(\"template\");\n  var resourceType = node2.getAttribute(\"resourceType\");\n  var resource = {};\n  if (format2) {\n    resource[\"format\"] = format2;\n  }\n  if (template) {\n    resource[\"template\"] = template;\n  }\n  if (resourceType) {\n    resource[\"resourceType\"] = resourceType;\n  }\n  return resource;\n}\nfunction readBoundingBox(node2, objectStack) {\n  var coordinates2 = pushParseAndPop([], WGS84_BBOX_READERS, node2, objectStack);\n  if (coordinates2.length != 2) {\n    return void 0;\n  }\n  return boundingExtent(coordinates2);\n}\nfunction readLegendUrl(node2, objectStack) {\n  var legend = {};\n  legend[\"format\"] = node2.getAttribute(\"format\");\n  legend[\"href\"] = readHref(node2);\n  return legend;\n}\nfunction readCoordinates(node2, objectStack) {\n  var coordinates2 = readString(node2).split(/\\s+/);\n  if (!coordinates2 || coordinates2.length != 2) {\n    return void 0;\n  }\n  var x2 = +coordinates2[0];\n  var y2 = +coordinates2[1];\n  if (isNaN(x2) || isNaN(y2)) {\n    return void 0;\n  }\n  return [x2, y2];\n}\nfunction readTileMatrix(node2, objectStack) {\n  return pushParseAndPop({}, TM_PARSERS, node2, objectStack);\n}\nfunction readTileMatrixLimitsList(node2, objectStack) {\n  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node2, objectStack);\n}\nfunction readTileMatrixLimits(node2, objectStack) {\n  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node2, objectStack);\n}\nvar WMTSCapabilities$1 = WMTSCapabilities;\nvar format = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  EsriJSON: EsriJSON$1,\n  GeoJSON: GeoJSON$1,\n  GML: GML$1,\n  GPX: GPX$1,\n  IGC: IGC$1,\n  IIIFInfo: IIIFInfo$1,\n  KML: KML$1,\n  MVT: MVT$1,\n  OWS: OWS$1,\n  Polyline: Polyline$1,\n  TopoJSON: TopoJSON$1,\n  WFS: WFS$1,\n  WKB: WKB$1,\n  WKT: WKT$1,\n  WMSCapabilities: WMSCapabilities$1,\n  WMSGetFeatureInfo: WMSGetFeatureInfo$1,\n  WMTSCapabilities: WMTSCapabilities$1\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction install(app) {\n  if (install.installed) {\n    console.error(\"OPENLAYERS MAP ALREADY INSTALLED\");\n    return;\n  }\n  install.installed = true;\n  app.use(Map$1);\n  app.use(Layers);\n  app.use(Sources);\n  app.use(MapControls);\n  app.use(Geometries);\n  app.use(Styles);\n  app.use(Interactions);\n  app.use(Animations);\n  app.provide(\"ol-feature\", feature);\n  app.provide(\"ol-geom\", geom);\n  app.provide(\"ol-animations\", animations);\n  app.provide(\"ol-format\", format);\n  app.provide(\"ol-loadingstrategy\", loadingstrategy);\n  app.provide(\"ol-selectconditions\", selectconditions);\n  app.provide(\"ol-extent\", extent);\n}\n/*!\n * html2canvas 1.4.1 <https://html2canvas.hertzen.com>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics = function(d2, b2) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p5 in b3)\n      if (Object.prototype.hasOwnProperty.call(b3, p5))\n        d3[p5] = b3[p5];\n  };\n  return extendStatics(d2, b2);\n};\nfunction __extends(d2, b2) {\n  if (typeof b2 !== \"function\" && b2 !== null)\n    throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n  extendStatics(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign = function() {\n  __assign = Object.assign || function __assign2(t3) {\n    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {\n      s2 = arguments[i2];\n      for (var p5 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p5))\n          t3[p5] = s2[p5];\n    }\n    return t3;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __awaiter(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve2) {\n      resolve2(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve2, reject2) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e2) {\n        reject2(e2);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e2) {\n        reject2(e2);\n      }\n    }\n    function step(result) {\n      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _2 = { label: 0, sent: function() {\n    if (t3[0] & 1)\n      throw t3[1];\n    return t3[1];\n  }, trys: [], ops: [] }, f2, y2, t3, g2;\n  return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n    return this;\n  }), g2;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f2)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_2)\n      try {\n        if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t3 = y2[\"return\"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)\n          return t3;\n        if (y2 = 0, t3)\n          op = [op[0] & 2, t3.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t3 = op;\n            break;\n          case 4:\n            _2.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _2.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _2.ops.pop();\n            _2.trys.pop();\n            continue;\n          default:\n            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _2 = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {\n              _2.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _2.label < t3[1]) {\n              _2.label = t3[1];\n              t3 = op;\n              break;\n            }\n            if (t3 && _2.label < t3[2]) {\n              _2.label = t3[2];\n              _2.ops.push(op);\n              break;\n            }\n            if (t3[2])\n              _2.ops.pop();\n            _2.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _2);\n      } catch (e2) {\n        op = [6, e2];\n        y2 = 0;\n      } finally {\n        f2 = t3 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\nfunction __spreadArray(to, from, pack2) {\n  if (pack2 || arguments.length === 2)\n    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {\n      if (ar || !(i2 in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i2);\n        ar[i2] = from[i2];\n      }\n    }\n  return to.concat(ar || from);\n}\nvar Bounds = function() {\n  function Bounds2(left, top, width, height) {\n    this.left = left;\n    this.top = top;\n    this.width = width;\n    this.height = height;\n  }\n  Bounds2.prototype.add = function(x2, y2, w2, h2) {\n    return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);\n  };\n  Bounds2.fromClientRect = function(context, clientRect) {\n    return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);\n  };\n  Bounds2.fromDOMRectList = function(context, domRectList) {\n    var domRect = Array.from(domRectList).find(function(rect) {\n      return rect.width !== 0;\n    });\n    return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;\n  };\n  Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);\n  return Bounds2;\n}();\nvar parseBounds = function(context, node2) {\n  return Bounds.fromClientRect(context, node2.getBoundingClientRect());\n};\nvar parseDocumentSize = function(document2) {\n  var body = document2.body;\n  var documentElement = document2.documentElement;\n  if (!body || !documentElement) {\n    throw new Error(\"Unable to get document size\");\n  }\n  var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));\n  var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));\n  return new Bounds(0, 0, width, height);\n};\nvar toCodePoints$1 = function(str) {\n  var codePoints = [];\n  var i2 = 0;\n  var length = str.length;\n  while (i2 < length) {\n    var value = str.charCodeAt(i2++);\n    if (value >= 55296 && value <= 56319 && i2 < length) {\n      var extra = str.charCodeAt(i2++);\n      if ((extra & 64512) === 56320) {\n        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n      } else {\n        codePoints.push(value);\n        i2--;\n      }\n    } else {\n      codePoints.push(value);\n    }\n  }\n  return codePoints;\n};\nvar fromCodePoint$1 = function() {\n  var codePoints = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n  if (String.fromCodePoint) {\n    return String.fromCodePoint.apply(String, codePoints);\n  }\n  var length = codePoints.length;\n  if (!length) {\n    return \"\";\n  }\n  var codeUnits = [];\n  var index2 = -1;\n  var result = \"\";\n  while (++index2 < length) {\n    var codePoint = codePoints[index2];\n    if (codePoint <= 65535) {\n      codeUnits.push(codePoint);\n    } else {\n      codePoint -= 65536;\n      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);\n    }\n    if (index2 + 1 === length || codeUnits.length > 16384) {\n      result += String.fromCharCode.apply(String, codeUnits);\n      codeUnits.length = 0;\n    }\n  }\n  return result;\n};\nvar chars$2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup$2 = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$2 = 0; i$2 < chars$2.length; i$2++) {\n  lookup$2[chars$2.charCodeAt(i$2)] = i$2;\n}\nvar chars$1$1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup$1$1 = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {\n  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;\n}\nvar decode$1 = function(base642) {\n  var bufferLength = base642.length * 0.75, len = base642.length, i2, p5 = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base642[base642.length - 1] === \"=\") {\n    bufferLength--;\n    if (base642[base642.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  var buffer2 = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\" && typeof Uint8Array.prototype.slice !== \"undefined\" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);\n  var bytes = Array.isArray(buffer2) ? buffer2 : new Uint8Array(buffer2);\n  for (i2 = 0; i2 < len; i2 += 4) {\n    encoded1 = lookup$1$1[base642.charCodeAt(i2)];\n    encoded2 = lookup$1$1[base642.charCodeAt(i2 + 1)];\n    encoded3 = lookup$1$1[base642.charCodeAt(i2 + 2)];\n    encoded4 = lookup$1$1[base642.charCodeAt(i2 + 3)];\n    bytes[p5++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return buffer2;\n};\nvar polyUint16Array$1 = function(buffer2) {\n  var length = buffer2.length;\n  var bytes = [];\n  for (var i2 = 0; i2 < length; i2 += 2) {\n    bytes.push(buffer2[i2 + 1] << 8 | buffer2[i2]);\n  }\n  return bytes;\n};\nvar polyUint32Array$1 = function(buffer2) {\n  var length = buffer2.length;\n  var bytes = [];\n  for (var i2 = 0; i2 < length; i2 += 4) {\n    bytes.push(buffer2[i2 + 3] << 24 | buffer2[i2 + 2] << 16 | buffer2[i2 + 1] << 8 | buffer2[i2]);\n  }\n  return bytes;\n};\nvar UTRIE2_SHIFT_2$1 = 5;\nvar UTRIE2_SHIFT_1$1 = 6 + 5;\nvar UTRIE2_INDEX_SHIFT$1 = 2;\nvar UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;\nvar UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;\nvar UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;\nvar UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;\nvar UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;\nvar UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;\nvar UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;\nvar UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;\nvar UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;\nvar UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;\nvar UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;\nvar UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;\nvar slice16$1 = function(view, start2, end) {\n  if (view.slice) {\n    return view.slice(start2, end);\n  }\n  return new Uint16Array(Array.prototype.slice.call(view, start2, end));\n};\nvar slice32$1 = function(view, start2, end) {\n  if (view.slice) {\n    return view.slice(start2, end);\n  }\n  return new Uint32Array(Array.prototype.slice.call(view, start2, end));\n};\nvar createTrieFromBase64$1 = function(base642, _byteLength) {\n  var buffer2 = decode$1(base642);\n  var view32 = Array.isArray(buffer2) ? polyUint32Array$1(buffer2) : new Uint32Array(buffer2);\n  var view16 = Array.isArray(buffer2) ? polyUint16Array$1(buffer2) : new Uint16Array(buffer2);\n  var headerLength = 24;\n  var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);\n  var data2 = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));\n  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data2);\n};\nvar Trie$1 = function() {\n  function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data2) {\n    this.initialValue = initialValue;\n    this.errorValue = errorValue;\n    this.highStart = highStart;\n    this.highValueIndex = highValueIndex;\n    this.index = index2;\n    this.data = data2;\n  }\n  Trie2.prototype.get = function(codePoint) {\n    var ix;\n    if (codePoint >= 0) {\n      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {\n        ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];\n        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);\n        return this.data[ix];\n      }\n      if (codePoint <= 65535) {\n        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];\n        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);\n        return this.data[ix];\n      }\n      if (codePoint < this.highStart) {\n        ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);\n        ix = this.index[ix];\n        ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;\n        ix = this.index[ix];\n        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);\n        return this.data[ix];\n      }\n      if (codePoint <= 1114111) {\n        return this.data[this.highValueIndex];\n      }\n    }\n    return this.errorValue;\n  };\n  return Trie2;\n}();\nvar chars$3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup$3 = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$3 = 0; i$3 < chars$3.length; i$3++) {\n  lookup$3[chars$3.charCodeAt(i$3)] = i$3;\n}\nvar base64$1 = \"KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==\";\nvar LETTER_NUMBER_MODIFIER = 50;\nvar BK = 1;\nvar CR$1 = 2;\nvar LF$1 = 3;\nvar CM = 4;\nvar NL = 5;\nvar WJ = 7;\nvar ZW = 8;\nvar GL = 9;\nvar SP = 10;\nvar ZWJ$1 = 11;\nvar B2 = 12;\nvar BA = 13;\nvar BB = 14;\nvar HY = 15;\nvar CB = 16;\nvar CL = 17;\nvar CP = 18;\nvar EX = 19;\nvar IN = 20;\nvar NS = 21;\nvar OP = 22;\nvar QU = 23;\nvar IS = 24;\nvar NU = 25;\nvar PO = 26;\nvar PR = 27;\nvar SY = 28;\nvar AI = 29;\nvar AL = 30;\nvar CJ = 31;\nvar EB = 32;\nvar EM = 33;\nvar H2 = 34;\nvar H3 = 35;\nvar HL = 36;\nvar ID = 37;\nvar JL = 38;\nvar JV = 39;\nvar JT = 40;\nvar RI$1 = 41;\nvar SA = 42;\nvar XX = 43;\nvar ea_OP = [9001, 65288];\nvar BREAK_MANDATORY = \"!\";\nvar BREAK_NOT_ALLOWED$1 = \"\\xD7\";\nvar BREAK_ALLOWED$1 = \"\\xF7\";\nvar UnicodeTrie$1 = createTrieFromBase64$1(base64$1);\nvar ALPHABETICS = [AL, HL];\nvar HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];\nvar SPACE$1 = [SP, ZW];\nvar PREFIX_POSTFIX = [PR, PO];\nvar LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);\nvar KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];\nvar HYPHEN = [HY, BA];\nvar codePointsToCharacterClasses = function(codePoints, lineBreak2) {\n  if (lineBreak2 === void 0) {\n    lineBreak2 = \"strict\";\n  }\n  var types = [];\n  var indices = [];\n  var categories = [];\n  codePoints.forEach(function(codePoint, index2) {\n    var classType = UnicodeTrie$1.get(codePoint);\n    if (classType > LETTER_NUMBER_MODIFIER) {\n      categories.push(true);\n      classType -= LETTER_NUMBER_MODIFIER;\n    } else {\n      categories.push(false);\n    }\n    if ([\"normal\", \"auto\", \"loose\"].indexOf(lineBreak2) !== -1) {\n      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {\n        indices.push(index2);\n        return types.push(CB);\n      }\n    }\n    if (classType === CM || classType === ZWJ$1) {\n      if (index2 === 0) {\n        indices.push(index2);\n        return types.push(AL);\n      }\n      var prev = types[index2 - 1];\n      if (LINE_BREAKS.indexOf(prev) === -1) {\n        indices.push(indices[index2 - 1]);\n        return types.push(prev);\n      }\n      indices.push(index2);\n      return types.push(AL);\n    }\n    indices.push(index2);\n    if (classType === CJ) {\n      return types.push(lineBreak2 === \"strict\" ? NS : ID);\n    }\n    if (classType === SA) {\n      return types.push(AL);\n    }\n    if (classType === AI) {\n      return types.push(AL);\n    }\n    if (classType === XX) {\n      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {\n        return types.push(ID);\n      } else {\n        return types.push(AL);\n      }\n    }\n    types.push(classType);\n  });\n  return [indices, types, categories];\n};\nvar isAdjacentWithSpaceIgnored = function(a2, b2, currentIndex, classTypes) {\n  var current = classTypes[currentIndex];\n  if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {\n    var i2 = currentIndex;\n    while (i2 <= classTypes.length) {\n      i2++;\n      var next = classTypes[i2];\n      if (next === b2) {\n        return true;\n      }\n      if (next !== SP) {\n        break;\n      }\n    }\n  }\n  if (current === SP) {\n    var i2 = currentIndex;\n    while (i2 > 0) {\n      i2--;\n      var prev = classTypes[i2];\n      if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {\n        var n2 = currentIndex;\n        while (n2 <= classTypes.length) {\n          n2++;\n          var next = classTypes[n2];\n          if (next === b2) {\n            return true;\n          }\n          if (next !== SP) {\n            break;\n          }\n        }\n      }\n      if (prev !== SP) {\n        break;\n      }\n    }\n  }\n  return false;\n};\nvar previousNonSpaceClassType = function(currentIndex, classTypes) {\n  var i2 = currentIndex;\n  while (i2 >= 0) {\n    var type = classTypes[i2];\n    if (type === SP) {\n      i2--;\n    } else {\n      return type;\n    }\n  }\n  return 0;\n};\nvar _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {\n  if (indicies[index2] === 0) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  var currentIndex = index2 - 1;\n  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  var beforeIndex = currentIndex - 1;\n  var afterIndex = currentIndex + 1;\n  var current = classTypes[currentIndex];\n  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;\n  var next = classTypes[afterIndex];\n  if (current === CR$1 && next === LF$1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (HARD_LINE_BREAKS.indexOf(current) !== -1) {\n    return BREAK_MANDATORY;\n  }\n  if (HARD_LINE_BREAKS.indexOf(next) !== -1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (SPACE$1.indexOf(next) !== -1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {\n    return BREAK_ALLOWED$1;\n  }\n  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (current === WJ || next === WJ) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (current === GL) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (current === SP) {\n    return BREAK_ALLOWED$1;\n  }\n  if (current === QU || next === QU) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (next === CB || current === CB) {\n    return BREAK_ALLOWED$1;\n  }\n  if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (before === HL && HYPHEN.indexOf(current) !== -1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (current === SY && next === HL) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (next === IN) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if ([PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || [OP, HY].indexOf(current) !== -1 && next === NU || current === NU && [NU, SY, IS].indexOf(next) !== -1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {\n    var prevIndex = currentIndex;\n    while (prevIndex >= 0) {\n      var type = classTypes[prevIndex];\n      if (type === NU) {\n        return BREAK_NOT_ALLOWED$1;\n      } else if ([SY, IS].indexOf(type) !== -1) {\n        prevIndex--;\n      } else {\n        break;\n      }\n    }\n  }\n  if ([PR, PO].indexOf(next) !== -1) {\n    var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;\n    while (prevIndex >= 0) {\n      var type = classTypes[prevIndex];\n      if (type === NU) {\n        return BREAK_NOT_ALLOWED$1;\n      } else if ([SY, IS].indexOf(type) !== -1) {\n        prevIndex--;\n      } else {\n        break;\n      }\n    }\n  }\n  if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (current === IS && ALPHABETICS.indexOf(next) !== -1) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  if (current === RI$1 && next === RI$1) {\n    var i2 = indicies[currentIndex];\n    var count = 1;\n    while (i2 > 0) {\n      i2--;\n      if (classTypes[i2] === RI$1) {\n        count++;\n      } else {\n        break;\n      }\n    }\n    if (count % 2 !== 0) {\n      return BREAK_NOT_ALLOWED$1;\n    }\n  }\n  if (current === EB && next === EM) {\n    return BREAK_NOT_ALLOWED$1;\n  }\n  return BREAK_ALLOWED$1;\n};\nvar cssFormattedClasses = function(codePoints, options) {\n  if (!options) {\n    options = { lineBreak: \"normal\", wordBreak: \"normal\" };\n  }\n  var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];\n  if (options.wordBreak === \"break-all\" || options.wordBreak === \"break-word\") {\n    classTypes = classTypes.map(function(type) {\n      return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;\n    });\n  }\n  var forbiddenBreakpoints = options.wordBreak === \"keep-all\" ? isLetterNumber.map(function(letterNumber, i2) {\n    return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;\n  }) : void 0;\n  return [indicies, classTypes, forbiddenBreakpoints];\n};\nvar Break = function() {\n  function Break2(codePoints, lineBreak2, start2, end) {\n    this.codePoints = codePoints;\n    this.required = lineBreak2 === BREAK_MANDATORY;\n    this.start = start2;\n    this.end = end;\n  }\n  Break2.prototype.slice = function() {\n    return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));\n  };\n  return Break2;\n}();\nvar LineBreaker = function(str, options) {\n  var codePoints = toCodePoints$1(str);\n  var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];\n  var length = codePoints.length;\n  var lastEnd = 0;\n  var nextIndex = 0;\n  return {\n    next: function() {\n      if (nextIndex >= length) {\n        return { done: true, value: null };\n      }\n      var lineBreak2 = BREAK_NOT_ALLOWED$1;\n      while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {\n      }\n      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {\n        var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);\n        lastEnd = nextIndex;\n        return { value, done: false };\n      }\n      return { done: true, value: null };\n    }\n  };\n};\nvar FLAG_UNRESTRICTED = 1 << 0;\nvar FLAG_ID = 1 << 1;\nvar FLAG_INTEGER = 1 << 2;\nvar FLAG_NUMBER = 1 << 3;\nvar LINE_FEED = 10;\nvar SOLIDUS = 47;\nvar REVERSE_SOLIDUS = 92;\nvar CHARACTER_TABULATION = 9;\nvar SPACE = 32;\nvar QUOTATION_MARK = 34;\nvar EQUALS_SIGN = 61;\nvar NUMBER_SIGN = 35;\nvar DOLLAR_SIGN = 36;\nvar PERCENTAGE_SIGN = 37;\nvar APOSTROPHE = 39;\nvar LEFT_PARENTHESIS = 40;\nvar RIGHT_PARENTHESIS = 41;\nvar LOW_LINE = 95;\nvar HYPHEN_MINUS = 45;\nvar EXCLAMATION_MARK = 33;\nvar LESS_THAN_SIGN = 60;\nvar GREATER_THAN_SIGN = 62;\nvar COMMERCIAL_AT = 64;\nvar LEFT_SQUARE_BRACKET = 91;\nvar RIGHT_SQUARE_BRACKET = 93;\nvar CIRCUMFLEX_ACCENT = 61;\nvar LEFT_CURLY_BRACKET = 123;\nvar QUESTION_MARK = 63;\nvar RIGHT_CURLY_BRACKET = 125;\nvar VERTICAL_LINE = 124;\nvar TILDE = 126;\nvar CONTROL = 128;\nvar REPLACEMENT_CHARACTER = 65533;\nvar ASTERISK = 42;\nvar PLUS_SIGN = 43;\nvar COMMA = 44;\nvar COLON = 58;\nvar SEMICOLON = 59;\nvar FULL_STOP = 46;\nvar NULL = 0;\nvar BACKSPACE = 8;\nvar LINE_TABULATION = 11;\nvar SHIFT_OUT = 14;\nvar INFORMATION_SEPARATOR_ONE = 31;\nvar DELETE = 127;\nvar EOF = -1;\nvar ZERO = 48;\nvar a$1 = 97;\nvar e$1 = 101;\nvar f$1 = 102;\nvar u$1 = 117;\nvar z = 122;\nvar A = 65;\nvar E = 69;\nvar F = 70;\nvar U = 85;\nvar Z = 90;\nvar isDigit = function(codePoint) {\n  return codePoint >= ZERO && codePoint <= 57;\n};\nvar isSurrogateCodePoint = function(codePoint) {\n  return codePoint >= 55296 && codePoint <= 57343;\n};\nvar isHex = function(codePoint) {\n  return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a$1 && codePoint <= f$1;\n};\nvar isLowerCaseLetter = function(codePoint) {\n  return codePoint >= a$1 && codePoint <= z;\n};\nvar isUpperCaseLetter = function(codePoint) {\n  return codePoint >= A && codePoint <= Z;\n};\nvar isLetter = function(codePoint) {\n  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);\n};\nvar isNonASCIICodePoint = function(codePoint) {\n  return codePoint >= CONTROL;\n};\nvar isWhiteSpace = function(codePoint) {\n  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;\n};\nvar isNameStartCodePoint = function(codePoint) {\n  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;\n};\nvar isNameCodePoint = function(codePoint) {\n  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;\n};\nvar isNonPrintableCodePoint = function(codePoint) {\n  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;\n};\nvar isValidEscape = function(c1, c2) {\n  if (c1 !== REVERSE_SOLIDUS) {\n    return false;\n  }\n  return c2 !== LINE_FEED;\n};\nvar isIdentifierStart = function(c1, c2, c3) {\n  if (c1 === HYPHEN_MINUS) {\n    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);\n  } else if (isNameStartCodePoint(c1)) {\n    return true;\n  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {\n    return true;\n  }\n  return false;\n};\nvar isNumberStart = function(c1, c2, c3) {\n  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {\n    if (isDigit(c2)) {\n      return true;\n    }\n    return c2 === FULL_STOP && isDigit(c3);\n  }\n  if (c1 === FULL_STOP) {\n    return isDigit(c2);\n  }\n  return isDigit(c1);\n};\nvar stringToNumber = function(codePoints) {\n  var c2 = 0;\n  var sign2 = 1;\n  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {\n    if (codePoints[c2] === HYPHEN_MINUS) {\n      sign2 = -1;\n    }\n    c2++;\n  }\n  var integers = [];\n  while (isDigit(codePoints[c2])) {\n    integers.push(codePoints[c2++]);\n  }\n  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;\n  if (codePoints[c2] === FULL_STOP) {\n    c2++;\n  }\n  var fraction = [];\n  while (isDigit(codePoints[c2])) {\n    fraction.push(codePoints[c2++]);\n  }\n  var fracd = fraction.length;\n  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;\n  if (codePoints[c2] === E || codePoints[c2] === e$1) {\n    c2++;\n  }\n  var expsign = 1;\n  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {\n    if (codePoints[c2] === HYPHEN_MINUS) {\n      expsign = -1;\n    }\n    c2++;\n  }\n  var exponent = [];\n  while (isDigit(codePoints[c2])) {\n    exponent.push(codePoints[c2++]);\n  }\n  var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;\n  return sign2 * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);\n};\nvar LEFT_PARENTHESIS_TOKEN = {\n  type: 2\n};\nvar RIGHT_PARENTHESIS_TOKEN = {\n  type: 3\n};\nvar COMMA_TOKEN = { type: 4 };\nvar SUFFIX_MATCH_TOKEN = { type: 13 };\nvar PREFIX_MATCH_TOKEN = { type: 8 };\nvar COLUMN_TOKEN = { type: 21 };\nvar DASH_MATCH_TOKEN = { type: 9 };\nvar INCLUDE_MATCH_TOKEN = { type: 10 };\nvar LEFT_CURLY_BRACKET_TOKEN = {\n  type: 11\n};\nvar RIGHT_CURLY_BRACKET_TOKEN = {\n  type: 12\n};\nvar SUBSTRING_MATCH_TOKEN = { type: 14 };\nvar BAD_URL_TOKEN = { type: 23 };\nvar BAD_STRING_TOKEN = { type: 1 };\nvar CDO_TOKEN = { type: 25 };\nvar CDC_TOKEN = { type: 24 };\nvar COLON_TOKEN = { type: 26 };\nvar SEMICOLON_TOKEN = { type: 27 };\nvar LEFT_SQUARE_BRACKET_TOKEN = {\n  type: 28\n};\nvar RIGHT_SQUARE_BRACKET_TOKEN = {\n  type: 29\n};\nvar WHITESPACE_TOKEN = { type: 31 };\nvar EOF_TOKEN = { type: 32 };\nvar Tokenizer = function() {\n  function Tokenizer2() {\n    this._value = [];\n  }\n  Tokenizer2.prototype.write = function(chunk) {\n    this._value = this._value.concat(toCodePoints$1(chunk));\n  };\n  Tokenizer2.prototype.read = function() {\n    var tokens = [];\n    var token = this.consumeToken();\n    while (token !== EOF_TOKEN) {\n      tokens.push(token);\n      token = this.consumeToken();\n    }\n    return tokens;\n  };\n  Tokenizer2.prototype.consumeToken = function() {\n    var codePoint = this.consumeCodePoint();\n    switch (codePoint) {\n      case QUOTATION_MARK:\n        return this.consumeStringToken(QUOTATION_MARK);\n      case NUMBER_SIGN:\n        var c1 = this.peekCodePoint(0);\n        var c2 = this.peekCodePoint(1);\n        var c3 = this.peekCodePoint(2);\n        if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {\n          var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;\n          var value = this.consumeName();\n          return { type: 5, value, flags };\n        }\n        break;\n      case DOLLAR_SIGN:\n        if (this.peekCodePoint(0) === EQUALS_SIGN) {\n          this.consumeCodePoint();\n          return SUFFIX_MATCH_TOKEN;\n        }\n        break;\n      case APOSTROPHE:\n        return this.consumeStringToken(APOSTROPHE);\n      case LEFT_PARENTHESIS:\n        return LEFT_PARENTHESIS_TOKEN;\n      case RIGHT_PARENTHESIS:\n        return RIGHT_PARENTHESIS_TOKEN;\n      case ASTERISK:\n        if (this.peekCodePoint(0) === EQUALS_SIGN) {\n          this.consumeCodePoint();\n          return SUBSTRING_MATCH_TOKEN;\n        }\n        break;\n      case PLUS_SIGN:\n        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {\n          this.reconsumeCodePoint(codePoint);\n          return this.consumeNumericToken();\n        }\n        break;\n      case COMMA:\n        return COMMA_TOKEN;\n      case HYPHEN_MINUS:\n        var e1 = codePoint;\n        var e2 = this.peekCodePoint(0);\n        var e3 = this.peekCodePoint(1);\n        if (isNumberStart(e1, e2, e3)) {\n          this.reconsumeCodePoint(codePoint);\n          return this.consumeNumericToken();\n        }\n        if (isIdentifierStart(e1, e2, e3)) {\n          this.reconsumeCodePoint(codePoint);\n          return this.consumeIdentLikeToken();\n        }\n        if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {\n          this.consumeCodePoint();\n          this.consumeCodePoint();\n          return CDC_TOKEN;\n        }\n        break;\n      case FULL_STOP:\n        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {\n          this.reconsumeCodePoint(codePoint);\n          return this.consumeNumericToken();\n        }\n        break;\n      case SOLIDUS:\n        if (this.peekCodePoint(0) === ASTERISK) {\n          this.consumeCodePoint();\n          while (true) {\n            var c4 = this.consumeCodePoint();\n            if (c4 === ASTERISK) {\n              c4 = this.consumeCodePoint();\n              if (c4 === SOLIDUS) {\n                return this.consumeToken();\n              }\n            }\n            if (c4 === EOF) {\n              return this.consumeToken();\n            }\n          }\n        }\n        break;\n      case COLON:\n        return COLON_TOKEN;\n      case SEMICOLON:\n        return SEMICOLON_TOKEN;\n      case LESS_THAN_SIGN:\n        if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {\n          this.consumeCodePoint();\n          this.consumeCodePoint();\n          return CDO_TOKEN;\n        }\n        break;\n      case COMMERCIAL_AT:\n        var a1 = this.peekCodePoint(0);\n        var a2 = this.peekCodePoint(1);\n        var a3 = this.peekCodePoint(2);\n        if (isIdentifierStart(a1, a2, a3)) {\n          var value = this.consumeName();\n          return { type: 7, value };\n        }\n        break;\n      case LEFT_SQUARE_BRACKET:\n        return LEFT_SQUARE_BRACKET_TOKEN;\n      case REVERSE_SOLIDUS:\n        if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n          this.reconsumeCodePoint(codePoint);\n          return this.consumeIdentLikeToken();\n        }\n        break;\n      case RIGHT_SQUARE_BRACKET:\n        return RIGHT_SQUARE_BRACKET_TOKEN;\n      case CIRCUMFLEX_ACCENT:\n        if (this.peekCodePoint(0) === EQUALS_SIGN) {\n          this.consumeCodePoint();\n          return PREFIX_MATCH_TOKEN;\n        }\n        break;\n      case LEFT_CURLY_BRACKET:\n        return LEFT_CURLY_BRACKET_TOKEN;\n      case RIGHT_CURLY_BRACKET:\n        return RIGHT_CURLY_BRACKET_TOKEN;\n      case u$1:\n      case U:\n        var u1 = this.peekCodePoint(0);\n        var u2 = this.peekCodePoint(1);\n        if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {\n          this.consumeCodePoint();\n          this.consumeUnicodeRangeToken();\n        }\n        this.reconsumeCodePoint(codePoint);\n        return this.consumeIdentLikeToken();\n      case VERTICAL_LINE:\n        if (this.peekCodePoint(0) === EQUALS_SIGN) {\n          this.consumeCodePoint();\n          return DASH_MATCH_TOKEN;\n        }\n        if (this.peekCodePoint(0) === VERTICAL_LINE) {\n          this.consumeCodePoint();\n          return COLUMN_TOKEN;\n        }\n        break;\n      case TILDE:\n        if (this.peekCodePoint(0) === EQUALS_SIGN) {\n          this.consumeCodePoint();\n          return INCLUDE_MATCH_TOKEN;\n        }\n        break;\n      case EOF:\n        return EOF_TOKEN;\n    }\n    if (isWhiteSpace(codePoint)) {\n      this.consumeWhiteSpace();\n      return WHITESPACE_TOKEN;\n    }\n    if (isDigit(codePoint)) {\n      this.reconsumeCodePoint(codePoint);\n      return this.consumeNumericToken();\n    }\n    if (isNameStartCodePoint(codePoint)) {\n      this.reconsumeCodePoint(codePoint);\n      return this.consumeIdentLikeToken();\n    }\n    return { type: 6, value: fromCodePoint$1(codePoint) };\n  };\n  Tokenizer2.prototype.consumeCodePoint = function() {\n    var value = this._value.shift();\n    return typeof value === \"undefined\" ? -1 : value;\n  };\n  Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {\n    this._value.unshift(codePoint);\n  };\n  Tokenizer2.prototype.peekCodePoint = function(delta) {\n    if (delta >= this._value.length) {\n      return -1;\n    }\n    return this._value[delta];\n  };\n  Tokenizer2.prototype.consumeUnicodeRangeToken = function() {\n    var digits = [];\n    var codePoint = this.consumeCodePoint();\n    while (isHex(codePoint) && digits.length < 6) {\n      digits.push(codePoint);\n      codePoint = this.consumeCodePoint();\n    }\n    var questionMarks = false;\n    while (codePoint === QUESTION_MARK && digits.length < 6) {\n      digits.push(codePoint);\n      codePoint = this.consumeCodePoint();\n      questionMarks = true;\n    }\n    if (questionMarks) {\n      var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {\n        return digit === QUESTION_MARK ? ZERO : digit;\n      })), 16);\n      var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {\n        return digit === QUESTION_MARK ? F : digit;\n      })), 16);\n      return { type: 30, start: start_1, end };\n    }\n    var start2 = parseInt(fromCodePoint$1.apply(void 0, digits), 16);\n    if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {\n      this.consumeCodePoint();\n      codePoint = this.consumeCodePoint();\n      var endDigits = [];\n      while (isHex(codePoint) && endDigits.length < 6) {\n        endDigits.push(codePoint);\n        codePoint = this.consumeCodePoint();\n      }\n      var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);\n      return { type: 30, start: start2, end };\n    } else {\n      return { type: 30, start: start2, end: start2 };\n    }\n  };\n  Tokenizer2.prototype.consumeIdentLikeToken = function() {\n    var value = this.consumeName();\n    if (value.toLowerCase() === \"url\" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {\n      this.consumeCodePoint();\n      return this.consumeUrlToken();\n    } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {\n      this.consumeCodePoint();\n      return { type: 19, value };\n    }\n    return { type: 20, value };\n  };\n  Tokenizer2.prototype.consumeUrlToken = function() {\n    var value = [];\n    this.consumeWhiteSpace();\n    if (this.peekCodePoint(0) === EOF) {\n      return { type: 22, value: \"\" };\n    }\n    var next = this.peekCodePoint(0);\n    if (next === APOSTROPHE || next === QUOTATION_MARK) {\n      var stringToken = this.consumeStringToken(this.consumeCodePoint());\n      if (stringToken.type === 0) {\n        this.consumeWhiteSpace();\n        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {\n          this.consumeCodePoint();\n          return { type: 22, value: stringToken.value };\n        }\n      }\n      this.consumeBadUrlRemnants();\n      return BAD_URL_TOKEN;\n    }\n    while (true) {\n      var codePoint = this.consumeCodePoint();\n      if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {\n        return { type: 22, value: fromCodePoint$1.apply(void 0, value) };\n      } else if (isWhiteSpace(codePoint)) {\n        this.consumeWhiteSpace();\n        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {\n          this.consumeCodePoint();\n          return { type: 22, value: fromCodePoint$1.apply(void 0, value) };\n        }\n        this.consumeBadUrlRemnants();\n        return BAD_URL_TOKEN;\n      } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {\n        this.consumeBadUrlRemnants();\n        return BAD_URL_TOKEN;\n      } else if (codePoint === REVERSE_SOLIDUS) {\n        if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n          value.push(this.consumeEscapedCodePoint());\n        } else {\n          this.consumeBadUrlRemnants();\n          return BAD_URL_TOKEN;\n        }\n      } else {\n        value.push(codePoint);\n      }\n    }\n  };\n  Tokenizer2.prototype.consumeWhiteSpace = function() {\n    while (isWhiteSpace(this.peekCodePoint(0))) {\n      this.consumeCodePoint();\n    }\n  };\n  Tokenizer2.prototype.consumeBadUrlRemnants = function() {\n    while (true) {\n      var codePoint = this.consumeCodePoint();\n      if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {\n        return;\n      }\n      if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n        this.consumeEscapedCodePoint();\n      }\n    }\n  };\n  Tokenizer2.prototype.consumeStringSlice = function(count) {\n    var SLICE_STACK_SIZE = 5e4;\n    var value = \"\";\n    while (count > 0) {\n      var amount = Math.min(SLICE_STACK_SIZE, count);\n      value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));\n      count -= amount;\n    }\n    this._value.shift();\n    return value;\n  };\n  Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {\n    var value = \"\";\n    var i2 = 0;\n    do {\n      var codePoint = this._value[i2];\n      if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {\n        value += this.consumeStringSlice(i2);\n        return { type: 0, value };\n      }\n      if (codePoint === LINE_FEED) {\n        this._value.splice(0, i2);\n        return BAD_STRING_TOKEN;\n      }\n      if (codePoint === REVERSE_SOLIDUS) {\n        var next = this._value[i2 + 1];\n        if (next !== EOF && next !== void 0) {\n          if (next === LINE_FEED) {\n            value += this.consumeStringSlice(i2);\n            i2 = -1;\n            this._value.shift();\n          } else if (isValidEscape(codePoint, next)) {\n            value += this.consumeStringSlice(i2);\n            value += fromCodePoint$1(this.consumeEscapedCodePoint());\n            i2 = -1;\n          }\n        }\n      }\n      i2++;\n    } while (true);\n  };\n  Tokenizer2.prototype.consumeNumber = function() {\n    var repr = [];\n    var type = FLAG_INTEGER;\n    var c1 = this.peekCodePoint(0);\n    if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {\n      repr.push(this.consumeCodePoint());\n    }\n    while (isDigit(this.peekCodePoint(0))) {\n      repr.push(this.consumeCodePoint());\n    }\n    c1 = this.peekCodePoint(0);\n    var c2 = this.peekCodePoint(1);\n    if (c1 === FULL_STOP && isDigit(c2)) {\n      repr.push(this.consumeCodePoint(), this.consumeCodePoint());\n      type = FLAG_NUMBER;\n      while (isDigit(this.peekCodePoint(0))) {\n        repr.push(this.consumeCodePoint());\n      }\n    }\n    c1 = this.peekCodePoint(0);\n    c2 = this.peekCodePoint(1);\n    var c3 = this.peekCodePoint(2);\n    if ((c1 === E || c1 === e$1) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {\n      repr.push(this.consumeCodePoint(), this.consumeCodePoint());\n      type = FLAG_NUMBER;\n      while (isDigit(this.peekCodePoint(0))) {\n        repr.push(this.consumeCodePoint());\n      }\n    }\n    return [stringToNumber(repr), type];\n  };\n  Tokenizer2.prototype.consumeNumericToken = function() {\n    var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];\n    var c1 = this.peekCodePoint(0);\n    var c2 = this.peekCodePoint(1);\n    var c3 = this.peekCodePoint(2);\n    if (isIdentifierStart(c1, c2, c3)) {\n      var unit = this.consumeName();\n      return { type: 15, number, flags, unit };\n    }\n    if (c1 === PERCENTAGE_SIGN) {\n      this.consumeCodePoint();\n      return { type: 16, number, flags };\n    }\n    return { type: 17, number, flags };\n  };\n  Tokenizer2.prototype.consumeEscapedCodePoint = function() {\n    var codePoint = this.consumeCodePoint();\n    if (isHex(codePoint)) {\n      var hex = fromCodePoint$1(codePoint);\n      while (isHex(this.peekCodePoint(0)) && hex.length < 6) {\n        hex += fromCodePoint$1(this.consumeCodePoint());\n      }\n      if (isWhiteSpace(this.peekCodePoint(0))) {\n        this.consumeCodePoint();\n      }\n      var hexCodePoint = parseInt(hex, 16);\n      if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {\n        return REPLACEMENT_CHARACTER;\n      }\n      return hexCodePoint;\n    }\n    if (codePoint === EOF) {\n      return REPLACEMENT_CHARACTER;\n    }\n    return codePoint;\n  };\n  Tokenizer2.prototype.consumeName = function() {\n    var result = \"\";\n    while (true) {\n      var codePoint = this.consumeCodePoint();\n      if (isNameCodePoint(codePoint)) {\n        result += fromCodePoint$1(codePoint);\n      } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n        result += fromCodePoint$1(this.consumeEscapedCodePoint());\n      } else {\n        this.reconsumeCodePoint(codePoint);\n        return result;\n      }\n    }\n  };\n  return Tokenizer2;\n}();\nvar Parser$1 = function() {\n  function Parser2(tokens) {\n    this._tokens = tokens;\n  }\n  Parser2.create = function(value) {\n    var tokenizer = new Tokenizer();\n    tokenizer.write(value);\n    return new Parser2(tokenizer.read());\n  };\n  Parser2.parseValue = function(value) {\n    return Parser2.create(value).parseComponentValue();\n  };\n  Parser2.parseValues = function(value) {\n    return Parser2.create(value).parseComponentValues();\n  };\n  Parser2.prototype.parseComponentValue = function() {\n    var token = this.consumeToken();\n    while (token.type === 31) {\n      token = this.consumeToken();\n    }\n    if (token.type === 32) {\n      throw new SyntaxError(\"Error parsing CSS component value, unexpected EOF\");\n    }\n    this.reconsumeToken(token);\n    var value = this.consumeComponentValue();\n    do {\n      token = this.consumeToken();\n    } while (token.type === 31);\n    if (token.type === 32) {\n      return value;\n    }\n    throw new SyntaxError(\"Error parsing CSS component value, multiple values found when expecting only one\");\n  };\n  Parser2.prototype.parseComponentValues = function() {\n    var values2 = [];\n    while (true) {\n      var value = this.consumeComponentValue();\n      if (value.type === 32) {\n        return values2;\n      }\n      values2.push(value);\n      values2.push();\n    }\n  };\n  Parser2.prototype.consumeComponentValue = function() {\n    var token = this.consumeToken();\n    switch (token.type) {\n      case 11:\n      case 28:\n      case 2:\n        return this.consumeSimpleBlock(token.type);\n      case 19:\n        return this.consumeFunction(token);\n    }\n    return token;\n  };\n  Parser2.prototype.consumeSimpleBlock = function(type) {\n    var block = { type, values: [] };\n    var token = this.consumeToken();\n    while (true) {\n      if (token.type === 32 || isEndingTokenFor(token, type)) {\n        return block;\n      }\n      this.reconsumeToken(token);\n      block.values.push(this.consumeComponentValue());\n      token = this.consumeToken();\n    }\n  };\n  Parser2.prototype.consumeFunction = function(functionToken) {\n    var cssFunction = {\n      name: functionToken.value,\n      values: [],\n      type: 18\n    };\n    while (true) {\n      var token = this.consumeToken();\n      if (token.type === 32 || token.type === 3) {\n        return cssFunction;\n      }\n      this.reconsumeToken(token);\n      cssFunction.values.push(this.consumeComponentValue());\n    }\n  };\n  Parser2.prototype.consumeToken = function() {\n    var token = this._tokens.shift();\n    return typeof token === \"undefined\" ? EOF_TOKEN : token;\n  };\n  Parser2.prototype.reconsumeToken = function(token) {\n    this._tokens.unshift(token);\n  };\n  return Parser2;\n}();\nvar isDimensionToken = function(token) {\n  return token.type === 15;\n};\nvar isNumberToken = function(token) {\n  return token.type === 17;\n};\nvar isIdentToken = function(token) {\n  return token.type === 20;\n};\nvar isStringToken = function(token) {\n  return token.type === 0;\n};\nvar isIdentWithValue = function(token, value) {\n  return isIdentToken(token) && token.value === value;\n};\nvar nonWhiteSpace = function(token) {\n  return token.type !== 31;\n};\nvar nonFunctionArgSeparator = function(token) {\n  return token.type !== 31 && token.type !== 4;\n};\nvar parseFunctionArgs = function(tokens) {\n  var args = [];\n  var arg = [];\n  tokens.forEach(function(token) {\n    if (token.type === 4) {\n      if (arg.length === 0) {\n        throw new Error(\"Error parsing function args, zero tokens for arg\");\n      }\n      args.push(arg);\n      arg = [];\n      return;\n    }\n    if (token.type !== 31) {\n      arg.push(token);\n    }\n  });\n  if (arg.length) {\n    args.push(arg);\n  }\n  return args;\n};\nvar isEndingTokenFor = function(token, type) {\n  if (type === 11 && token.type === 12) {\n    return true;\n  }\n  if (type === 28 && token.type === 29) {\n    return true;\n  }\n  return type === 2 && token.type === 3;\n};\nvar isLength = function(token) {\n  return token.type === 17 || token.type === 15;\n};\nvar isLengthPercentage = function(token) {\n  return token.type === 16 || isLength(token);\n};\nvar parseLengthPercentageTuple = function(tokens) {\n  return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];\n};\nvar ZERO_LENGTH = {\n  type: 17,\n  number: 0,\n  flags: FLAG_INTEGER\n};\nvar FIFTY_PERCENT = {\n  type: 16,\n  number: 50,\n  flags: FLAG_INTEGER\n};\nvar HUNDRED_PERCENT = {\n  type: 16,\n  number: 100,\n  flags: FLAG_INTEGER\n};\nvar getAbsoluteValueForTuple = function(tuple, width, height) {\n  var x2 = tuple[0], y2 = tuple[1];\n  return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y2 !== \"undefined\" ? y2 : x2, height)];\n};\nvar getAbsoluteValue = function(token, parent) {\n  if (token.type === 16) {\n    return token.number / 100 * parent;\n  }\n  if (isDimensionToken(token)) {\n    switch (token.unit) {\n      case \"rem\":\n      case \"em\":\n        return 16 * token.number;\n      case \"px\":\n      default:\n        return token.number;\n    }\n  }\n  return token.number;\n};\nvar DEG = \"deg\";\nvar GRAD = \"grad\";\nvar RAD = \"rad\";\nvar TURN = \"turn\";\nvar angle = {\n  name: \"angle\",\n  parse: function(_context, value) {\n    if (value.type === 15) {\n      switch (value.unit) {\n        case DEG:\n          return Math.PI * value.number / 180;\n        case GRAD:\n          return Math.PI / 200 * value.number;\n        case RAD:\n          return value.number;\n        case TURN:\n          return Math.PI * 2 * value.number;\n      }\n    }\n    throw new Error(\"Unsupported angle type\");\n  }\n};\nvar isAngle = function(value) {\n  if (value.type === 15) {\n    if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {\n      return true;\n    }\n  }\n  return false;\n};\nvar parseNamedSide = function(tokens) {\n  var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {\n    return ident.value;\n  }).join(\" \");\n  switch (sideOrCorner) {\n    case \"to bottom right\":\n    case \"to right bottom\":\n    case \"left top\":\n    case \"top left\":\n      return [ZERO_LENGTH, ZERO_LENGTH];\n    case \"to top\":\n    case \"bottom\":\n      return deg(0);\n    case \"to bottom left\":\n    case \"to left bottom\":\n    case \"right top\":\n    case \"top right\":\n      return [ZERO_LENGTH, HUNDRED_PERCENT];\n    case \"to right\":\n    case \"left\":\n      return deg(90);\n    case \"to top left\":\n    case \"to left top\":\n    case \"right bottom\":\n    case \"bottom right\":\n      return [HUNDRED_PERCENT, HUNDRED_PERCENT];\n    case \"to bottom\":\n    case \"top\":\n      return deg(180);\n    case \"to top right\":\n    case \"to right top\":\n    case \"left bottom\":\n    case \"bottom left\":\n      return [HUNDRED_PERCENT, ZERO_LENGTH];\n    case \"to left\":\n    case \"right\":\n      return deg(270);\n  }\n  return 0;\n};\nvar deg = function(deg2) {\n  return Math.PI * deg2 / 180;\n};\nvar color$1 = {\n  name: \"color\",\n  parse: function(context, value) {\n    if (value.type === 18) {\n      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];\n      if (typeof colorFunction === \"undefined\") {\n        throw new Error('Attempting to parse an unsupported color function \"' + value.name + '\"');\n      }\n      return colorFunction(context, value.values);\n    }\n    if (value.type === 5) {\n      if (value.value.length === 3) {\n        var r2 = value.value.substring(0, 1);\n        var g2 = value.value.substring(1, 2);\n        var b2 = value.value.substring(2, 3);\n        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);\n      }\n      if (value.value.length === 4) {\n        var r2 = value.value.substring(0, 1);\n        var g2 = value.value.substring(1, 2);\n        var b2 = value.value.substring(2, 3);\n        var a2 = value.value.substring(3, 4);\n        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a2 + a2, 16) / 255);\n      }\n      if (value.value.length === 6) {\n        var r2 = value.value.substring(0, 2);\n        var g2 = value.value.substring(2, 4);\n        var b2 = value.value.substring(4, 6);\n        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);\n      }\n      if (value.value.length === 8) {\n        var r2 = value.value.substring(0, 2);\n        var g2 = value.value.substring(2, 4);\n        var b2 = value.value.substring(4, 6);\n        var a2 = value.value.substring(6, 8);\n        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a2, 16) / 255);\n      }\n    }\n    if (value.type === 20) {\n      var namedColor = COLORS[value.value.toUpperCase()];\n      if (typeof namedColor !== \"undefined\") {\n        return namedColor;\n      }\n    }\n    return COLORS.TRANSPARENT;\n  }\n};\nvar isTransparent = function(color2) {\n  return (255 & color2) === 0;\n};\nvar asString = function(color2) {\n  var alpha = 255 & color2;\n  var blue = 255 & color2 >> 8;\n  var green = 255 & color2 >> 16;\n  var red = 255 & color2 >> 24;\n  return alpha < 255 ? \"rgba(\" + red + \",\" + green + \",\" + blue + \",\" + alpha / 255 + \")\" : \"rgb(\" + red + \",\" + green + \",\" + blue + \")\";\n};\nvar pack = function(r2, g2, b2, a2) {\n  return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a2 * 255) << 0) >>> 0;\n};\nvar getTokenColorValue = function(token, i2) {\n  if (token.type === 17) {\n    return token.number;\n  }\n  if (token.type === 16) {\n    var max2 = i2 === 3 ? 1 : 255;\n    return i2 === 3 ? token.number / 100 * max2 : Math.round(token.number / 100 * max2);\n  }\n  return 0;\n};\nvar rgb = function(_context, args) {\n  var tokens = args.filter(nonFunctionArgSeparator);\n  if (tokens.length === 3) {\n    var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g2 = _a2[1], b2 = _a2[2];\n    return pack(r2, g2, b2, 1);\n  }\n  if (tokens.length === 4) {\n    var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g2 = _b2[1], b2 = _b2[2], a2 = _b2[3];\n    return pack(r2, g2, b2, a2);\n  }\n  return 0;\n};\nfunction hue2rgb(t1, t22, hue) {\n  if (hue < 0) {\n    hue += 1;\n  }\n  if (hue >= 1) {\n    hue -= 1;\n  }\n  if (hue < 1 / 6) {\n    return (t22 - t1) * hue * 6 + t1;\n  } else if (hue < 1 / 2) {\n    return t22;\n  } else if (hue < 2 / 3) {\n    return (t22 - t1) * 6 * (2 / 3 - hue) + t1;\n  } else {\n    return t1;\n  }\n}\nvar hsl = function(context, args) {\n  var tokens = args.filter(nonFunctionArgSeparator);\n  var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];\n  var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);\n  var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;\n  var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;\n  var a2 = typeof alpha !== \"undefined\" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;\n  if (s2 === 0) {\n    return pack(l2 * 255, l2 * 255, l2 * 255, 1);\n  }\n  var t22 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;\n  var t1 = l2 * 2 - t22;\n  var r2 = hue2rgb(t1, t22, h2 + 1 / 3);\n  var g2 = hue2rgb(t1, t22, h2);\n  var b2 = hue2rgb(t1, t22, h2 - 1 / 3);\n  return pack(r2 * 255, g2 * 255, b2 * 255, a2);\n};\nvar SUPPORTED_COLOR_FUNCTIONS = {\n  hsl,\n  hsla: hsl,\n  rgb,\n  rgba: rgb\n};\nvar parseColor = function(context, value) {\n  return color$1.parse(context, Parser$1.create(value).parseComponentValue());\n};\nvar COLORS = {\n  ALICEBLUE: 4042850303,\n  ANTIQUEWHITE: 4209760255,\n  AQUA: 16777215,\n  AQUAMARINE: 2147472639,\n  AZURE: 4043309055,\n  BEIGE: 4126530815,\n  BISQUE: 4293182719,\n  BLACK: 255,\n  BLANCHEDALMOND: 4293643775,\n  BLUE: 65535,\n  BLUEVIOLET: 2318131967,\n  BROWN: 2771004159,\n  BURLYWOOD: 3736635391,\n  CADETBLUE: 1604231423,\n  CHARTREUSE: 2147418367,\n  CHOCOLATE: 3530104575,\n  CORAL: 4286533887,\n  CORNFLOWERBLUE: 1687547391,\n  CORNSILK: 4294499583,\n  CRIMSON: 3692313855,\n  CYAN: 16777215,\n  DARKBLUE: 35839,\n  DARKCYAN: 9145343,\n  DARKGOLDENROD: 3095837695,\n  DARKGRAY: 2846468607,\n  DARKGREEN: 6553855,\n  DARKGREY: 2846468607,\n  DARKKHAKI: 3182914559,\n  DARKMAGENTA: 2332068863,\n  DARKOLIVEGREEN: 1433087999,\n  DARKORANGE: 4287365375,\n  DARKORCHID: 2570243327,\n  DARKRED: 2332033279,\n  DARKSALMON: 3918953215,\n  DARKSEAGREEN: 2411499519,\n  DARKSLATEBLUE: 1211993087,\n  DARKSLATEGRAY: 793726975,\n  DARKSLATEGREY: 793726975,\n  DARKTURQUOISE: 13554175,\n  DARKVIOLET: 2483082239,\n  DEEPPINK: 4279538687,\n  DEEPSKYBLUE: 12582911,\n  DIMGRAY: 1768516095,\n  DIMGREY: 1768516095,\n  DODGERBLUE: 512819199,\n  FIREBRICK: 2988581631,\n  FLORALWHITE: 4294635775,\n  FORESTGREEN: 579543807,\n  FUCHSIA: 4278255615,\n  GAINSBORO: 3705462015,\n  GHOSTWHITE: 4177068031,\n  GOLD: 4292280575,\n  GOLDENROD: 3668254975,\n  GRAY: 2155905279,\n  GREEN: 8388863,\n  GREENYELLOW: 2919182335,\n  GREY: 2155905279,\n  HONEYDEW: 4043305215,\n  HOTPINK: 4285117695,\n  INDIANRED: 3445382399,\n  INDIGO: 1258324735,\n  IVORY: 4294963455,\n  KHAKI: 4041641215,\n  LAVENDER: 3873897215,\n  LAVENDERBLUSH: 4293981695,\n  LAWNGREEN: 2096890111,\n  LEMONCHIFFON: 4294626815,\n  LIGHTBLUE: 2916673279,\n  LIGHTCORAL: 4034953471,\n  LIGHTCYAN: 3774873599,\n  LIGHTGOLDENRODYELLOW: 4210742015,\n  LIGHTGRAY: 3553874943,\n  LIGHTGREEN: 2431553791,\n  LIGHTGREY: 3553874943,\n  LIGHTPINK: 4290167295,\n  LIGHTSALMON: 4288707327,\n  LIGHTSEAGREEN: 548580095,\n  LIGHTSKYBLUE: 2278488831,\n  LIGHTSLATEGRAY: 2005441023,\n  LIGHTSLATEGREY: 2005441023,\n  LIGHTSTEELBLUE: 2965692159,\n  LIGHTYELLOW: 4294959359,\n  LIME: 16711935,\n  LIMEGREEN: 852308735,\n  LINEN: 4210091775,\n  MAGENTA: 4278255615,\n  MAROON: 2147483903,\n  MEDIUMAQUAMARINE: 1724754687,\n  MEDIUMBLUE: 52735,\n  MEDIUMORCHID: 3126187007,\n  MEDIUMPURPLE: 2473647103,\n  MEDIUMSEAGREEN: 1018393087,\n  MEDIUMSLATEBLUE: 2070474495,\n  MEDIUMSPRINGGREEN: 16423679,\n  MEDIUMTURQUOISE: 1221709055,\n  MEDIUMVIOLETRED: 3340076543,\n  MIDNIGHTBLUE: 421097727,\n  MINTCREAM: 4127193855,\n  MISTYROSE: 4293190143,\n  MOCCASIN: 4293178879,\n  NAVAJOWHITE: 4292783615,\n  NAVY: 33023,\n  OLDLACE: 4260751103,\n  OLIVE: 2155872511,\n  OLIVEDRAB: 1804477439,\n  ORANGE: 4289003775,\n  ORANGERED: 4282712319,\n  ORCHID: 3664828159,\n  PALEGOLDENROD: 4008225535,\n  PALEGREEN: 2566625535,\n  PALETURQUOISE: 2951671551,\n  PALEVIOLETRED: 3681588223,\n  PAPAYAWHIP: 4293907967,\n  PEACHPUFF: 4292524543,\n  PERU: 3448061951,\n  PINK: 4290825215,\n  PLUM: 3718307327,\n  POWDERBLUE: 2967529215,\n  PURPLE: 2147516671,\n  REBECCAPURPLE: 1714657791,\n  RED: 4278190335,\n  ROSYBROWN: 3163525119,\n  ROYALBLUE: 1097458175,\n  SADDLEBROWN: 2336560127,\n  SALMON: 4202722047,\n  SANDYBROWN: 4104413439,\n  SEAGREEN: 780883967,\n  SEASHELL: 4294307583,\n  SIENNA: 2689740287,\n  SILVER: 3233857791,\n  SKYBLUE: 2278484991,\n  SLATEBLUE: 1784335871,\n  SLATEGRAY: 1887473919,\n  SLATEGREY: 1887473919,\n  SNOW: 4294638335,\n  SPRINGGREEN: 16744447,\n  STEELBLUE: 1182971135,\n  TAN: 3535047935,\n  TEAL: 8421631,\n  THISTLE: 3636451583,\n  TOMATO: 4284696575,\n  TRANSPARENT: 0,\n  TURQUOISE: 1088475391,\n  VIOLET: 4001558271,\n  WHEAT: 4125012991,\n  WHITE: 4294967295,\n  WHITESMOKE: 4126537215,\n  YELLOW: 4294902015,\n  YELLOWGREEN: 2597139199\n};\nvar backgroundClip = {\n  name: \"background-clip\",\n  initialValue: \"border-box\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    return tokens.map(function(token) {\n      if (isIdentToken(token)) {\n        switch (token.value) {\n          case \"padding-box\":\n            return 1;\n          case \"content-box\":\n            return 2;\n        }\n      }\n      return 0;\n    });\n  }\n};\nvar backgroundColor = {\n  name: \"background-color\",\n  initialValue: \"transparent\",\n  prefix: false,\n  type: 3,\n  format: \"color\"\n};\nvar parseColorStop = function(context, args) {\n  var color2 = color$1.parse(context, args[0]);\n  var stop = args[1];\n  return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };\n};\nvar processColorStops = function(stops, lineLength) {\n  var first = stops[0];\n  var last = stops[stops.length - 1];\n  if (first.stop === null) {\n    first.stop = ZERO_LENGTH;\n  }\n  if (last.stop === null) {\n    last.stop = HUNDRED_PERCENT;\n  }\n  var processStops = [];\n  var previous = 0;\n  for (var i2 = 0; i2 < stops.length; i2++) {\n    var stop_1 = stops[i2].stop;\n    if (stop_1 !== null) {\n      var absoluteValue = getAbsoluteValue(stop_1, lineLength);\n      if (absoluteValue > previous) {\n        processStops.push(absoluteValue);\n      } else {\n        processStops.push(previous);\n      }\n      previous = absoluteValue;\n    } else {\n      processStops.push(null);\n    }\n  }\n  var gapBegin = null;\n  for (var i2 = 0; i2 < processStops.length; i2++) {\n    var stop_2 = processStops[i2];\n    if (stop_2 === null) {\n      if (gapBegin === null) {\n        gapBegin = i2;\n      }\n    } else if (gapBegin !== null) {\n      var gapLength = i2 - gapBegin;\n      var beforeGap = processStops[gapBegin - 1];\n      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);\n      for (var g2 = 1; g2 <= gapLength; g2++) {\n        processStops[gapBegin + g2 - 1] = gapValue * g2;\n      }\n      gapBegin = null;\n    }\n  }\n  return stops.map(function(_a2, i3) {\n    var color2 = _a2.color;\n    return { color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0) };\n  });\n};\nvar getAngleFromCorner = function(corner, width, height) {\n  var centerX = width / 2;\n  var centerY = height / 2;\n  var x2 = getAbsoluteValue(corner[0], width) - centerX;\n  var y2 = centerY - getAbsoluteValue(corner[1], height);\n  return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);\n};\nvar calculateGradientDirection = function(angle2, width, height) {\n  var radian = typeof angle2 === \"number\" ? angle2 : getAngleFromCorner(angle2, width, height);\n  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var halfLineLength = lineLength / 2;\n  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;\n  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;\n  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];\n};\nvar distance = function(a2, b2) {\n  return Math.sqrt(a2 * a2 + b2 * b2);\n};\nvar findCorner = function(width, height, x2, y2, closest) {\n  var corners = [\n    [0, 0],\n    [0, height],\n    [width, 0],\n    [width, height]\n  ];\n  return corners.reduce(function(stat, corner) {\n    var cx = corner[0], cy = corner[1];\n    var d2 = distance(x2 - cx, y2 - cy);\n    if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {\n      return {\n        optimumCorner: corner,\n        optimumDistance: d2\n      };\n    }\n    return stat;\n  }, {\n    optimumDistance: closest ? Infinity : -Infinity,\n    optimumCorner: null\n  }).optimumCorner;\n};\nvar calculateRadius = function(gradient, x2, y2, width, height) {\n  var rx = 0;\n  var ry = 0;\n  switch (gradient.size) {\n    case 0:\n      if (gradient.shape === 0) {\n        rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));\n      } else if (gradient.shape === 1) {\n        rx = Math.min(Math.abs(x2), Math.abs(x2 - width));\n        ry = Math.min(Math.abs(y2), Math.abs(y2 - height));\n      }\n      break;\n    case 2:\n      if (gradient.shape === 0) {\n        rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));\n      } else if (gradient.shape === 1) {\n        var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));\n        var _a2 = findCorner(width, height, x2, y2, true), cx = _a2[0], cy = _a2[1];\n        rx = distance(cx - x2, (cy - y2) / c2);\n        ry = c2 * rx;\n      }\n      break;\n    case 1:\n      if (gradient.shape === 0) {\n        rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));\n      } else if (gradient.shape === 1) {\n        rx = Math.max(Math.abs(x2), Math.abs(x2 - width));\n        ry = Math.max(Math.abs(y2), Math.abs(y2 - height));\n      }\n      break;\n    case 3:\n      if (gradient.shape === 0) {\n        rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));\n      } else if (gradient.shape === 1) {\n        var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));\n        var _b2 = findCorner(width, height, x2, y2, false), cx = _b2[0], cy = _b2[1];\n        rx = distance(cx - x2, (cy - y2) / c2);\n        ry = c2 * rx;\n      }\n      break;\n  }\n  if (Array.isArray(gradient.size)) {\n    rx = getAbsoluteValue(gradient.size[0], width);\n    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;\n  }\n  return [rx, ry];\n};\nvar linearGradient = function(context, tokens) {\n  var angle$1 = deg(180);\n  var stops = [];\n  parseFunctionArgs(tokens).forEach(function(arg, i2) {\n    if (i2 === 0) {\n      var firstToken = arg[0];\n      if (firstToken.type === 20 && firstToken.value === \"to\") {\n        angle$1 = parseNamedSide(arg);\n        return;\n      } else if (isAngle(firstToken)) {\n        angle$1 = angle.parse(context, firstToken);\n        return;\n      }\n    }\n    var colorStop = parseColorStop(context, arg);\n    stops.push(colorStop);\n  });\n  return { angle: angle$1, stops, type: 1 };\n};\nvar prefixLinearGradient = function(context, tokens) {\n  var angle$1 = deg(180);\n  var stops = [];\n  parseFunctionArgs(tokens).forEach(function(arg, i2) {\n    if (i2 === 0) {\n      var firstToken = arg[0];\n      if (firstToken.type === 20 && [\"top\", \"left\", \"right\", \"bottom\"].indexOf(firstToken.value) !== -1) {\n        angle$1 = parseNamedSide(arg);\n        return;\n      } else if (isAngle(firstToken)) {\n        angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);\n        return;\n      }\n    }\n    var colorStop = parseColorStop(context, arg);\n    stops.push(colorStop);\n  });\n  return {\n    angle: angle$1,\n    stops,\n    type: 1\n  };\n};\nvar webkitGradient = function(context, tokens) {\n  var angle2 = deg(180);\n  var stops = [];\n  var type = 1;\n  var shape = 0;\n  var size = 3;\n  var position2 = [];\n  parseFunctionArgs(tokens).forEach(function(arg, i2) {\n    var firstToken = arg[0];\n    if (i2 === 0) {\n      if (isIdentToken(firstToken) && firstToken.value === \"linear\") {\n        type = 1;\n        return;\n      } else if (isIdentToken(firstToken) && firstToken.value === \"radial\") {\n        type = 2;\n        return;\n      }\n    }\n    if (firstToken.type === 18) {\n      if (firstToken.name === \"from\") {\n        var color2 = color$1.parse(context, firstToken.values[0]);\n        stops.push({ stop: ZERO_LENGTH, color: color2 });\n      } else if (firstToken.name === \"to\") {\n        var color2 = color$1.parse(context, firstToken.values[0]);\n        stops.push({ stop: HUNDRED_PERCENT, color: color2 });\n      } else if (firstToken.name === \"color-stop\") {\n        var values2 = firstToken.values.filter(nonFunctionArgSeparator);\n        if (values2.length === 2) {\n          var color2 = color$1.parse(context, values2[1]);\n          var stop_1 = values2[0];\n          if (isNumberToken(stop_1)) {\n            stops.push({\n              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },\n              color: color2\n            });\n          }\n        }\n      }\n    }\n  });\n  return type === 1 ? {\n    angle: (angle2 + deg(180)) % deg(360),\n    stops,\n    type\n  } : { size, shape, stops, position: position2, type };\n};\nvar CLOSEST_SIDE = \"closest-side\";\nvar FARTHEST_SIDE = \"farthest-side\";\nvar CLOSEST_CORNER = \"closest-corner\";\nvar FARTHEST_CORNER = \"farthest-corner\";\nvar CIRCLE = \"circle\";\nvar ELLIPSE = \"ellipse\";\nvar COVER = \"cover\";\nvar CONTAIN = \"contain\";\nvar radialGradient = function(context, tokens) {\n  var shape = 0;\n  var size = 3;\n  var stops = [];\n  var position2 = [];\n  parseFunctionArgs(tokens).forEach(function(arg, i2) {\n    var isColorStop = true;\n    if (i2 === 0) {\n      var isAtPosition_1 = false;\n      isColorStop = arg.reduce(function(acc, token) {\n        if (isAtPosition_1) {\n          if (isIdentToken(token)) {\n            switch (token.value) {\n              case \"center\":\n                position2.push(FIFTY_PERCENT);\n                return acc;\n              case \"top\":\n              case \"left\":\n                position2.push(ZERO_LENGTH);\n                return acc;\n              case \"right\":\n              case \"bottom\":\n                position2.push(HUNDRED_PERCENT);\n                return acc;\n            }\n          } else if (isLengthPercentage(token) || isLength(token)) {\n            position2.push(token);\n          }\n        } else if (isIdentToken(token)) {\n          switch (token.value) {\n            case CIRCLE:\n              shape = 0;\n              return false;\n            case ELLIPSE:\n              shape = 1;\n              return false;\n            case \"at\":\n              isAtPosition_1 = true;\n              return false;\n            case CLOSEST_SIDE:\n              size = 0;\n              return false;\n            case COVER:\n            case FARTHEST_SIDE:\n              size = 1;\n              return false;\n            case CONTAIN:\n            case CLOSEST_CORNER:\n              size = 2;\n              return false;\n            case FARTHEST_CORNER:\n              size = 3;\n              return false;\n          }\n        } else if (isLength(token) || isLengthPercentage(token)) {\n          if (!Array.isArray(size)) {\n            size = [];\n          }\n          size.push(token);\n          return false;\n        }\n        return acc;\n      }, isColorStop);\n    }\n    if (isColorStop) {\n      var colorStop = parseColorStop(context, arg);\n      stops.push(colorStop);\n    }\n  });\n  return { size, shape, stops, position: position2, type: 2 };\n};\nvar prefixRadialGradient = function(context, tokens) {\n  var shape = 0;\n  var size = 3;\n  var stops = [];\n  var position2 = [];\n  parseFunctionArgs(tokens).forEach(function(arg, i2) {\n    var isColorStop = true;\n    if (i2 === 0) {\n      isColorStop = arg.reduce(function(acc, token) {\n        if (isIdentToken(token)) {\n          switch (token.value) {\n            case \"center\":\n              position2.push(FIFTY_PERCENT);\n              return false;\n            case \"top\":\n            case \"left\":\n              position2.push(ZERO_LENGTH);\n              return false;\n            case \"right\":\n            case \"bottom\":\n              position2.push(HUNDRED_PERCENT);\n              return false;\n          }\n        } else if (isLengthPercentage(token) || isLength(token)) {\n          position2.push(token);\n          return false;\n        }\n        return acc;\n      }, isColorStop);\n    } else if (i2 === 1) {\n      isColorStop = arg.reduce(function(acc, token) {\n        if (isIdentToken(token)) {\n          switch (token.value) {\n            case CIRCLE:\n              shape = 0;\n              return false;\n            case ELLIPSE:\n              shape = 1;\n              return false;\n            case CONTAIN:\n            case CLOSEST_SIDE:\n              size = 0;\n              return false;\n            case FARTHEST_SIDE:\n              size = 1;\n              return false;\n            case CLOSEST_CORNER:\n              size = 2;\n              return false;\n            case COVER:\n            case FARTHEST_CORNER:\n              size = 3;\n              return false;\n          }\n        } else if (isLength(token) || isLengthPercentage(token)) {\n          if (!Array.isArray(size)) {\n            size = [];\n          }\n          size.push(token);\n          return false;\n        }\n        return acc;\n      }, isColorStop);\n    }\n    if (isColorStop) {\n      var colorStop = parseColorStop(context, arg);\n      stops.push(colorStop);\n    }\n  });\n  return { size, shape, stops, position: position2, type: 2 };\n};\nvar isLinearGradient = function(background) {\n  return background.type === 1;\n};\nvar isRadialGradient = function(background) {\n  return background.type === 2;\n};\nvar image = {\n  name: \"image\",\n  parse: function(context, value) {\n    if (value.type === 22) {\n      var image_1 = { url: value.value, type: 0 };\n      context.cache.addImage(value.value);\n      return image_1;\n    }\n    if (value.type === 18) {\n      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];\n      if (typeof imageFunction === \"undefined\") {\n        throw new Error('Attempting to parse an unsupported image function \"' + value.name + '\"');\n      }\n      return imageFunction(context, value.values);\n    }\n    throw new Error(\"Unsupported image type \" + value.type);\n  }\n};\nfunction isSupportedImage(value) {\n  return !(value.type === 20 && value.value === \"none\") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);\n}\nvar SUPPORTED_IMAGE_FUNCTIONS = {\n  \"linear-gradient\": linearGradient,\n  \"-moz-linear-gradient\": prefixLinearGradient,\n  \"-ms-linear-gradient\": prefixLinearGradient,\n  \"-o-linear-gradient\": prefixLinearGradient,\n  \"-webkit-linear-gradient\": prefixLinearGradient,\n  \"radial-gradient\": radialGradient,\n  \"-moz-radial-gradient\": prefixRadialGradient,\n  \"-ms-radial-gradient\": prefixRadialGradient,\n  \"-o-radial-gradient\": prefixRadialGradient,\n  \"-webkit-radial-gradient\": prefixRadialGradient,\n  \"-webkit-gradient\": webkitGradient\n};\nvar backgroundImage = {\n  name: \"background-image\",\n  initialValue: \"none\",\n  type: 1,\n  prefix: false,\n  parse: function(context, tokens) {\n    if (tokens.length === 0) {\n      return [];\n    }\n    var first = tokens[0];\n    if (first.type === 20 && first.value === \"none\") {\n      return [];\n    }\n    return tokens.filter(function(value) {\n      return nonFunctionArgSeparator(value) && isSupportedImage(value);\n    }).map(function(value) {\n      return image.parse(context, value);\n    });\n  }\n};\nvar backgroundOrigin = {\n  name: \"background-origin\",\n  initialValue: \"border-box\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    return tokens.map(function(token) {\n      if (isIdentToken(token)) {\n        switch (token.value) {\n          case \"padding-box\":\n            return 1;\n          case \"content-box\":\n            return 2;\n        }\n      }\n      return 0;\n    });\n  }\n};\nvar backgroundPosition = {\n  name: \"background-position\",\n  initialValue: \"0% 0%\",\n  type: 1,\n  prefix: false,\n  parse: function(_context, tokens) {\n    return parseFunctionArgs(tokens).map(function(values2) {\n      return values2.filter(isLengthPercentage);\n    }).map(parseLengthPercentageTuple);\n  }\n};\nvar backgroundRepeat = {\n  name: \"background-repeat\",\n  initialValue: \"repeat\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    return parseFunctionArgs(tokens).map(function(values2) {\n      return values2.filter(isIdentToken).map(function(token) {\n        return token.value;\n      }).join(\" \");\n    }).map(parseBackgroundRepeat);\n  }\n};\nvar parseBackgroundRepeat = function(value) {\n  switch (value) {\n    case \"no-repeat\":\n      return 1;\n    case \"repeat-x\":\n    case \"repeat no-repeat\":\n      return 2;\n    case \"repeat-y\":\n    case \"no-repeat repeat\":\n      return 3;\n    case \"repeat\":\n    default:\n      return 0;\n  }\n};\nvar BACKGROUND_SIZE;\n(function(BACKGROUND_SIZE2) {\n  BACKGROUND_SIZE2[\"AUTO\"] = \"auto\";\n  BACKGROUND_SIZE2[\"CONTAIN\"] = \"contain\";\n  BACKGROUND_SIZE2[\"COVER\"] = \"cover\";\n})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));\nvar backgroundSize = {\n  name: \"background-size\",\n  initialValue: \"0\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    return parseFunctionArgs(tokens).map(function(values2) {\n      return values2.filter(isBackgroundSizeInfoToken);\n    });\n  }\n};\nvar isBackgroundSizeInfoToken = function(value) {\n  return isIdentToken(value) || isLengthPercentage(value);\n};\nvar borderColorForSide = function(side) {\n  return {\n    name: \"border-\" + side + \"-color\",\n    initialValue: \"transparent\",\n    prefix: false,\n    type: 3,\n    format: \"color\"\n  };\n};\nvar borderTopColor = borderColorForSide(\"top\");\nvar borderRightColor = borderColorForSide(\"right\");\nvar borderBottomColor = borderColorForSide(\"bottom\");\nvar borderLeftColor = borderColorForSide(\"left\");\nvar borderRadiusForSide = function(side) {\n  return {\n    name: \"border-radius-\" + side,\n    initialValue: \"0 0\",\n    prefix: false,\n    type: 1,\n    parse: function(_context, tokens) {\n      return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));\n    }\n  };\n};\nvar borderTopLeftRadius = borderRadiusForSide(\"top-left\");\nvar borderTopRightRadius = borderRadiusForSide(\"top-right\");\nvar borderBottomRightRadius = borderRadiusForSide(\"bottom-right\");\nvar borderBottomLeftRadius = borderRadiusForSide(\"bottom-left\");\nvar borderStyleForSide = function(side) {\n  return {\n    name: \"border-\" + side + \"-style\",\n    initialValue: \"solid\",\n    prefix: false,\n    type: 2,\n    parse: function(_context, style2) {\n      switch (style2) {\n        case \"none\":\n          return 0;\n        case \"dashed\":\n          return 2;\n        case \"dotted\":\n          return 3;\n        case \"double\":\n          return 4;\n      }\n      return 1;\n    }\n  };\n};\nvar borderTopStyle = borderStyleForSide(\"top\");\nvar borderRightStyle = borderStyleForSide(\"right\");\nvar borderBottomStyle = borderStyleForSide(\"bottom\");\nvar borderLeftStyle = borderStyleForSide(\"left\");\nvar borderWidthForSide = function(side) {\n  return {\n    name: \"border-\" + side + \"-width\",\n    initialValue: \"0\",\n    type: 0,\n    prefix: false,\n    parse: function(_context, token) {\n      if (isDimensionToken(token)) {\n        return token.number;\n      }\n      return 0;\n    }\n  };\n};\nvar borderTopWidth = borderWidthForSide(\"top\");\nvar borderRightWidth = borderWidthForSide(\"right\");\nvar borderBottomWidth = borderWidthForSide(\"bottom\");\nvar borderLeftWidth = borderWidthForSide(\"left\");\nvar color = {\n  name: \"color\",\n  initialValue: \"transparent\",\n  prefix: false,\n  type: 3,\n  format: \"color\"\n};\nvar direction = {\n  name: \"direction\",\n  initialValue: \"ltr\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, direction2) {\n    switch (direction2) {\n      case \"rtl\":\n        return 1;\n      case \"ltr\":\n      default:\n        return 0;\n    }\n  }\n};\nvar display = {\n  name: \"display\",\n  initialValue: \"inline-block\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    return tokens.filter(isIdentToken).reduce(function(bit, token) {\n      return bit | parseDisplayValue(token.value);\n    }, 0);\n  }\n};\nvar parseDisplayValue = function(display2) {\n  switch (display2) {\n    case \"block\":\n    case \"-webkit-box\":\n      return 2;\n    case \"inline\":\n      return 4;\n    case \"run-in\":\n      return 8;\n    case \"flow\":\n      return 16;\n    case \"flow-root\":\n      return 32;\n    case \"table\":\n      return 64;\n    case \"flex\":\n    case \"-webkit-flex\":\n      return 128;\n    case \"grid\":\n    case \"-ms-grid\":\n      return 256;\n    case \"ruby\":\n      return 512;\n    case \"subgrid\":\n      return 1024;\n    case \"list-item\":\n      return 2048;\n    case \"table-row-group\":\n      return 4096;\n    case \"table-header-group\":\n      return 8192;\n    case \"table-footer-group\":\n      return 16384;\n    case \"table-row\":\n      return 32768;\n    case \"table-cell\":\n      return 65536;\n    case \"table-column-group\":\n      return 131072;\n    case \"table-column\":\n      return 262144;\n    case \"table-caption\":\n      return 524288;\n    case \"ruby-base\":\n      return 1048576;\n    case \"ruby-text\":\n      return 2097152;\n    case \"ruby-base-container\":\n      return 4194304;\n    case \"ruby-text-container\":\n      return 8388608;\n    case \"contents\":\n      return 16777216;\n    case \"inline-block\":\n      return 33554432;\n    case \"inline-list-item\":\n      return 67108864;\n    case \"inline-table\":\n      return 134217728;\n    case \"inline-flex\":\n      return 268435456;\n    case \"inline-grid\":\n      return 536870912;\n  }\n  return 0;\n};\nvar float = {\n  name: \"float\",\n  initialValue: \"none\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, float2) {\n    switch (float2) {\n      case \"left\":\n        return 1;\n      case \"right\":\n        return 2;\n      case \"inline-start\":\n        return 3;\n      case \"inline-end\":\n        return 4;\n    }\n    return 0;\n  }\n};\nvar letterSpacing = {\n  name: \"letter-spacing\",\n  initialValue: \"0\",\n  prefix: false,\n  type: 0,\n  parse: function(_context, token) {\n    if (token.type === 20 && token.value === \"normal\") {\n      return 0;\n    }\n    if (token.type === 17) {\n      return token.number;\n    }\n    if (token.type === 15) {\n      return token.number;\n    }\n    return 0;\n  }\n};\nvar LINE_BREAK;\n(function(LINE_BREAK2) {\n  LINE_BREAK2[\"NORMAL\"] = \"normal\";\n  LINE_BREAK2[\"STRICT\"] = \"strict\";\n})(LINE_BREAK || (LINE_BREAK = {}));\nvar lineBreak = {\n  name: \"line-break\",\n  initialValue: \"normal\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, lineBreak2) {\n    switch (lineBreak2) {\n      case \"strict\":\n        return LINE_BREAK.STRICT;\n      case \"normal\":\n      default:\n        return LINE_BREAK.NORMAL;\n    }\n  }\n};\nvar lineHeight = {\n  name: \"line-height\",\n  initialValue: \"normal\",\n  prefix: false,\n  type: 4\n};\nvar computeLineHeight = function(token, fontSize2) {\n  if (isIdentToken(token) && token.value === \"normal\") {\n    return 1.2 * fontSize2;\n  } else if (token.type === 17) {\n    return fontSize2 * token.number;\n  } else if (isLengthPercentage(token)) {\n    return getAbsoluteValue(token, fontSize2);\n  }\n  return fontSize2;\n};\nvar listStyleImage = {\n  name: \"list-style-image\",\n  initialValue: \"none\",\n  type: 0,\n  prefix: false,\n  parse: function(context, token) {\n    if (token.type === 20 && token.value === \"none\") {\n      return null;\n    }\n    return image.parse(context, token);\n  }\n};\nvar listStylePosition = {\n  name: \"list-style-position\",\n  initialValue: \"outside\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, position2) {\n    switch (position2) {\n      case \"inside\":\n        return 0;\n      case \"outside\":\n      default:\n        return 1;\n    }\n  }\n};\nvar listStyleType = {\n  name: \"list-style-type\",\n  initialValue: \"none\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, type) {\n    switch (type) {\n      case \"disc\":\n        return 0;\n      case \"circle\":\n        return 1;\n      case \"square\":\n        return 2;\n      case \"decimal\":\n        return 3;\n      case \"cjk-decimal\":\n        return 4;\n      case \"decimal-leading-zero\":\n        return 5;\n      case \"lower-roman\":\n        return 6;\n      case \"upper-roman\":\n        return 7;\n      case \"lower-greek\":\n        return 8;\n      case \"lower-alpha\":\n        return 9;\n      case \"upper-alpha\":\n        return 10;\n      case \"arabic-indic\":\n        return 11;\n      case \"armenian\":\n        return 12;\n      case \"bengali\":\n        return 13;\n      case \"cambodian\":\n        return 14;\n      case \"cjk-earthly-branch\":\n        return 15;\n      case \"cjk-heavenly-stem\":\n        return 16;\n      case \"cjk-ideographic\":\n        return 17;\n      case \"devanagari\":\n        return 18;\n      case \"ethiopic-numeric\":\n        return 19;\n      case \"georgian\":\n        return 20;\n      case \"gujarati\":\n        return 21;\n      case \"gurmukhi\":\n        return 22;\n      case \"hebrew\":\n        return 22;\n      case \"hiragana\":\n        return 23;\n      case \"hiragana-iroha\":\n        return 24;\n      case \"japanese-formal\":\n        return 25;\n      case \"japanese-informal\":\n        return 26;\n      case \"kannada\":\n        return 27;\n      case \"katakana\":\n        return 28;\n      case \"katakana-iroha\":\n        return 29;\n      case \"khmer\":\n        return 30;\n      case \"korean-hangul-formal\":\n        return 31;\n      case \"korean-hanja-formal\":\n        return 32;\n      case \"korean-hanja-informal\":\n        return 33;\n      case \"lao\":\n        return 34;\n      case \"lower-armenian\":\n        return 35;\n      case \"malayalam\":\n        return 36;\n      case \"mongolian\":\n        return 37;\n      case \"myanmar\":\n        return 38;\n      case \"oriya\":\n        return 39;\n      case \"persian\":\n        return 40;\n      case \"simp-chinese-formal\":\n        return 41;\n      case \"simp-chinese-informal\":\n        return 42;\n      case \"tamil\":\n        return 43;\n      case \"telugu\":\n        return 44;\n      case \"thai\":\n        return 45;\n      case \"tibetan\":\n        return 46;\n      case \"trad-chinese-formal\":\n        return 47;\n      case \"trad-chinese-informal\":\n        return 48;\n      case \"upper-armenian\":\n        return 49;\n      case \"disclosure-open\":\n        return 50;\n      case \"disclosure-closed\":\n        return 51;\n      case \"none\":\n      default:\n        return -1;\n    }\n  }\n};\nvar marginForSide = function(side) {\n  return {\n    name: \"margin-\" + side,\n    initialValue: \"0\",\n    prefix: false,\n    type: 4\n  };\n};\nvar marginTop = marginForSide(\"top\");\nvar marginRight = marginForSide(\"right\");\nvar marginBottom = marginForSide(\"bottom\");\nvar marginLeft = marginForSide(\"left\");\nvar overflow = {\n  name: \"overflow\",\n  initialValue: \"visible\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    return tokens.filter(isIdentToken).map(function(overflow2) {\n      switch (overflow2.value) {\n        case \"hidden\":\n          return 1;\n        case \"scroll\":\n          return 2;\n        case \"clip\":\n          return 3;\n        case \"auto\":\n          return 4;\n        case \"visible\":\n        default:\n          return 0;\n      }\n    });\n  }\n};\nvar overflowWrap = {\n  name: \"overflow-wrap\",\n  initialValue: \"normal\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, overflow2) {\n    switch (overflow2) {\n      case \"break-word\":\n        return \"break-word\";\n      case \"normal\":\n      default:\n        return \"normal\";\n    }\n  }\n};\nvar paddingForSide = function(side) {\n  return {\n    name: \"padding-\" + side,\n    initialValue: \"0\",\n    prefix: false,\n    type: 3,\n    format: \"length-percentage\"\n  };\n};\nvar paddingTop = paddingForSide(\"top\");\nvar paddingRight = paddingForSide(\"right\");\nvar paddingBottom = paddingForSide(\"bottom\");\nvar paddingLeft = paddingForSide(\"left\");\nvar textAlign = {\n  name: \"text-align\",\n  initialValue: \"left\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, textAlign2) {\n    switch (textAlign2) {\n      case \"right\":\n        return 2;\n      case \"center\":\n      case \"justify\":\n        return 1;\n      case \"left\":\n      default:\n        return 0;\n    }\n  }\n};\nvar position = {\n  name: \"position\",\n  initialValue: \"static\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, position2) {\n    switch (position2) {\n      case \"relative\":\n        return 1;\n      case \"absolute\":\n        return 2;\n      case \"fixed\":\n        return 3;\n      case \"sticky\":\n        return 4;\n    }\n    return 0;\n  }\n};\nvar textShadow = {\n  name: \"text-shadow\",\n  initialValue: \"none\",\n  type: 1,\n  prefix: false,\n  parse: function(context, tokens) {\n    if (tokens.length === 1 && isIdentWithValue(tokens[0], \"none\")) {\n      return [];\n    }\n    return parseFunctionArgs(tokens).map(function(values2) {\n      var shadow = {\n        color: COLORS.TRANSPARENT,\n        offsetX: ZERO_LENGTH,\n        offsetY: ZERO_LENGTH,\n        blur: ZERO_LENGTH\n      };\n      var c2 = 0;\n      for (var i2 = 0; i2 < values2.length; i2++) {\n        var token = values2[i2];\n        if (isLength(token)) {\n          if (c2 === 0) {\n            shadow.offsetX = token;\n          } else if (c2 === 1) {\n            shadow.offsetY = token;\n          } else {\n            shadow.blur = token;\n          }\n          c2++;\n        } else {\n          shadow.color = color$1.parse(context, token);\n        }\n      }\n      return shadow;\n    });\n  }\n};\nvar textTransform = {\n  name: \"text-transform\",\n  initialValue: \"none\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, textTransform2) {\n    switch (textTransform2) {\n      case \"uppercase\":\n        return 2;\n      case \"lowercase\":\n        return 1;\n      case \"capitalize\":\n        return 3;\n    }\n    return 0;\n  }\n};\nvar transform$1 = {\n  name: \"transform\",\n  initialValue: \"none\",\n  prefix: true,\n  type: 0,\n  parse: function(_context, token) {\n    if (token.type === 20 && token.value === \"none\") {\n      return null;\n    }\n    if (token.type === 18) {\n      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];\n      if (typeof transformFunction === \"undefined\") {\n        throw new Error('Attempting to parse an unsupported transform function \"' + token.name + '\"');\n      }\n      return transformFunction(token.values);\n    }\n    return null;\n  }\n};\nvar matrix = function(args) {\n  var values2 = args.filter(function(arg) {\n    return arg.type === 17;\n  }).map(function(arg) {\n    return arg.number;\n  });\n  return values2.length === 6 ? values2 : null;\n};\nvar matrix3d = function(args) {\n  var values2 = args.filter(function(arg) {\n    return arg.type === 17;\n  }).map(function(arg) {\n    return arg.number;\n  });\n  var a1 = values2[0], b1 = values2[1];\n  values2[2];\n  values2[3];\n  var a2 = values2[4], b2 = values2[5];\n  values2[6];\n  values2[7];\n  values2[8];\n  values2[9];\n  values2[10];\n  values2[11];\n  var a4 = values2[12], b4 = values2[13];\n  values2[14];\n  values2[15];\n  return values2.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;\n};\nvar SUPPORTED_TRANSFORM_FUNCTIONS = {\n  matrix,\n  matrix3d\n};\nvar DEFAULT_VALUE = {\n  type: 16,\n  number: 50,\n  flags: FLAG_INTEGER\n};\nvar DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];\nvar transformOrigin = {\n  name: \"transform-origin\",\n  initialValue: \"50% 50%\",\n  prefix: true,\n  type: 1,\n  parse: function(_context, tokens) {\n    var origins = tokens.filter(isLengthPercentage);\n    if (origins.length !== 2) {\n      return DEFAULT;\n    }\n    return [origins[0], origins[1]];\n  }\n};\nvar visibility = {\n  name: \"visible\",\n  initialValue: \"none\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, visibility2) {\n    switch (visibility2) {\n      case \"hidden\":\n        return 1;\n      case \"collapse\":\n        return 2;\n      case \"visible\":\n      default:\n        return 0;\n    }\n  }\n};\nvar WORD_BREAK;\n(function(WORD_BREAK2) {\n  WORD_BREAK2[\"NORMAL\"] = \"normal\";\n  WORD_BREAK2[\"BREAK_ALL\"] = \"break-all\";\n  WORD_BREAK2[\"KEEP_ALL\"] = \"keep-all\";\n})(WORD_BREAK || (WORD_BREAK = {}));\nvar wordBreak = {\n  name: \"word-break\",\n  initialValue: \"normal\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, wordBreak2) {\n    switch (wordBreak2) {\n      case \"break-all\":\n        return WORD_BREAK.BREAK_ALL;\n      case \"keep-all\":\n        return WORD_BREAK.KEEP_ALL;\n      case \"normal\":\n      default:\n        return WORD_BREAK.NORMAL;\n    }\n  }\n};\nvar zIndex = {\n  name: \"z-index\",\n  initialValue: \"auto\",\n  prefix: false,\n  type: 0,\n  parse: function(_context, token) {\n    if (token.type === 20) {\n      return { auto: true, order: 0 };\n    }\n    if (isNumberToken(token)) {\n      return { auto: false, order: token.number };\n    }\n    throw new Error(\"Invalid z-index number parsed\");\n  }\n};\nvar time = {\n  name: \"time\",\n  parse: function(_context, value) {\n    if (value.type === 15) {\n      switch (value.unit.toLowerCase()) {\n        case \"s\":\n          return 1e3 * value.number;\n        case \"ms\":\n          return value.number;\n      }\n    }\n    throw new Error(\"Unsupported time type\");\n  }\n};\nvar opacity = {\n  name: \"opacity\",\n  initialValue: \"1\",\n  type: 0,\n  prefix: false,\n  parse: function(_context, token) {\n    if (isNumberToken(token)) {\n      return token.number;\n    }\n    return 1;\n  }\n};\nvar textDecorationColor = {\n  name: \"text-decoration-color\",\n  initialValue: \"transparent\",\n  prefix: false,\n  type: 3,\n  format: \"color\"\n};\nvar textDecorationLine = {\n  name: \"text-decoration-line\",\n  initialValue: \"none\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    return tokens.filter(isIdentToken).map(function(token) {\n      switch (token.value) {\n        case \"underline\":\n          return 1;\n        case \"overline\":\n          return 2;\n        case \"line-through\":\n          return 3;\n        case \"none\":\n          return 4;\n      }\n      return 0;\n    }).filter(function(line) {\n      return line !== 0;\n    });\n  }\n};\nvar fontFamily = {\n  name: \"font-family\",\n  initialValue: \"\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    var accumulator = [];\n    var results = [];\n    tokens.forEach(function(token) {\n      switch (token.type) {\n        case 20:\n        case 0:\n          accumulator.push(token.value);\n          break;\n        case 17:\n          accumulator.push(token.number.toString());\n          break;\n        case 4:\n          results.push(accumulator.join(\" \"));\n          accumulator.length = 0;\n          break;\n      }\n    });\n    if (accumulator.length) {\n      results.push(accumulator.join(\" \"));\n    }\n    return results.map(function(result) {\n      return result.indexOf(\" \") === -1 ? result : \"'\" + result + \"'\";\n    });\n  }\n};\nvar fontSize = {\n  name: \"font-size\",\n  initialValue: \"0\",\n  prefix: false,\n  type: 3,\n  format: \"length\"\n};\nvar fontWeight = {\n  name: \"font-weight\",\n  initialValue: \"normal\",\n  type: 0,\n  prefix: false,\n  parse: function(_context, token) {\n    if (isNumberToken(token)) {\n      return token.number;\n    }\n    if (isIdentToken(token)) {\n      switch (token.value) {\n        case \"bold\":\n          return 700;\n        case \"normal\":\n        default:\n          return 400;\n      }\n    }\n    return 400;\n  }\n};\nvar fontVariant = {\n  name: \"font-variant\",\n  initialValue: \"none\",\n  type: 1,\n  prefix: false,\n  parse: function(_context, tokens) {\n    return tokens.filter(isIdentToken).map(function(token) {\n      return token.value;\n    });\n  }\n};\nvar fontStyle = {\n  name: \"font-style\",\n  initialValue: \"normal\",\n  prefix: false,\n  type: 2,\n  parse: function(_context, overflow2) {\n    switch (overflow2) {\n      case \"oblique\":\n        return \"oblique\";\n      case \"italic\":\n        return \"italic\";\n      case \"normal\":\n      default:\n        return \"normal\";\n    }\n  }\n};\nvar contains = function(bit, value) {\n  return (bit & value) !== 0;\n};\nvar content = {\n  name: \"content\",\n  initialValue: \"none\",\n  type: 1,\n  prefix: false,\n  parse: function(_context, tokens) {\n    if (tokens.length === 0) {\n      return [];\n    }\n    var first = tokens[0];\n    if (first.type === 20 && first.value === \"none\") {\n      return [];\n    }\n    return tokens;\n  }\n};\nvar counterIncrement = {\n  name: \"counter-increment\",\n  initialValue: \"none\",\n  prefix: true,\n  type: 1,\n  parse: function(_context, tokens) {\n    if (tokens.length === 0) {\n      return null;\n    }\n    var first = tokens[0];\n    if (first.type === 20 && first.value === \"none\") {\n      return null;\n    }\n    var increments = [];\n    var filtered = tokens.filter(nonWhiteSpace);\n    for (var i2 = 0; i2 < filtered.length; i2++) {\n      var counter2 = filtered[i2];\n      var next = filtered[i2 + 1];\n      if (counter2.type === 20) {\n        var increment = next && isNumberToken(next) ? next.number : 1;\n        increments.push({ counter: counter2.value, increment });\n      }\n    }\n    return increments;\n  }\n};\nvar counterReset = {\n  name: \"counter-reset\",\n  initialValue: \"none\",\n  prefix: true,\n  type: 1,\n  parse: function(_context, tokens) {\n    if (tokens.length === 0) {\n      return [];\n    }\n    var resets = [];\n    var filtered = tokens.filter(nonWhiteSpace);\n    for (var i2 = 0; i2 < filtered.length; i2++) {\n      var counter2 = filtered[i2];\n      var next = filtered[i2 + 1];\n      if (isIdentToken(counter2) && counter2.value !== \"none\") {\n        var reset2 = next && isNumberToken(next) ? next.number : 0;\n        resets.push({ counter: counter2.value, reset: reset2 });\n      }\n    }\n    return resets;\n  }\n};\nvar duration = {\n  name: \"duration\",\n  initialValue: \"0s\",\n  prefix: false,\n  type: 1,\n  parse: function(context, tokens) {\n    return tokens.filter(isDimensionToken).map(function(token) {\n      return time.parse(context, token);\n    });\n  }\n};\nvar quotes = {\n  name: \"quotes\",\n  initialValue: \"none\",\n  prefix: true,\n  type: 1,\n  parse: function(_context, tokens) {\n    if (tokens.length === 0) {\n      return null;\n    }\n    var first = tokens[0];\n    if (first.type === 20 && first.value === \"none\") {\n      return null;\n    }\n    var quotes2 = [];\n    var filtered = tokens.filter(isStringToken);\n    if (filtered.length % 2 !== 0) {\n      return null;\n    }\n    for (var i2 = 0; i2 < filtered.length; i2 += 2) {\n      var open_1 = filtered[i2].value;\n      var close_1 = filtered[i2 + 1].value;\n      quotes2.push({ open: open_1, close: close_1 });\n    }\n    return quotes2;\n  }\n};\nvar getQuote = function(quotes2, depth, open2) {\n  if (!quotes2) {\n    return \"\";\n  }\n  var quote = quotes2[Math.min(depth, quotes2.length - 1)];\n  if (!quote) {\n    return \"\";\n  }\n  return open2 ? quote.open : quote.close;\n};\nvar boxShadow = {\n  name: \"box-shadow\",\n  initialValue: \"none\",\n  type: 1,\n  prefix: false,\n  parse: function(context, tokens) {\n    if (tokens.length === 1 && isIdentWithValue(tokens[0], \"none\")) {\n      return [];\n    }\n    return parseFunctionArgs(tokens).map(function(values2) {\n      var shadow = {\n        color: 255,\n        offsetX: ZERO_LENGTH,\n        offsetY: ZERO_LENGTH,\n        blur: ZERO_LENGTH,\n        spread: ZERO_LENGTH,\n        inset: false\n      };\n      var c2 = 0;\n      for (var i2 = 0; i2 < values2.length; i2++) {\n        var token = values2[i2];\n        if (isIdentWithValue(token, \"inset\")) {\n          shadow.inset = true;\n        } else if (isLength(token)) {\n          if (c2 === 0) {\n            shadow.offsetX = token;\n          } else if (c2 === 1) {\n            shadow.offsetY = token;\n          } else if (c2 === 2) {\n            shadow.blur = token;\n          } else {\n            shadow.spread = token;\n          }\n          c2++;\n        } else {\n          shadow.color = color$1.parse(context, token);\n        }\n      }\n      return shadow;\n    });\n  }\n};\nvar paintOrder = {\n  name: \"paint-order\",\n  initialValue: \"normal\",\n  prefix: false,\n  type: 1,\n  parse: function(_context, tokens) {\n    var DEFAULT_VALUE2 = [0, 1, 2];\n    var layers = [];\n    tokens.filter(isIdentToken).forEach(function(token) {\n      switch (token.value) {\n        case \"stroke\":\n          layers.push(1);\n          break;\n        case \"fill\":\n          layers.push(0);\n          break;\n        case \"markers\":\n          layers.push(2);\n          break;\n      }\n    });\n    DEFAULT_VALUE2.forEach(function(value) {\n      if (layers.indexOf(value) === -1) {\n        layers.push(value);\n      }\n    });\n    return layers;\n  }\n};\nvar webkitTextStrokeColor = {\n  name: \"-webkit-text-stroke-color\",\n  initialValue: \"currentcolor\",\n  prefix: false,\n  type: 3,\n  format: \"color\"\n};\nvar webkitTextStrokeWidth = {\n  name: \"-webkit-text-stroke-width\",\n  initialValue: \"0\",\n  type: 0,\n  prefix: false,\n  parse: function(_context, token) {\n    if (isDimensionToken(token)) {\n      return token.number;\n    }\n    return 0;\n  }\n};\nvar CSSParsedDeclaration = function() {\n  function CSSParsedDeclaration2(context, declaration) {\n    var _a2, _b2;\n    this.animationDuration = parse(context, duration, declaration.animationDuration);\n    this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);\n    this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);\n    this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);\n    this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);\n    this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);\n    this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);\n    this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);\n    this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);\n    this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);\n    this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);\n    this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);\n    this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);\n    this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);\n    this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);\n    this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);\n    this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);\n    this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);\n    this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);\n    this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);\n    this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);\n    this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);\n    this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);\n    this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);\n    this.boxShadow = parse(context, boxShadow, declaration.boxShadow);\n    this.color = parse(context, color, declaration.color);\n    this.direction = parse(context, direction, declaration.direction);\n    this.display = parse(context, display, declaration.display);\n    this.float = parse(context, float, declaration.cssFloat);\n    this.fontFamily = parse(context, fontFamily, declaration.fontFamily);\n    this.fontSize = parse(context, fontSize, declaration.fontSize);\n    this.fontStyle = parse(context, fontStyle, declaration.fontStyle);\n    this.fontVariant = parse(context, fontVariant, declaration.fontVariant);\n    this.fontWeight = parse(context, fontWeight, declaration.fontWeight);\n    this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);\n    this.lineBreak = parse(context, lineBreak, declaration.lineBreak);\n    this.lineHeight = parse(context, lineHeight, declaration.lineHeight);\n    this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);\n    this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);\n    this.listStyleType = parse(context, listStyleType, declaration.listStyleType);\n    this.marginTop = parse(context, marginTop, declaration.marginTop);\n    this.marginRight = parse(context, marginRight, declaration.marginRight);\n    this.marginBottom = parse(context, marginBottom, declaration.marginBottom);\n    this.marginLeft = parse(context, marginLeft, declaration.marginLeft);\n    this.opacity = parse(context, opacity, declaration.opacity);\n    var overflowTuple = parse(context, overflow, declaration.overflow);\n    this.overflowX = overflowTuple[0];\n    this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];\n    this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);\n    this.paddingTop = parse(context, paddingTop, declaration.paddingTop);\n    this.paddingRight = parse(context, paddingRight, declaration.paddingRight);\n    this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);\n    this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);\n    this.paintOrder = parse(context, paintOrder, declaration.paintOrder);\n    this.position = parse(context, position, declaration.position);\n    this.textAlign = parse(context, textAlign, declaration.textAlign);\n    this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);\n    this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);\n    this.textShadow = parse(context, textShadow, declaration.textShadow);\n    this.textTransform = parse(context, textTransform, declaration.textTransform);\n    this.transform = parse(context, transform$1, declaration.transform);\n    this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);\n    this.visibility = parse(context, visibility, declaration.visibility);\n    this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);\n    this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);\n    this.wordBreak = parse(context, wordBreak, declaration.wordBreak);\n    this.zIndex = parse(context, zIndex, declaration.zIndex);\n  }\n  CSSParsedDeclaration2.prototype.isVisible = function() {\n    return this.display > 0 && this.opacity > 0 && this.visibility === 0;\n  };\n  CSSParsedDeclaration2.prototype.isTransparent = function() {\n    return isTransparent(this.backgroundColor);\n  };\n  CSSParsedDeclaration2.prototype.isTransformed = function() {\n    return this.transform !== null;\n  };\n  CSSParsedDeclaration2.prototype.isPositioned = function() {\n    return this.position !== 0;\n  };\n  CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {\n    return this.isPositioned() && !this.zIndex.auto;\n  };\n  CSSParsedDeclaration2.prototype.isFloating = function() {\n    return this.float !== 0;\n  };\n  CSSParsedDeclaration2.prototype.isInlineLevel = function() {\n    return contains(this.display, 4) || contains(this.display, 33554432) || contains(this.display, 268435456) || contains(this.display, 536870912) || contains(this.display, 67108864) || contains(this.display, 134217728);\n  };\n  return CSSParsedDeclaration2;\n}();\nvar CSSParsedPseudoDeclaration = function() {\n  function CSSParsedPseudoDeclaration2(context, declaration) {\n    this.content = parse(context, content, declaration.content);\n    this.quotes = parse(context, quotes, declaration.quotes);\n  }\n  return CSSParsedPseudoDeclaration2;\n}();\nvar CSSParsedCounterDeclaration = function() {\n  function CSSParsedCounterDeclaration2(context, declaration) {\n    this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);\n    this.counterReset = parse(context, counterReset, declaration.counterReset);\n  }\n  return CSSParsedCounterDeclaration2;\n}();\nvar parse = function(context, descriptor, style2) {\n  var tokenizer = new Tokenizer();\n  var value = style2 !== null && typeof style2 !== \"undefined\" ? style2.toString() : descriptor.initialValue;\n  tokenizer.write(value);\n  var parser = new Parser$1(tokenizer.read());\n  switch (descriptor.type) {\n    case 2:\n      var token = parser.parseComponentValue();\n      return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);\n    case 0:\n      return descriptor.parse(context, parser.parseComponentValue());\n    case 1:\n      return descriptor.parse(context, parser.parseComponentValues());\n    case 4:\n      return parser.parseComponentValue();\n    case 3:\n      switch (descriptor.format) {\n        case \"angle\":\n          return angle.parse(context, parser.parseComponentValue());\n        case \"color\":\n          return color$1.parse(context, parser.parseComponentValue());\n        case \"image\":\n          return image.parse(context, parser.parseComponentValue());\n        case \"length\":\n          var length_1 = parser.parseComponentValue();\n          return isLength(length_1) ? length_1 : ZERO_LENGTH;\n        case \"length-percentage\":\n          var value_1 = parser.parseComponentValue();\n          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;\n        case \"time\":\n          return time.parse(context, parser.parseComponentValue());\n      }\n      break;\n  }\n};\nvar elementDebuggerAttribute = \"data-html2canvas-debug\";\nvar getElementDebugType = function(element) {\n  var attribute = element.getAttribute(elementDebuggerAttribute);\n  switch (attribute) {\n    case \"all\":\n      return 1;\n    case \"clone\":\n      return 2;\n    case \"parse\":\n      return 3;\n    case \"render\":\n      return 4;\n    default:\n      return 0;\n  }\n};\nvar isDebugging = function(element, type) {\n  var elementType = getElementDebugType(element);\n  return elementType === 1 || type === elementType;\n};\nvar ElementContainer = function() {\n  function ElementContainer2(context, element) {\n    this.context = context;\n    this.textNodes = [];\n    this.elements = [];\n    this.flags = 0;\n    if (isDebugging(element, 3)) {\n      debugger;\n    }\n    this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));\n    if (isHTMLElementNode(element)) {\n      if (this.styles.animationDuration.some(function(duration2) {\n        return duration2 > 0;\n      })) {\n        element.style.animationDuration = \"0s\";\n      }\n      if (this.styles.transform !== null) {\n        element.style.transform = \"none\";\n      }\n    }\n    this.bounds = parseBounds(this.context, element);\n    if (isDebugging(element, 4)) {\n      this.flags |= 16;\n    }\n  }\n  return ElementContainer2;\n}();\nvar base64 = \"AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=\";\nvar chars$1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup$1 = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1$2 = 0; i$1$2 < chars$1.length; i$1$2++) {\n  lookup$1[chars$1.charCodeAt(i$1$2)] = i$1$2;\n}\nvar decode = function(base642) {\n  var bufferLength = base642.length * 0.75, len = base642.length, i2, p5 = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base642[base642.length - 1] === \"=\") {\n    bufferLength--;\n    if (base642[base642.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  var buffer2 = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\" && typeof Uint8Array.prototype.slice !== \"undefined\" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);\n  var bytes = Array.isArray(buffer2) ? buffer2 : new Uint8Array(buffer2);\n  for (i2 = 0; i2 < len; i2 += 4) {\n    encoded1 = lookup$1[base642.charCodeAt(i2)];\n    encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];\n    encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];\n    encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];\n    bytes[p5++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p5++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p5++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return buffer2;\n};\nvar polyUint16Array = function(buffer2) {\n  var length = buffer2.length;\n  var bytes = [];\n  for (var i2 = 0; i2 < length; i2 += 2) {\n    bytes.push(buffer2[i2 + 1] << 8 | buffer2[i2]);\n  }\n  return bytes;\n};\nvar polyUint32Array = function(buffer2) {\n  var length = buffer2.length;\n  var bytes = [];\n  for (var i2 = 0; i2 < length; i2 += 4) {\n    bytes.push(buffer2[i2 + 3] << 24 | buffer2[i2 + 2] << 16 | buffer2[i2 + 1] << 8 | buffer2[i2]);\n  }\n  return bytes;\n};\nvar UTRIE2_SHIFT_2 = 5;\nvar UTRIE2_SHIFT_1 = 6 + 5;\nvar UTRIE2_INDEX_SHIFT = 2;\nvar UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;\nvar UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;\nvar UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;\nvar UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;\nvar UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;\nvar UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;\nvar UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;\nvar UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;\nvar UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;\nvar UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;\nvar UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;\nvar UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;\nvar slice16 = function(view, start2, end) {\n  if (view.slice) {\n    return view.slice(start2, end);\n  }\n  return new Uint16Array(Array.prototype.slice.call(view, start2, end));\n};\nvar slice32 = function(view, start2, end) {\n  if (view.slice) {\n    return view.slice(start2, end);\n  }\n  return new Uint32Array(Array.prototype.slice.call(view, start2, end));\n};\nvar createTrieFromBase64 = function(base642, _byteLength) {\n  var buffer2 = decode(base642);\n  var view32 = Array.isArray(buffer2) ? polyUint32Array(buffer2) : new Uint32Array(buffer2);\n  var view16 = Array.isArray(buffer2) ? polyUint16Array(buffer2) : new Uint16Array(buffer2);\n  var headerLength = 24;\n  var index2 = slice16(view16, headerLength / 2, view32[4] / 2);\n  var data2 = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));\n  return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data2);\n};\nvar Trie = function() {\n  function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data2) {\n    this.initialValue = initialValue;\n    this.errorValue = errorValue;\n    this.highStart = highStart;\n    this.highValueIndex = highValueIndex;\n    this.index = index2;\n    this.data = data2;\n  }\n  Trie2.prototype.get = function(codePoint) {\n    var ix;\n    if (codePoint >= 0) {\n      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {\n        ix = this.index[codePoint >> UTRIE2_SHIFT_2];\n        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n        return this.data[ix];\n      }\n      if (codePoint <= 65535) {\n        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];\n        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n        return this.data[ix];\n      }\n      if (codePoint < this.highStart) {\n        ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);\n        ix = this.index[ix];\n        ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;\n        ix = this.index[ix];\n        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n        return this.data[ix];\n      }\n      if (codePoint <= 1114111) {\n        return this.data[this.highValueIndex];\n      }\n    }\n    return this.errorValue;\n  };\n  return Trie2;\n}();\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$4 = 0; i$4 < chars.length; i$4++) {\n  lookup[chars.charCodeAt(i$4)] = i$4;\n}\nvar Prepend = 1;\nvar CR = 2;\nvar LF = 3;\nvar Control = 4;\nvar Extend = 5;\nvar SpacingMark = 7;\nvar L = 8;\nvar V = 9;\nvar T$1 = 10;\nvar LV = 11;\nvar LVT = 12;\nvar ZWJ = 13;\nvar Extended_Pictographic = 14;\nvar RI = 15;\nvar toCodePoints = function(str) {\n  var codePoints = [];\n  var i2 = 0;\n  var length = str.length;\n  while (i2 < length) {\n    var value = str.charCodeAt(i2++);\n    if (value >= 55296 && value <= 56319 && i2 < length) {\n      var extra = str.charCodeAt(i2++);\n      if ((extra & 64512) === 56320) {\n        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n      } else {\n        codePoints.push(value);\n        i2--;\n      }\n    } else {\n      codePoints.push(value);\n    }\n  }\n  return codePoints;\n};\nvar fromCodePoint = function() {\n  var codePoints = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n  if (String.fromCodePoint) {\n    return String.fromCodePoint.apply(String, codePoints);\n  }\n  var length = codePoints.length;\n  if (!length) {\n    return \"\";\n  }\n  var codeUnits = [];\n  var index2 = -1;\n  var result = \"\";\n  while (++index2 < length) {\n    var codePoint = codePoints[index2];\n    if (codePoint <= 65535) {\n      codeUnits.push(codePoint);\n    } else {\n      codePoint -= 65536;\n      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);\n    }\n    if (index2 + 1 === length || codeUnits.length > 16384) {\n      result += String.fromCharCode.apply(String, codeUnits);\n      codeUnits.length = 0;\n    }\n  }\n  return result;\n};\nvar UnicodeTrie = createTrieFromBase64(base64);\nvar BREAK_NOT_ALLOWED = \"\\xD7\";\nvar BREAK_ALLOWED = \"\\xF7\";\nvar codePointToClass = function(codePoint) {\n  return UnicodeTrie.get(codePoint);\n};\nvar _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {\n  var prevIndex = index2 - 2;\n  var prev = classTypes[prevIndex];\n  var current = classTypes[index2 - 1];\n  var next = classTypes[index2];\n  if (current === CR && next === LF) {\n    return BREAK_NOT_ALLOWED;\n  }\n  if (current === CR || current === LF || current === Control) {\n    return BREAK_ALLOWED;\n  }\n  if (next === CR || next === LF || next === Control) {\n    return BREAK_ALLOWED;\n  }\n  if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {\n    return BREAK_NOT_ALLOWED;\n  }\n  if ((current === LV || current === V) && (next === V || next === T$1)) {\n    return BREAK_NOT_ALLOWED;\n  }\n  if ((current === LVT || current === T$1) && next === T$1) {\n    return BREAK_NOT_ALLOWED;\n  }\n  if (next === ZWJ || next === Extend) {\n    return BREAK_NOT_ALLOWED;\n  }\n  if (next === SpacingMark) {\n    return BREAK_NOT_ALLOWED;\n  }\n  if (current === Prepend) {\n    return BREAK_NOT_ALLOWED;\n  }\n  if (current === ZWJ && next === Extended_Pictographic) {\n    while (prev === Extend) {\n      prev = classTypes[--prevIndex];\n    }\n    if (prev === Extended_Pictographic) {\n      return BREAK_NOT_ALLOWED;\n    }\n  }\n  if (current === RI && next === RI) {\n    var countRI = 0;\n    while (prev === RI) {\n      countRI++;\n      prev = classTypes[--prevIndex];\n    }\n    if (countRI % 2 === 0) {\n      return BREAK_NOT_ALLOWED;\n    }\n  }\n  return BREAK_ALLOWED;\n};\nvar GraphemeBreaker = function(str) {\n  var codePoints = toCodePoints(str);\n  var length = codePoints.length;\n  var index2 = 0;\n  var lastEnd = 0;\n  var classTypes = codePoints.map(codePointToClass);\n  return {\n    next: function() {\n      if (index2 >= length) {\n        return { done: true, value: null };\n      }\n      var graphemeBreak = BREAK_NOT_ALLOWED;\n      while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {\n      }\n      if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {\n        var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));\n        lastEnd = index2;\n        return { value, done: false };\n      }\n      return { done: true, value: null };\n    }\n  };\n};\nvar splitGraphemes = function(str) {\n  var breaker = GraphemeBreaker(str);\n  var graphemes = [];\n  var bk;\n  while (!(bk = breaker.next()).done) {\n    if (bk.value) {\n      graphemes.push(bk.value.slice());\n    }\n  }\n  return graphemes;\n};\nvar testRangeBounds = function(document2) {\n  var TEST_HEIGHT = 123;\n  if (document2.createRange) {\n    var range = document2.createRange();\n    if (range.getBoundingClientRect) {\n      var testElement = document2.createElement(\"boundtest\");\n      testElement.style.height = TEST_HEIGHT + \"px\";\n      testElement.style.display = \"block\";\n      document2.body.appendChild(testElement);\n      range.selectNode(testElement);\n      var rangeBounds = range.getBoundingClientRect();\n      var rangeHeight = Math.round(rangeBounds.height);\n      document2.body.removeChild(testElement);\n      if (rangeHeight === TEST_HEIGHT) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\nvar testIOSLineBreak = function(document2) {\n  var testElement = document2.createElement(\"boundtest\");\n  testElement.style.width = \"50px\";\n  testElement.style.display = \"block\";\n  testElement.style.fontSize = \"12px\";\n  testElement.style.letterSpacing = \"0px\";\n  testElement.style.wordSpacing = \"0px\";\n  document2.body.appendChild(testElement);\n  var range = document2.createRange();\n  testElement.innerHTML = typeof \"\".repeat === \"function\" ? \"&#128104;\".repeat(10) : \"\";\n  var node2 = testElement.firstChild;\n  var textList = toCodePoints$1(node2.data).map(function(i2) {\n    return fromCodePoint$1(i2);\n  });\n  var offset2 = 0;\n  var prev = {};\n  var supports = textList.every(function(text2, i2) {\n    range.setStart(node2, offset2);\n    range.setEnd(node2, offset2 + text2.length);\n    var rect = range.getBoundingClientRect();\n    offset2 += text2.length;\n    var boundAhead = rect.x > prev.x || rect.y > prev.y;\n    prev = rect;\n    if (i2 === 0) {\n      return true;\n    }\n    return boundAhead;\n  });\n  document2.body.removeChild(testElement);\n  return supports;\n};\nvar testCORS = function() {\n  return typeof new Image().crossOrigin !== \"undefined\";\n};\nvar testResponseType = function() {\n  return typeof new XMLHttpRequest().responseType === \"string\";\n};\nvar testSVG = function(document2) {\n  var img = new Image();\n  var canvas = document2.createElement(\"canvas\");\n  var ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return false;\n  }\n  img.src = \"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>\";\n  try {\n    ctx.drawImage(img, 0, 0);\n    canvas.toDataURL();\n  } catch (e2) {\n    return false;\n  }\n  return true;\n};\nvar isGreenPixel = function(data2) {\n  return data2[0] === 0 && data2[1] === 255 && data2[2] === 0 && data2[3] === 255;\n};\nvar testForeignObject = function(document2) {\n  var canvas = document2.createElement(\"canvas\");\n  var size = 100;\n  canvas.width = size;\n  canvas.height = size;\n  var ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return Promise.reject(false);\n  }\n  ctx.fillStyle = \"rgb(0, 255, 0)\";\n  ctx.fillRect(0, 0, size, size);\n  var img = new Image();\n  var greenImageSrc = canvas.toDataURL();\n  img.src = greenImageSrc;\n  var svg2 = createForeignObjectSVG(size, size, 0, 0, img);\n  ctx.fillStyle = \"red\";\n  ctx.fillRect(0, 0, size, size);\n  return loadSerializedSVG$1(svg2).then(function(img2) {\n    ctx.drawImage(img2, 0, 0);\n    var data2 = ctx.getImageData(0, 0, size, size).data;\n    ctx.fillStyle = \"red\";\n    ctx.fillRect(0, 0, size, size);\n    var node2 = document2.createElement(\"div\");\n    node2.style.backgroundImage = \"url(\" + greenImageSrc + \")\";\n    node2.style.height = size + \"px\";\n    return isGreenPixel(data2) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);\n  }).then(function(img2) {\n    ctx.drawImage(img2, 0, 0);\n    return isGreenPixel(ctx.getImageData(0, 0, size, size).data);\n  }).catch(function() {\n    return false;\n  });\n};\nvar createForeignObjectSVG = function(width, height, x2, y2, node2) {\n  var xmlns = \"http://www.w3.org/2000/svg\";\n  var svg2 = document.createElementNS(xmlns, \"svg\");\n  var foreignObject = document.createElementNS(xmlns, \"foreignObject\");\n  svg2.setAttributeNS(null, \"width\", width.toString());\n  svg2.setAttributeNS(null, \"height\", height.toString());\n  foreignObject.setAttributeNS(null, \"width\", \"100%\");\n  foreignObject.setAttributeNS(null, \"height\", \"100%\");\n  foreignObject.setAttributeNS(null, \"x\", x2.toString());\n  foreignObject.setAttributeNS(null, \"y\", y2.toString());\n  foreignObject.setAttributeNS(null, \"externalResourcesRequired\", \"true\");\n  svg2.appendChild(foreignObject);\n  foreignObject.appendChild(node2);\n  return svg2;\n};\nvar loadSerializedSVG$1 = function(svg2) {\n  return new Promise(function(resolve2, reject2) {\n    var img = new Image();\n    img.onload = function() {\n      return resolve2(img);\n    };\n    img.onerror = reject2;\n    img.src = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(new XMLSerializer().serializeToString(svg2));\n  });\n};\nvar FEATURES = {\n  get SUPPORT_RANGE_BOUNDS() {\n    var value = testRangeBounds(document);\n    Object.defineProperty(FEATURES, \"SUPPORT_RANGE_BOUNDS\", { value });\n    return value;\n  },\n  get SUPPORT_WORD_BREAKING() {\n    var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);\n    Object.defineProperty(FEATURES, \"SUPPORT_WORD_BREAKING\", { value });\n    return value;\n  },\n  get SUPPORT_SVG_DRAWING() {\n    var value = testSVG(document);\n    Object.defineProperty(FEATURES, \"SUPPORT_SVG_DRAWING\", { value });\n    return value;\n  },\n  get SUPPORT_FOREIGNOBJECT_DRAWING() {\n    var value = typeof Array.from === \"function\" && typeof window.fetch === \"function\" ? testForeignObject(document) : Promise.resolve(false);\n    Object.defineProperty(FEATURES, \"SUPPORT_FOREIGNOBJECT_DRAWING\", { value });\n    return value;\n  },\n  get SUPPORT_CORS_IMAGES() {\n    var value = testCORS();\n    Object.defineProperty(FEATURES, \"SUPPORT_CORS_IMAGES\", { value });\n    return value;\n  },\n  get SUPPORT_RESPONSE_TYPE() {\n    var value = testResponseType();\n    Object.defineProperty(FEATURES, \"SUPPORT_RESPONSE_TYPE\", { value });\n    return value;\n  },\n  get SUPPORT_CORS_XHR() {\n    var value = \"withCredentials\" in new XMLHttpRequest();\n    Object.defineProperty(FEATURES, \"SUPPORT_CORS_XHR\", { value });\n    return value;\n  },\n  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {\n    var value = !!(typeof Intl !== \"undefined\" && Intl.Segmenter);\n    Object.defineProperty(FEATURES, \"SUPPORT_NATIVE_TEXT_SEGMENTATION\", { value });\n    return value;\n  }\n};\nvar TextBounds = function() {\n  function TextBounds2(text2, bounds) {\n    this.text = text2;\n    this.bounds = bounds;\n  }\n  return TextBounds2;\n}();\nvar parseTextBounds = function(context, value, styles, node2) {\n  var textList = breakText(value, styles);\n  var textBounds = [];\n  var offset2 = 0;\n  textList.forEach(function(text2) {\n    if (styles.textDecorationLine.length || text2.trim().length > 0) {\n      if (FEATURES.SUPPORT_RANGE_BOUNDS) {\n        var clientRects = createRange(node2, offset2, text2.length).getClientRects();\n        if (clientRects.length > 1) {\n          var subSegments = segmentGraphemes(text2);\n          var subOffset_1 = 0;\n          subSegments.forEach(function(subSegment) {\n            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node2, subOffset_1 + offset2, subSegment.length).getClientRects())));\n            subOffset_1 += subSegment.length;\n          });\n        } else {\n          textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context, clientRects)));\n        }\n      } else {\n        var replacementNode = node2.splitText(text2.length);\n        textBounds.push(new TextBounds(text2, getWrapperBounds(context, node2)));\n        node2 = replacementNode;\n      }\n    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {\n      node2 = node2.splitText(text2.length);\n    }\n    offset2 += text2.length;\n  });\n  return textBounds;\n};\nvar getWrapperBounds = function(context, node2) {\n  var ownerDocument = node2.ownerDocument;\n  if (ownerDocument) {\n    var wrapper = ownerDocument.createElement(\"html2canvaswrapper\");\n    wrapper.appendChild(node2.cloneNode(true));\n    var parentNode = node2.parentNode;\n    if (parentNode) {\n      parentNode.replaceChild(wrapper, node2);\n      var bounds = parseBounds(context, wrapper);\n      if (wrapper.firstChild) {\n        parentNode.replaceChild(wrapper.firstChild, wrapper);\n      }\n      return bounds;\n    }\n  }\n  return Bounds.EMPTY;\n};\nvar createRange = function(node2, offset2, length) {\n  var ownerDocument = node2.ownerDocument;\n  if (!ownerDocument) {\n    throw new Error(\"Node has no owner document\");\n  }\n  var range = ownerDocument.createRange();\n  range.setStart(node2, offset2);\n  range.setEnd(node2, offset2 + length);\n  return range;\n};\nvar segmentGraphemes = function(value) {\n  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {\n    var segmenter = new Intl.Segmenter(void 0, { granularity: \"grapheme\" });\n    return Array.from(segmenter.segment(value)).map(function(segment) {\n      return segment.segment;\n    });\n  }\n  return splitGraphemes(value);\n};\nvar segmentWords = function(value, styles) {\n  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {\n    var segmenter = new Intl.Segmenter(void 0, {\n      granularity: \"word\"\n    });\n    return Array.from(segmenter.segment(value)).map(function(segment) {\n      return segment.segment;\n    });\n  }\n  return breakWords(value, styles);\n};\nvar breakText = function(value, styles) {\n  return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);\n};\nvar wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];\nvar breakWords = function(str, styles) {\n  var breaker = LineBreaker(str, {\n    lineBreak: styles.lineBreak,\n    wordBreak: styles.overflowWrap === \"break-word\" ? \"break-word\" : styles.wordBreak\n  });\n  var words = [];\n  var bk;\n  var _loop_1 = function() {\n    if (bk.value) {\n      var value = bk.value.slice();\n      var codePoints = toCodePoints$1(value);\n      var word_1 = \"\";\n      codePoints.forEach(function(codePoint) {\n        if (wordSeparators.indexOf(codePoint) === -1) {\n          word_1 += fromCodePoint$1(codePoint);\n        } else {\n          if (word_1.length) {\n            words.push(word_1);\n          }\n          words.push(fromCodePoint$1(codePoint));\n          word_1 = \"\";\n        }\n      });\n      if (word_1.length) {\n        words.push(word_1);\n      }\n    }\n  };\n  while (!(bk = breaker.next()).done) {\n    _loop_1();\n  }\n  return words;\n};\nvar TextContainer = function() {\n  function TextContainer2(context, node2, styles) {\n    this.text = transform(node2.data, styles.textTransform);\n    this.textBounds = parseTextBounds(context, this.text, styles, node2);\n  }\n  return TextContainer2;\n}();\nvar transform = function(text2, transform2) {\n  switch (transform2) {\n    case 1:\n      return text2.toLowerCase();\n    case 3:\n      return text2.replace(CAPITALIZE, capitalize);\n    case 2:\n      return text2.toUpperCase();\n    default:\n      return text2;\n  }\n};\nvar CAPITALIZE = /(^|\\s|:|-|\\(|\\))([a-z])/g;\nvar capitalize = function(m2, p12, p22) {\n  if (m2.length > 0) {\n    return p12 + p22.toUpperCase();\n  }\n  return m2;\n};\nvar ImageElementContainer = function(_super) {\n  __extends(ImageElementContainer2, _super);\n  function ImageElementContainer2(context, img) {\n    var _this = _super.call(this, context, img) || this;\n    _this.src = img.currentSrc || img.src;\n    _this.intrinsicWidth = img.naturalWidth;\n    _this.intrinsicHeight = img.naturalHeight;\n    _this.context.cache.addImage(_this.src);\n    return _this;\n  }\n  return ImageElementContainer2;\n}(ElementContainer);\nvar CanvasElementContainer = function(_super) {\n  __extends(CanvasElementContainer2, _super);\n  function CanvasElementContainer2(context, canvas) {\n    var _this = _super.call(this, context, canvas) || this;\n    _this.canvas = canvas;\n    _this.intrinsicWidth = canvas.width;\n    _this.intrinsicHeight = canvas.height;\n    return _this;\n  }\n  return CanvasElementContainer2;\n}(ElementContainer);\nvar SVGElementContainer = function(_super) {\n  __extends(SVGElementContainer2, _super);\n  function SVGElementContainer2(context, img) {\n    var _this = _super.call(this, context, img) || this;\n    var s2 = new XMLSerializer();\n    var bounds = parseBounds(context, img);\n    img.setAttribute(\"width\", bounds.width + \"px\");\n    img.setAttribute(\"height\", bounds.height + \"px\");\n    _this.svg = \"data:image/svg+xml,\" + encodeURIComponent(s2.serializeToString(img));\n    _this.intrinsicWidth = img.width.baseVal.value;\n    _this.intrinsicHeight = img.height.baseVal.value;\n    _this.context.cache.addImage(_this.svg);\n    return _this;\n  }\n  return SVGElementContainer2;\n}(ElementContainer);\nvar LIElementContainer = function(_super) {\n  __extends(LIElementContainer2, _super);\n  function LIElementContainer2(context, element) {\n    var _this = _super.call(this, context, element) || this;\n    _this.value = element.value;\n    return _this;\n  }\n  return LIElementContainer2;\n}(ElementContainer);\nvar OLElementContainer = function(_super) {\n  __extends(OLElementContainer2, _super);\n  function OLElementContainer2(context, element) {\n    var _this = _super.call(this, context, element) || this;\n    _this.start = element.start;\n    _this.reversed = typeof element.reversed === \"boolean\" && element.reversed === true;\n    return _this;\n  }\n  return OLElementContainer2;\n}(ElementContainer);\nvar CHECKBOX_BORDER_RADIUS = [\n  {\n    type: 15,\n    flags: 0,\n    unit: \"px\",\n    number: 3\n  }\n];\nvar RADIO_BORDER_RADIUS = [\n  {\n    type: 16,\n    flags: 0,\n    number: 50\n  }\n];\nvar reformatInputBounds = function(bounds) {\n  if (bounds.width > bounds.height) {\n    return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);\n  } else if (bounds.width < bounds.height) {\n    return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);\n  }\n  return bounds;\n};\nvar getInputValue = function(node2) {\n  var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join(\"\\u2022\") : node2.value;\n  return value.length === 0 ? node2.placeholder || \"\" : value;\n};\nvar CHECKBOX = \"checkbox\";\nvar RADIO = \"radio\";\nvar PASSWORD = \"password\";\nvar INPUT_COLOR = 707406591;\nvar InputElementContainer = function(_super) {\n  __extends(InputElementContainer2, _super);\n  function InputElementContainer2(context, input) {\n    var _this = _super.call(this, context, input) || this;\n    _this.type = input.type.toLowerCase();\n    _this.checked = input.checked;\n    _this.value = getInputValue(input);\n    if (_this.type === CHECKBOX || _this.type === RADIO) {\n      _this.styles.backgroundColor = 3739148031;\n      _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;\n      _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;\n      _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;\n      _this.styles.backgroundClip = [0];\n      _this.styles.backgroundOrigin = [0];\n      _this.bounds = reformatInputBounds(_this.bounds);\n    }\n    switch (_this.type) {\n      case CHECKBOX:\n        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;\n        break;\n      case RADIO:\n        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;\n        break;\n    }\n    return _this;\n  }\n  return InputElementContainer2;\n}(ElementContainer);\nvar SelectElementContainer = function(_super) {\n  __extends(SelectElementContainer2, _super);\n  function SelectElementContainer2(context, element) {\n    var _this = _super.call(this, context, element) || this;\n    var option = element.options[element.selectedIndex || 0];\n    _this.value = option ? option.text || \"\" : \"\";\n    return _this;\n  }\n  return SelectElementContainer2;\n}(ElementContainer);\nvar TextareaElementContainer = function(_super) {\n  __extends(TextareaElementContainer2, _super);\n  function TextareaElementContainer2(context, element) {\n    var _this = _super.call(this, context, element) || this;\n    _this.value = element.value;\n    return _this;\n  }\n  return TextareaElementContainer2;\n}(ElementContainer);\nvar IFrameElementContainer = function(_super) {\n  __extends(IFrameElementContainer2, _super);\n  function IFrameElementContainer2(context, iframe) {\n    var _this = _super.call(this, context, iframe) || this;\n    _this.src = iframe.src;\n    _this.width = parseInt(iframe.width, 10) || 0;\n    _this.height = parseInt(iframe.height, 10) || 0;\n    _this.backgroundColor = _this.styles.backgroundColor;\n    try {\n      if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {\n        _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);\n        var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;\n        var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;\n        _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;\n      }\n    } catch (e2) {\n    }\n    return _this;\n  }\n  return IFrameElementContainer2;\n}(ElementContainer);\nvar LIST_OWNERS = [\"OL\", \"UL\", \"MENU\"];\nvar parseNodeTree = function(context, node2, parent, root2) {\n  for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {\n    nextNode = childNode.nextSibling;\n    if (isTextNode(childNode) && childNode.data.trim().length > 0) {\n      parent.textNodes.push(new TextContainer(context, childNode, parent.styles));\n    } else if (isElementNode(childNode)) {\n      if (isSlotElement(childNode) && childNode.assignedNodes) {\n        childNode.assignedNodes().forEach(function(childNode2) {\n          return parseNodeTree(context, childNode2, parent, root2);\n        });\n      } else {\n        var container = createContainer(context, childNode);\n        if (container.styles.isVisible()) {\n          if (createsRealStackingContext(childNode, container, root2)) {\n            container.flags |= 4;\n          } else if (createsStackingContext(container.styles)) {\n            container.flags |= 2;\n          }\n          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {\n            container.flags |= 8;\n          }\n          parent.elements.push(container);\n          childNode.slot;\n          if (childNode.shadowRoot) {\n            parseNodeTree(context, childNode.shadowRoot, container, root2);\n          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {\n            parseNodeTree(context, childNode, container, root2);\n          }\n        }\n      }\n    }\n  }\n};\nvar createContainer = function(context, element) {\n  if (isImageElement(element)) {\n    return new ImageElementContainer(context, element);\n  }\n  if (isCanvasElement(element)) {\n    return new CanvasElementContainer(context, element);\n  }\n  if (isSVGElement(element)) {\n    return new SVGElementContainer(context, element);\n  }\n  if (isLIElement(element)) {\n    return new LIElementContainer(context, element);\n  }\n  if (isOLElement(element)) {\n    return new OLElementContainer(context, element);\n  }\n  if (isInputElement(element)) {\n    return new InputElementContainer(context, element);\n  }\n  if (isSelectElement(element)) {\n    return new SelectElementContainer(context, element);\n  }\n  if (isTextareaElement(element)) {\n    return new TextareaElementContainer(context, element);\n  }\n  if (isIFrameElement(element)) {\n    return new IFrameElementContainer(context, element);\n  }\n  return new ElementContainer(context, element);\n};\nvar parseTree = function(context, element) {\n  var container = createContainer(context, element);\n  container.flags |= 4;\n  parseNodeTree(context, element, container, container);\n  return container;\n};\nvar createsRealStackingContext = function(node2, container, root2) {\n  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root2.styles.isTransparent();\n};\nvar createsStackingContext = function(styles) {\n  return styles.isPositioned() || styles.isFloating();\n};\nvar isTextNode = function(node2) {\n  return node2.nodeType === Node.TEXT_NODE;\n};\nvar isElementNode = function(node2) {\n  return node2.nodeType === Node.ELEMENT_NODE;\n};\nvar isHTMLElementNode = function(node2) {\n  return isElementNode(node2) && typeof node2.style !== \"undefined\" && !isSVGElementNode(node2);\n};\nvar isSVGElementNode = function(element) {\n  return typeof element.className === \"object\";\n};\nvar isLIElement = function(node2) {\n  return node2.tagName === \"LI\";\n};\nvar isOLElement = function(node2) {\n  return node2.tagName === \"OL\";\n};\nvar isInputElement = function(node2) {\n  return node2.tagName === \"INPUT\";\n};\nvar isHTMLElement = function(node2) {\n  return node2.tagName === \"HTML\";\n};\nvar isSVGElement = function(node2) {\n  return node2.tagName === \"svg\";\n};\nvar isBodyElement = function(node2) {\n  return node2.tagName === \"BODY\";\n};\nvar isCanvasElement = function(node2) {\n  return node2.tagName === \"CANVAS\";\n};\nvar isVideoElement = function(node2) {\n  return node2.tagName === \"VIDEO\";\n};\nvar isImageElement = function(node2) {\n  return node2.tagName === \"IMG\";\n};\nvar isIFrameElement = function(node2) {\n  return node2.tagName === \"IFRAME\";\n};\nvar isStyleElement = function(node2) {\n  return node2.tagName === \"STYLE\";\n};\nvar isScriptElement = function(node2) {\n  return node2.tagName === \"SCRIPT\";\n};\nvar isTextareaElement = function(node2) {\n  return node2.tagName === \"TEXTAREA\";\n};\nvar isSelectElement = function(node2) {\n  return node2.tagName === \"SELECT\";\n};\nvar isSlotElement = function(node2) {\n  return node2.tagName === \"SLOT\";\n};\nvar isCustomElement = function(node2) {\n  return node2.tagName.indexOf(\"-\") > 0;\n};\nvar CounterState = function() {\n  function CounterState2() {\n    this.counters = {};\n  }\n  CounterState2.prototype.getCounterValue = function(name) {\n    var counter2 = this.counters[name];\n    if (counter2 && counter2.length) {\n      return counter2[counter2.length - 1];\n    }\n    return 1;\n  };\n  CounterState2.prototype.getCounterValues = function(name) {\n    var counter2 = this.counters[name];\n    return counter2 ? counter2 : [];\n  };\n  CounterState2.prototype.pop = function(counters) {\n    var _this = this;\n    counters.forEach(function(counter2) {\n      return _this.counters[counter2].pop();\n    });\n  };\n  CounterState2.prototype.parse = function(style2) {\n    var _this = this;\n    var counterIncrement2 = style2.counterIncrement;\n    var counterReset2 = style2.counterReset;\n    var canReset = true;\n    if (counterIncrement2 !== null) {\n      counterIncrement2.forEach(function(entry) {\n        var counter2 = _this.counters[entry.counter];\n        if (counter2 && entry.increment !== 0) {\n          canReset = false;\n          if (!counter2.length) {\n            counter2.push(1);\n          }\n          counter2[Math.max(0, counter2.length - 1)] += entry.increment;\n        }\n      });\n    }\n    var counterNames = [];\n    if (canReset) {\n      counterReset2.forEach(function(entry) {\n        var counter2 = _this.counters[entry.counter];\n        counterNames.push(entry.counter);\n        if (!counter2) {\n          counter2 = _this.counters[entry.counter] = [];\n        }\n        counter2.push(entry.reset);\n      });\n    }\n    return counterNames;\n  };\n  return CounterState2;\n}();\nvar ROMAN_UPPER = {\n  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],\n  values: [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n};\nvar ARMENIAN = {\n  integers: [\n    9e3,\n    8e3,\n    7e3,\n    6e3,\n    5e3,\n    4e3,\n    3e3,\n    2e3,\n    1e3,\n    900,\n    800,\n    700,\n    600,\n    500,\n    400,\n    300,\n    200,\n    100,\n    90,\n    80,\n    70,\n    60,\n    50,\n    40,\n    30,\n    20,\n    10,\n    9,\n    8,\n    7,\n    6,\n    5,\n    4,\n    3,\n    2,\n    1\n  ],\n  values: [\n    \"\\u0554\",\n    \"\\u0553\",\n    \"\\u0552\",\n    \"\\u0551\",\n    \"\\u0550\",\n    \"\\u054F\",\n    \"\\u054E\",\n    \"\\u054D\",\n    \"\\u054C\",\n    \"\\u054B\",\n    \"\\u054A\",\n    \"\\u0549\",\n    \"\\u0548\",\n    \"\\u0547\",\n    \"\\u0546\",\n    \"\\u0545\",\n    \"\\u0544\",\n    \"\\u0543\",\n    \"\\u0542\",\n    \"\\u0541\",\n    \"\\u0540\",\n    \"\\u053F\",\n    \"\\u053E\",\n    \"\\u053D\",\n    \"\\u053C\",\n    \"\\u053B\",\n    \"\\u053A\",\n    \"\\u0539\",\n    \"\\u0538\",\n    \"\\u0537\",\n    \"\\u0536\",\n    \"\\u0535\",\n    \"\\u0534\",\n    \"\\u0533\",\n    \"\\u0532\",\n    \"\\u0531\"\n  ]\n};\nvar HEBREW = {\n  integers: [\n    1e4,\n    9e3,\n    8e3,\n    7e3,\n    6e3,\n    5e3,\n    4e3,\n    3e3,\n    2e3,\n    1e3,\n    400,\n    300,\n    200,\n    100,\n    90,\n    80,\n    70,\n    60,\n    50,\n    40,\n    30,\n    20,\n    19,\n    18,\n    17,\n    16,\n    15,\n    10,\n    9,\n    8,\n    7,\n    6,\n    5,\n    4,\n    3,\n    2,\n    1\n  ],\n  values: [\n    \"\\u05D9\\u05F3\",\n    \"\\u05D8\\u05F3\",\n    \"\\u05D7\\u05F3\",\n    \"\\u05D6\\u05F3\",\n    \"\\u05D5\\u05F3\",\n    \"\\u05D4\\u05F3\",\n    \"\\u05D3\\u05F3\",\n    \"\\u05D2\\u05F3\",\n    \"\\u05D1\\u05F3\",\n    \"\\u05D0\\u05F3\",\n    \"\\u05EA\",\n    \"\\u05E9\",\n    \"\\u05E8\",\n    \"\\u05E7\",\n    \"\\u05E6\",\n    \"\\u05E4\",\n    \"\\u05E2\",\n    \"\\u05E1\",\n    \"\\u05E0\",\n    \"\\u05DE\",\n    \"\\u05DC\",\n    \"\\u05DB\",\n    \"\\u05D9\\u05D8\",\n    \"\\u05D9\\u05D7\",\n    \"\\u05D9\\u05D6\",\n    \"\\u05D8\\u05D6\",\n    \"\\u05D8\\u05D5\",\n    \"\\u05D9\",\n    \"\\u05D8\",\n    \"\\u05D7\",\n    \"\\u05D6\",\n    \"\\u05D5\",\n    \"\\u05D4\",\n    \"\\u05D3\",\n    \"\\u05D2\",\n    \"\\u05D1\",\n    \"\\u05D0\"\n  ]\n};\nvar GEORGIAN = {\n  integers: [\n    1e4,\n    9e3,\n    8e3,\n    7e3,\n    6e3,\n    5e3,\n    4e3,\n    3e3,\n    2e3,\n    1e3,\n    900,\n    800,\n    700,\n    600,\n    500,\n    400,\n    300,\n    200,\n    100,\n    90,\n    80,\n    70,\n    60,\n    50,\n    40,\n    30,\n    20,\n    10,\n    9,\n    8,\n    7,\n    6,\n    5,\n    4,\n    3,\n    2,\n    1\n  ],\n  values: [\n    \"\\u10F5\",\n    \"\\u10F0\",\n    \"\\u10EF\",\n    \"\\u10F4\",\n    \"\\u10EE\",\n    \"\\u10ED\",\n    \"\\u10EC\",\n    \"\\u10EB\",\n    \"\\u10EA\",\n    \"\\u10E9\",\n    \"\\u10E8\",\n    \"\\u10E7\",\n    \"\\u10E6\",\n    \"\\u10E5\",\n    \"\\u10E4\",\n    \"\\u10F3\",\n    \"\\u10E2\",\n    \"\\u10E1\",\n    \"\\u10E0\",\n    \"\\u10DF\",\n    \"\\u10DE\",\n    \"\\u10DD\",\n    \"\\u10F2\",\n    \"\\u10DC\",\n    \"\\u10DB\",\n    \"\\u10DA\",\n    \"\\u10D9\",\n    \"\\u10D8\",\n    \"\\u10D7\",\n    \"\\u10F1\",\n    \"\\u10D6\",\n    \"\\u10D5\",\n    \"\\u10D4\",\n    \"\\u10D3\",\n    \"\\u10D2\",\n    \"\\u10D1\",\n    \"\\u10D0\"\n  ]\n};\nvar createAdditiveCounter = function(value, min2, max2, symbols, fallback, suffix2) {\n  if (value < min2 || value > max2) {\n    return createCounterText(value, fallback, suffix2.length > 0);\n  }\n  return symbols.integers.reduce(function(string, integer, index2) {\n    while (value >= integer) {\n      value -= integer;\n      string += symbols.values[index2];\n    }\n    return string;\n  }, \"\") + suffix2;\n};\nvar createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {\n  var string = \"\";\n  do {\n    if (!isNumeric) {\n      value--;\n    }\n    string = resolver(value) + string;\n    value /= codePointRangeLength;\n  } while (value * codePointRangeLength >= codePointRangeLength);\n  return string;\n};\nvar createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix2) {\n  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;\n  return (value < 0 ? \"-\" : \"\") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {\n    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);\n  }) + suffix2);\n};\nvar createCounterStyleFromSymbols = function(value, symbols, suffix2) {\n  if (suffix2 === void 0) {\n    suffix2 = \". \";\n  }\n  var codePointRangeLength = symbols.length;\n  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {\n    return symbols[Math.floor(codePoint % codePointRangeLength)];\n  }) + suffix2;\n};\nvar CJK_ZEROS = 1 << 0;\nvar CJK_TEN_COEFFICIENTS = 1 << 1;\nvar CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;\nvar CJK_HUNDRED_COEFFICIENTS = 1 << 3;\nvar createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix2, flags) {\n  if (value < -9999 || value > 9999) {\n    return createCounterText(value, 4, suffix2.length > 0);\n  }\n  var tmp = Math.abs(value);\n  var string = suffix2;\n  if (tmp === 0) {\n    return numbers[0] + string;\n  }\n  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {\n    var coefficient = tmp % 10;\n    if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== \"\") {\n      string = numbers[coefficient] + string;\n    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {\n      string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : \"\") + string;\n    } else if (coefficient === 1 && digit > 0) {\n      string = multipliers[digit - 1] + string;\n    }\n    tmp = Math.floor(tmp / 10);\n  }\n  return (value < 0 ? negativeSign : \"\") + string;\n};\nvar CHINESE_INFORMAL_MULTIPLIERS = \"\\u5341\\u767E\\u5343\\u842C\";\nvar CHINESE_FORMAL_MULTIPLIERS = \"\\u62FE\\u4F70\\u4EDF\\u842C\";\nvar JAPANESE_NEGATIVE = \"\\u30DE\\u30A4\\u30CA\\u30B9\";\nvar KOREAN_NEGATIVE = \"\\uB9C8\\uC774\\uB108\\uC2A4\";\nvar createCounterText = function(value, type, appendSuffix) {\n  var defaultSuffix = appendSuffix ? \". \" : \"\";\n  var cjkSuffix = appendSuffix ? \"\\u3001\" : \"\";\n  var koreanSuffix = appendSuffix ? \", \" : \"\";\n  var spaceSuffix = appendSuffix ? \" \" : \"\";\n  switch (type) {\n    case 0:\n      return \"\\u2022\" + spaceSuffix;\n    case 1:\n      return \"\\u25E6\" + spaceSuffix;\n    case 2:\n      return \"\\u25FE\" + spaceSuffix;\n    case 5:\n      var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);\n      return string.length < 4 ? \"0\" + string : string;\n    case 4:\n      return createCounterStyleFromSymbols(value, \"\\u3007\\u4E00\\u4E8C\\u4E09\\u56DB\\u4E94\\u516D\\u4E03\\u516B\\u4E5D\", cjkSuffix);\n    case 6:\n      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();\n    case 7:\n      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);\n    case 8:\n      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);\n    case 9:\n      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);\n    case 10:\n      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);\n    case 11:\n      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);\n    case 12:\n    case 49:\n      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);\n    case 35:\n      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();\n    case 13:\n      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);\n    case 14:\n    case 30:\n      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);\n    case 15:\n      return createCounterStyleFromSymbols(value, \"\\u5B50\\u4E11\\u5BC5\\u536F\\u8FB0\\u5DF3\\u5348\\u672A\\u7533\\u9149\\u620C\\u4EA5\", cjkSuffix);\n    case 16:\n      return createCounterStyleFromSymbols(value, \"\\u7532\\u4E59\\u4E19\\u4E01\\u620A\\u5DF1\\u5E9A\\u8F9B\\u58EC\\u7678\", cjkSuffix);\n    case 17:\n    case 48:\n      return createCJKCounter(value, \"\\u96F6\\u4E00\\u4E8C\\u4E09\\u56DB\\u4E94\\u516D\\u4E03\\u516B\\u4E5D\", CHINESE_INFORMAL_MULTIPLIERS, \"\\u8CA0\", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);\n    case 47:\n      return createCJKCounter(value, \"\\u96F6\\u58F9\\u8CB3\\u53C3\\u8086\\u4F0D\\u9678\\u67D2\\u634C\\u7396\", CHINESE_FORMAL_MULTIPLIERS, \"\\u8CA0\", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);\n    case 42:\n      return createCJKCounter(value, \"\\u96F6\\u4E00\\u4E8C\\u4E09\\u56DB\\u4E94\\u516D\\u4E03\\u516B\\u4E5D\", CHINESE_INFORMAL_MULTIPLIERS, \"\\u8D1F\", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);\n    case 41:\n      return createCJKCounter(value, \"\\u96F6\\u58F9\\u8D30\\u53C1\\u8086\\u4F0D\\u9646\\u67D2\\u634C\\u7396\", CHINESE_FORMAL_MULTIPLIERS, \"\\u8D1F\", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);\n    case 26:\n      return createCJKCounter(value, \"\\u3007\\u4E00\\u4E8C\\u4E09\\u56DB\\u4E94\\u516D\\u4E03\\u516B\\u4E5D\", \"\\u5341\\u767E\\u5343\\u4E07\", JAPANESE_NEGATIVE, cjkSuffix, 0);\n    case 25:\n      return createCJKCounter(value, \"\\u96F6\\u58F1\\u5F10\\u53C2\\u56DB\\u4F0D\\u516D\\u4E03\\u516B\\u4E5D\", \"\\u62FE\\u767E\\u5343\\u4E07\", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);\n    case 31:\n      return createCJKCounter(value, \"\\uC601\\uC77C\\uC774\\uC0BC\\uC0AC\\uC624\\uC721\\uCE60\\uD314\\uAD6C\", \"\\uC2ED\\uBC31\\uCC9C\\uB9CC\", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);\n    case 33:\n      return createCJKCounter(value, \"\\u96F6\\u4E00\\u4E8C\\u4E09\\u56DB\\u4E94\\u516D\\u4E03\\u516B\\u4E5D\", \"\\u5341\\u767E\\u5343\\u842C\", KOREAN_NEGATIVE, koreanSuffix, 0);\n    case 32:\n      return createCJKCounter(value, \"\\u96F6\\u58F9\\u8CB3\\u53C3\\u56DB\\u4E94\\u516D\\u4E03\\u516B\\u4E5D\", \"\\u62FE\\u767E\\u5343\", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);\n    case 18:\n      return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);\n    case 20:\n      return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);\n    case 21:\n      return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);\n    case 22:\n      return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);\n    case 22:\n      return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);\n    case 23:\n      return createCounterStyleFromSymbols(value, \"\\u3042\\u3044\\u3046\\u3048\\u304A\\u304B\\u304D\\u304F\\u3051\\u3053\\u3055\\u3057\\u3059\\u305B\\u305D\\u305F\\u3061\\u3064\\u3066\\u3068\\u306A\\u306B\\u306C\\u306D\\u306E\\u306F\\u3072\\u3075\\u3078\\u307B\\u307E\\u307F\\u3080\\u3081\\u3082\\u3084\\u3086\\u3088\\u3089\\u308A\\u308B\\u308C\\u308D\\u308F\\u3090\\u3091\\u3092\\u3093\");\n    case 24:\n      return createCounterStyleFromSymbols(value, \"\\u3044\\u308D\\u306F\\u306B\\u307B\\u3078\\u3068\\u3061\\u308A\\u306C\\u308B\\u3092\\u308F\\u304B\\u3088\\u305F\\u308C\\u305D\\u3064\\u306D\\u306A\\u3089\\u3080\\u3046\\u3090\\u306E\\u304A\\u304F\\u3084\\u307E\\u3051\\u3075\\u3053\\u3048\\u3066\\u3042\\u3055\\u304D\\u3086\\u3081\\u307F\\u3057\\u3091\\u3072\\u3082\\u305B\\u3059\");\n    case 27:\n      return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);\n    case 28:\n      return createCounterStyleFromSymbols(value, \"\\u30A2\\u30A4\\u30A6\\u30A8\\u30AA\\u30AB\\u30AD\\u30AF\\u30B1\\u30B3\\u30B5\\u30B7\\u30B9\\u30BB\\u30BD\\u30BF\\u30C1\\u30C4\\u30C6\\u30C8\\u30CA\\u30CB\\u30CC\\u30CD\\u30CE\\u30CF\\u30D2\\u30D5\\u30D8\\u30DB\\u30DE\\u30DF\\u30E0\\u30E1\\u30E2\\u30E4\\u30E6\\u30E8\\u30E9\\u30EA\\u30EB\\u30EC\\u30ED\\u30EF\\u30F0\\u30F1\\u30F2\\u30F3\", cjkSuffix);\n    case 29:\n      return createCounterStyleFromSymbols(value, \"\\u30A4\\u30ED\\u30CF\\u30CB\\u30DB\\u30D8\\u30C8\\u30C1\\u30EA\\u30CC\\u30EB\\u30F2\\u30EF\\u30AB\\u30E8\\u30BF\\u30EC\\u30BD\\u30C4\\u30CD\\u30CA\\u30E9\\u30E0\\u30A6\\u30F0\\u30CE\\u30AA\\u30AF\\u30E4\\u30DE\\u30B1\\u30D5\\u30B3\\u30A8\\u30C6\\u30A2\\u30B5\\u30AD\\u30E6\\u30E1\\u30DF\\u30B7\\u30F1\\u30D2\\u30E2\\u30BB\\u30B9\", cjkSuffix);\n    case 34:\n      return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);\n    case 37:\n      return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);\n    case 38:\n      return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);\n    case 39:\n      return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);\n    case 40:\n      return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);\n    case 43:\n      return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);\n    case 44:\n      return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);\n    case 45:\n      return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);\n    case 46:\n      return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);\n    case 3:\n    default:\n      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);\n  }\n};\nvar IGNORE_ATTRIBUTE = \"data-html2canvas-ignore\";\nvar DocumentCloner = function() {\n  function DocumentCloner2(context, element, options) {\n    this.context = context;\n    this.options = options;\n    this.scrolledElements = [];\n    this.referenceElement = element;\n    this.counters = new CounterState();\n    this.quoteDepth = 0;\n    if (!element.ownerDocument) {\n      throw new Error(\"Cloned element does not have an owner document\");\n    }\n    this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);\n  }\n  DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {\n    var _this = this;\n    var iframe = createIFrameContainer(ownerDocument, windowSize);\n    if (!iframe.contentWindow) {\n      return Promise.reject(\"Unable to find iframe window\");\n    }\n    var scrollX = ownerDocument.defaultView.pageXOffset;\n    var scrollY = ownerDocument.defaultView.pageYOffset;\n    var cloneWindow = iframe.contentWindow;\n    var documentClone = cloneWindow.document;\n    var iframeLoad = iframeLoader(iframe).then(function() {\n      return __awaiter(_this, void 0, void 0, function() {\n        var onclone, referenceElement;\n        return __generator(this, function(_a2) {\n          switch (_a2.label) {\n            case 0:\n              this.scrolledElements.forEach(restoreNodeScroll);\n              if (cloneWindow) {\n                cloneWindow.scrollTo(windowSize.left, windowSize.top);\n                if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {\n                  this.context.logger.warn(\"Unable to restore scroll position for cloned document\");\n                  this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);\n                }\n              }\n              onclone = this.options.onclone;\n              referenceElement = this.clonedReferenceElement;\n              if (typeof referenceElement === \"undefined\") {\n                return [2, Promise.reject(\"Error finding the \" + this.referenceElement.nodeName + \" in the cloned document\")];\n              }\n              if (!(documentClone.fonts && documentClone.fonts.ready))\n                return [3, 2];\n              return [4, documentClone.fonts.ready];\n            case 1:\n              _a2.sent();\n              _a2.label = 2;\n            case 2:\n              if (!/(AppleWebKit)/g.test(navigator.userAgent))\n                return [3, 4];\n              return [4, imagesReady(documentClone)];\n            case 3:\n              _a2.sent();\n              _a2.label = 4;\n            case 4:\n              if (typeof onclone === \"function\") {\n                return [2, Promise.resolve().then(function() {\n                  return onclone(documentClone, referenceElement);\n                }).then(function() {\n                  return iframe;\n                })];\n              }\n              return [2, iframe];\n          }\n        });\n      });\n    });\n    documentClone.open();\n    documentClone.write(serializeDoctype(document.doctype) + \"<html></html>\");\n    restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);\n    documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);\n    documentClone.close();\n    return iframeLoad;\n  };\n  DocumentCloner2.prototype.createElementClone = function(node2) {\n    if (isDebugging(node2, 2)) {\n      debugger;\n    }\n    if (isCanvasElement(node2)) {\n      return this.createCanvasClone(node2);\n    }\n    if (isVideoElement(node2)) {\n      return this.createVideoClone(node2);\n    }\n    if (isStyleElement(node2)) {\n      return this.createStyleClone(node2);\n    }\n    var clone2 = node2.cloneNode(false);\n    if (isImageElement(clone2)) {\n      if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {\n        clone2.src = node2.currentSrc;\n        clone2.srcset = \"\";\n      }\n      if (clone2.loading === \"lazy\") {\n        clone2.loading = \"eager\";\n      }\n    }\n    if (isCustomElement(clone2)) {\n      return this.createCustomElementClone(clone2);\n    }\n    return clone2;\n  };\n  DocumentCloner2.prototype.createCustomElementClone = function(node2) {\n    var clone2 = document.createElement(\"html2canvascustomelement\");\n    copyCSSStyles(node2.style, clone2);\n    return clone2;\n  };\n  DocumentCloner2.prototype.createStyleClone = function(node2) {\n    try {\n      var sheet = node2.sheet;\n      if (sheet && sheet.cssRules) {\n        var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {\n          if (rule && typeof rule.cssText === \"string\") {\n            return css2 + rule.cssText;\n          }\n          return css2;\n        }, \"\");\n        var style2 = node2.cloneNode(false);\n        style2.textContent = css;\n        return style2;\n      }\n    } catch (e2) {\n      this.context.logger.error(\"Unable to access cssRules property\", e2);\n      if (e2.name !== \"SecurityError\") {\n        throw e2;\n      }\n    }\n    return node2.cloneNode(false);\n  };\n  DocumentCloner2.prototype.createCanvasClone = function(canvas) {\n    var _a2;\n    if (this.options.inlineImages && canvas.ownerDocument) {\n      var img = canvas.ownerDocument.createElement(\"img\");\n      try {\n        img.src = canvas.toDataURL();\n        return img;\n      } catch (e2) {\n        this.context.logger.info(\"Unable to inline canvas contents, canvas is tainted\", canvas);\n      }\n    }\n    var clonedCanvas = canvas.cloneNode(false);\n    try {\n      clonedCanvas.width = canvas.width;\n      clonedCanvas.height = canvas.height;\n      var ctx = canvas.getContext(\"2d\");\n      var clonedCtx = clonedCanvas.getContext(\"2d\");\n      if (clonedCtx) {\n        if (!this.options.allowTaint && ctx) {\n          clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);\n        } else {\n          var gl = (_a2 = canvas.getContext(\"webgl2\")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext(\"webgl\");\n          if (gl) {\n            var attribs = gl.getContextAttributes();\n            if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {\n              this.context.logger.warn(\"Unable to clone WebGL context as it has preserveDrawingBuffer=false\", canvas);\n            }\n          }\n          clonedCtx.drawImage(canvas, 0, 0);\n        }\n      }\n      return clonedCanvas;\n    } catch (e2) {\n      this.context.logger.info(\"Unable to clone canvas as it is tainted\", canvas);\n    }\n    return clonedCanvas;\n  };\n  DocumentCloner2.prototype.createVideoClone = function(video) {\n    var canvas = video.ownerDocument.createElement(\"canvas\");\n    canvas.width = video.offsetWidth;\n    canvas.height = video.offsetHeight;\n    var ctx = canvas.getContext(\"2d\");\n    try {\n      if (ctx) {\n        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        if (!this.options.allowTaint) {\n          ctx.getImageData(0, 0, canvas.width, canvas.height);\n        }\n      }\n      return canvas;\n    } catch (e2) {\n      this.context.logger.info(\"Unable to clone video as it is tainted\", video);\n    }\n    var blankCanvas = video.ownerDocument.createElement(\"canvas\");\n    blankCanvas.width = video.offsetWidth;\n    blankCanvas.height = video.offsetHeight;\n    return blankCanvas;\n  };\n  DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {\n    if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== \"function\" || !this.options.ignoreElements(child))) {\n      if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {\n        clone2.appendChild(this.cloneNode(child, copyStyles));\n      }\n    }\n  };\n  DocumentCloner2.prototype.cloneChildNodes = function(node2, clone2, copyStyles) {\n    var _this = this;\n    for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {\n      if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === \"function\") {\n        var assignedNodes = child.assignedNodes();\n        if (assignedNodes.length) {\n          assignedNodes.forEach(function(assignedNode) {\n            return _this.appendChildNode(clone2, assignedNode, copyStyles);\n          });\n        }\n      } else {\n        this.appendChildNode(clone2, child, copyStyles);\n      }\n    }\n  };\n  DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {\n    if (isTextNode(node2)) {\n      return document.createTextNode(node2.data);\n    }\n    if (!node2.ownerDocument) {\n      return node2.cloneNode(false);\n    }\n    var window2 = node2.ownerDocument.defaultView;\n    if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {\n      var clone2 = this.createElementClone(node2);\n      clone2.style.transitionProperty = \"none\";\n      var style2 = window2.getComputedStyle(node2);\n      var styleBefore = window2.getComputedStyle(node2, \":before\");\n      var styleAfter = window2.getComputedStyle(node2, \":after\");\n      if (this.referenceElement === node2 && isHTMLElementNode(clone2)) {\n        this.clonedReferenceElement = clone2;\n      }\n      if (isBodyElement(clone2)) {\n        createPseudoHideStyles(clone2);\n      }\n      var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));\n      var before = this.resolvePseudoContent(node2, clone2, styleBefore, PseudoElementType.BEFORE);\n      if (isCustomElement(node2)) {\n        copyStyles = true;\n      }\n      if (!isVideoElement(node2)) {\n        this.cloneChildNodes(node2, clone2, copyStyles);\n      }\n      if (before) {\n        clone2.insertBefore(before, clone2.firstChild);\n      }\n      var after = this.resolvePseudoContent(node2, clone2, styleAfter, PseudoElementType.AFTER);\n      if (after) {\n        clone2.appendChild(after);\n      }\n      this.counters.pop(counters);\n      if (style2 && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {\n        copyCSSStyles(style2, clone2);\n      }\n      if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {\n        this.scrolledElements.push([clone2, node2.scrollLeft, node2.scrollTop]);\n      }\n      if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {\n        clone2.value = node2.value;\n      }\n      return clone2;\n    }\n    return node2.cloneNode(false);\n  };\n  DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone2, style2, pseudoElt) {\n    var _this = this;\n    if (!style2) {\n      return;\n    }\n    var value = style2.content;\n    var document2 = clone2.ownerDocument;\n    if (!document2 || !value || value === \"none\" || value === \"-moz-alt-content\" || style2.display === \"none\") {\n      return;\n    }\n    this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));\n    var declaration = new CSSParsedPseudoDeclaration(this.context, style2);\n    var anonymousReplacedElement = document2.createElement(\"html2canvaspseudoelement\");\n    copyCSSStyles(style2, anonymousReplacedElement);\n    declaration.content.forEach(function(token) {\n      if (token.type === 0) {\n        anonymousReplacedElement.appendChild(document2.createTextNode(token.value));\n      } else if (token.type === 22) {\n        var img = document2.createElement(\"img\");\n        img.src = token.value;\n        img.style.opacity = \"1\";\n        anonymousReplacedElement.appendChild(img);\n      } else if (token.type === 18) {\n        if (token.name === \"attr\") {\n          var attr = token.values.filter(isIdentToken);\n          if (attr.length) {\n            anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || \"\"));\n          }\n        } else if (token.name === \"counter\") {\n          var _a2 = token.values.filter(nonFunctionArgSeparator), counter2 = _a2[0], counterStyle = _a2[1];\n          if (counter2 && isIdentToken(counter2)) {\n            var counterState = _this.counters.getCounterValue(counter2.value);\n            var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;\n            anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));\n          }\n        } else if (token.name === \"counters\") {\n          var _b2 = token.values.filter(nonFunctionArgSeparator), counter2 = _b2[0], delim = _b2[1], counterStyle = _b2[2];\n          if (counter2 && isIdentToken(counter2)) {\n            var counterStates = _this.counters.getCounterValues(counter2.value);\n            var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;\n            var separator = delim && delim.type === 0 ? delim.value : \"\";\n            var text2 = counterStates.map(function(value2) {\n              return createCounterText(value2, counterType_1, false);\n            }).join(separator);\n            anonymousReplacedElement.appendChild(document2.createTextNode(text2));\n          }\n        } else\n          ;\n      } else if (token.type === 20) {\n        switch (token.value) {\n          case \"open-quote\":\n            anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));\n            break;\n          case \"close-quote\":\n            anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));\n            break;\n          default:\n            anonymousReplacedElement.appendChild(document2.createTextNode(token.value));\n        }\n      }\n    });\n    anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + \" \" + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;\n    var newClassName = pseudoElt === PseudoElementType.BEFORE ? \" \" + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : \" \" + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;\n    if (isSVGElementNode(clone2)) {\n      clone2.className.baseValue += newClassName;\n    } else {\n      clone2.className += newClassName;\n    }\n    return anonymousReplacedElement;\n  };\n  DocumentCloner2.destroy = function(container) {\n    if (container.parentNode) {\n      container.parentNode.removeChild(container);\n      return true;\n    }\n    return false;\n  };\n  return DocumentCloner2;\n}();\nvar PseudoElementType;\n(function(PseudoElementType2) {\n  PseudoElementType2[PseudoElementType2[\"BEFORE\"] = 0] = \"BEFORE\";\n  PseudoElementType2[PseudoElementType2[\"AFTER\"] = 1] = \"AFTER\";\n})(PseudoElementType || (PseudoElementType = {}));\nvar createIFrameContainer = function(ownerDocument, bounds) {\n  var cloneIframeContainer = ownerDocument.createElement(\"iframe\");\n  cloneIframeContainer.className = \"html2canvas-container\";\n  cloneIframeContainer.style.visibility = \"hidden\";\n  cloneIframeContainer.style.position = \"fixed\";\n  cloneIframeContainer.style.left = \"-10000px\";\n  cloneIframeContainer.style.top = \"0px\";\n  cloneIframeContainer.style.border = \"0\";\n  cloneIframeContainer.width = bounds.width.toString();\n  cloneIframeContainer.height = bounds.height.toString();\n  cloneIframeContainer.scrolling = \"no\";\n  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, \"true\");\n  ownerDocument.body.appendChild(cloneIframeContainer);\n  return cloneIframeContainer;\n};\nvar imageReady = function(img) {\n  return new Promise(function(resolve2) {\n    if (img.complete) {\n      resolve2();\n      return;\n    }\n    if (!img.src) {\n      resolve2();\n      return;\n    }\n    img.onload = resolve2;\n    img.onerror = resolve2;\n  });\n};\nvar imagesReady = function(document2) {\n  return Promise.all([].slice.call(document2.images, 0).map(imageReady));\n};\nvar iframeLoader = function(iframe) {\n  return new Promise(function(resolve2, reject2) {\n    var cloneWindow = iframe.contentWindow;\n    if (!cloneWindow) {\n      return reject2(\"No window assigned for iframe\");\n    }\n    var documentClone = cloneWindow.document;\n    cloneWindow.onload = iframe.onload = function() {\n      cloneWindow.onload = iframe.onload = null;\n      var interval = setInterval(function() {\n        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === \"complete\") {\n          clearInterval(interval);\n          resolve2(iframe);\n        }\n      }, 50);\n    };\n  });\n};\nvar ignoredStyleProperties = [\n  \"all\",\n  \"d\",\n  \"content\"\n];\nvar copyCSSStyles = function(style2, target) {\n  for (var i2 = style2.length - 1; i2 >= 0; i2--) {\n    var property = style2.item(i2);\n    if (ignoredStyleProperties.indexOf(property) === -1) {\n      target.style.setProperty(property, style2.getPropertyValue(property));\n    }\n  }\n  return target;\n};\nvar serializeDoctype = function(doctype) {\n  var str = \"\";\n  if (doctype) {\n    str += \"<!DOCTYPE \";\n    if (doctype.name) {\n      str += doctype.name;\n    }\n    if (doctype.internalSubset) {\n      str += doctype.internalSubset;\n    }\n    if (doctype.publicId) {\n      str += '\"' + doctype.publicId + '\"';\n    }\n    if (doctype.systemId) {\n      str += '\"' + doctype.systemId + '\"';\n    }\n    str += \">\";\n  }\n  return str;\n};\nvar restoreOwnerScroll = function(ownerDocument, x2, y2) {\n  if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y2 !== ownerDocument.defaultView.pageYOffset)) {\n    ownerDocument.defaultView.scrollTo(x2, y2);\n  }\n};\nvar restoreNodeScroll = function(_a2) {\n  var element = _a2[0], x2 = _a2[1], y2 = _a2[2];\n  element.scrollLeft = x2;\n  element.scrollTop = y2;\n};\nvar PSEUDO_BEFORE = \":before\";\nvar PSEUDO_AFTER = \":after\";\nvar PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = \"___html2canvas___pseudoelement_before\";\nvar PSEUDO_HIDE_ELEMENT_CLASS_AFTER = \"___html2canvas___pseudoelement_after\";\nvar PSEUDO_HIDE_ELEMENT_STYLE = '{\\n    content: \"\" !important;\\n    display: none !important;\\n}';\nvar createPseudoHideStyles = function(body) {\n  createStyles(body, \".\" + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + \"\\n         .\" + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);\n};\nvar createStyles = function(body, styles) {\n  var document2 = body.ownerDocument;\n  if (document2) {\n    var style2 = document2.createElement(\"style\");\n    style2.textContent = styles;\n    body.appendChild(style2);\n  }\n};\nvar CacheStorage = function() {\n  function CacheStorage2() {\n  }\n  CacheStorage2.getOrigin = function(url) {\n    var link = CacheStorage2._link;\n    if (!link) {\n      return \"about:blank\";\n    }\n    link.href = url;\n    link.href = link.href;\n    return link.protocol + link.hostname + link.port;\n  };\n  CacheStorage2.isSameOrigin = function(src) {\n    return CacheStorage2.getOrigin(src) === CacheStorage2._origin;\n  };\n  CacheStorage2.setContext = function(window2) {\n    CacheStorage2._link = window2.document.createElement(\"a\");\n    CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);\n  };\n  CacheStorage2._origin = \"about:blank\";\n  return CacheStorage2;\n}();\nvar Cache = function() {\n  function Cache2(context, _options) {\n    this.context = context;\n    this._options = _options;\n    this._cache = {};\n  }\n  Cache2.prototype.addImage = function(src) {\n    var result = Promise.resolve();\n    if (this.has(src)) {\n      return result;\n    }\n    if (isBlobImage(src) || isRenderable(src)) {\n      (this._cache[src] = this.loadImage(src)).catch(function() {\n      });\n      return result;\n    }\n    return result;\n  };\n  Cache2.prototype.match = function(src) {\n    return this._cache[src];\n  };\n  Cache2.prototype.loadImage = function(key) {\n    return __awaiter(this, void 0, void 0, function() {\n      var isSameOrigin, useCORS, useProxy, src;\n      var _this = this;\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            isSameOrigin = CacheStorage.isSameOrigin(key);\n            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;\n            useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === \"string\" && FEATURES.SUPPORT_CORS_XHR && !useCORS;\n            if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {\n              return [2];\n            }\n            src = key;\n            if (!useProxy)\n              return [3, 2];\n            return [4, this.proxy(src)];\n          case 1:\n            src = _a2.sent();\n            _a2.label = 2;\n          case 2:\n            this.context.logger.debug(\"Added image \" + key.substring(0, 256));\n            return [4, new Promise(function(resolve2, reject2) {\n              var img = new Image();\n              img.onload = function() {\n                return resolve2(img);\n              };\n              img.onerror = reject2;\n              if (isInlineBase64Image(src) || useCORS) {\n                img.crossOrigin = \"anonymous\";\n              }\n              img.src = src;\n              if (img.complete === true) {\n                setTimeout(function() {\n                  return resolve2(img);\n                }, 500);\n              }\n              if (_this._options.imageTimeout > 0) {\n                setTimeout(function() {\n                  return reject2(\"Timed out (\" + _this._options.imageTimeout + \"ms) loading image\");\n                }, _this._options.imageTimeout);\n              }\n            })];\n          case 3:\n            return [2, _a2.sent()];\n        }\n      });\n    });\n  };\n  Cache2.prototype.has = function(key) {\n    return typeof this._cache[key] !== \"undefined\";\n  };\n  Cache2.prototype.keys = function() {\n    return Promise.resolve(Object.keys(this._cache));\n  };\n  Cache2.prototype.proxy = function(src) {\n    var _this = this;\n    var proxy = this._options.proxy;\n    if (!proxy) {\n      throw new Error(\"No proxy defined\");\n    }\n    var key = src.substring(0, 256);\n    return new Promise(function(resolve2, reject2) {\n      var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? \"blob\" : \"text\";\n      var xhr2 = new XMLHttpRequest();\n      xhr2.onload = function() {\n        if (xhr2.status === 200) {\n          if (responseType === \"text\") {\n            resolve2(xhr2.response);\n          } else {\n            var reader_1 = new FileReader();\n            reader_1.addEventListener(\"load\", function() {\n              return resolve2(reader_1.result);\n            }, false);\n            reader_1.addEventListener(\"error\", function(e2) {\n              return reject2(e2);\n            }, false);\n            reader_1.readAsDataURL(xhr2.response);\n          }\n        } else {\n          reject2(\"Failed to proxy resource \" + key + \" with status code \" + xhr2.status);\n        }\n      };\n      xhr2.onerror = reject2;\n      var queryString = proxy.indexOf(\"?\") > -1 ? \"&\" : \"?\";\n      xhr2.open(\"GET\", \"\" + proxy + queryString + \"url=\" + encodeURIComponent(src) + \"&responseType=\" + responseType);\n      if (responseType !== \"text\" && xhr2 instanceof XMLHttpRequest) {\n        xhr2.responseType = responseType;\n      }\n      if (_this._options.imageTimeout) {\n        var timeout_1 = _this._options.imageTimeout;\n        xhr2.timeout = timeout_1;\n        xhr2.ontimeout = function() {\n          return reject2(\"Timed out (\" + timeout_1 + \"ms) proxying \" + key);\n        };\n      }\n      xhr2.send();\n    });\n  };\n  return Cache2;\n}();\nvar INLINE_SVG = /^data:image\\/svg\\+xml/i;\nvar INLINE_BASE64 = /^data:image\\/.*;base64,/i;\nvar INLINE_IMG = /^data:image\\/.*/i;\nvar isRenderable = function(src) {\n  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);\n};\nvar isInlineImage = function(src) {\n  return INLINE_IMG.test(src);\n};\nvar isInlineBase64Image = function(src) {\n  return INLINE_BASE64.test(src);\n};\nvar isBlobImage = function(src) {\n  return src.substr(0, 4) === \"blob\";\n};\nvar isSVG = function(src) {\n  return src.substr(-3).toLowerCase() === \"svg\" || INLINE_SVG.test(src);\n};\nvar Vector = function() {\n  function Vector2(x2, y2) {\n    this.type = 0;\n    this.x = x2;\n    this.y = y2;\n  }\n  Vector2.prototype.add = function(deltaX, deltaY) {\n    return new Vector2(this.x + deltaX, this.y + deltaY);\n  };\n  return Vector2;\n}();\nvar lerp = function(a2, b2, t3) {\n  return new Vector(a2.x + (b2.x - a2.x) * t3, a2.y + (b2.y - a2.y) * t3);\n};\nvar BezierCurve = function() {\n  function BezierCurve2(start2, startControl, endControl, end) {\n    this.type = 1;\n    this.start = start2;\n    this.startControl = startControl;\n    this.endControl = endControl;\n    this.end = end;\n  }\n  BezierCurve2.prototype.subdivide = function(t3, firstHalf) {\n    var ab = lerp(this.start, this.startControl, t3);\n    var bc = lerp(this.startControl, this.endControl, t3);\n    var cd = lerp(this.endControl, this.end, t3);\n    var abbc = lerp(ab, bc, t3);\n    var bccd = lerp(bc, cd, t3);\n    var dest = lerp(abbc, bccd, t3);\n    return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);\n  };\n  BezierCurve2.prototype.add = function(deltaX, deltaY) {\n    return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));\n  };\n  BezierCurve2.prototype.reverse = function() {\n    return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);\n  };\n  return BezierCurve2;\n}();\nvar isBezierCurve = function(path) {\n  return path.type === 1;\n};\nvar BoundCurves = function() {\n  function BoundCurves2(element) {\n    var styles = element.styles;\n    var bounds = element.bounds;\n    var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];\n    var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];\n    var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];\n    var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];\n    var factors = [];\n    factors.push((tlh + trh) / bounds.width);\n    factors.push((blh + brh) / bounds.width);\n    factors.push((tlv + blv) / bounds.height);\n    factors.push((trv + brv) / bounds.height);\n    var maxFactor = Math.max.apply(Math, factors);\n    if (maxFactor > 1) {\n      tlh /= maxFactor;\n      tlv /= maxFactor;\n      trh /= maxFactor;\n      trv /= maxFactor;\n      brh /= maxFactor;\n      brv /= maxFactor;\n      blh /= maxFactor;\n      blv /= maxFactor;\n    }\n    var topWidth = bounds.width - trh;\n    var rightHeight = bounds.height - brv;\n    var bottomWidth = bounds.width - brh;\n    var leftHeight = bounds.height - blv;\n    var borderTopWidth2 = styles.borderTopWidth;\n    var borderRightWidth2 = styles.borderRightWidth;\n    var borderBottomWidth2 = styles.borderBottomWidth;\n    var borderLeftWidth2 = styles.borderLeftWidth;\n    var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);\n    var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);\n    var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);\n    var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);\n    this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);\n    this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);\n    this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);\n    this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);\n    this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);\n    this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);\n    this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);\n    this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);\n    this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);\n    this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);\n    this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);\n    this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);\n    this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);\n    this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);\n    this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);\n    this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);\n    this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);\n    this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);\n    this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);\n    this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);\n    this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);\n    this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);\n    this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));\n    this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));\n  }\n  return BoundCurves2;\n}();\nvar CORNER;\n(function(CORNER2) {\n  CORNER2[CORNER2[\"TOP_LEFT\"] = 0] = \"TOP_LEFT\";\n  CORNER2[CORNER2[\"TOP_RIGHT\"] = 1] = \"TOP_RIGHT\";\n  CORNER2[CORNER2[\"BOTTOM_RIGHT\"] = 2] = \"BOTTOM_RIGHT\";\n  CORNER2[CORNER2[\"BOTTOM_LEFT\"] = 3] = \"BOTTOM_LEFT\";\n})(CORNER || (CORNER = {}));\nvar getCurvePoints = function(x2, y2, r1, r2, position2) {\n  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);\n  var ox = r1 * kappa;\n  var oy = r2 * kappa;\n  var xm = x2 + r1;\n  var ym = y2 + r2;\n  switch (position2) {\n    case CORNER.TOP_LEFT:\n      return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));\n    case CORNER.TOP_RIGHT:\n      return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));\n    case CORNER.BOTTOM_RIGHT:\n      return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));\n    case CORNER.BOTTOM_LEFT:\n    default:\n      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));\n  }\n};\nvar calculateBorderBoxPath = function(curves) {\n  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];\n};\nvar calculateContentBoxPath = function(curves) {\n  return [\n    curves.topLeftContentBox,\n    curves.topRightContentBox,\n    curves.bottomRightContentBox,\n    curves.bottomLeftContentBox\n  ];\n};\nvar calculatePaddingBoxPath = function(curves) {\n  return [\n    curves.topLeftPaddingBox,\n    curves.topRightPaddingBox,\n    curves.bottomRightPaddingBox,\n    curves.bottomLeftPaddingBox\n  ];\n};\nvar TransformEffect = function() {\n  function TransformEffect2(offsetX, offsetY, matrix2) {\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    this.matrix = matrix2;\n    this.type = 0;\n    this.target = 2 | 4;\n  }\n  return TransformEffect2;\n}();\nvar ClipEffect = function() {\n  function ClipEffect2(path, target) {\n    this.path = path;\n    this.target = target;\n    this.type = 1;\n  }\n  return ClipEffect2;\n}();\nvar OpacityEffect = function() {\n  function OpacityEffect2(opacity2) {\n    this.opacity = opacity2;\n    this.type = 2;\n    this.target = 2 | 4;\n  }\n  return OpacityEffect2;\n}();\nvar isTransformEffect = function(effect) {\n  return effect.type === 0;\n};\nvar isClipEffect = function(effect) {\n  return effect.type === 1;\n};\nvar isOpacityEffect = function(effect) {\n  return effect.type === 2;\n};\nvar equalPath = function(a2, b2) {\n  if (a2.length === b2.length) {\n    return a2.some(function(v2, i2) {\n      return v2 === b2[i2];\n    });\n  }\n  return false;\n};\nvar transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {\n  return path.map(function(point, index2) {\n    switch (index2) {\n      case 0:\n        return point.add(deltaX, deltaY);\n      case 1:\n        return point.add(deltaX + deltaW, deltaY);\n      case 2:\n        return point.add(deltaX + deltaW, deltaY + deltaH);\n      case 3:\n        return point.add(deltaX, deltaY + deltaH);\n    }\n    return point;\n  });\n};\nvar StackingContext = function() {\n  function StackingContext2(container) {\n    this.element = container;\n    this.inlineLevel = [];\n    this.nonInlineLevel = [];\n    this.negativeZIndex = [];\n    this.zeroOrAutoZIndexOrTransformedOrOpacity = [];\n    this.positiveZIndex = [];\n    this.nonPositionedFloats = [];\n    this.nonPositionedInlineLevel = [];\n  }\n  return StackingContext2;\n}();\nvar ElementPaint = function() {\n  function ElementPaint2(container, parent) {\n    this.container = container;\n    this.parent = parent;\n    this.effects = [];\n    this.curves = new BoundCurves(this.container);\n    if (this.container.styles.opacity < 1) {\n      this.effects.push(new OpacityEffect(this.container.styles.opacity));\n    }\n    if (this.container.styles.transform !== null) {\n      var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;\n      var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;\n      var matrix2 = this.container.styles.transform;\n      this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));\n    }\n    if (this.container.styles.overflowX !== 0) {\n      var borderBox = calculateBorderBoxPath(this.curves);\n      var paddingBox2 = calculatePaddingBoxPath(this.curves);\n      if (equalPath(borderBox, paddingBox2)) {\n        this.effects.push(new ClipEffect(borderBox, 2 | 4));\n      } else {\n        this.effects.push(new ClipEffect(borderBox, 2));\n        this.effects.push(new ClipEffect(paddingBox2, 4));\n      }\n    }\n  }\n  ElementPaint2.prototype.getEffects = function(target) {\n    var inFlow = [2, 3].indexOf(this.container.styles.position) === -1;\n    var parent = this.parent;\n    var effects = this.effects.slice(0);\n    while (parent) {\n      var croplessEffects = parent.effects.filter(function(effect) {\n        return !isClipEffect(effect);\n      });\n      if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {\n        effects.unshift.apply(effects, croplessEffects);\n        inFlow = [2, 3].indexOf(parent.container.styles.position) === -1;\n        if (parent.container.styles.overflowX !== 0) {\n          var borderBox = calculateBorderBoxPath(parent.curves);\n          var paddingBox2 = calculatePaddingBoxPath(parent.curves);\n          if (!equalPath(borderBox, paddingBox2)) {\n            effects.unshift(new ClipEffect(paddingBox2, 2 | 4));\n          }\n        }\n      } else {\n        effects.unshift.apply(effects, croplessEffects);\n      }\n      parent = parent.parent;\n    }\n    return effects.filter(function(effect) {\n      return contains(effect.target, target);\n    });\n  };\n  return ElementPaint2;\n}();\nvar parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {\n  parent.container.elements.forEach(function(child) {\n    var treatAsRealStackingContext = contains(child.flags, 4);\n    var createsStackingContext2 = contains(child.flags, 2);\n    var paintContainer = new ElementPaint(child, parent);\n    if (contains(child.styles.display, 2048)) {\n      listItems.push(paintContainer);\n    }\n    var listOwnerItems = contains(child.flags, 8) ? [] : listItems;\n    if (treatAsRealStackingContext || createsStackingContext2) {\n      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;\n      var stack = new StackingContext(paintContainer);\n      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {\n        var order_1 = child.styles.zIndex.order;\n        if (order_1 < 0) {\n          var index_1 = 0;\n          parentStack.negativeZIndex.some(function(current, i2) {\n            if (order_1 > current.element.container.styles.zIndex.order) {\n              index_1 = i2;\n              return false;\n            } else if (index_1 > 0) {\n              return true;\n            }\n            return false;\n          });\n          parentStack.negativeZIndex.splice(index_1, 0, stack);\n        } else if (order_1 > 0) {\n          var index_2 = 0;\n          parentStack.positiveZIndex.some(function(current, i2) {\n            if (order_1 >= current.element.container.styles.zIndex.order) {\n              index_2 = i2 + 1;\n              return false;\n            } else if (index_2 > 0) {\n              return true;\n            }\n            return false;\n          });\n          parentStack.positiveZIndex.splice(index_2, 0, stack);\n        } else {\n          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);\n        }\n      } else {\n        if (child.styles.isFloating()) {\n          parentStack.nonPositionedFloats.push(stack);\n        } else {\n          parentStack.nonPositionedInlineLevel.push(stack);\n        }\n      }\n      parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);\n    } else {\n      if (child.styles.isInlineLevel()) {\n        stackingContext.inlineLevel.push(paintContainer);\n      } else {\n        stackingContext.nonInlineLevel.push(paintContainer);\n      }\n      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);\n    }\n    if (contains(child.flags, 8)) {\n      processListItems(child, listOwnerItems);\n    }\n  });\n};\nvar processListItems = function(owner, elements2) {\n  var numbering = owner instanceof OLElementContainer ? owner.start : 1;\n  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;\n  for (var i2 = 0; i2 < elements2.length; i2++) {\n    var item = elements2[i2];\n    if (item.container instanceof LIElementContainer && typeof item.container.value === \"number\" && item.container.value !== 0) {\n      numbering = item.container.value;\n    }\n    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);\n    numbering += reversed ? -1 : 1;\n  }\n};\nvar parseStackingContexts = function(container) {\n  var paintContainer = new ElementPaint(container, null);\n  var root2 = new StackingContext(paintContainer);\n  var listItems = [];\n  parseStackTree(paintContainer, root2, root2, listItems);\n  processListItems(paintContainer.container, listItems);\n  return root2;\n};\nvar parsePathForBorder = function(curves, borderSide) {\n  switch (borderSide) {\n    case 0:\n      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);\n    case 1:\n      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);\n    case 2:\n      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);\n    case 3:\n    default:\n      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);\n  }\n};\nvar parsePathForBorderDoubleOuter = function(curves, borderSide) {\n  switch (borderSide) {\n    case 0:\n      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);\n    case 1:\n      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);\n    case 2:\n      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);\n    case 3:\n    default:\n      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);\n  }\n};\nvar parsePathForBorderDoubleInner = function(curves, borderSide) {\n  switch (borderSide) {\n    case 0:\n      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);\n    case 1:\n      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);\n    case 2:\n      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);\n    case 3:\n    default:\n      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);\n  }\n};\nvar parsePathForBorderStroke = function(curves, borderSide) {\n  switch (borderSide) {\n    case 0:\n      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);\n    case 1:\n      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);\n    case 2:\n      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);\n    case 3:\n    default:\n      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);\n  }\n};\nvar createStrokePathFromCurves = function(outer1, outer2) {\n  var path = [];\n  if (isBezierCurve(outer1)) {\n    path.push(outer1.subdivide(0.5, false));\n  } else {\n    path.push(outer1);\n  }\n  if (isBezierCurve(outer2)) {\n    path.push(outer2.subdivide(0.5, true));\n  } else {\n    path.push(outer2);\n  }\n  return path;\n};\nvar createPathFromCurves = function(outer1, inner1, outer2, inner2) {\n  var path = [];\n  if (isBezierCurve(outer1)) {\n    path.push(outer1.subdivide(0.5, false));\n  } else {\n    path.push(outer1);\n  }\n  if (isBezierCurve(outer2)) {\n    path.push(outer2.subdivide(0.5, true));\n  } else {\n    path.push(outer2);\n  }\n  if (isBezierCurve(inner2)) {\n    path.push(inner2.subdivide(0.5, true).reverse());\n  } else {\n    path.push(inner2);\n  }\n  if (isBezierCurve(inner1)) {\n    path.push(inner1.subdivide(0.5, false).reverse());\n  } else {\n    path.push(inner1);\n  }\n  return path;\n};\nvar paddingBox = function(element) {\n  var bounds = element.bounds;\n  var styles = element.styles;\n  return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));\n};\nvar contentBox = function(element) {\n  var styles = element.styles;\n  var bounds = element.bounds;\n  var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);\n  var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);\n  var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);\n  var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);\n  return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));\n};\nvar calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {\n  if (backgroundOrigin2 === 0) {\n    return element.bounds;\n  }\n  if (backgroundOrigin2 === 2) {\n    return contentBox(element);\n  }\n  return paddingBox(element);\n};\nvar calculateBackgroundPaintingArea = function(backgroundClip2, element) {\n  if (backgroundClip2 === 0) {\n    return element.bounds;\n  }\n  if (backgroundClip2 === 2) {\n    return contentBox(element);\n  }\n  return paddingBox(element);\n};\nvar calculateBackgroundRendering = function(container, index2, intrinsicSize) {\n  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);\n  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);\n  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);\n  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];\n  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);\n  var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);\n  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);\n  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);\n  return [path, offsetX, offsetY, sizeWidth, sizeHeight];\n};\nvar isAuto = function(token) {\n  return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;\n};\nvar hasIntrinsicValue = function(value) {\n  return typeof value === \"number\";\n};\nvar calculateBackgroundSize = function(size, _a2, bounds) {\n  var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];\n  var first = size[0], second = size[1];\n  if (!first) {\n    return [0, 0];\n  }\n  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {\n    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];\n  }\n  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);\n  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {\n    if (hasIntrinsicValue(intrinsicProportion)) {\n      var targetRatio = bounds.width / bounds.height;\n      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];\n    }\n    return [bounds.width, bounds.height];\n  }\n  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);\n  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);\n  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;\n  if (isAuto(first) && (!second || isAuto(second))) {\n    if (hasIntrinsicWidth && hasIntrinsicHeight) {\n      return [intrinsicWidth, intrinsicHeight];\n    }\n    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {\n      return [bounds.width, bounds.height];\n    }\n    if (hasIntrinsicDimensions && hasIntrinsicProportion) {\n      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;\n      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;\n      return [width_1, height_1];\n    }\n    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;\n    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;\n    return [width_2, height_2];\n  }\n  if (hasIntrinsicProportion) {\n    var width_3 = 0;\n    var height_3 = 0;\n    if (isLengthPercentage(first)) {\n      width_3 = getAbsoluteValue(first, bounds.width);\n    } else if (isLengthPercentage(second)) {\n      height_3 = getAbsoluteValue(second, bounds.height);\n    }\n    if (isAuto(first)) {\n      width_3 = height_3 * intrinsicProportion;\n    } else if (!second || isAuto(second)) {\n      height_3 = width_3 / intrinsicProportion;\n    }\n    return [width_3, height_3];\n  }\n  var width = null;\n  var height = null;\n  if (isLengthPercentage(first)) {\n    width = getAbsoluteValue(first, bounds.width);\n  } else if (second && isLengthPercentage(second)) {\n    height = getAbsoluteValue(second, bounds.height);\n  }\n  if (width !== null && (!second || isAuto(second))) {\n    height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;\n  }\n  if (height !== null && isAuto(first)) {\n    width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;\n  }\n  if (width !== null && height !== null) {\n    return [width, height];\n  }\n  throw new Error(\"Unable to calculate background-size for element\");\n};\nvar getBackgroundValueForIndex = function(values2, index2) {\n  var value = values2[index2];\n  if (typeof value === \"undefined\") {\n    return values2[0];\n  }\n  return value;\n};\nvar calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {\n  var x2 = _a2[0], y2 = _a2[1];\n  var width = _b2[0], height = _b2[1];\n  switch (repeat) {\n    case 2:\n      return [\n        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),\n        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),\n        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)),\n        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))\n      ];\n    case 3:\n      return [\n        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),\n        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),\n        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),\n        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))\n      ];\n    case 1:\n      return [\n        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),\n        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2)),\n        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2 + height)),\n        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))\n      ];\n    default:\n      return [\n        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),\n        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),\n        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),\n        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))\n      ];\n  }\n};\nvar SMALL_IMAGE = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nvar SAMPLE_TEXT = \"Hidden Text\";\nvar FontMetrics = function() {\n  function FontMetrics2(document2) {\n    this._data = {};\n    this._document = document2;\n  }\n  FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {\n    var container = this._document.createElement(\"div\");\n    var img = this._document.createElement(\"img\");\n    var span = this._document.createElement(\"span\");\n    var body = this._document.body;\n    container.style.visibility = \"hidden\";\n    container.style.fontFamily = fontFamily2;\n    container.style.fontSize = fontSize2;\n    container.style.margin = \"0\";\n    container.style.padding = \"0\";\n    container.style.whiteSpace = \"nowrap\";\n    body.appendChild(container);\n    img.src = SMALL_IMAGE;\n    img.width = 1;\n    img.height = 1;\n    img.style.margin = \"0\";\n    img.style.padding = \"0\";\n    img.style.verticalAlign = \"baseline\";\n    span.style.fontFamily = fontFamily2;\n    span.style.fontSize = fontSize2;\n    span.style.margin = \"0\";\n    span.style.padding = \"0\";\n    span.appendChild(this._document.createTextNode(SAMPLE_TEXT));\n    container.appendChild(span);\n    container.appendChild(img);\n    var baseline = img.offsetTop - span.offsetTop + 2;\n    container.removeChild(span);\n    container.appendChild(this._document.createTextNode(SAMPLE_TEXT));\n    container.style.lineHeight = \"normal\";\n    img.style.verticalAlign = \"super\";\n    var middle = img.offsetTop - container.offsetTop + 2;\n    body.removeChild(container);\n    return { baseline, middle };\n  };\n  FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {\n    var key = fontFamily2 + \" \" + fontSize2;\n    if (typeof this._data[key] === \"undefined\") {\n      this._data[key] = this.parseMetrics(fontFamily2, fontSize2);\n    }\n    return this._data[key];\n  };\n  return FontMetrics2;\n}();\nvar Renderer = function() {\n  function Renderer2(context, options) {\n    this.context = context;\n    this.options = options;\n  }\n  return Renderer2;\n}();\nvar MASK_OFFSET = 1e4;\nvar CanvasRenderer = function(_super) {\n  __extends(CanvasRenderer2, _super);\n  function CanvasRenderer2(context, options) {\n    var _this = _super.call(this, context, options) || this;\n    _this._activeEffects = [];\n    _this.canvas = options.canvas ? options.canvas : document.createElement(\"canvas\");\n    _this.ctx = _this.canvas.getContext(\"2d\");\n    if (!options.canvas) {\n      _this.canvas.width = Math.floor(options.width * options.scale);\n      _this.canvas.height = Math.floor(options.height * options.scale);\n      _this.canvas.style.width = options.width + \"px\";\n      _this.canvas.style.height = options.height + \"px\";\n    }\n    _this.fontMetrics = new FontMetrics(document);\n    _this.ctx.scale(_this.options.scale, _this.options.scale);\n    _this.ctx.translate(-options.x, -options.y);\n    _this.ctx.textBaseline = \"bottom\";\n    _this._activeEffects = [];\n    _this.context.logger.debug(\"Canvas renderer initialized (\" + options.width + \"x\" + options.height + \") with scale \" + options.scale);\n    return _this;\n  }\n  CanvasRenderer2.prototype.applyEffects = function(effects) {\n    var _this = this;\n    while (this._activeEffects.length) {\n      this.popEffect();\n    }\n    effects.forEach(function(effect) {\n      return _this.applyEffect(effect);\n    });\n  };\n  CanvasRenderer2.prototype.applyEffect = function(effect) {\n    this.ctx.save();\n    if (isOpacityEffect(effect)) {\n      this.ctx.globalAlpha = effect.opacity;\n    }\n    if (isTransformEffect(effect)) {\n      this.ctx.translate(effect.offsetX, effect.offsetY);\n      this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);\n      this.ctx.translate(-effect.offsetX, -effect.offsetY);\n    }\n    if (isClipEffect(effect)) {\n      this.path(effect.path);\n      this.ctx.clip();\n    }\n    this._activeEffects.push(effect);\n  };\n  CanvasRenderer2.prototype.popEffect = function() {\n    this._activeEffects.pop();\n    this.ctx.restore();\n  };\n  CanvasRenderer2.prototype.renderStack = function(stack) {\n    return __awaiter(this, void 0, void 0, function() {\n      var styles;\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            styles = stack.element.container.styles;\n            if (!styles.isVisible())\n              return [3, 2];\n            return [4, this.renderStackContent(stack)];\n          case 1:\n            _a2.sent();\n            _a2.label = 2;\n          case 2:\n            return [2];\n        }\n      });\n    });\n  };\n  CanvasRenderer2.prototype.renderNode = function(paint) {\n    return __awaiter(this, void 0, void 0, function() {\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            if (contains(paint.container.flags, 16)) {\n              debugger;\n            }\n            if (!paint.container.styles.isVisible())\n              return [3, 3];\n            return [4, this.renderNodeBackgroundAndBorders(paint)];\n          case 1:\n            _a2.sent();\n            return [4, this.renderNodeContent(paint)];\n          case 2:\n            _a2.sent();\n            _a2.label = 3;\n          case 3:\n            return [2];\n        }\n      });\n    });\n  };\n  CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {\n    var _this = this;\n    if (letterSpacing2 === 0) {\n      this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);\n    } else {\n      var letters = segmentGraphemes(text2.text);\n      letters.reduce(function(left, letter) {\n        _this.ctx.fillText(letter, left, text2.bounds.top + baseline);\n        return left + _this.ctx.measureText(letter).width;\n      }, text2.bounds.left);\n    }\n  };\n  CanvasRenderer2.prototype.createFontStyle = function(styles) {\n    var fontVariant2 = styles.fontVariant.filter(function(variant) {\n      return variant === \"normal\" || variant === \"small-caps\";\n    }).join(\"\");\n    var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(\", \");\n    var fontSize2 = isDimensionToken(styles.fontSize) ? \"\" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + \"px\";\n    return [\n      [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(\" \"),\n      fontFamily2,\n      fontSize2\n    ];\n  };\n  CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {\n    return __awaiter(this, void 0, void 0, function() {\n      var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;\n      var _this = this;\n      return __generator(this, function(_c) {\n        _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];\n        this.ctx.font = font;\n        this.ctx.direction = styles.direction === 1 ? \"rtl\" : \"ltr\";\n        this.ctx.textAlign = \"left\";\n        this.ctx.textBaseline = \"alphabetic\";\n        _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;\n        paintOrder2 = styles.paintOrder;\n        text2.textBounds.forEach(function(text3) {\n          paintOrder2.forEach(function(paintOrderLayer) {\n            switch (paintOrderLayer) {\n              case 0:\n                _this.ctx.fillStyle = asString(styles.color);\n                _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);\n                var textShadows = styles.textShadow;\n                if (textShadows.length && text3.text.trim().length) {\n                  textShadows.slice(0).reverse().forEach(function(textShadow2) {\n                    _this.ctx.shadowColor = asString(textShadow2.color);\n                    _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;\n                    _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;\n                    _this.ctx.shadowBlur = textShadow2.blur.number;\n                    _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);\n                  });\n                  _this.ctx.shadowColor = \"\";\n                  _this.ctx.shadowOffsetX = 0;\n                  _this.ctx.shadowOffsetY = 0;\n                  _this.ctx.shadowBlur = 0;\n                }\n                if (styles.textDecorationLine.length) {\n                  _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);\n                  styles.textDecorationLine.forEach(function(textDecorationLine2) {\n                    switch (textDecorationLine2) {\n                      case 1:\n                        _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);\n                        break;\n                      case 2:\n                        _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);\n                        break;\n                      case 3:\n                        _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);\n                        break;\n                    }\n                  });\n                }\n                break;\n              case 1:\n                if (styles.webkitTextStrokeWidth && text3.text.trim().length) {\n                  _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);\n                  _this.ctx.lineWidth = styles.webkitTextStrokeWidth;\n                  _this.ctx.lineJoin = !!window.chrome ? \"miter\" : \"round\";\n                  _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);\n                }\n                _this.ctx.strokeStyle = \"\";\n                _this.ctx.lineWidth = 0;\n                _this.ctx.lineJoin = \"miter\";\n                break;\n            }\n          });\n        });\n        return [2];\n      });\n    });\n  };\n  CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {\n    if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {\n      var box = contentBox(container);\n      var path = calculatePaddingBoxPath(curves);\n      this.path(path);\n      this.ctx.save();\n      this.ctx.clip();\n      this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);\n      this.ctx.restore();\n    }\n  };\n  CanvasRenderer2.prototype.renderNodeContent = function(paint) {\n    return __awaiter(this, void 0, void 0, function() {\n      var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;\n      return __generator(this, function(_c) {\n        switch (_c.label) {\n          case 0:\n            this.applyEffects(paint.getEffects(4));\n            container = paint.container;\n            curves = paint.curves;\n            styles = container.styles;\n            _i = 0, _a2 = container.textNodes;\n            _c.label = 1;\n          case 1:\n            if (!(_i < _a2.length))\n              return [3, 4];\n            child = _a2[_i];\n            return [4, this.renderTextNode(child, styles)];\n          case 2:\n            _c.sent();\n            _c.label = 3;\n          case 3:\n            _i++;\n            return [3, 1];\n          case 4:\n            if (!(container instanceof ImageElementContainer))\n              return [3, 8];\n            _c.label = 5;\n          case 5:\n            _c.trys.push([5, 7, , 8]);\n            return [4, this.context.cache.match(container.src)];\n          case 6:\n            image2 = _c.sent();\n            this.renderReplacedElement(container, curves, image2);\n            return [3, 8];\n          case 7:\n            _c.sent();\n            this.context.logger.error(\"Error loading image \" + container.src);\n            return [3, 8];\n          case 8:\n            if (container instanceof CanvasElementContainer) {\n              this.renderReplacedElement(container, curves, container.canvas);\n            }\n            if (!(container instanceof SVGElementContainer))\n              return [3, 12];\n            _c.label = 9;\n          case 9:\n            _c.trys.push([9, 11, , 12]);\n            return [4, this.context.cache.match(container.svg)];\n          case 10:\n            image2 = _c.sent();\n            this.renderReplacedElement(container, curves, image2);\n            return [3, 12];\n          case 11:\n            _c.sent();\n            this.context.logger.error(\"Error loading svg \" + container.svg.substring(0, 255));\n            return [3, 12];\n          case 12:\n            if (!(container instanceof IFrameElementContainer && container.tree))\n              return [3, 14];\n            iframeRenderer = new CanvasRenderer2(this.context, {\n              scale: this.options.scale,\n              backgroundColor: container.backgroundColor,\n              x: 0,\n              y: 0,\n              width: container.width,\n              height: container.height\n            });\n            return [4, iframeRenderer.render(container.tree)];\n          case 13:\n            canvas = _c.sent();\n            if (container.width && container.height) {\n              this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);\n            }\n            _c.label = 14;\n          case 14:\n            if (container instanceof InputElementContainer) {\n              size = Math.min(container.bounds.width, container.bounds.height);\n              if (container.type === CHECKBOX) {\n                if (container.checked) {\n                  this.ctx.save();\n                  this.path([\n                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),\n                    new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),\n                    new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),\n                    new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),\n                    new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),\n                    new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),\n                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)\n                  ]);\n                  this.ctx.fillStyle = asString(INPUT_COLOR);\n                  this.ctx.fill();\n                  this.ctx.restore();\n                }\n              } else if (container.type === RADIO) {\n                if (container.checked) {\n                  this.ctx.save();\n                  this.ctx.beginPath();\n                  this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);\n                  this.ctx.fillStyle = asString(INPUT_COLOR);\n                  this.ctx.fill();\n                  this.ctx.restore();\n                }\n              }\n            }\n            if (isTextInputElement(container) && container.value.length) {\n              _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];\n              baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;\n              this.ctx.font = fontFamily2;\n              this.ctx.fillStyle = asString(styles.color);\n              this.ctx.textBaseline = \"alphabetic\";\n              this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);\n              bounds = contentBox(container);\n              x2 = 0;\n              switch (container.styles.textAlign) {\n                case 1:\n                  x2 += bounds.width / 2;\n                  break;\n                case 2:\n                  x2 += bounds.width;\n                  break;\n              }\n              textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);\n              this.ctx.save();\n              this.path([\n                new Vector(bounds.left, bounds.top),\n                new Vector(bounds.left + bounds.width, bounds.top),\n                new Vector(bounds.left + bounds.width, bounds.top + bounds.height),\n                new Vector(bounds.left, bounds.top + bounds.height)\n              ]);\n              this.ctx.clip();\n              this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);\n              this.ctx.restore();\n              this.ctx.textBaseline = \"alphabetic\";\n              this.ctx.textAlign = \"left\";\n            }\n            if (!contains(container.styles.display, 2048))\n              return [3, 20];\n            if (!(container.styles.listStyleImage !== null))\n              return [3, 19];\n            img = container.styles.listStyleImage;\n            if (!(img.type === 0))\n              return [3, 18];\n            image2 = void 0;\n            url = img.url;\n            _c.label = 15;\n          case 15:\n            _c.trys.push([15, 17, , 18]);\n            return [4, this.context.cache.match(url)];\n          case 16:\n            image2 = _c.sent();\n            this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);\n            return [3, 18];\n          case 17:\n            _c.sent();\n            this.context.logger.error(\"Error loading list-style-image \" + url);\n            return [3, 18];\n          case 18:\n            return [3, 20];\n          case 19:\n            if (paint.listValue && container.styles.listStyleType !== -1) {\n              fontFamily2 = this.createFontStyle(styles)[0];\n              this.ctx.font = fontFamily2;\n              this.ctx.fillStyle = asString(styles.color);\n              this.ctx.textBaseline = \"middle\";\n              this.ctx.textAlign = \"right\";\n              bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);\n              this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);\n              this.ctx.textBaseline = \"bottom\";\n              this.ctx.textAlign = \"left\";\n            }\n            _c.label = 20;\n          case 20:\n            return [2];\n        }\n      });\n    });\n  };\n  CanvasRenderer2.prototype.renderStackContent = function(stack) {\n    return __awaiter(this, void 0, void 0, function() {\n      var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;\n      return __generator(this, function(_p) {\n        switch (_p.label) {\n          case 0:\n            if (contains(stack.element.container.flags, 16)) {\n              debugger;\n            }\n            return [4, this.renderNodeBackgroundAndBorders(stack.element)];\n          case 1:\n            _p.sent();\n            _i = 0, _a2 = stack.negativeZIndex;\n            _p.label = 2;\n          case 2:\n            if (!(_i < _a2.length))\n              return [3, 5];\n            child = _a2[_i];\n            return [4, this.renderStack(child)];\n          case 3:\n            _p.sent();\n            _p.label = 4;\n          case 4:\n            _i++;\n            return [3, 2];\n          case 5:\n            return [4, this.renderNodeContent(stack.element)];\n          case 6:\n            _p.sent();\n            _b2 = 0, _c = stack.nonInlineLevel;\n            _p.label = 7;\n          case 7:\n            if (!(_b2 < _c.length))\n              return [3, 10];\n            child = _c[_b2];\n            return [4, this.renderNode(child)];\n          case 8:\n            _p.sent();\n            _p.label = 9;\n          case 9:\n            _b2++;\n            return [3, 7];\n          case 10:\n            _d = 0, _e = stack.nonPositionedFloats;\n            _p.label = 11;\n          case 11:\n            if (!(_d < _e.length))\n              return [3, 14];\n            child = _e[_d];\n            return [4, this.renderStack(child)];\n          case 12:\n            _p.sent();\n            _p.label = 13;\n          case 13:\n            _d++;\n            return [3, 11];\n          case 14:\n            _f = 0, _g = stack.nonPositionedInlineLevel;\n            _p.label = 15;\n          case 15:\n            if (!(_f < _g.length))\n              return [3, 18];\n            child = _g[_f];\n            return [4, this.renderStack(child)];\n          case 16:\n            _p.sent();\n            _p.label = 17;\n          case 17:\n            _f++;\n            return [3, 15];\n          case 18:\n            _h = 0, _j = stack.inlineLevel;\n            _p.label = 19;\n          case 19:\n            if (!(_h < _j.length))\n              return [3, 22];\n            child = _j[_h];\n            return [4, this.renderNode(child)];\n          case 20:\n            _p.sent();\n            _p.label = 21;\n          case 21:\n            _h++;\n            return [3, 19];\n          case 22:\n            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;\n            _p.label = 23;\n          case 23:\n            if (!(_k < _l.length))\n              return [3, 26];\n            child = _l[_k];\n            return [4, this.renderStack(child)];\n          case 24:\n            _p.sent();\n            _p.label = 25;\n          case 25:\n            _k++;\n            return [3, 23];\n          case 26:\n            _m = 0, _o = stack.positiveZIndex;\n            _p.label = 27;\n          case 27:\n            if (!(_m < _o.length))\n              return [3, 30];\n            child = _o[_m];\n            return [4, this.renderStack(child)];\n          case 28:\n            _p.sent();\n            _p.label = 29;\n          case 29:\n            _m++;\n            return [3, 27];\n          case 30:\n            return [2];\n        }\n      });\n    });\n  };\n  CanvasRenderer2.prototype.mask = function(paths) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(0, 0);\n    this.ctx.lineTo(this.canvas.width, 0);\n    this.ctx.lineTo(this.canvas.width, this.canvas.height);\n    this.ctx.lineTo(0, this.canvas.height);\n    this.ctx.lineTo(0, 0);\n    this.formatPath(paths.slice(0).reverse());\n    this.ctx.closePath();\n  };\n  CanvasRenderer2.prototype.path = function(paths) {\n    this.ctx.beginPath();\n    this.formatPath(paths);\n    this.ctx.closePath();\n  };\n  CanvasRenderer2.prototype.formatPath = function(paths) {\n    var _this = this;\n    paths.forEach(function(point, index2) {\n      var start2 = isBezierCurve(point) ? point.start : point;\n      if (index2 === 0) {\n        _this.ctx.moveTo(start2.x, start2.y);\n      } else {\n        _this.ctx.lineTo(start2.x, start2.y);\n      }\n      if (isBezierCurve(point)) {\n        _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);\n      }\n    });\n  };\n  CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {\n    this.path(path);\n    this.ctx.fillStyle = pattern;\n    this.ctx.translate(offsetX, offsetY);\n    this.ctx.fill();\n    this.ctx.translate(-offsetX, -offsetY);\n  };\n  CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {\n    var _a2;\n    if (image2.width === width && image2.height === height) {\n      return image2;\n    }\n    var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;\n    var canvas = ownerDocument.createElement(\"canvas\");\n    canvas.width = Math.max(1, width);\n    canvas.height = Math.max(1, height);\n    var ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);\n    return canvas;\n  };\n  CanvasRenderer2.prototype.renderBackgroundImage = function(container) {\n    return __awaiter(this, void 0, void 0, function() {\n      var index2, _loop_1, this_1, _i, _a2, backgroundImage2;\n      return __generator(this, function(_b2) {\n        switch (_b2.label) {\n          case 0:\n            index2 = container.styles.backgroundImage.length - 1;\n            _loop_1 = function(backgroundImage3) {\n              var image2, url, _c, path, x2, y2, width, height, pattern, _d, path, x2, y2, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;\n              return __generator(this, function(_h) {\n                switch (_h.label) {\n                  case 0:\n                    if (!(backgroundImage3.type === 0))\n                      return [3, 5];\n                    image2 = void 0;\n                    url = backgroundImage3.url;\n                    _h.label = 1;\n                  case 1:\n                    _h.trys.push([1, 3, , 4]);\n                    return [4, this_1.context.cache.match(url)];\n                  case 2:\n                    image2 = _h.sent();\n                    return [3, 4];\n                  case 3:\n                    _h.sent();\n                    this_1.context.logger.error(\"Error loading background-image \" + url);\n                    return [3, 4];\n                  case 4:\n                    if (image2) {\n                      _c = calculateBackgroundRendering(container, index2, [\n                        image2.width,\n                        image2.height,\n                        image2.width / image2.height\n                      ]), path = _c[0], x2 = _c[1], y2 = _c[2], width = _c[3], height = _c[4];\n                      pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), \"repeat\");\n                      this_1.renderRepeat(path, pattern, x2, y2);\n                    }\n                    return [3, 6];\n                  case 5:\n                    if (isLinearGradient(backgroundImage3)) {\n                      _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x2 = _d[1], y2 = _d[2], width = _d[3], height = _d[4];\n                      _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];\n                      canvas = document.createElement(\"canvas\");\n                      canvas.width = width;\n                      canvas.height = height;\n                      ctx = canvas.getContext(\"2d\");\n                      gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);\n                      processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {\n                        return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));\n                      });\n                      ctx.fillStyle = gradient_1;\n                      ctx.fillRect(0, 0, width, height);\n                      if (width > 0 && height > 0) {\n                        pattern = this_1.ctx.createPattern(canvas, \"repeat\");\n                        this_1.renderRepeat(path, pattern, x2, y2);\n                      }\n                    } else if (isRadialGradient(backgroundImage3)) {\n                      _f = calculateBackgroundRendering(container, index2, [\n                        null,\n                        null,\n                        null\n                      ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];\n                      position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;\n                      x2 = getAbsoluteValue(position2[0], width);\n                      y2 = getAbsoluteValue(position2[position2.length - 1], height);\n                      _g = calculateRadius(backgroundImage3, x2, y2, width, height), rx = _g[0], ry = _g[1];\n                      if (rx > 0 && ry > 0) {\n                        radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);\n                        processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {\n                          return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));\n                        });\n                        this_1.path(path);\n                        this_1.ctx.fillStyle = radialGradient_1;\n                        if (rx !== ry) {\n                          midX = container.bounds.left + 0.5 * container.bounds.width;\n                          midY = container.bounds.top + 0.5 * container.bounds.height;\n                          f2 = ry / rx;\n                          invF = 1 / f2;\n                          this_1.ctx.save();\n                          this_1.ctx.translate(midX, midY);\n                          this_1.ctx.transform(1, 0, 0, f2, 0, 0);\n                          this_1.ctx.translate(-midX, -midY);\n                          this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);\n                          this_1.ctx.restore();\n                        } else {\n                          this_1.ctx.fill();\n                        }\n                      }\n                    }\n                    _h.label = 6;\n                  case 6:\n                    index2--;\n                    return [2];\n                }\n              });\n            };\n            this_1 = this;\n            _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();\n            _b2.label = 1;\n          case 1:\n            if (!(_i < _a2.length))\n              return [3, 4];\n            backgroundImage2 = _a2[_i];\n            return [5, _loop_1(backgroundImage2)];\n          case 2:\n            _b2.sent();\n            _b2.label = 3;\n          case 3:\n            _i++;\n            return [3, 1];\n          case 4:\n            return [2];\n        }\n      });\n    });\n  };\n  CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {\n    return __awaiter(this, void 0, void 0, function() {\n      return __generator(this, function(_a2) {\n        this.path(parsePathForBorder(curvePoints, side));\n        this.ctx.fillStyle = asString(color2);\n        this.ctx.fill();\n        return [2];\n      });\n    });\n  };\n  CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {\n    return __awaiter(this, void 0, void 0, function() {\n      var outerPaths, innerPaths;\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            if (!(width < 3))\n              return [3, 2];\n            return [4, this.renderSolidBorder(color2, side, curvePoints)];\n          case 1:\n            _a2.sent();\n            return [2];\n          case 2:\n            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);\n            this.path(outerPaths);\n            this.ctx.fillStyle = asString(color2);\n            this.ctx.fill();\n            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);\n            this.path(innerPaths);\n            this.ctx.fill();\n            return [2];\n        }\n      });\n    });\n  };\n  CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {\n    return __awaiter(this, void 0, void 0, function() {\n      var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;\n      var _this = this;\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            this.applyEffects(paint.getEffects(2));\n            styles = paint.container.styles;\n            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;\n            borders = [\n              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },\n              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },\n              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },\n              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }\n            ];\n            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);\n            if (!(hasBackground || styles.boxShadow.length))\n              return [3, 2];\n            this.ctx.save();\n            this.path(backgroundPaintingArea);\n            this.ctx.clip();\n            if (!isTransparent(styles.backgroundColor)) {\n              this.ctx.fillStyle = asString(styles.backgroundColor);\n              this.ctx.fill();\n            }\n            return [4, this.renderBackgroundImage(paint.container)];\n          case 1:\n            _a2.sent();\n            this.ctx.restore();\n            styles.boxShadow.slice(0).reverse().forEach(function(shadow) {\n              _this.ctx.save();\n              var borderBoxArea = calculateBorderBoxPath(paint.curves);\n              var maskOffset = shadow.inset ? 0 : MASK_OFFSET;\n              var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));\n              if (shadow.inset) {\n                _this.path(borderBoxArea);\n                _this.ctx.clip();\n                _this.mask(shadowPaintingArea);\n              } else {\n                _this.mask(borderBoxArea);\n                _this.ctx.clip();\n                _this.path(shadowPaintingArea);\n              }\n              _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;\n              _this.ctx.shadowOffsetY = shadow.offsetY.number;\n              _this.ctx.shadowColor = asString(shadow.color);\n              _this.ctx.shadowBlur = shadow.blur.number;\n              _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : \"rgba(0,0,0,1)\";\n              _this.ctx.fill();\n              _this.ctx.restore();\n            });\n            _a2.label = 2;\n          case 2:\n            side = 0;\n            _i = 0, borders_1 = borders;\n            _a2.label = 3;\n          case 3:\n            if (!(_i < borders_1.length))\n              return [3, 13];\n            border = borders_1[_i];\n            if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))\n              return [3, 11];\n            if (!(border.style === 2))\n              return [3, 5];\n            return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2)];\n          case 4:\n            _a2.sent();\n            return [3, 11];\n          case 5:\n            if (!(border.style === 3))\n              return [3, 7];\n            return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3)];\n          case 6:\n            _a2.sent();\n            return [3, 11];\n          case 7:\n            if (!(border.style === 4))\n              return [3, 9];\n            return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];\n          case 8:\n            _a2.sent();\n            return [3, 11];\n          case 9:\n            return [4, this.renderSolidBorder(border.color, side, paint.curves)];\n          case 10:\n            _a2.sent();\n            _a2.label = 11;\n          case 11:\n            side++;\n            _a2.label = 12;\n          case 12:\n            _i++;\n            return [3, 3];\n          case 13:\n            return [2];\n        }\n      });\n    });\n  };\n  CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style2) {\n    return __awaiter(this, void 0, void 0, function() {\n      var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;\n      return __generator(this, function(_a2) {\n        this.ctx.save();\n        strokePaths = parsePathForBorderStroke(curvePoints, side);\n        boxPaths = parsePathForBorder(curvePoints, side);\n        if (style2 === 2) {\n          this.path(boxPaths);\n          this.ctx.clip();\n        }\n        if (isBezierCurve(boxPaths[0])) {\n          startX = boxPaths[0].start.x;\n          startY = boxPaths[0].start.y;\n        } else {\n          startX = boxPaths[0].x;\n          startY = boxPaths[0].y;\n        }\n        if (isBezierCurve(boxPaths[1])) {\n          endX = boxPaths[1].end.x;\n          endY = boxPaths[1].end.y;\n        } else {\n          endX = boxPaths[1].x;\n          endY = boxPaths[1].y;\n        }\n        if (side === 0 || side === 2) {\n          length = Math.abs(startX - endX);\n        } else {\n          length = Math.abs(startY - endY);\n        }\n        this.ctx.beginPath();\n        if (style2 === 3) {\n          this.formatPath(strokePaths);\n        } else {\n          this.formatPath(boxPaths.slice(0, 2));\n        }\n        dashLength = width < 3 ? width * 3 : width * 2;\n        spaceLength = width < 3 ? width * 2 : width;\n        if (style2 === 3) {\n          dashLength = width;\n          spaceLength = width;\n        }\n        useLineDash = true;\n        if (length <= dashLength * 2) {\n          useLineDash = false;\n        } else if (length <= dashLength * 2 + spaceLength) {\n          multiplier = length / (2 * dashLength + spaceLength);\n          dashLength *= multiplier;\n          spaceLength *= multiplier;\n        } else {\n          numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));\n          minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);\n          maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;\n          spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;\n        }\n        if (useLineDash) {\n          if (style2 === 3) {\n            this.ctx.setLineDash([0, dashLength + spaceLength]);\n          } else {\n            this.ctx.setLineDash([dashLength, spaceLength]);\n          }\n        }\n        if (style2 === 3) {\n          this.ctx.lineCap = \"round\";\n          this.ctx.lineWidth = width;\n        } else {\n          this.ctx.lineWidth = width * 2 + 1.1;\n        }\n        this.ctx.strokeStyle = asString(color2);\n        this.ctx.stroke();\n        this.ctx.setLineDash([]);\n        if (style2 === 2) {\n          if (isBezierCurve(boxPaths[0])) {\n            path1 = boxPaths[3];\n            path2 = boxPaths[0];\n            this.ctx.beginPath();\n            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);\n            this.ctx.stroke();\n          }\n          if (isBezierCurve(boxPaths[1])) {\n            path1 = boxPaths[1];\n            path2 = boxPaths[2];\n            this.ctx.beginPath();\n            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);\n            this.ctx.stroke();\n          }\n        }\n        this.ctx.restore();\n        return [2];\n      });\n    });\n  };\n  CanvasRenderer2.prototype.render = function(element) {\n    return __awaiter(this, void 0, void 0, function() {\n      var stack;\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            if (this.options.backgroundColor) {\n              this.ctx.fillStyle = asString(this.options.backgroundColor);\n              this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);\n            }\n            stack = parseStackingContexts(element);\n            return [4, this.renderStack(stack)];\n          case 1:\n            _a2.sent();\n            this.applyEffects([]);\n            return [2, this.canvas];\n        }\n      });\n    });\n  };\n  return CanvasRenderer2;\n}(Renderer);\nvar isTextInputElement = function(container) {\n  if (container instanceof TextareaElementContainer) {\n    return true;\n  } else if (container instanceof SelectElementContainer) {\n    return true;\n  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {\n    return true;\n  }\n  return false;\n};\nvar calculateBackgroundCurvedPaintingArea = function(clip, curves) {\n  switch (clip) {\n    case 0:\n      return calculateBorderBoxPath(curves);\n    case 2:\n      return calculateContentBoxPath(curves);\n    case 1:\n    default:\n      return calculatePaddingBoxPath(curves);\n  }\n};\nvar canvasTextAlign = function(textAlign2) {\n  switch (textAlign2) {\n    case 1:\n      return \"center\";\n    case 2:\n      return \"right\";\n    case 0:\n    default:\n      return \"left\";\n  }\n};\nvar iOSBrokenFonts = [\"-apple-system\", \"system-ui\"];\nvar fixIOSSystemFonts = function(fontFamilies) {\n  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {\n    return iOSBrokenFonts.indexOf(fontFamily2) === -1;\n  }) : fontFamilies;\n};\nvar ForeignObjectRenderer = function(_super) {\n  __extends(ForeignObjectRenderer2, _super);\n  function ForeignObjectRenderer2(context, options) {\n    var _this = _super.call(this, context, options) || this;\n    _this.canvas = options.canvas ? options.canvas : document.createElement(\"canvas\");\n    _this.ctx = _this.canvas.getContext(\"2d\");\n    _this.options = options;\n    _this.canvas.width = Math.floor(options.width * options.scale);\n    _this.canvas.height = Math.floor(options.height * options.scale);\n    _this.canvas.style.width = options.width + \"px\";\n    _this.canvas.style.height = options.height + \"px\";\n    _this.ctx.scale(_this.options.scale, _this.options.scale);\n    _this.ctx.translate(-options.x, -options.y);\n    _this.context.logger.debug(\"EXPERIMENTAL ForeignObject renderer initialized (\" + options.width + \"x\" + options.height + \" at \" + options.x + \",\" + options.y + \") with scale \" + options.scale);\n    return _this;\n  }\n  ForeignObjectRenderer2.prototype.render = function(element) {\n    return __awaiter(this, void 0, void 0, function() {\n      var svg2, img;\n      return __generator(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            svg2 = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);\n            return [4, loadSerializedSVG(svg2)];\n          case 1:\n            img = _a2.sent();\n            if (this.options.backgroundColor) {\n              this.ctx.fillStyle = asString(this.options.backgroundColor);\n              this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);\n            }\n            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);\n            return [2, this.canvas];\n        }\n      });\n    });\n  };\n  return ForeignObjectRenderer2;\n}(Renderer);\nvar loadSerializedSVG = function(svg2) {\n  return new Promise(function(resolve2, reject2) {\n    var img = new Image();\n    img.onload = function() {\n      resolve2(img);\n    };\n    img.onerror = reject2;\n    img.src = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(new XMLSerializer().serializeToString(svg2));\n  });\n};\nvar Logger = function() {\n  function Logger2(_a2) {\n    var id = _a2.id, enabled = _a2.enabled;\n    this.id = id;\n    this.enabled = enabled;\n    this.start = Date.now();\n  }\n  Logger2.prototype.debug = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (this.enabled) {\n      if (typeof window !== \"undefined\" && window.console && typeof console.debug === \"function\") {\n        console.debug.apply(console, __spreadArray([this.id, this.getTime() + \"ms\"], args));\n      } else {\n        this.info.apply(this, args);\n      }\n    }\n  };\n  Logger2.prototype.getTime = function() {\n    return Date.now() - this.start;\n  };\n  Logger2.prototype.info = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (this.enabled) {\n      if (typeof window !== \"undefined\" && window.console && typeof console.info === \"function\") {\n        console.info.apply(console, __spreadArray([this.id, this.getTime() + \"ms\"], args));\n      }\n    }\n  };\n  Logger2.prototype.warn = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (this.enabled) {\n      if (typeof window !== \"undefined\" && window.console && typeof console.warn === \"function\") {\n        console.warn.apply(console, __spreadArray([this.id, this.getTime() + \"ms\"], args));\n      } else {\n        this.info.apply(this, args);\n      }\n    }\n  };\n  Logger2.prototype.error = function() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (this.enabled) {\n      if (typeof window !== \"undefined\" && window.console && typeof console.error === \"function\") {\n        console.error.apply(console, __spreadArray([this.id, this.getTime() + \"ms\"], args));\n      } else {\n        this.info.apply(this, args);\n      }\n    }\n  };\n  Logger2.instances = {};\n  return Logger2;\n}();\nvar Context = function() {\n  function Context2(options, windowBounds) {\n    var _a2;\n    this.windowBounds = windowBounds;\n    this.instanceName = \"#\" + Context2.instanceCount++;\n    this.logger = new Logger({ id: this.instanceName, enabled: options.logging });\n    this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);\n  }\n  Context2.instanceCount = 1;\n  return Context2;\n}();\nvar html2canvas = function(element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return renderElement(element, options);\n};\nif (typeof window !== \"undefined\") {\n  CacheStorage.setContext(window);\n}\nvar renderElement = function(element, opts) {\n  return __awaiter(void 0, void 0, void 0, function() {\n    var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root2, renderer;\n    var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;\n    return __generator(this, function(_u) {\n      switch (_u.label) {\n        case 0:\n          if (!element || typeof element !== \"object\") {\n            return [2, Promise.reject(\"Invalid element provided as first argument\")];\n          }\n          ownerDocument = element.ownerDocument;\n          if (!ownerDocument) {\n            throw new Error(\"Element is not attached to a Document\");\n          }\n          defaultView = ownerDocument.defaultView;\n          if (!defaultView) {\n            throw new Error(\"Document is not attached to a Window\");\n          }\n          resourceOptions = {\n            allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,\n            imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,\n            proxy: opts.proxy,\n            useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false\n          };\n          contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);\n          windowOptions = {\n            windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,\n            windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,\n            scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,\n            scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset\n          };\n          windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);\n          context = new Context(contextOptions, windowBounds);\n          foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;\n          cloneOptions = {\n            allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,\n            onclone: opts.onclone,\n            ignoreElements: opts.ignoreElements,\n            inlineImages: foreignObjectRendering,\n            copyStyles: foreignObjectRendering\n          };\n          context.logger.debug(\"Starting document clone with size \" + windowBounds.width + \"x\" + windowBounds.height + \" scrolled to \" + -windowBounds.left + \",\" + -windowBounds.top);\n          documentCloner = new DocumentCloner(context, element, cloneOptions);\n          clonedElement = documentCloner.clonedReferenceElement;\n          if (!clonedElement) {\n            return [2, Promise.reject(\"Unable to find element in cloned iframe\")];\n          }\n          return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];\n        case 1:\n          container = _u.sent();\n          _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;\n          backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);\n          renderOptions = {\n            canvas: opts.canvas,\n            backgroundColor: backgroundColor2,\n            scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,\n            x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,\n            y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,\n            width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),\n            height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)\n          };\n          if (!foreignObjectRendering)\n            return [3, 3];\n          context.logger.debug(\"Document cloned, using foreign object rendering\");\n          renderer = new ForeignObjectRenderer(context, renderOptions);\n          return [4, renderer.render(clonedElement)];\n        case 2:\n          canvas = _u.sent();\n          return [3, 5];\n        case 3:\n          context.logger.debug(\"Document cloned, element located at \" + left + \",\" + top + \" with size \" + width + \"x\" + height + \" using computed rendering\");\n          context.logger.debug(\"Starting DOM parsing\");\n          root2 = parseTree(context, clonedElement);\n          if (backgroundColor2 === root2.styles.backgroundColor) {\n            root2.styles.backgroundColor = COLORS.TRANSPARENT;\n          }\n          context.logger.debug(\"Starting renderer for element at \" + renderOptions.x + \",\" + renderOptions.y + \" with size \" + renderOptions.width + \"x\" + renderOptions.height);\n          renderer = new CanvasRenderer(context, renderOptions);\n          return [4, renderer.render(root2)];\n        case 4:\n          canvas = _u.sent();\n          _u.label = 5;\n        case 5:\n          if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {\n            if (!DocumentCloner.destroy(container)) {\n              context.logger.error(\"Cannot detach cloned iframe as it is not in the DOM anymore\");\n            }\n          }\n          context.logger.debug(\"Finished rendering\");\n          return [2, canvas];\n      }\n    });\n  });\n};\nvar parseBackgroundColor = function(context, element, backgroundColorOverride) {\n  var ownerDocument = element.ownerDocument;\n  var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;\n  var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;\n  var defaultBackgroundColor = typeof backgroundColorOverride === \"string\" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;\n  return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;\n};\nvar html2canvas_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": html2canvas\n}, Symbol.toStringTag, { value: \"Module\" }));\n/*! @license DOMPurify 2.3.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.5/LICENSE */\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {\n      arr2[i2] = arr[i2];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nvar hasOwnProperty$1 = Object.hasOwnProperty, setPrototypeOf$2 = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf$2 = Object.getPrototypeOf, getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor;\nvar freeze = Object.freeze, seal = Object.seal, create$3 = Object.create;\nvar _ref = typeof Reflect !== \"undefined\" && Reflect, apply$4 = _ref.apply, construct$1 = _ref.construct;\nif (!apply$4) {\n  apply$4 = function apply2(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\nif (!freeze) {\n  freeze = function freeze2(x2) {\n    return x2;\n  };\n}\nif (!seal) {\n  seal = function seal2(x2) {\n    return x2;\n  };\n}\nif (!construct$1) {\n  construct$1 = function construct2(Func, args) {\n    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n  };\n}\nvar arrayForEach = unapply(Array.prototype.forEach);\nvar arrayPop = unapply(Array.prototype.pop);\nvar arrayPush = unapply(Array.prototype.push);\nvar stringToLowerCase = unapply(String.prototype.toLowerCase);\nvar stringMatch = unapply(String.prototype.match);\nvar stringReplace = unapply(String.prototype.replace);\nvar stringIndexOf$2 = unapply(String.prototype.indexOf);\nvar stringTrim$1 = unapply(String.prototype.trim);\nvar regExpTest = unapply(RegExp.prototype.test);\nvar typeErrorCreate = unconstruct(TypeError);\nfunction unapply(func) {\n  return function(thisArg) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return apply$4(func, thisArg, args);\n  };\n}\nfunction unconstruct(func) {\n  return function() {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return construct$1(func, args);\n  };\n}\nfunction addToSet(set2, array) {\n  if (setPrototypeOf$2) {\n    setPrototypeOf$2(set2, null);\n  }\n  var l2 = array.length;\n  while (l2--) {\n    var element = array[l2];\n    if (typeof element === \"string\") {\n      var lcElement = stringToLowerCase(element);\n      if (lcElement !== element) {\n        if (!isFrozen(array)) {\n          array[l2] = lcElement;\n        }\n        element = lcElement;\n      }\n    }\n    set2[element] = true;\n  }\n  return set2;\n}\nfunction clone(object) {\n  var newObject = create$3(null);\n  var property = void 0;\n  for (property in object) {\n    if (apply$4(hasOwnProperty$1, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n  return newObject;\n}\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    var desc = getOwnPropertyDescriptor$5(object, prop);\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n      if (typeof desc.value === \"function\") {\n        return unapply(desc.value);\n      }\n    }\n    object = getPrototypeOf$2(object);\n  }\n  function fallbackValue(element) {\n    console.warn(\"fallback value for\", element);\n    return null;\n  }\n  return fallbackValue;\n}\nvar html$3 = freeze([\"a\", \"abbr\", \"acronym\", \"address\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"bdi\", \"bdo\", \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"decorator\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"img\", \"input\", \"ins\", \"kbd\", \"label\", \"legend\", \"li\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meter\", \"nav\", \"nobr\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"picture\", \"pre\", \"progress\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"section\", \"select\", \"shadow\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\"]);\nvar svg = freeze([\"svg\", \"a\", \"altglyph\", \"altglyphdef\", \"altglyphitem\", \"animatecolor\", \"animatemotion\", \"animatetransform\", \"circle\", \"clippath\", \"defs\", \"desc\", \"ellipse\", \"filter\", \"font\", \"g\", \"glyph\", \"glyphref\", \"hkern\", \"image\", \"line\", \"lineargradient\", \"marker\", \"mask\", \"metadata\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialgradient\", \"rect\", \"stop\", \"style\", \"switch\", \"symbol\", \"text\", \"textpath\", \"title\", \"tref\", \"tspan\", \"view\", \"vkern\"]);\nvar svgFilters = freeze([\"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\"]);\nvar svgDisallowed = freeze([\"animate\", \"color-profile\", \"cursor\", \"discard\", \"fedropshadow\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignobject\", \"hatch\", \"hatchpath\", \"mesh\", \"meshgradient\", \"meshpatch\", \"meshrow\", \"missing-glyph\", \"script\", \"set\", \"solidcolor\", \"unknown\", \"use\"]);\nvar mathMl = freeze([\"math\", \"menclose\", \"merror\", \"mfenced\", \"mfrac\", \"mglyph\", \"mi\", \"mlabeledtr\", \"mmultiscripts\", \"mn\", \"mo\", \"mover\", \"mpadded\", \"mphantom\", \"mroot\", \"mrow\", \"ms\", \"mspace\", \"msqrt\", \"mstyle\", \"msub\", \"msup\", \"msubsup\", \"mtable\", \"mtd\", \"mtext\", \"mtr\", \"munder\", \"munderover\"]);\nvar mathMlDisallowed = freeze([\"maction\", \"maligngroup\", \"malignmark\", \"mlongdiv\", \"mscarries\", \"mscarry\", \"msgroup\", \"mstack\", \"msline\", \"msrow\", \"semantics\", \"annotation\", \"annotation-xml\", \"mprescripts\", \"none\"]);\nvar text = freeze([\"#text\"]);\nvar html$1$1 = freeze([\"accept\", \"action\", \"align\", \"alt\", \"autocapitalize\", \"autocomplete\", \"autopictureinpicture\", \"autoplay\", \"background\", \"bgcolor\", \"border\", \"capture\", \"cellpadding\", \"cellspacing\", \"checked\", \"cite\", \"class\", \"clear\", \"color\", \"cols\", \"colspan\", \"controls\", \"controlslist\", \"coords\", \"crossorigin\", \"datetime\", \"decoding\", \"default\", \"dir\", \"disabled\", \"disablepictureinpicture\", \"disableremoteplayback\", \"download\", \"draggable\", \"enctype\", \"enterkeyhint\", \"face\", \"for\", \"headers\", \"height\", \"hidden\", \"high\", \"href\", \"hreflang\", \"id\", \"inputmode\", \"integrity\", \"ismap\", \"kind\", \"label\", \"lang\", \"list\", \"loading\", \"loop\", \"low\", \"max\", \"maxlength\", \"media\", \"method\", \"min\", \"minlength\", \"multiple\", \"muted\", \"name\", \"nonce\", \"noshade\", \"novalidate\", \"nowrap\", \"open\", \"optimum\", \"pattern\", \"placeholder\", \"playsinline\", \"poster\", \"preload\", \"pubdate\", \"radiogroup\", \"readonly\", \"rel\", \"required\", \"rev\", \"reversed\", \"role\", \"rows\", \"rowspan\", \"spellcheck\", \"scope\", \"selected\", \"shape\", \"size\", \"sizes\", \"span\", \"srclang\", \"start\", \"src\", \"srcset\", \"step\", \"style\", \"summary\", \"tabindex\", \"title\", \"translate\", \"type\", \"usemap\", \"valign\", \"value\", \"width\", \"xmlns\", \"slot\"]);\nvar svg$1 = freeze([\"accent-height\", \"accumulate\", \"additive\", \"alignment-baseline\", \"ascent\", \"attributename\", \"attributetype\", \"azimuth\", \"basefrequency\", \"baseline-shift\", \"begin\", \"bias\", \"by\", \"class\", \"clip\", \"clippathunits\", \"clip-path\", \"clip-rule\", \"color\", \"color-interpolation\", \"color-interpolation-filters\", \"color-profile\", \"color-rendering\", \"cx\", \"cy\", \"d\", \"dx\", \"dy\", \"diffuseconstant\", \"direction\", \"display\", \"divisor\", \"dur\", \"edgemode\", \"elevation\", \"end\", \"fill\", \"fill-opacity\", \"fill-rule\", \"filter\", \"filterunits\", \"flood-color\", \"flood-opacity\", \"font-family\", \"font-size\", \"font-size-adjust\", \"font-stretch\", \"font-style\", \"font-variant\", \"font-weight\", \"fx\", \"fy\", \"g1\", \"g2\", \"glyph-name\", \"glyphref\", \"gradientunits\", \"gradienttransform\", \"height\", \"href\", \"id\", \"image-rendering\", \"in\", \"in2\", \"k\", \"k1\", \"k2\", \"k3\", \"k4\", \"kerning\", \"keypoints\", \"keysplines\", \"keytimes\", \"lang\", \"lengthadjust\", \"letter-spacing\", \"kernelmatrix\", \"kernelunitlength\", \"lighting-color\", \"local\", \"marker-end\", \"marker-mid\", \"marker-start\", \"markerheight\", \"markerunits\", \"markerwidth\", \"maskcontentunits\", \"maskunits\", \"max\", \"mask\", \"media\", \"method\", \"mode\", \"min\", \"name\", \"numoctaves\", \"offset\", \"operator\", \"opacity\", \"order\", \"orient\", \"orientation\", \"origin\", \"overflow\", \"paint-order\", \"path\", \"pathlength\", \"patterncontentunits\", \"patterntransform\", \"patternunits\", \"points\", \"preservealpha\", \"preserveaspectratio\", \"primitiveunits\", \"r\", \"rx\", \"ry\", \"radius\", \"refx\", \"refy\", \"repeatcount\", \"repeatdur\", \"restart\", \"result\", \"rotate\", \"scale\", \"seed\", \"shape-rendering\", \"specularconstant\", \"specularexponent\", \"spreadmethod\", \"startoffset\", \"stddeviation\", \"stitchtiles\", \"stop-color\", \"stop-opacity\", \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\", \"stroke-miterlimit\", \"stroke-opacity\", \"stroke\", \"stroke-width\", \"style\", \"surfacescale\", \"systemlanguage\", \"tabindex\", \"targetx\", \"targety\", \"transform\", \"transform-origin\", \"text-anchor\", \"text-decoration\", \"text-rendering\", \"textlength\", \"type\", \"u1\", \"u2\", \"unicode\", \"values\", \"viewbox\", \"visibility\", \"version\", \"vert-adv-y\", \"vert-origin-x\", \"vert-origin-y\", \"width\", \"word-spacing\", \"wrap\", \"writing-mode\", \"xchannelselector\", \"ychannelselector\", \"x\", \"x1\", \"x2\", \"xmlns\", \"y\", \"y1\", \"y2\", \"z\", \"zoomandpan\"]);\nvar mathMl$1 = freeze([\"accent\", \"accentunder\", \"align\", \"bevelled\", \"close\", \"columnsalign\", \"columnlines\", \"columnspan\", \"denomalign\", \"depth\", \"dir\", \"display\", \"displaystyle\", \"encoding\", \"fence\", \"frame\", \"height\", \"href\", \"id\", \"largeop\", \"length\", \"linethickness\", \"lspace\", \"lquote\", \"mathbackground\", \"mathcolor\", \"mathsize\", \"mathvariant\", \"maxsize\", \"minsize\", \"movablelimits\", \"notation\", \"numalign\", \"open\", \"rowalign\", \"rowlines\", \"rowspacing\", \"rowspan\", \"rspace\", \"rquote\", \"scriptlevel\", \"scriptminsize\", \"scriptsizemultiplier\", \"selection\", \"separator\", \"separators\", \"stretchy\", \"subscriptshift\", \"supscriptshift\", \"symmetric\", \"voffset\", \"width\", \"xmlns\"]);\nvar xml = freeze([\"xlink:href\", \"xml:id\", \"xlink:title\", \"xml:space\", \"xmlns:xlink\"]);\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm);\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\nvar _typeof$1 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n  return typeof obj;\n} : function(obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nfunction _toConsumableArray$1(arr) {\n  if (Array.isArray(arr)) {\n    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {\n      arr2[i2] = arr[i2];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nvar getGlobal = function getGlobal2() {\n  return typeof window === \"undefined\" ? null : window;\n};\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {\n  if ((typeof trustedTypes === \"undefined\" ? \"undefined\" : _typeof$1(trustedTypes)) !== \"object\" || typeof trustedTypes.createPolicy !== \"function\") {\n    return null;\n  }\n  var suffix2 = null;\n  var ATTR_NAME = \"data-tt-policy-suffix\";\n  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix2 = document2.currentScript.getAttribute(ATTR_NAME);\n  }\n  var policyName = \"dompurify\" + (suffix2 ? \"#\" + suffix2 : \"\");\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (_2) {\n    console.warn(\"TrustedTypes policy \" + policyName + \" could not be created.\");\n    return null;\n  }\n};\nfunction createDOMPurify() {\n  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();\n  var DOMPurify = function DOMPurify2(root2) {\n    return createDOMPurify(root2);\n  };\n  DOMPurify.version = \"2.3.5\";\n  DOMPurify.removed = [];\n  if (!window2 || !window2.document || window2.document.nodeType !== 9) {\n    DOMPurify.isSupported = false;\n    return DOMPurify;\n  }\n  var originalDocument = window2.document;\n  var document2 = window2.document;\n  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;\n  var ElementPrototype = Element2.prototype;\n  var cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n  var getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n  var getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n  var getParentNode = lookupGetter(ElementPrototype, \"parentNode\");\n  if (typeof HTMLTemplateElement === \"function\") {\n    var template = document2.createElement(\"template\");\n    if (template.content && template.content.ownerDocument) {\n      document2 = template.content.ownerDocument;\n    }\n  }\n  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML(\"\") : \"\";\n  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;\n  var importNode = originalDocument.importNode;\n  var documentMode = {};\n  try {\n    documentMode = clone(document2).documentMode ? document2.documentMode : {};\n  } catch (_2) {\n  }\n  var hooks = {};\n  DOMPurify.isSupported = typeof getParentNode === \"function\" && implementation && typeof implementation.createHTMLDocument !== \"undefined\" && documentMode !== 9;\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$3), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n    tagNameCheck: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: null\n    },\n    attributeNameCheck: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: null\n    },\n    allowCustomizedBuiltInElements: {\n      writable: true,\n      configurable: false,\n      enumerable: true,\n      value: false\n    }\n  }));\n  var FORBID_TAGS = null;\n  var FORBID_ATTR = null;\n  var ALLOW_ARIA_ATTR = true;\n  var ALLOW_DATA_ATTR = true;\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n  var SAFE_FOR_TEMPLATES = false;\n  var WHOLE_DOCUMENT = false;\n  var SET_CONFIG = false;\n  var FORCE_BODY = false;\n  var RETURN_DOM = false;\n  var RETURN_DOM_FRAGMENT = false;\n  var RETURN_TRUSTED_TYPE = false;\n  var SANITIZE_DOM = true;\n  var KEEP_CONTENT = true;\n  var IN_PLACE = false;\n  var USE_PROFILES = {};\n  var FORBID_CONTENTS = null;\n  var DEFAULT_FORBID_CONTENTS = addToSet({}, [\"annotation-xml\", \"audio\", \"colgroup\", \"desc\", \"foreignobject\", \"head\", \"iframe\", \"math\", \"mi\", \"mn\", \"mo\", \"ms\", \"mtext\", \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\", \"svg\", \"template\", \"thead\", \"title\", \"video\", \"xmp\"]);\n  var DATA_URI_TAGS = null;\n  var DEFAULT_DATA_URI_TAGS = addToSet({}, [\"audio\", \"video\", \"img\", \"source\", \"image\", \"track\"]);\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\"alt\", \"class\", \"for\", \"id\", \"label\", \"name\", \"pattern\", \"placeholder\", \"role\", \"summary\", \"title\", \"value\", \"style\", \"xmlns\"]);\n  var MATHML_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n  var SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n  var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n  var NAMESPACE = HTML_NAMESPACE;\n  var IS_EMPTY_INPUT = false;\n  var PARSER_MEDIA_TYPE = void 0;\n  var SUPPORTED_PARSER_MEDIA_TYPES = [\"application/xhtml+xml\", \"text/html\"];\n  var DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n  var transformCaseFunc = void 0;\n  var CONFIG = null;\n  var formElement = document2.createElement(\"form\");\n  var isRegexOrFunction = function isRegexOrFunction2(testValue) {\n    return testValue instanceof RegExp || testValue instanceof Function;\n  };\n  var _parseConfig = function _parseConfig2(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n    if (!cfg || (typeof cfg === \"undefined\" ? \"undefined\" : _typeof$1(cfg)) !== \"object\") {\n      cfg = {};\n    }\n    cfg = clone(cfg);\n    ALLOWED_TAGS = \"ALLOWED_TAGS\" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = \"ALLOWED_ATTR\" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = \"ADD_URI_SAFE_ATTR\" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = \"ADD_DATA_URI_TAGS\" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = \"FORBID_CONTENTS\" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = \"FORBID_TAGS\" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = \"FORBID_ATTR\" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = \"USE_PROFILES\" in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n    RETURN_DOM = cfg.RETURN_DOM || false;\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n    FORCE_BODY = cfg.FORCE_BODY || false;\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n    IN_PLACE = cfg.IN_PLACE || false;\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n    }\n    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n    }\n    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") {\n      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n    }\n    PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n    transformCaseFunc = PARSER_MEDIA_TYPE === \"application/xhtml+xml\" ? function(x2) {\n      return x2;\n    } : stringToLowerCase;\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html$3);\n        addToSet(ALLOWED_ATTR, html$1$1);\n      }\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n    }\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS[\"#text\"] = true;\n    }\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, [\"html\", \"head\", \"body\"]);\n    }\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, [\"tbody\"]);\n      delete FORBID_TAGS.tbody;\n    }\n    if (freeze) {\n      freeze(cfg);\n    }\n    CONFIG = cfg;\n  };\n  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\"mi\", \"mo\", \"mn\", \"ms\", \"mtext\"]);\n  var HTML_INTEGRATION_POINTS = addToSet({}, [\"foreignobject\", \"desc\", \"title\", \"annotation-xml\"]);\n  var ALL_SVG_TAGS = addToSet({}, svg);\n  addToSet(ALL_SVG_TAGS, svgFilters);\n  addToSet(ALL_SVG_TAGS, svgDisallowed);\n  var ALL_MATHML_TAGS = addToSet({}, mathMl);\n  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n  var _checkValidNamespace = function _checkValidNamespace2(element) {\n    var parent = getParentNode(element);\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: HTML_NAMESPACE,\n        tagName: \"template\"\n      };\n    }\n    var tagName = stringToLowerCase(element.tagName);\n    var parentTagName = stringToLowerCase(parent.tagName);\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === \"svg\";\n      }\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return tagName === \"svg\" && (parentTagName === \"annotation-xml\" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n      }\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === \"math\";\n      }\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === \"math\" && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n      var commonSvgAndHTMLElements = addToSet({}, [\"title\", \"style\", \"font\", \"a\", \"script\"]);\n      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n    }\n    return false;\n  };\n  var _forceRemove = function _forceRemove2(node2) {\n    arrayPush(DOMPurify.removed, { element: node2 });\n    try {\n      node2.parentNode.removeChild(node2);\n    } catch (_2) {\n      try {\n        node2.outerHTML = emptyHTML;\n      } catch (_3) {\n        node2.remove();\n      }\n    }\n  };\n  var _removeAttribute = function _removeAttribute2(name, node2) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node2.getAttributeNode(name),\n        from: node2\n      });\n    } catch (_2) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node2\n      });\n    }\n    node2.removeAttribute(name);\n    if (name === \"is\" && !ALLOWED_ATTR[name]) {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(node2);\n        } catch (_2) {\n        }\n      } else {\n        try {\n          node2.setAttribute(name, \"\");\n        } catch (_2) {\n        }\n      }\n    }\n  };\n  var _initDocument = function _initDocument2(dirty) {\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n    if (FORCE_BODY) {\n      dirty = \"<remove></remove>\" + dirty;\n    } else {\n      var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n    if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\") {\n      dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + \"</body></html>\";\n    }\n    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_2) {\n      }\n    }\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, \"template\", null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? \"\" : dirtyPayload;\n      } catch (_2) {\n      }\n    }\n    var body = doc.body || doc.documentElement;\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n    }\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n    }\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n  var _createIterator = function _createIterator2(root2) {\n    return createNodeIterator.call(root2.ownerDocument || root2, root2, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n  };\n  var _isClobbered = function _isClobbered2(elm) {\n    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== \"string\" || typeof elm.textContent !== \"string\" || typeof elm.removeChild !== \"function\" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== \"function\" || typeof elm.setAttribute !== \"function\" || typeof elm.namespaceURI !== \"string\" || typeof elm.insertBefore !== \"function\");\n  };\n  var _isNode = function _isNode2(object) {\n    return (typeof Node2 === \"undefined\" ? \"undefined\" : _typeof$1(Node2)) === \"object\" ? object instanceof Node2 : object && (typeof object === \"undefined\" ? \"undefined\" : _typeof$1(object)) === \"object\" && typeof object.nodeType === \"number\" && typeof object.nodeName === \"string\";\n  };\n  var _executeHook = function _executeHook2(entryPoint, currentNode, data2) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n    arrayForEach(hooks[entryPoint], function(hook) {\n      hook.call(DOMPurify, currentNode, data2, CONFIG);\n    });\n  };\n  var _sanitizeElements = function _sanitizeElements2(currentNode) {\n    var content2 = void 0;\n    _executeHook(\"beforeSanitizeElements\", currentNode, null);\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    var tagName = transformCaseFunc(currentNode.nodeName);\n    _executeHook(\"uponSanitizeElement\", currentNode, {\n      tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    if (tagName === \"select\" && regExpTest(/<template/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n        if (childNodes && parentNode) {\n          var childCount = childNodes.length;\n          for (var i2 = childCount - 1; i2 >= 0; --i2) {\n            parentNode.insertBefore(cloneNode(childNodes[i2], true), getNextSibling(currentNode));\n          }\n        }\n      }\n      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\n          return false;\n        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\n          return false;\n      }\n      _forceRemove(currentNode);\n      return true;\n    }\n    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    if ((tagName === \"noscript\" || tagName === \"noembed\") && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      content2 = currentNode.textContent;\n      content2 = stringReplace(content2, MUSTACHE_EXPR$$1, \" \");\n      content2 = stringReplace(content2, ERB_EXPR$$1, \" \");\n      if (currentNode.textContent !== content2) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content2;\n      }\n    }\n    _executeHook(\"afterSanitizeElements\", currentNode, null);\n    return false;\n  };\n  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {\n    if (SANITIZE_DOM && (lcName === \"id\" || lcName === \"name\") && (value in document2 || value in formElement)) {\n      return false;\n    }\n    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName))\n      ;\n    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))\n      ;\n    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === \"is\" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))\n        ;\n      else {\n        return false;\n      }\n    } else if (URI_SAFE_ATTRIBUTES[lcName])\n      ;\n    else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, \"\")))\n      ;\n    else if ((lcName === \"src\" || lcName === \"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && stringIndexOf$2(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag])\n      ;\n    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, \"\")))\n      ;\n    else if (!value)\n      ;\n    else {\n      return false;\n    }\n    return true;\n  };\n  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {\n    return tagName.indexOf(\"-\") > 0;\n  };\n  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var l2 = void 0;\n    _executeHook(\"beforeSanitizeAttributes\", currentNode, null);\n    var attributes = currentNode.attributes;\n    if (!attributes) {\n      return;\n    }\n    var hookEvent = {\n      attrName: \"\",\n      attrValue: \"\",\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l2 = attributes.length;\n    while (l2--) {\n      attr = attributes[l2];\n      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;\n      value = stringTrim$1(attr.value);\n      lcName = transformCaseFunc(name);\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = void 0;\n      _executeHook(\"uponSanitizeAttribute\", currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n      _removeAttribute(name, currentNode);\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n      if (regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n      if (SAFE_FOR_TEMPLATES) {\n        value = stringReplace(value, MUSTACHE_EXPR$$1, \" \");\n        value = stringReplace(value, ERB_EXPR$$1, \" \");\n      }\n      var lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          currentNode.setAttribute(name, value);\n        }\n        arrayPop(DOMPurify.removed);\n      } catch (_2) {\n      }\n    }\n    _executeHook(\"afterSanitizeAttributes\", currentNode, null);\n  };\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n    _executeHook(\"beforeSanitizeShadowDOM\", fragment, null);\n    while (shadowNode = shadowIterator.nextNode()) {\n      _executeHook(\"uponSanitizeShadowNode\", shadowNode, null);\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM2(shadowNode.content);\n      }\n      _sanitizeAttributes(shadowNode);\n    }\n    _executeHook(\"afterSanitizeShadowDOM\", fragment, null);\n  };\n  DOMPurify.sanitize = function(dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = \"<!-->\";\n    }\n    if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n      if (typeof dirty.toString !== \"function\") {\n        throw typeErrorCreate(\"toString is not a function\");\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== \"string\") {\n          throw typeErrorCreate(\"dirty is not a string, aborting\");\n        }\n      }\n    }\n    if (!DOMPurify.isSupported) {\n      if (_typeof$1(window2.toStaticHTML) === \"object\" || typeof window2.toStaticHTML === \"function\") {\n        if (typeof dirty === \"string\") {\n          return window2.toStaticHTML(dirty);\n        }\n        if (_isNode(dirty)) {\n          return window2.toStaticHTML(dirty.outerHTML);\n        }\n      }\n      return dirty;\n    }\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n    DOMPurify.removed = [];\n    if (typeof dirty === \"string\") {\n      IN_PLACE = false;\n    }\n    if (IN_PLACE) {\n      if (dirty.nodeName) {\n        var tagName = transformCaseFunc(dirty.nodeName);\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          throw typeErrorCreate(\"root node is forbidden and cannot be sanitized in-place\");\n        }\n      }\n    } else if (dirty instanceof Node2) {\n      body = _initDocument(\"<!---->\");\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === \"BODY\") {\n        body = importedNode;\n      } else if (importedNode.nodeName === \"HTML\") {\n        body = importedNode;\n      } else {\n        body.appendChild(importedNode);\n      }\n    } else {\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf(\"<\") === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n      body = _initDocument(dirty);\n      if (!body) {\n        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \"\";\n      }\n    }\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n    while (currentNode = nodeIterator.nextNode()) {\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n      _sanitizeAttributes(currentNode);\n      oldNode = currentNode;\n    }\n    oldNode = null;\n    if (IN_PLACE) {\n      return dirty;\n    }\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n        while (body.firstChild) {\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n      if (ALLOWED_ATTR.shadowroot) {\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n      return returnNode;\n    }\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, \" \");\n      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, \" \");\n    }\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n  DOMPurify.setConfig = function(cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n  DOMPurify.clearConfig = function() {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n  DOMPurify.isValidAttribute = function(tag, attr, value) {\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n    var lcTag = transformCaseFunc(tag);\n    var lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n  DOMPurify.addHook = function(entryPoint, hookFunction) {\n    if (typeof hookFunction !== \"function\") {\n      return;\n    }\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n  DOMPurify.removeHook = function(entryPoint) {\n    if (hooks[entryPoint]) {\n      arrayPop(hooks[entryPoint]);\n    }\n  };\n  DOMPurify.removeHooks = function(entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n  DOMPurify.removeAllHooks = function() {\n    hooks = {};\n  };\n  return DOMPurify;\n}\nvar purify = createDOMPurify();\nvar purify_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": purify\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar check = function(it2) {\n  return it2 && it2.Math == Math && it2;\n};\nvar global$I = check(typeof globalThis == \"object\" && globalThis) || check(typeof window == \"object\" && window) || check(typeof self == \"object\" && self) || check(typeof commonjsGlobal == \"object\" && commonjsGlobal) || function() {\n  return this;\n}() || Function(\"return this\")();\nvar objectGetOwnPropertyDescriptor = {};\nvar fails$k = function(exec2) {\n  try {\n    return !!exec2();\n  } catch (error) {\n    return true;\n  }\n};\nvar fails$j = fails$k;\nvar descriptors = !fails$j(function() {\n  return Object.defineProperty({}, 1, { get: function() {\n    return 7;\n  } })[1] != 7;\n});\nvar fails$i = fails$k;\nvar functionBindNative = !fails$i(function() {\n  var test2 = function() {\n  }.bind();\n  return typeof test2 != \"function\" || test2.hasOwnProperty(\"prototype\");\n});\nvar NATIVE_BIND$3 = functionBindNative;\nvar call$f = Function.prototype.call;\nvar functionCall = NATIVE_BIND$3 ? call$f.bind(call$f) : function() {\n  return call$f.apply(call$f, arguments);\n};\nvar objectPropertyIsEnumerable = {};\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;\nvar NASHORN_BUG = getOwnPropertyDescriptor$4 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {\n  var descriptor = getOwnPropertyDescriptor$4(this, V2);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\nvar createPropertyDescriptor$4 = function(bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value\n  };\n};\nvar NATIVE_BIND$2 = functionBindNative;\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$5 = FunctionPrototype$2.bind;\nvar call$e = FunctionPrototype$2.call;\nvar uncurryThis$q = NATIVE_BIND$2 && bind$5.bind(call$e, call$e);\nvar functionUncurryThis = NATIVE_BIND$2 ? function(fn) {\n  return fn && uncurryThis$q(fn);\n} : function(fn) {\n  return fn && function() {\n    return call$e.apply(fn, arguments);\n  };\n};\nvar uncurryThis$p = functionUncurryThis;\nvar toString$b = uncurryThis$p({}.toString);\nvar stringSlice$6 = uncurryThis$p(\"\".slice);\nvar classofRaw$1 = function(it2) {\n  return stringSlice$6(toString$b(it2), 8, -1);\n};\nvar global$H = global$I;\nvar uncurryThis$o = functionUncurryThis;\nvar fails$h = fails$k;\nvar classof$8 = classofRaw$1;\nvar Object$5 = global$H.Object;\nvar split = uncurryThis$o(\"\".split);\nvar indexedObject = fails$h(function() {\n  return !Object$5(\"z\").propertyIsEnumerable(0);\n}) ? function(it2) {\n  return classof$8(it2) == \"String\" ? split(it2, \"\") : Object$5(it2);\n} : Object$5;\nvar global$G = global$I;\nvar TypeError$g = global$G.TypeError;\nvar requireObjectCoercible$a = function(it2) {\n  if (it2 == void 0)\n    throw TypeError$g(\"Can't call method on \" + it2);\n  return it2;\n};\nvar IndexedObject$1 = indexedObject;\nvar requireObjectCoercible$9 = requireObjectCoercible$a;\nvar toIndexedObject$5 = function(it2) {\n  return IndexedObject$1(requireObjectCoercible$9(it2));\n};\nvar isCallable$j = function(argument) {\n  return typeof argument == \"function\";\n};\nvar isCallable$i = isCallable$j;\nvar isObject$8 = function(it2) {\n  return typeof it2 == \"object\" ? it2 !== null : isCallable$i(it2);\n};\nvar global$F = global$I;\nvar isCallable$h = isCallable$j;\nvar aFunction = function(argument) {\n  return isCallable$h(argument) ? argument : void 0;\n};\nvar getBuiltIn$7 = function(namespace, method) {\n  return arguments.length < 2 ? aFunction(global$F[namespace]) : global$F[namespace] && global$F[namespace][method];\n};\nvar uncurryThis$n = functionUncurryThis;\nvar objectIsPrototypeOf = uncurryThis$n({}.isPrototypeOf);\nvar getBuiltIn$6 = getBuiltIn$7;\nvar engineUserAgent = getBuiltIn$6(\"navigator\", \"userAgent\") || \"\";\nvar global$E = global$I;\nvar userAgent$3 = engineUserAgent;\nvar process$4 = global$E.process;\nvar Deno = global$E.Deno;\nvar versions = process$4 && process$4.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n  match = v8.split(\".\");\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\nif (!version && userAgent$3) {\n  match = userAgent$3.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$3.match(/Chrome\\/(\\d+)/);\n    if (match)\n      version = +match[1];\n  }\n}\nvar engineV8Version = version;\nvar V8_VERSION$1 = engineV8Version;\nvar fails$g = fails$k;\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$g(function() {\n  var symbol = Symbol();\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\nvar NATIVE_SYMBOL$1 = nativeSymbol;\nvar useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\nvar global$D = global$I;\nvar getBuiltIn$5 = getBuiltIn$7;\nvar isCallable$g = isCallable$j;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\nvar Object$4 = global$D.Object;\nvar isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it2) {\n  return typeof it2 == \"symbol\";\n} : function(it2) {\n  var $Symbol = getBuiltIn$5(\"Symbol\");\n  return isCallable$g($Symbol) && isPrototypeOf$3($Symbol.prototype, Object$4(it2));\n};\nvar global$C = global$I;\nvar String$5 = global$C.String;\nvar tryToString$4 = function(argument) {\n  try {\n    return String$5(argument);\n  } catch (error) {\n    return \"Object\";\n  }\n};\nvar global$B = global$I;\nvar isCallable$f = isCallable$j;\nvar tryToString$3 = tryToString$4;\nvar TypeError$f = global$B.TypeError;\nvar aCallable$6 = function(argument) {\n  if (isCallable$f(argument))\n    return argument;\n  throw TypeError$f(tryToString$3(argument) + \" is not a function\");\n};\nvar aCallable$5 = aCallable$6;\nvar getMethod$6 = function(V2, P2) {\n  var func = V2[P2];\n  return func == null ? void 0 : aCallable$5(func);\n};\nvar global$A = global$I;\nvar call$d = functionCall;\nvar isCallable$e = isCallable$j;\nvar isObject$7 = isObject$8;\nvar TypeError$e = global$A.TypeError;\nvar ordinaryToPrimitive$1 = function(input, pref) {\n  var fn, val;\n  if (pref === \"string\" && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input)))\n    return val;\n  if (isCallable$e(fn = input.valueOf) && !isObject$7(val = call$d(fn, input)))\n    return val;\n  if (pref !== \"string\" && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input)))\n    return val;\n  throw TypeError$e(\"Can't convert object to primitive value\");\n};\nvar shared$4 = { exports: {} };\nvar global$z = global$I;\nvar defineProperty$2 = Object.defineProperty;\nvar setGlobal$3 = function(key, value) {\n  try {\n    defineProperty$2(global$z, key, { value, configurable: true, writable: true });\n  } catch (error) {\n    global$z[key] = value;\n  }\n  return value;\n};\nvar global$y = global$I;\nvar setGlobal$2 = setGlobal$3;\nvar SHARED = \"__core-js_shared__\";\nvar store$3 = global$y[SHARED] || setGlobal$2(SHARED, {});\nvar sharedStore = store$3;\nvar store$2 = sharedStore;\n(shared$4.exports = function(key, value) {\n  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});\n})(\"versions\", []).push({\n  version: \"3.20.3\",\n  mode: \"global\",\n  copyright: \"\\xA9 2014-2022 Denis Pushkarev (zloirock.ru)\",\n  license: \"https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE\",\n  source: \"https://github.com/zloirock/core-js\"\n});\nvar global$x = global$I;\nvar requireObjectCoercible$8 = requireObjectCoercible$a;\nvar Object$3 = global$x.Object;\nvar toObject$4 = function(argument) {\n  return Object$3(requireObjectCoercible$8(argument));\n};\nvar uncurryThis$m = functionUncurryThis;\nvar toObject$3 = toObject$4;\nvar hasOwnProperty = uncurryThis$m({}.hasOwnProperty);\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it2, key) {\n  return hasOwnProperty(toObject$3(it2), key);\n};\nvar uncurryThis$l = functionUncurryThis;\nvar id$1 = 0;\nvar postfix = Math.random();\nvar toString$a = uncurryThis$l(1 .toString);\nvar uid$2 = function(key) {\n  return \"Symbol(\" + (key === void 0 ? \"\" : key) + \")_\" + toString$a(++id$1 + postfix, 36);\n};\nvar global$w = global$I;\nvar shared$3 = shared$4.exports;\nvar hasOwn$9 = hasOwnProperty_1;\nvar uid$1 = uid$2;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\nvar WellKnownSymbolsStore = shared$3(\"wks\");\nvar Symbol$1 = global$w.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1[\"for\"];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;\nvar wellKnownSymbol$i = function(name) {\n  if (!hasOwn$9(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n    var description = \"Symbol.\" + name;\n    if (NATIVE_SYMBOL && hasOwn$9(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  }\n  return WellKnownSymbolsStore[name];\n};\nvar global$v = global$I;\nvar call$c = functionCall;\nvar isObject$6 = isObject$8;\nvar isSymbol$1 = isSymbol$2;\nvar getMethod$5 = getMethod$6;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$h = wellKnownSymbol$i;\nvar TypeError$d = global$v.TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$h(\"toPrimitive\");\nvar toPrimitive$1 = function(input, pref) {\n  if (!isObject$6(input) || isSymbol$1(input))\n    return input;\n  var exoticToPrim = getMethod$5(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === void 0)\n      pref = \"default\";\n    result = call$c(exoticToPrim, input, pref);\n    if (!isObject$6(result) || isSymbol$1(result))\n      return result;\n    throw TypeError$d(\"Can't convert object to primitive value\");\n  }\n  if (pref === void 0)\n    pref = \"number\";\n  return ordinaryToPrimitive(input, pref);\n};\nvar toPrimitive = toPrimitive$1;\nvar isSymbol = isSymbol$2;\nvar toPropertyKey$3 = function(argument) {\n  var key = toPrimitive(argument, \"string\");\n  return isSymbol(key) ? key : key + \"\";\n};\nvar global$u = global$I;\nvar isObject$5 = isObject$8;\nvar document$3 = global$u.document;\nvar EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);\nvar documentCreateElement$2 = function(it2) {\n  return EXISTS$1 ? document$3.createElement(it2) : {};\n};\nvar DESCRIPTORS$8 = descriptors;\nvar fails$f = fails$k;\nvar createElement$1 = documentCreateElement$2;\nvar ie8DomDefine = !DESCRIPTORS$8 && !fails$f(function() {\n  return Object.defineProperty(createElement$1(\"div\"), \"a\", {\n    get: function() {\n      return 7;\n    }\n  }).a != 7;\n});\nvar DESCRIPTORS$7 = descriptors;\nvar call$b = functionCall;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$4;\nvar toIndexedObject$4 = toIndexedObject$5;\nvar toPropertyKey$2 = toPropertyKey$3;\nvar hasOwn$8 = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O2, P2) {\n  O2 = toIndexedObject$4(O2);\n  P2 = toPropertyKey$2(P2);\n  if (IE8_DOM_DEFINE$1)\n    try {\n      return $getOwnPropertyDescriptor$1(O2, P2);\n    } catch (error) {\n    }\n  if (hasOwn$8(O2, P2))\n    return createPropertyDescriptor$3(!call$b(propertyIsEnumerableModule.f, O2, P2), O2[P2]);\n};\nvar objectDefineProperty = {};\nvar DESCRIPTORS$6 = descriptors;\nvar fails$e = fails$k;\nvar v8PrototypeDefineBug = DESCRIPTORS$6 && fails$e(function() {\n  return Object.defineProperty(function() {\n  }, \"prototype\", {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\nvar global$t = global$I;\nvar isObject$4 = isObject$8;\nvar String$4 = global$t.String;\nvar TypeError$c = global$t.TypeError;\nvar anObject$g = function(argument) {\n  if (isObject$4(argument))\n    return argument;\n  throw TypeError$c(String$4(argument) + \" is not an object\");\n};\nvar global$s = global$I;\nvar DESCRIPTORS$5 = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$f = anObject$g;\nvar toPropertyKey$1 = toPropertyKey$3;\nvar TypeError$b = global$s.TypeError;\nvar $defineProperty = Object.defineProperty;\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = \"enumerable\";\nvar CONFIGURABLE$1 = \"configurable\";\nvar WRITABLE = \"writable\";\nobjectDefineProperty.f = DESCRIPTORS$5 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O2, P2, Attributes2) {\n  anObject$f(O2);\n  P2 = toPropertyKey$1(P2);\n  anObject$f(Attributes2);\n  if (typeof O2 === \"function\" && P2 === \"prototype\" && \"value\" in Attributes2 && WRITABLE in Attributes2 && !Attributes2[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O2, P2);\n    if (current && current[WRITABLE]) {\n      O2[P2] = Attributes2.value;\n      Attributes2 = {\n        configurable: CONFIGURABLE$1 in Attributes2 ? Attributes2[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes2 ? Attributes2[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  }\n  return $defineProperty(O2, P2, Attributes2);\n} : $defineProperty : function defineProperty2(O2, P2, Attributes2) {\n  anObject$f(O2);\n  P2 = toPropertyKey$1(P2);\n  anObject$f(Attributes2);\n  if (IE8_DOM_DEFINE)\n    try {\n      return $defineProperty(O2, P2, Attributes2);\n    } catch (error) {\n    }\n  if (\"get\" in Attributes2 || \"set\" in Attributes2)\n    throw TypeError$b(\"Accessors not supported\");\n  if (\"value\" in Attributes2)\n    O2[P2] = Attributes2.value;\n  return O2;\n};\nvar DESCRIPTORS$4 = descriptors;\nvar definePropertyModule$5 = objectDefineProperty;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$4;\nvar createNonEnumerableProperty$6 = DESCRIPTORS$4 ? function(object, key, value) {\n  return definePropertyModule$5.f(object, key, createPropertyDescriptor$2(1, value));\n} : function(object, key, value) {\n  object[key] = value;\n  return object;\n};\nvar redefine$7 = { exports: {} };\nvar uncurryThis$k = functionUncurryThis;\nvar isCallable$d = isCallable$j;\nvar store$1 = sharedStore;\nvar functionToString = uncurryThis$k(Function.toString);\nif (!isCallable$d(store$1.inspectSource)) {\n  store$1.inspectSource = function(it2) {\n    return functionToString(it2);\n  };\n}\nvar inspectSource$4 = store$1.inspectSource;\nvar global$r = global$I;\nvar isCallable$c = isCallable$j;\nvar inspectSource$3 = inspectSource$4;\nvar WeakMap$1 = global$r.WeakMap;\nvar nativeWeakMap = isCallable$c(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\nvar shared$2 = shared$4.exports;\nvar uid = uid$2;\nvar keys = shared$2(\"keys\");\nvar sharedKey$3 = function(key) {\n  return keys[key] || (keys[key] = uid(key));\n};\nvar hiddenKeys$4 = {};\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$q = global$I;\nvar uncurryThis$j = functionUncurryThis;\nvar isObject$3 = isObject$8;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$6;\nvar hasOwn$7 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\nvar OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\nvar TypeError$a = global$q.TypeError;\nvar WeakMap = global$q.WeakMap;\nvar set$1, get, has;\nvar enforce = function(it2) {\n  return has(it2) ? get(it2) : set$1(it2, {});\n};\nvar getterFor = function(TYPE) {\n  return function(it2) {\n    var state;\n    if (!isObject$3(it2) || (state = get(it2)).type !== TYPE) {\n      throw TypeError$a(\"Incompatible receiver, \" + TYPE + \" required\");\n    }\n    return state;\n  };\n};\nif (NATIVE_WEAK_MAP || shared$1.state) {\n  var store = shared$1.state || (shared$1.state = new WeakMap());\n  var wmget = uncurryThis$j(store.get);\n  var wmhas = uncurryThis$j(store.has);\n  var wmset = uncurryThis$j(store.set);\n  set$1 = function(it2, metadata) {\n    if (wmhas(store, it2))\n      throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it2;\n    wmset(store, it2, metadata);\n    return metadata;\n  };\n  get = function(it2) {\n    return wmget(store, it2) || {};\n  };\n  has = function(it2) {\n    return wmhas(store, it2);\n  };\n} else {\n  var STATE = sharedKey$2(\"state\");\n  hiddenKeys$3[STATE] = true;\n  set$1 = function(it2, metadata) {\n    if (hasOwn$7(it2, STATE))\n      throw new TypeError$a(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it2;\n    createNonEnumerableProperty$5(it2, STATE, metadata);\n    return metadata;\n  };\n  get = function(it2) {\n    return hasOwn$7(it2, STATE) ? it2[STATE] : {};\n  };\n  has = function(it2) {\n    return hasOwn$7(it2, STATE);\n  };\n}\nvar internalState = {\n  set: set$1,\n  get,\n  has,\n  enforce,\n  getterFor\n};\nvar DESCRIPTORS$3 = descriptors;\nvar hasOwn$6 = hasOwnProperty_1;\nvar FunctionPrototype$1 = Function.prototype;\nvar getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn$6(FunctionPrototype$1, \"name\");\nvar PROPER = EXISTS && function something() {\n}.name === \"something\";\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || DESCRIPTORS$3 && getDescriptor(FunctionPrototype$1, \"name\").configurable);\nvar functionName = {\n  EXISTS,\n  PROPER,\n  CONFIGURABLE\n};\nvar global$p = global$I;\nvar isCallable$b = isCallable$j;\nvar hasOwn$5 = hasOwnProperty_1;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$6;\nvar setGlobal$1 = setGlobal$3;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$2 = internalState;\nvar CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;\nvar getInternalState$3 = InternalStateModule$2.get;\nvar enforceInternalState = InternalStateModule$2.enforce;\nvar TEMPLATE = String(String).split(\"String\");\n(redefine$7.exports = function(O2, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var name = options && options.name !== void 0 ? options.name : key;\n  var state;\n  if (isCallable$b(value)) {\n    if (String(name).slice(0, 7) === \"Symbol(\") {\n      name = \"[\" + String(name).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\";\n    }\n    if (!hasOwn$5(value, \"name\") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {\n      createNonEnumerableProperty$4(value, \"name\", name);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof name == \"string\" ? name : \"\");\n    }\n  }\n  if (O2 === global$p) {\n    if (simple)\n      O2[key] = value;\n    else\n      setGlobal$1(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O2[key];\n  } else if (!noTargetGet && O2[key]) {\n    simple = true;\n  }\n  if (simple)\n    O2[key] = value;\n  else\n    createNonEnumerableProperty$4(O2, key, value);\n})(Function.prototype, \"toString\", function toString() {\n  return isCallable$b(this) && getInternalState$3(this).source || inspectSource$2(this);\n});\nvar objectGetOwnPropertyNames = {};\nvar ceil = Math.ceil;\nvar floor$1 = Math.floor;\nvar toIntegerOrInfinity$4 = function(argument) {\n  var number = +argument;\n  return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);\n};\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$4;\nvar max$2 = Math.max;\nvar min$5 = Math.min;\nvar toAbsoluteIndex$2 = function(index2, length) {\n  var integer = toIntegerOrInfinity$3(index2);\n  return integer < 0 ? max$2(integer + length, 0) : min$5(integer, length);\n};\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$4;\nvar min$4 = Math.min;\nvar toLength$6 = function(argument) {\n  return argument > 0 ? min$4(toIntegerOrInfinity$2(argument), 9007199254740991) : 0;\n};\nvar toLength$5 = toLength$6;\nvar lengthOfArrayLike$4 = function(obj) {\n  return toLength$5(obj.length);\n};\nvar toIndexedObject$3 = toIndexedObject$5;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$2;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$4;\nvar createMethod$3 = function(IS_INCLUDES) {\n  return function($this, el, fromIndex) {\n    var O2 = toIndexedObject$3($this);\n    var length = lengthOfArrayLike$3(O2);\n    var index2 = toAbsoluteIndex$1(fromIndex, length);\n    var value;\n    if (IS_INCLUDES && el != el)\n      while (length > index2) {\n        value = O2[index2++];\n        if (value != value)\n          return true;\n      }\n    else\n      for (; length > index2; index2++) {\n        if ((IS_INCLUDES || index2 in O2) && O2[index2] === el)\n          return IS_INCLUDES || index2 || 0;\n      }\n    return !IS_INCLUDES && -1;\n  };\n};\nvar arrayIncludes = {\n  includes: createMethod$3(true),\n  indexOf: createMethod$3(false)\n};\nvar uncurryThis$i = functionUncurryThis;\nvar hasOwn$4 = hasOwnProperty_1;\nvar toIndexedObject$2 = toIndexedObject$5;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\nvar push$2 = uncurryThis$i([].push);\nvar objectKeysInternal = function(object, names2) {\n  var O2 = toIndexedObject$2(object);\n  var i2 = 0;\n  var result = [];\n  var key;\n  for (key in O2)\n    !hasOwn$4(hiddenKeys$2, key) && hasOwn$4(O2, key) && push$2(result, key);\n  while (names2.length > i2)\n    if (hasOwn$4(O2, key = names2[i2++])) {\n      ~indexOf$1(result, key) || push$2(result, key);\n    }\n  return result;\n};\nvar enumBugKeys$3 = [\n  \"constructor\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"toLocaleString\",\n  \"toString\",\n  \"valueOf\"\n];\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\nvar hiddenKeys$1 = enumBugKeys$2.concat(\"length\", \"prototype\");\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {\n  return internalObjectKeys$1(O2, hiddenKeys$1);\n};\nvar objectGetOwnPropertySymbols = {};\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\nvar getBuiltIn$4 = getBuiltIn$7;\nvar uncurryThis$h = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar anObject$e = anObject$g;\nvar concat$1 = uncurryThis$h([].concat);\nvar ownKeys$4 = getBuiltIn$4(\"Reflect\", \"ownKeys\") || function ownKeys(it2) {\n  var keys3 = getOwnPropertyNamesModule.f(anObject$e(it2));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat$1(keys3, getOwnPropertySymbols(it2)) : keys3;\n};\nvar hasOwn$3 = hasOwnProperty_1;\nvar ownKeys$3 = ownKeys$4;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$4 = objectDefineProperty;\nvar copyConstructorProperties$1 = function(target, source, exceptions) {\n  var keys3 = ownKeys$3(source);\n  var defineProperty4 = definePropertyModule$4.f;\n  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;\n  for (var i2 = 0; i2 < keys3.length; i2++) {\n    var key = keys3[i2];\n    if (!hasOwn$3(target, key) && !(exceptions && hasOwn$3(exceptions, key))) {\n      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));\n    }\n  }\n};\nvar fails$d = fails$k;\nvar isCallable$a = isCallable$j;\nvar replacement = /#|\\.prototype\\./;\nvar isForced$2 = function(feature2, detection) {\n  var value = data[normalize(feature2)];\n  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$a(detection) ? fails$d(detection) : !!detection;\n};\nvar normalize = isForced$2.normalize = function(string) {\n  return String(string).replace(replacement, \".\").toLowerCase();\n};\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = \"N\";\nvar POLYFILL = isForced$2.POLYFILL = \"P\";\nvar isForced_1 = isForced$2;\nvar global$o = global$I;\nvar getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$6;\nvar redefine$6 = redefine$7.exports;\nvar setGlobal = setGlobal$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\nvar _export = function(options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$o;\n  } else if (STATIC) {\n    target = global$o[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global$o[TARGET] || {}).prototype;\n  }\n  if (target)\n    for (key in source) {\n      sourceProperty = source[key];\n      if (options.noTargetGet) {\n        descriptor = getOwnPropertyDescriptor$3(target, key);\n        targetProperty = descriptor && descriptor.value;\n      } else\n        targetProperty = target[key];\n      FORCED2 = isForced$1(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n      if (!FORCED2 && targetProperty !== void 0) {\n        if (typeof sourceProperty == typeof targetProperty)\n          continue;\n        copyConstructorProperties(sourceProperty, targetProperty);\n      }\n      if (options.sham || targetProperty && targetProperty.sham) {\n        createNonEnumerableProperty$3(sourceProperty, \"sham\", true);\n      }\n      redefine$6(target, key, sourceProperty, options);\n    }\n};\nvar global$n = global$I;\nvar nativePromiseConstructor = global$n.Promise;\nvar redefine$5 = redefine$7.exports;\nvar redefineAll$1 = function(target, src, options) {\n  for (var key in src)\n    redefine$5(target, key, src[key], options);\n  return target;\n};\nvar global$m = global$I;\nvar isCallable$9 = isCallable$j;\nvar String$3 = global$m.String;\nvar TypeError$9 = global$m.TypeError;\nvar aPossiblePrototype$1 = function(argument) {\n  if (typeof argument == \"object\" || isCallable$9(argument))\n    return argument;\n  throw TypeError$9(\"Can't set \" + String$3(argument) + \" as a prototype\");\n};\nvar uncurryThis$g = functionUncurryThis;\nvar anObject$d = anObject$g;\nvar aPossiblePrototype = aPossiblePrototype$1;\nvar objectSetPrototypeOf = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n  var CORRECT_SETTER = false;\n  var test2 = {};\n  var setter;\n  try {\n    setter = uncurryThis$g(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set);\n    setter(test2, []);\n    CORRECT_SETTER = test2 instanceof Array;\n  } catch (error) {\n  }\n  return function setPrototypeOf2(O2, proto) {\n    anObject$d(O2);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER)\n      setter(O2, proto);\n    else\n      O2.__proto__ = proto;\n    return O2;\n  };\n}() : void 0);\nvar defineProperty$1 = objectDefineProperty.f;\nvar hasOwn$2 = hasOwnProperty_1;\nvar wellKnownSymbol$g = wellKnownSymbol$i;\nvar TO_STRING_TAG$3 = wellKnownSymbol$g(\"toStringTag\");\nvar setToStringTag$3 = function(target, TAG, STATIC) {\n  if (target && !STATIC)\n    target = target.prototype;\n  if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {\n    defineProperty$1(target, TO_STRING_TAG$3, { configurable: true, value: TAG });\n  }\n};\nvar getBuiltIn$3 = getBuiltIn$7;\nvar definePropertyModule$3 = objectDefineProperty;\nvar wellKnownSymbol$f = wellKnownSymbol$i;\nvar DESCRIPTORS$2 = descriptors;\nvar SPECIES$3 = wellKnownSymbol$f(\"species\");\nvar setSpecies$1 = function(CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);\n  var defineProperty4 = definePropertyModule$3.f;\n  if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$3]) {\n    defineProperty4(Constructor, SPECIES$3, {\n      configurable: true,\n      get: function() {\n        return this;\n      }\n    });\n  }\n};\nvar global$l = global$I;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar TypeError$8 = global$l.TypeError;\nvar anInstance$1 = function(it2, Prototype) {\n  if (isPrototypeOf$2(Prototype, it2))\n    return it2;\n  throw TypeError$8(\"Incorrect invocation\");\n};\nvar uncurryThis$f = functionUncurryThis;\nvar aCallable$4 = aCallable$6;\nvar NATIVE_BIND$1 = functionBindNative;\nvar bind$4 = uncurryThis$f(uncurryThis$f.bind);\nvar functionBindContext = function(fn, that) {\n  aCallable$4(fn);\n  return that === void 0 ? fn : NATIVE_BIND$1 ? bind$4(fn, that) : function() {\n    return fn.apply(that, arguments);\n  };\n};\nvar iterators = {};\nvar wellKnownSymbol$e = wellKnownSymbol$i;\nvar Iterators$4 = iterators;\nvar ITERATOR$5 = wellKnownSymbol$e(\"iterator\");\nvar ArrayPrototype$1 = Array.prototype;\nvar isArrayIteratorMethod$1 = function(it2) {\n  return it2 !== void 0 && (Iterators$4.Array === it2 || ArrayPrototype$1[ITERATOR$5] === it2);\n};\nvar wellKnownSymbol$d = wellKnownSymbol$i;\nvar TO_STRING_TAG$2 = wellKnownSymbol$d(\"toStringTag\");\nvar test$1 = {};\ntest$1[TO_STRING_TAG$2] = \"z\";\nvar toStringTagSupport = String(test$1) === \"[object z]\";\nvar global$k = global$I;\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$8 = isCallable$j;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$c = wellKnownSymbol$i;\nvar TO_STRING_TAG$1 = wellKnownSymbol$c(\"toStringTag\");\nvar Object$2 = global$k.Object;\nvar CORRECT_ARGUMENTS = classofRaw(function() {\n  return arguments;\n}()) == \"Arguments\";\nvar tryGet = function(it2, key) {\n  try {\n    return it2[key];\n  } catch (error) {\n  }\n};\nvar classof$7 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {\n  var O2, tag, result;\n  return it2 === void 0 ? \"Undefined\" : it2 === null ? \"Null\" : typeof (tag = tryGet(O2 = Object$2(it2), TO_STRING_TAG$1)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == \"Object\" && isCallable$8(O2.callee) ? \"Arguments\" : result;\n};\nvar classof$6 = classof$7;\nvar getMethod$4 = getMethod$6;\nvar Iterators$3 = iterators;\nvar wellKnownSymbol$b = wellKnownSymbol$i;\nvar ITERATOR$4 = wellKnownSymbol$b(\"iterator\");\nvar getIteratorMethod$2 = function(it2) {\n  if (it2 != void 0)\n    return getMethod$4(it2, ITERATOR$4) || getMethod$4(it2, \"@@iterator\") || Iterators$3[classof$6(it2)];\n};\nvar global$j = global$I;\nvar call$a = functionCall;\nvar aCallable$3 = aCallable$6;\nvar anObject$c = anObject$g;\nvar tryToString$2 = tryToString$4;\nvar getIteratorMethod$1 = getIteratorMethod$2;\nvar TypeError$7 = global$j.TypeError;\nvar getIterator$1 = function(argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;\n  if (aCallable$3(iteratorMethod))\n    return anObject$c(call$a(iteratorMethod, argument));\n  throw TypeError$7(tryToString$2(argument) + \" is not iterable\");\n};\nvar call$9 = functionCall;\nvar anObject$b = anObject$g;\nvar getMethod$3 = getMethod$6;\nvar iteratorClose$1 = function(iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$b(iterator);\n  try {\n    innerResult = getMethod$3(iterator, \"return\");\n    if (!innerResult) {\n      if (kind === \"throw\")\n        throw value;\n      return value;\n    }\n    innerResult = call$9(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === \"throw\")\n    throw value;\n  if (innerError)\n    throw innerResult;\n  anObject$b(innerResult);\n  return value;\n};\nvar global$i = global$I;\nvar bind$3 = functionBindContext;\nvar call$8 = functionCall;\nvar anObject$a = anObject$g;\nvar tryToString$1 = tryToString$4;\nvar isArrayIteratorMethod = isArrayIteratorMethod$1;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$4;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getIterator = getIterator$1;\nvar getIteratorMethod = getIteratorMethod$2;\nvar iteratorClose = iteratorClose$1;\nvar TypeError$6 = global$i.TypeError;\nvar Result = function(stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\nvar ResultPrototype = Result.prototype;\nvar iterate$1 = function(iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$3(unboundFunction, that);\n  var iterator, iterFn, index2, length, result, next, step;\n  var stop = function(condition) {\n    if (iterator)\n      iteratorClose(iterator, \"normal\", condition);\n    return new Result(true, condition);\n  };\n  var callFn = function(value) {\n    if (AS_ENTRIES) {\n      anObject$a(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    }\n    return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn)\n      throw TypeError$6(tryToString$1(iterable) + \" is not iterable\");\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index2 = 0, length = lengthOfArrayLike$2(iterable); length > index2; index2++) {\n        result = callFn(iterable[index2]);\n        if (result && isPrototypeOf$1(ResultPrototype, result))\n          return result;\n      }\n      return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n  next = iterator.next;\n  while (!(step = call$8(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, \"throw\", error);\n    }\n    if (typeof result == \"object\" && result && isPrototypeOf$1(ResultPrototype, result))\n      return result;\n  }\n  return new Result(false);\n};\nvar wellKnownSymbol$a = wellKnownSymbol$i;\nvar ITERATOR$3 = wellKnownSymbol$a(\"iterator\");\nvar SAFE_CLOSING = false;\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function() {\n      return { done: !!called++ };\n    },\n    \"return\": function() {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$3] = function() {\n    return this;\n  };\n  Array.from(iteratorWithReturn, function() {\n    throw 2;\n  });\n} catch (error) {\n}\nvar checkCorrectnessOfIteration$1 = function(exec2, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING)\n    return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$3] = function() {\n      return {\n        next: function() {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec2(object);\n  } catch (error) {\n  }\n  return ITERATION_SUPPORT;\n};\nvar uncurryThis$e = functionUncurryThis;\nvar fails$c = fails$k;\nvar isCallable$7 = isCallable$j;\nvar classof$5 = classof$7;\nvar getBuiltIn$2 = getBuiltIn$7;\nvar inspectSource$1 = inspectSource$4;\nvar noop$1 = function() {\n};\nvar empty = [];\nvar construct = getBuiltIn$2(\"Reflect\", \"construct\");\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$e(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop$1);\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$7(argument))\n    return false;\n  try {\n    construct(noop$1, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\nvar isConstructorLegacy = function isConstructor2(argument) {\n  if (!isCallable$7(argument))\n    return false;\n  switch (classof$5(argument)) {\n    case \"AsyncFunction\":\n    case \"GeneratorFunction\":\n    case \"AsyncGeneratorFunction\":\n      return false;\n  }\n  try {\n    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\nisConstructorLegacy.sham = true;\nvar isConstructor$1 = !construct || fails$c(function() {\n  var called;\n  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {\n    called = true;\n  }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\nvar global$h = global$I;\nvar isConstructor3 = isConstructor$1;\nvar tryToString = tryToString$4;\nvar TypeError$5 = global$h.TypeError;\nvar aConstructor$1 = function(argument) {\n  if (isConstructor3(argument))\n    return argument;\n  throw TypeError$5(tryToString(argument) + \" is not a constructor\");\n};\nvar anObject$9 = anObject$g;\nvar aConstructor = aConstructor$1;\nvar wellKnownSymbol$9 = wellKnownSymbol$i;\nvar SPECIES$2 = wellKnownSymbol$9(\"species\");\nvar speciesConstructor$2 = function(O2, defaultConstructor) {\n  var C2 = anObject$9(O2).constructor;\n  var S2;\n  return C2 === void 0 || (S2 = anObject$9(C2)[SPECIES$2]) == void 0 ? defaultConstructor : aConstructor(S2);\n};\nvar NATIVE_BIND = functionBindNative;\nvar FunctionPrototype = Function.prototype;\nvar apply$3 = FunctionPrototype.apply;\nvar call$7 = FunctionPrototype.call;\nvar functionApply = typeof Reflect == \"object\" && Reflect.apply || (NATIVE_BIND ? call$7.bind(apply$3) : function() {\n  return call$7.apply(apply$3, arguments);\n});\nvar getBuiltIn$1 = getBuiltIn$7;\nvar html$2 = getBuiltIn$1(\"document\", \"documentElement\");\nvar uncurryThis$d = functionUncurryThis;\nvar arraySlice$2 = uncurryThis$d([].slice);\nvar userAgent$2 = engineUserAgent;\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);\nvar classof$4 = classofRaw$1;\nvar global$g = global$I;\nvar engineIsNode = classof$4(global$g.process) == \"process\";\nvar global$f = global$I;\nvar apply$2 = functionApply;\nvar bind$2 = functionBindContext;\nvar isCallable$6 = isCallable$j;\nvar hasOwn$1 = hasOwnProperty_1;\nvar fails$b = fails$k;\nvar html$1 = html$2;\nvar arraySlice$1 = arraySlice$2;\nvar createElement = documentCreateElement$2;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$3 = engineIsNode;\nvar set = global$f.setImmediate;\nvar clear = global$f.clearImmediate;\nvar process$3 = global$f.process;\nvar Dispatch = global$f.Dispatch;\nvar Function$1 = global$f.Function;\nvar MessageChannel = global$f.MessageChannel;\nvar String$2 = global$f.String;\nvar counter = 0;\nvar queue$2 = {};\nvar ONREADYSTATECHANGE = \"onreadystatechange\";\nvar location$1, defer, channel, port;\ntry {\n  location$1 = global$f.location;\n} catch (error) {\n}\nvar run = function(id) {\n  if (hasOwn$1(queue$2, id)) {\n    var fn = queue$2[id];\n    delete queue$2[id];\n    fn();\n  }\n};\nvar runner = function(id) {\n  return function() {\n    run(id);\n  };\n};\nvar listener = function(event) {\n  run(event.data);\n};\nvar post = function(id) {\n  global$f.postMessage(String$2(id), location$1.protocol + \"//\" + location$1.host);\n};\nif (!set || !clear) {\n  set = function setImmediate(fn) {\n    var args = arraySlice$1(arguments, 1);\n    queue$2[++counter] = function() {\n      apply$2(isCallable$6(fn) ? fn : Function$1(fn), void 0, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$2[id];\n  };\n  if (IS_NODE$3) {\n    defer = function(id) {\n      process$3.nextTick(runner(id));\n    };\n  } else if (Dispatch && Dispatch.now) {\n    defer = function(id) {\n      Dispatch.now(runner(id));\n    };\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$2(port.postMessage, port);\n  } else if (global$f.addEventListener && isCallable$6(global$f.postMessage) && !global$f.importScripts && location$1 && location$1.protocol !== \"file:\" && !fails$b(post)) {\n    defer = post;\n    global$f.addEventListener(\"message\", listener, false);\n  } else if (ONREADYSTATECHANGE in createElement(\"script\")) {\n    defer = function(id) {\n      html$1.appendChild(createElement(\"script\"))[ONREADYSTATECHANGE] = function() {\n        html$1.removeChild(this);\n        run(id);\n      };\n    };\n  } else {\n    defer = function(id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\nvar task$1 = {\n  set,\n  clear\n};\nvar userAgent$1 = engineUserAgent;\nvar global$e = global$I;\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$e.Pebble !== void 0;\nvar userAgent = engineUserAgent;\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);\nvar global$d = global$I;\nvar bind$1 = functionBindContext;\nvar getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$2 = engineIsNode;\nvar MutationObserver = global$d.MutationObserver || global$d.WebKitMutationObserver;\nvar document$2 = global$d.document;\nvar process$2 = global$d.process;\nvar Promise$1 = global$d.Promise;\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global$d, \"queueMicrotask\");\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\nvar flush, head, last$1, notify$1, toggle, node$1, promise, then;\nif (!queueMicrotask) {\n  flush = function() {\n    var parent, fn;\n    if (IS_NODE$2 && (parent = process$2.domain))\n      parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head)\n          notify$1();\n        else\n          last$1 = void 0;\n        throw error;\n      }\n    }\n    last$1 = void 0;\n    if (parent)\n      parent.enter();\n  };\n  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node$1 = document$2.createTextNode(\"\");\n    new MutationObserver(flush).observe(node$1, { characterData: true });\n    notify$1 = function() {\n      node$1.data = toggle = !toggle;\n    };\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    promise = Promise$1.resolve(void 0);\n    promise.constructor = Promise$1;\n    then = bind$1(promise.then, promise);\n    notify$1 = function() {\n      then(flush);\n    };\n  } else if (IS_NODE$2) {\n    notify$1 = function() {\n      process$2.nextTick(flush);\n    };\n  } else {\n    macrotask = bind$1(macrotask, global$d);\n    notify$1 = function() {\n      macrotask(flush);\n    };\n  }\n}\nvar microtask$1 = queueMicrotask || function(fn) {\n  var task2 = { fn, next: void 0 };\n  if (last$1)\n    last$1.next = task2;\n  if (!head) {\n    head = task2;\n    notify$1();\n  }\n  last$1 = task2;\n};\nvar newPromiseCapability$2 = {};\nvar aCallable$2 = aCallable$6;\nvar PromiseCapability = function(C2) {\n  var resolve2, reject2;\n  this.promise = new C2(function($$resolve, $$reject) {\n    if (resolve2 !== void 0 || reject2 !== void 0)\n      throw TypeError(\"Bad Promise constructor\");\n    resolve2 = $$resolve;\n    reject2 = $$reject;\n  });\n  this.resolve = aCallable$2(resolve2);\n  this.reject = aCallable$2(reject2);\n};\nnewPromiseCapability$2.f = function(C2) {\n  return new PromiseCapability(C2);\n};\nvar anObject$8 = anObject$g;\nvar isObject$2 = isObject$8;\nvar newPromiseCapability$1 = newPromiseCapability$2;\nvar promiseResolve$1 = function(C2, x2) {\n  anObject$8(C2);\n  if (isObject$2(x2) && x2.constructor === C2)\n    return x2;\n  var promiseCapability = newPromiseCapability$1.f(C2);\n  var resolve2 = promiseCapability.resolve;\n  resolve2(x2);\n  return promiseCapability.promise;\n};\nvar global$c = global$I;\nvar hostReportErrors$1 = function(a2, b2) {\n  var console2 = global$c.console;\n  if (console2 && console2.error) {\n    arguments.length == 1 ? console2.error(a2) : console2.error(a2, b2);\n  }\n};\nvar perform$1 = function(exec2) {\n  try {\n    return { error: false, value: exec2() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\nvar Queue$1 = function() {\n  this.head = null;\n  this.tail = null;\n};\nQueue$1.prototype = {\n  add: function(item) {\n    var entry = { item, next: null };\n    if (this.head)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n  },\n  get: function() {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry)\n        this.tail = null;\n      return entry.item;\n    }\n  }\n};\nvar queue$1 = Queue$1;\nvar engineIsBrowser = typeof window == \"object\";\nvar $$9 = _export;\nvar global$b = global$I;\nvar getBuiltIn = getBuiltIn$7;\nvar call$6 = functionCall;\nvar NativePromise = nativePromiseConstructor;\nvar redefine$4 = redefine$7.exports;\nvar redefineAll = redefineAll$1;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\nvar setToStringTag$2 = setToStringTag$3;\nvar setSpecies = setSpecies$1;\nvar aCallable$1 = aCallable$6;\nvar isCallable$5 = isCallable$j;\nvar isObject$1 = isObject$8;\nvar anInstance = anInstance$1;\nvar inspectSource = inspectSource$4;\nvar iterate = iterate$1;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\nvar speciesConstructor$1 = speciesConstructor$2;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar promiseResolve = promiseResolve$1;\nvar hostReportErrors = hostReportErrors$1;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar perform = perform$1;\nvar Queue = queue$1;\nvar InternalStateModule$1 = internalState;\nvar isForced = isForced_1;\nvar wellKnownSymbol$8 = wellKnownSymbol$i;\nvar IS_BROWSER = engineIsBrowser;\nvar IS_NODE$1 = engineIsNode;\nvar V8_VERSION = engineV8Version;\nvar SPECIES$1 = wellKnownSymbol$8(\"species\");\nvar PROMISE = \"Promise\";\nvar getInternalState$2 = InternalStateModule$1.getterFor(PROMISE);\nvar setInternalState$1 = InternalStateModule$1.set;\nvar getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);\nvar NativePromisePrototype = NativePromise && NativePromise.prototype;\nvar PromiseConstructor = NativePromise;\nvar PromisePrototype = NativePromisePrototype;\nvar TypeError$4 = global$b.TypeError;\nvar document$1 = global$b.document;\nvar process$1 = global$b.process;\nvar newPromiseCapability = newPromiseCapabilityModule.f;\nvar newGenericPromiseCapability = newPromiseCapability;\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$b.dispatchEvent);\nvar NATIVE_REJECTION_EVENT = isCallable$5(global$b.PromiseRejectionEvent);\nvar UNHANDLED_REJECTION = \"unhandledrejection\";\nvar REJECTION_HANDLED = \"rejectionhandled\";\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\nvar SUBCLASSING = false;\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\nvar FORCED = isForced(PROMISE, function() {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)\n    return true;\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))\n    return false;\n  var promise2 = new PromiseConstructor(function(resolve2) {\n    resolve2(1);\n  });\n  var FakePromise = function(exec2) {\n    exec2(function() {\n    }, function() {\n    });\n  };\n  var constructor = promise2.constructor = {};\n  constructor[SPECIES$1] = FakePromise;\n  SUBCLASSING = promise2.then(function() {\n  }) instanceof FakePromise;\n  if (!SUBCLASSING)\n    return true;\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;\n});\nvar INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {\n  PromiseConstructor.all(iterable)[\"catch\"](function() {\n  });\n});\nvar isThenable = function(it2) {\n  var then2;\n  return isObject$1(it2) && isCallable$5(then2 = it2.then) ? then2 : false;\n};\nvar callReaction = function(reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve2 = reaction.resolve;\n  var reject2 = reaction.reject;\n  var domain = reaction.domain;\n  var result, then2, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED)\n          onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true)\n        result = value;\n      else {\n        if (domain)\n          domain.enter();\n        result = handler(value);\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject2(TypeError$4(\"Promise-chain cycle\"));\n      } else if (then2 = isThenable(result)) {\n        call$6(then2, result, resolve2, reject2);\n      } else\n        resolve2(result);\n    } else\n      reject2(value);\n  } catch (error) {\n    if (domain && !exited)\n      domain.exit();\n    reject2(error);\n  }\n};\nvar notify = function(state, isReject) {\n  if (state.notified)\n    return;\n  state.notified = true;\n  microtask(function() {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection)\n      onUnhandled(state);\n  });\n};\nvar dispatchEvent = function(name, promise2, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent(\"Event\");\n    event.promise = promise2;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$b.dispatchEvent(event);\n  } else\n    event = { promise: promise2, reason };\n  if (!NATIVE_REJECTION_EVENT && (handler = global$b[\"on\" + name]))\n    handler(event);\n  else if (name === UNHANDLED_REJECTION)\n    hostReportErrors(\"Unhandled promise rejection\", reason);\n};\nvar onUnhandled = function(state) {\n  call$6(task, global$b, function() {\n    var promise2 = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform(function() {\n        if (IS_NODE$1) {\n          process$1.emit(\"unhandledRejection\", value, promise2);\n        } else\n          dispatchEvent(UNHANDLED_REJECTION, promise2, value);\n      });\n      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error)\n        throw result.value;\n    }\n  });\n};\nvar isUnhandled = function(state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\nvar onHandleUnhandled = function(state) {\n  call$6(task, global$b, function() {\n    var promise2 = state.facade;\n    if (IS_NODE$1) {\n      process$1.emit(\"rejectionHandled\", promise2);\n    } else\n      dispatchEvent(REJECTION_HANDLED, promise2, state.value);\n  });\n};\nvar bind = function(fn, state, unwrap) {\n  return function(value) {\n    fn(state, value, unwrap);\n  };\n};\nvar internalReject = function(state, value, unwrap) {\n  if (state.done)\n    return;\n  state.done = true;\n  if (unwrap)\n    state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\nvar internalResolve = function(state, value, unwrap) {\n  if (state.done)\n    return;\n  state.done = true;\n  if (unwrap)\n    state = unwrap;\n  try {\n    if (state.facade === value)\n      throw TypeError$4(\"Promise can't be resolved itself\");\n    var then2 = isThenable(value);\n    if (then2) {\n      microtask(function() {\n        var wrapper = { done: false };\n        try {\n          call$6(then2, value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\nif (FORCED) {\n  PromiseConstructor = function Promise2(executor) {\n    anInstance(this, PromisePrototype);\n    aCallable$1(executor);\n    call$6(Internal, this);\n    var state = getInternalState$2(this);\n    try {\n      executor(bind(internalResolve, state), bind(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n  PromisePrototype = PromiseConstructor.prototype;\n  Internal = function Promise2(executor) {\n    setInternalState$1(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: void 0\n    });\n  };\n  Internal.prototype = redefineAll(PromisePrototype, {\n    then: function then2(onFulfilled, onRejected) {\n      var state = getInternalPromiseState(this);\n      var reaction = newPromiseCapability(speciesConstructor$1(this, PromiseConstructor));\n      state.parent = true;\n      reaction.ok = isCallable$5(onFulfilled) ? onFulfilled : true;\n      reaction.fail = isCallable$5(onRejected) && onRejected;\n      reaction.domain = IS_NODE$1 ? process$1.domain : void 0;\n      if (state.state == PENDING)\n        state.reactions.add(reaction);\n      else\n        microtask(function() {\n          callReaction(reaction, state);\n        });\n      return reaction.promise;\n    },\n    \"catch\": function(onRejected) {\n      return this.then(void 0, onRejected);\n    }\n  });\n  OwnPromiseCapability = function() {\n    var promise2 = new Internal();\n    var state = getInternalState$2(promise2);\n    this.promise = promise2;\n    this.resolve = bind(internalResolve, state);\n    this.reject = bind(internalReject, state);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function(C2) {\n    return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);\n  };\n  if (isCallable$5(NativePromise) && NativePromisePrototype !== Object.prototype) {\n    nativeThen = NativePromisePrototype.then;\n    if (!SUBCLASSING) {\n      redefine$4(NativePromisePrototype, \"then\", function then2(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function(resolve2, reject2) {\n          call$6(nativeThen, that, resolve2, reject2);\n        }).then(onFulfilled, onRejected);\n      }, { unsafe: true });\n      redefine$4(NativePromisePrototype, \"catch\", PromisePrototype[\"catch\"], { unsafe: true });\n    }\n    try {\n      delete NativePromisePrototype.constructor;\n    } catch (error) {\n    }\n    if (setPrototypeOf$1) {\n      setPrototypeOf$1(NativePromisePrototype, PromisePrototype);\n    }\n  }\n}\n$$9({ global: true, wrap: true, forced: FORCED }, {\n  Promise: PromiseConstructor\n});\nsetToStringTag$2(PromiseConstructor, PROMISE, false);\nsetSpecies(PROMISE);\nPromiseWrapper = getBuiltIn(PROMISE);\n$$9({ target: PROMISE, stat: true, forced: FORCED }, {\n  reject: function reject(r2) {\n    var capability = newPromiseCapability(this);\n    call$6(capability.reject, void 0, r2);\n    return capability.promise;\n  }\n});\n$$9({ target: PROMISE, stat: true, forced: FORCED }, {\n  resolve: function resolve(x2) {\n    return promiseResolve(this, x2);\n  }\n});\n$$9({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {\n  all: function all2(iterable) {\n    var C2 = this;\n    var capability = newPromiseCapability(C2);\n    var resolve2 = capability.resolve;\n    var reject2 = capability.reject;\n    var result = perform(function() {\n      var $promiseResolve = aCallable$1(C2.resolve);\n      var values2 = [];\n      var counter2 = 0;\n      var remaining = 1;\n      iterate(iterable, function(promise2) {\n        var index2 = counter2++;\n        var alreadyCalled = false;\n        remaining++;\n        call$6($promiseResolve, C2, promise2).then(function(value) {\n          if (alreadyCalled)\n            return;\n          alreadyCalled = true;\n          values2[index2] = value;\n          --remaining || resolve2(values2);\n        }, reject2);\n      });\n      --remaining || resolve2(values2);\n    });\n    if (result.error)\n      reject2(result.value);\n    return capability.promise;\n  },\n  race: function race(iterable) {\n    var C2 = this;\n    var capability = newPromiseCapability(C2);\n    var reject2 = capability.reject;\n    var result = perform(function() {\n      var $promiseResolve = aCallable$1(C2.resolve);\n      iterate(iterable, function(promise2) {\n        call$6($promiseResolve, C2, promise2).then(capability.resolve, reject2);\n      });\n    });\n    if (result.error)\n      reject2(result.value);\n    return capability.promise;\n  }\n});\nfunction asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject2(error);\n    return;\n  }\n  if (info.done) {\n    resolve2(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function() {\n    var self2 = this, args = arguments;\n    return new Promise(function(resolve2, reject2) {\n      var gen = fn.apply(self2, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, \"throw\", err);\n      }\n      _next(void 0);\n    });\n  };\n}\nvar global$a = global$I;\nvar classof$3 = classof$7;\nvar String$1 = global$a.String;\nvar toString$9 = function(argument) {\n  if (classof$3(argument) === \"Symbol\")\n    throw TypeError(\"Cannot convert a Symbol value to a string\");\n  return String$1(argument);\n};\nvar anObject$7 = anObject$g;\nvar regexpFlags$1 = function() {\n  var that = anObject$7(this);\n  var result = \"\";\n  if (that.global)\n    result += \"g\";\n  if (that.ignoreCase)\n    result += \"i\";\n  if (that.multiline)\n    result += \"m\";\n  if (that.dotAll)\n    result += \"s\";\n  if (that.unicode)\n    result += \"u\";\n  if (that.sticky)\n    result += \"y\";\n  return result;\n};\nvar fails$a = fails$k;\nvar global$9 = global$I;\nvar $RegExp$2 = global$9.RegExp;\nvar UNSUPPORTED_Y$2 = fails$a(function() {\n  var re2 = $RegExp$2(\"a\", \"y\");\n  re2.lastIndex = 2;\n  return re2.exec(\"abcd\") != null;\n});\nvar MISSED_STICKY = UNSUPPORTED_Y$2 || fails$a(function() {\n  return !$RegExp$2(\"a\", \"y\").sticky;\n});\nvar BROKEN_CARET = UNSUPPORTED_Y$2 || fails$a(function() {\n  var re2 = $RegExp$2(\"^r\", \"gy\");\n  re2.lastIndex = 2;\n  return re2.exec(\"str\") != null;\n});\nvar regexpStickyHelpers = {\n  BROKEN_CARET,\n  MISSED_STICKY,\n  UNSUPPORTED_Y: UNSUPPORTED_Y$2\n};\nvar objectDefineProperties = {};\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar objectKeys$1 = Object.keys || function keys2(O2) {\n  return internalObjectKeys(O2, enumBugKeys$1);\n};\nvar DESCRIPTORS$1 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$6 = anObject$g;\nvar toIndexedObject$1 = toIndexedObject$5;\nvar objectKeys = objectKeys$1;\nobjectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {\n  anObject$6(O2);\n  var props = toIndexedObject$1(Properties);\n  var keys3 = objectKeys(Properties);\n  var length = keys3.length;\n  var index2 = 0;\n  var key;\n  while (length > index2)\n    definePropertyModule$2.f(O2, key = keys3[index2++], props[key]);\n  return O2;\n};\nvar anObject$5 = anObject$g;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\nvar GT = \">\";\nvar LT = \"<\";\nvar PROTOTYPE = \"prototype\";\nvar SCRIPT = \"script\";\nvar IE_PROTO$1 = sharedKey$1(\"IE_PROTO\");\nvar EmptyConstructor = function() {\n};\nvar scriptTag = function(content2) {\n  return LT + SCRIPT + GT + content2 + LT + \"/\" + SCRIPT + GT;\n};\nvar NullProtoObjectViaActiveX = function(activeXDocument2) {\n  activeXDocument2.write(scriptTag(\"\"));\n  activeXDocument2.close();\n  var temp = activeXDocument2.parentWindow.Object;\n  activeXDocument2 = null;\n  return temp;\n};\nvar NullProtoObjectViaIFrame = function() {\n  var iframe = documentCreateElement$1(\"iframe\");\n  var JS = \"java\" + SCRIPT + \":\";\n  var iframeDocument;\n  iframe.style.display = \"none\";\n  html.appendChild(iframe);\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag(\"document.F=Object\"));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\nvar activeXDocument;\nvar NullProtoObject = function() {\n  try {\n    activeXDocument = new ActiveXObject(\"htmlfile\");\n  } catch (error) {\n  }\n  NullProtoObject = typeof document != \"undefined\" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);\n  var length = enumBugKeys.length;\n  while (length--)\n    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\nhiddenKeys[IE_PROTO$1] = true;\nvar objectCreate = Object.create || function create(O2, Properties) {\n  var result;\n  if (O2 !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject$5(O2);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    result[IE_PROTO$1] = O2;\n  } else\n    result = NullProtoObject();\n  return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);\n};\nvar fails$9 = fails$k;\nvar global$8 = global$I;\nvar $RegExp$1 = global$8.RegExp;\nvar regexpUnsupportedDotAll = fails$9(function() {\n  var re2 = $RegExp$1(\".\", \"s\");\n  return !(re2.dotAll && re2.exec(\"\\n\") && re2.flags === \"s\");\n});\nvar fails$8 = fails$k;\nvar global$7 = global$I;\nvar $RegExp = global$7.RegExp;\nvar regexpUnsupportedNcg = fails$8(function() {\n  var re2 = $RegExp(\"(?<a>b)\", \"g\");\n  return re2.exec(\"b\").groups.a !== \"b\" || \"b\".replace(re2, \"$<a>c\") !== \"bc\";\n});\nvar call$5 = functionCall;\nvar uncurryThis$c = functionUncurryThis;\nvar toString$8 = toString$9;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers$1 = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create$2 = objectCreate;\nvar getInternalState$1 = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\nvar nativeReplace = shared(\"native-string-replace\", String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$3 = uncurryThis$c(\"\".charAt);\nvar indexOf = uncurryThis$c(\"\".indexOf);\nvar replace$2 = uncurryThis$c(\"\".replace);\nvar stringSlice$5 = uncurryThis$c(\"\".slice);\nvar UPDATES_LAST_INDEX_WRONG = function() {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  call$5(nativeExec, re1, \"a\");\n  call$5(nativeExec, re2, \"a\");\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n}();\nvar UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;\nvar NPCG_INCLUDED = /()??/.exec(\"\")[1] !== void 0;\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\nif (PATCH) {\n  patchedExec = function exec2(string) {\n    var re2 = this;\n    var state = getInternalState$1(re2);\n    var str = toString$8(string);\n    var raw = state.raw;\n    var result, reCopy, lastIndex, match2, i2, object, group;\n    if (raw) {\n      raw.lastIndex = re2.lastIndex;\n      result = call$5(patchedExec, raw, str);\n      re2.lastIndex = raw.lastIndex;\n      return result;\n    }\n    var groups = state.groups;\n    var sticky = UNSUPPORTED_Y$1 && re2.sticky;\n    var flags = call$5(regexpFlags, re2);\n    var source = re2.source;\n    var charsAdded = 0;\n    var strCopy = str;\n    if (sticky) {\n      flags = replace$2(flags, \"y\", \"\");\n      if (indexOf(flags, \"g\") === -1) {\n        flags += \"g\";\n      }\n      strCopy = stringSlice$5(str, re2.lastIndex);\n      if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt$3(str, re2.lastIndex - 1) !== \"\\n\")) {\n        source = \"(?: \" + source + \")\";\n        strCopy = \" \" + strCopy;\n        charsAdded++;\n      }\n      reCopy = new RegExp(\"^(?:\" + source + \")\", flags);\n    }\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp(\"^\" + source + \"$(?!\\\\s)\", flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG)\n      lastIndex = re2.lastIndex;\n    match2 = call$5(nativeExec, sticky ? reCopy : re2, strCopy);\n    if (sticky) {\n      if (match2) {\n        match2.input = stringSlice$5(match2.input, charsAdded);\n        match2[0] = stringSlice$5(match2[0], charsAdded);\n        match2.index = re2.lastIndex;\n        re2.lastIndex += match2[0].length;\n      } else\n        re2.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match2) {\n      re2.lastIndex = re2.global ? match2.index + match2[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match2 && match2.length > 1) {\n      call$5(nativeReplace, match2[0], reCopy, function() {\n        for (i2 = 1; i2 < arguments.length - 2; i2++) {\n          if (arguments[i2] === void 0)\n            match2[i2] = void 0;\n        }\n      });\n    }\n    if (match2 && groups) {\n      match2.groups = object = create$2(null);\n      for (i2 = 0; i2 < groups.length; i2++) {\n        group = groups[i2];\n        object[group[0]] = match2[group[1]];\n      }\n    }\n    return match2;\n  };\n}\nvar regexpExec$3 = patchedExec;\nvar $$8 = _export;\nvar exec$1 = regexpExec$3;\n$$8({ target: \"RegExp\", proto: true, forced: /./.exec !== exec$1 }, {\n  exec: exec$1\n});\nvar uncurryThis$b = functionUncurryThis;\nvar redefine$3 = redefine$7.exports;\nvar regexpExec$2 = regexpExec$3;\nvar fails$7 = fails$k;\nvar wellKnownSymbol$7 = wellKnownSymbol$i;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$6;\nvar SPECIES = wellKnownSymbol$7(\"species\");\nvar RegExpPrototype$1 = RegExp.prototype;\nvar fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {\n  var SYMBOL = wellKnownSymbol$7(KEY);\n  var DELEGATES_TO_SYMBOL = !fails$7(function() {\n    var O2 = {};\n    O2[SYMBOL] = function() {\n      return 7;\n    };\n    return \"\"[KEY](O2) != 7;\n  });\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$7(function() {\n    var execCalled = false;\n    var re2 = /a/;\n    if (KEY === \"split\") {\n      re2 = {};\n      re2.constructor = {};\n      re2.constructor[SPECIES] = function() {\n        return re2;\n      };\n      re2.flags = \"\";\n      re2[SYMBOL] = /./[SYMBOL];\n    }\n    re2.exec = function() {\n      execCalled = true;\n      return null;\n    };\n    re2[SYMBOL](\"\");\n    return !execCalled;\n  });\n  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {\n    var uncurriedNativeRegExpMethod = uncurryThis$b(/./[SYMBOL]);\n    var methods = exec2(SYMBOL, \"\"[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {\n      var uncurriedNativeMethod = uncurryThis$b(nativeMethod);\n      var $exec = regexp.exec;\n      if ($exec === regexpExec$2 || $exec === RegExpPrototype$1.exec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };\n        }\n        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };\n      }\n      return { done: false };\n    });\n    redefine$3(String.prototype, KEY, methods[0]);\n    redefine$3(RegExpPrototype$1, SYMBOL, methods[1]);\n  }\n  if (SHAM)\n    createNonEnumerableProperty$2(RegExpPrototype$1[SYMBOL], \"sham\", true);\n};\nvar uncurryThis$a = functionUncurryThis;\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$4;\nvar toString$7 = toString$9;\nvar requireObjectCoercible$7 = requireObjectCoercible$a;\nvar charAt$2 = uncurryThis$a(\"\".charAt);\nvar charCodeAt = uncurryThis$a(\"\".charCodeAt);\nvar stringSlice$4 = uncurryThis$a(\"\".slice);\nvar createMethod$2 = function(CONVERT_TO_STRING) {\n  return function($this, pos) {\n    var S2 = toString$7(requireObjectCoercible$7($this));\n    var position2 = toIntegerOrInfinity$1(pos);\n    var size = S2.length;\n    var first, second;\n    if (position2 < 0 || position2 >= size)\n      return CONVERT_TO_STRING ? \"\" : void 0;\n    first = charCodeAt(S2, position2);\n    return first < 55296 || first > 56319 || position2 + 1 === size || (second = charCodeAt(S2, position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$2(S2, position2) : first : CONVERT_TO_STRING ? stringSlice$4(S2, position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;\n  };\n};\nvar stringMultibyte = {\n  codeAt: createMethod$2(false),\n  charAt: createMethod$2(true)\n};\nvar charAt$1 = stringMultibyte.charAt;\nvar advanceStringIndex$3 = function(S2, index2, unicode) {\n  return index2 + (unicode ? charAt$1(S2, index2).length : 1);\n};\nvar global$6 = global$I;\nvar call$4 = functionCall;\nvar anObject$4 = anObject$g;\nvar isCallable$4 = isCallable$j;\nvar classof$2 = classofRaw$1;\nvar regexpExec$1 = regexpExec$3;\nvar TypeError$3 = global$6.TypeError;\nvar regexpExecAbstract = function(R2, S2) {\n  var exec2 = R2.exec;\n  if (isCallable$4(exec2)) {\n    var result = call$4(exec2, R2, S2);\n    if (result !== null)\n      anObject$4(result);\n    return result;\n  }\n  if (classof$2(R2) === \"RegExp\")\n    return call$4(regexpExec$1, R2, S2);\n  throw TypeError$3(\"RegExp#exec called on incompatible receiver\");\n};\nvar call$3 = functionCall;\nvar fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;\nvar anObject$3 = anObject$g;\nvar toLength$4 = toLength$6;\nvar toString$6 = toString$9;\nvar requireObjectCoercible$6 = requireObjectCoercible$a;\nvar getMethod$2 = getMethod$6;\nvar advanceStringIndex$2 = advanceStringIndex$3;\nvar regExpExec$1 = regexpExecAbstract;\nfixRegExpWellKnownSymbolLogic$2(\"match\", function(MATCH2, nativeMatch, maybeCallNative) {\n  return [\n    function match2(regexp) {\n      var O2 = requireObjectCoercible$6(this);\n      var matcher = regexp == void 0 ? void 0 : getMethod$2(regexp, MATCH2);\n      return matcher ? call$3(matcher, regexp, O2) : new RegExp(regexp)[MATCH2](toString$6(O2));\n    },\n    function(string) {\n      var rx = anObject$3(this);\n      var S2 = toString$6(string);\n      var res = maybeCallNative(nativeMatch, rx, S2);\n      if (res.done)\n        return res.value;\n      if (!rx.global)\n        return regExpExec$1(rx, S2);\n      var fullUnicode = rx.unicode;\n      rx.lastIndex = 0;\n      var A2 = [];\n      var n2 = 0;\n      var result;\n      while ((result = regExpExec$1(rx, S2)) !== null) {\n        var matchStr = toString$6(result[0]);\n        A2[n2] = matchStr;\n        if (matchStr === \"\")\n          rx.lastIndex = advanceStringIndex$2(S2, toLength$4(rx.lastIndex), fullUnicode);\n        n2++;\n      }\n      return n2 === 0 ? null : A2;\n    }\n  ];\n});\nvar uncurryThis$9 = functionUncurryThis;\nvar toObject$2 = toObject$4;\nvar floor = Math.floor;\nvar charAt = uncurryThis$9(\"\".charAt);\nvar replace$1 = uncurryThis$9(\"\".replace);\nvar stringSlice$3 = uncurryThis$9(\"\".slice);\nvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d{1,2})/g;\nvar getSubstitution$1 = function(matched, str, position2, captures, namedCaptures, replacement2) {\n  var tailPos = position2 + matched.length;\n  var m2 = captures.length;\n  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n  if (namedCaptures !== void 0) {\n    namedCaptures = toObject$2(namedCaptures);\n    symbols = SUBSTITUTION_SYMBOLS;\n  }\n  return replace$1(replacement2, symbols, function(match2, ch) {\n    var capture;\n    switch (charAt(ch, 0)) {\n      case \"$\":\n        return \"$\";\n      case \"&\":\n        return matched;\n      case \"`\":\n        return stringSlice$3(str, 0, position2);\n      case \"'\":\n        return stringSlice$3(str, tailPos);\n      case \"<\":\n        capture = namedCaptures[stringSlice$3(ch, 1, -1)];\n        break;\n      default:\n        var n2 = +ch;\n        if (n2 === 0)\n          return match2;\n        if (n2 > m2) {\n          var f2 = floor(n2 / 10);\n          if (f2 === 0)\n            return match2;\n          if (f2 <= m2)\n            return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);\n          return match2;\n        }\n        capture = captures[n2 - 1];\n    }\n    return capture === void 0 ? \"\" : capture;\n  });\n};\nvar apply$1 = functionApply;\nvar call$2 = functionCall;\nvar uncurryThis$8 = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;\nvar fails$6 = fails$k;\nvar anObject$2 = anObject$g;\nvar isCallable$3 = isCallable$j;\nvar toIntegerOrInfinity = toIntegerOrInfinity$4;\nvar toLength$3 = toLength$6;\nvar toString$5 = toString$9;\nvar requireObjectCoercible$5 = requireObjectCoercible$a;\nvar advanceStringIndex$1 = advanceStringIndex$3;\nvar getMethod$1 = getMethod$6;\nvar getSubstitution = getSubstitution$1;\nvar regExpExec = regexpExecAbstract;\nvar wellKnownSymbol$6 = wellKnownSymbol$i;\nvar REPLACE = wellKnownSymbol$6(\"replace\");\nvar max$1 = Math.max;\nvar min$3 = Math.min;\nvar concat = uncurryThis$8([].concat);\nvar push$1 = uncurryThis$8([].push);\nvar stringIndexOf$1 = uncurryThis$8(\"\".indexOf);\nvar stringSlice$2 = uncurryThis$8(\"\".slice);\nvar maybeToString = function(it2) {\n  return it2 === void 0 ? it2 : String(it2);\n};\nvar REPLACE_KEEPS_$0 = function() {\n  return \"a\".replace(/./, \"$0\") === \"$0\";\n}();\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {\n  if (/./[REPLACE]) {\n    return /./[REPLACE](\"a\", \"$0\") === \"\";\n  }\n  return false;\n}();\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails$6(function() {\n  var re2 = /./;\n  re2.exec = function() {\n    var result = [];\n    result.groups = { a: \"7\" };\n    return result;\n  };\n  return \"\".replace(re2, \"$<a>\") !== \"7\";\n});\nfixRegExpWellKnownSymbolLogic$1(\"replace\", function(_2, nativeReplace2, maybeCallNative) {\n  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? \"$\" : \"$0\";\n  return [\n    function replace2(searchValue, replaceValue) {\n      var O2 = requireObjectCoercible$5(this);\n      var replacer = searchValue == void 0 ? void 0 : getMethod$1(searchValue, REPLACE);\n      return replacer ? call$2(replacer, searchValue, O2, replaceValue) : call$2(nativeReplace2, toString$5(O2), searchValue, replaceValue);\n    },\n    function(string, replaceValue) {\n      var rx = anObject$2(this);\n      var S2 = toString$5(string);\n      if (typeof replaceValue == \"string\" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, \"$<\") === -1) {\n        var res = maybeCallNative(nativeReplace2, rx, S2, replaceValue);\n        if (res.done)\n          return res.value;\n      }\n      var functionalReplace = isCallable$3(replaceValue);\n      if (!functionalReplace)\n        replaceValue = toString$5(replaceValue);\n      var global2 = rx.global;\n      if (global2) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S2);\n        if (result === null)\n          break;\n        push$1(results, result);\n        if (!global2)\n          break;\n        var matchStr = toString$5(result[0]);\n        if (matchStr === \"\")\n          rx.lastIndex = advanceStringIndex$1(S2, toLength$3(rx.lastIndex), fullUnicode);\n      }\n      var accumulatedResult = \"\";\n      var nextSourcePosition = 0;\n      for (var i2 = 0; i2 < results.length; i2++) {\n        result = results[i2];\n        var matched = toString$5(result[0]);\n        var position2 = max$1(min$3(toIntegerOrInfinity(result.index), S2.length), 0);\n        var captures = [];\n        for (var j2 = 1; j2 < result.length; j2++)\n          push$1(captures, maybeToString(result[j2]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = concat([matched], captures, position2, S2);\n          if (namedCaptures !== void 0)\n            push$1(replacerArgs, namedCaptures);\n          var replacement2 = toString$5(apply$1(replaceValue, void 0, replacerArgs));\n        } else {\n          replacement2 = getSubstitution(matched, S2, position2, captures, namedCaptures, replaceValue);\n        }\n        if (position2 >= nextSourcePosition) {\n          accumulatedResult += stringSlice$2(S2, nextSourcePosition, position2) + replacement2;\n          nextSourcePosition = position2 + matched.length;\n        }\n      }\n      return accumulatedResult + stringSlice$2(S2, nextSourcePosition);\n    }\n  ];\n}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);\nvar isObject = isObject$8;\nvar classof$1 = classofRaw$1;\nvar wellKnownSymbol$5 = wellKnownSymbol$i;\nvar MATCH$1 = wellKnownSymbol$5(\"match\");\nvar isRegexp = function(it2) {\n  var isRegExp2;\n  return isObject(it2) && ((isRegExp2 = it2[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$1(it2) == \"RegExp\");\n};\nvar global$5 = global$I;\nvar isRegExp$1 = isRegexp;\nvar TypeError$2 = global$5.TypeError;\nvar notARegexp = function(it2) {\n  if (isRegExp$1(it2)) {\n    throw TypeError$2(\"The method doesn't accept regular expressions\");\n  }\n  return it2;\n};\nvar wellKnownSymbol$4 = wellKnownSymbol$i;\nvar MATCH = wellKnownSymbol$4(\"match\");\nvar correctIsRegexpLogic = function(METHOD_NAME) {\n  var regexp = /./;\n  try {\n    \"/./\"[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return \"/./\"[METHOD_NAME](regexp);\n    } catch (error2) {\n    }\n  }\n  return false;\n};\nvar $$7 = _export;\nvar uncurryThis$7 = functionUncurryThis;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar toLength$2 = toLength$6;\nvar toString$4 = toString$9;\nvar notARegExp$2 = notARegexp;\nvar requireObjectCoercible$4 = requireObjectCoercible$a;\nvar correctIsRegExpLogic$2 = correctIsRegexpLogic;\nvar un$StartsWith = uncurryThis$7(\"\".startsWith);\nvar stringSlice$1 = uncurryThis$7(\"\".slice);\nvar min$2 = Math.min;\nvar CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$2(\"startsWith\");\nvar MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function() {\n  var descriptor = getOwnPropertyDescriptor$1(String.prototype, \"startsWith\");\n  return descriptor && !descriptor.writable;\n}();\n$$7({ target: \"String\", proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {\n  startsWith: function startsWith(searchString) {\n    var that = toString$4(requireObjectCoercible$4(this));\n    notARegExp$2(searchString);\n    var index2 = toLength$2(min$2(arguments.length > 1 ? arguments[1] : void 0, that.length));\n    var search = toString$4(searchString);\n    return un$StartsWith ? un$StartsWith(that, search, index2) : stringSlice$1(that, index2, index2 + search.length) === search;\n  }\n});\nvar wellKnownSymbol$3 = wellKnownSymbol$i;\nvar create$1 = objectCreate;\nvar definePropertyModule$1 = objectDefineProperty;\nvar UNSCOPABLES = wellKnownSymbol$3(\"unscopables\");\nvar ArrayPrototype = Array.prototype;\nif (ArrayPrototype[UNSCOPABLES] == void 0) {\n  definePropertyModule$1.f(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create$1(null)\n  });\n}\nvar addToUnscopables$1 = function(key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\nvar fails$5 = fails$k;\nvar correctPrototypeGetter = !fails$5(function() {\n  function F2() {\n  }\n  F2.prototype.constructor = null;\n  return Object.getPrototypeOf(new F2()) !== F2.prototype;\n});\nvar global$4 = global$I;\nvar hasOwn2 = hasOwnProperty_1;\nvar isCallable$2 = isCallable$j;\nvar toObject$1 = toObject$4;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\nvar IE_PROTO = sharedKey(\"IE_PROTO\");\nvar Object$1 = global$4.Object;\nvar ObjectPrototype = Object$1.prototype;\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$1.getPrototypeOf : function(O2) {\n  var object = toObject$1(O2);\n  if (hasOwn2(object, IE_PROTO))\n    return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$2(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  }\n  return object instanceof Object$1 ? ObjectPrototype : null;\n};\nvar fails$4 = fails$k;\nvar isCallable$1 = isCallable$j;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar redefine$2 = redefine$7.exports;\nvar wellKnownSymbol$2 = wellKnownSymbol$i;\nvar ITERATOR$2 = wellKnownSymbol$2(\"iterator\");\nvar BUGGY_SAFARI_ITERATORS$1 = false;\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\nif ([].keys) {\n  arrayIterator = [].keys();\n  if (!(\"next\" in arrayIterator))\n    BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)\n      IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == void 0 || fails$4(function() {\n  var test2 = {};\n  return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;\n});\nif (NEW_ITERATOR_PROTOTYPE)\n  IteratorPrototype$2 = {};\nif (!isCallable$1(IteratorPrototype$2[ITERATOR$2])) {\n  redefine$2(IteratorPrototype$2, ITERATOR$2, function() {\n    return this;\n  });\n}\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create2 = objectCreate;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$4;\nvar setToStringTag$1 = setToStringTag$3;\nvar Iterators$2 = iterators;\nvar returnThis$1 = function() {\n  return this;\n};\nvar createIteratorConstructor$1 = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG2 = NAME + \" Iterator\";\n  IteratorConstructor.prototype = create2(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$1(IteratorConstructor, TO_STRING_TAG2, false);\n  Iterators$2[TO_STRING_TAG2] = returnThis$1;\n  return IteratorConstructor;\n};\nvar $$6 = _export;\nvar call$1 = functionCall;\nvar FunctionName = functionName;\nvar isCallable = isCallable$j;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar setToStringTag = setToStringTag$3;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$6;\nvar redefine$1 = redefine$7.exports;\nvar wellKnownSymbol$1 = wellKnownSymbol$i;\nvar Iterators$1 = iterators;\nvar IteratorsCore = iteratorsCore;\nvar PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$1 = wellKnownSymbol$1(\"iterator\");\nvar KEYS = \"keys\";\nvar VALUES = \"values\";\nvar ENTRIES = \"entries\";\nvar returnThis = function() {\n  return this;\n};\nvar defineIterator$1 = function(Iterable, NAME, IteratorConstructor, next, DEFAULT2, IS_SET, FORCED2) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n  var getIterationMethod = function(KIND) {\n    if (KIND === DEFAULT2 && defaultIterator)\n      return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)\n      return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS:\n        return function keys3() {\n          return new IteratorConstructor(this, KIND);\n        };\n      case VALUES:\n        return function values2() {\n          return new IteratorConstructor(this, KIND);\n        };\n      case ENTRIES:\n        return function entries() {\n          return new IteratorConstructor(this, KIND);\n        };\n    }\n    return function() {\n      return new IteratorConstructor(this);\n    };\n  };\n  var TO_STRING_TAG2 = NAME + \" Iterator\";\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype[\"@@iterator\"] || DEFAULT2 && IterablePrototype[DEFAULT2];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT2);\n  var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$1])) {\n          redefine$1(CurrentIteratorPrototype, ITERATOR$1, returnThis);\n        }\n      }\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG2, true);\n    }\n  }\n  if (PROPER_FUNCTION_NAME$2 && DEFAULT2 == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty$1(IterablePrototype, \"name\", VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values2() {\n        return call$1(nativeIterator, this);\n      };\n    }\n  }\n  if (DEFAULT2) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED2)\n      for (KEY in methods) {\n        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n          redefine$1(IterablePrototype, KEY, methods[KEY]);\n        }\n      }\n    else\n      $$6({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {\n    redefine$1(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT2 });\n  }\n  Iterators$1[NAME] = defaultIterator;\n  return methods;\n};\nvar toIndexedObject = toIndexedObject$5;\nvar addToUnscopables = addToUnscopables$1;\nvar Iterators = iterators;\nvar InternalStateModule = internalState;\nvar defineProperty3 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS = descriptors;\nvar ARRAY_ITERATOR = \"Array Iterator\";\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\nvar es_array_iterator = defineIterator(Array, \"Array\", function(iterated, kind) {\n  setInternalState(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated),\n    index: 0,\n    kind\n  });\n}, function() {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index2 = state.index++;\n  if (!target || index2 >= target.length) {\n    state.target = void 0;\n    return { value: void 0, done: true };\n  }\n  if (kind == \"keys\")\n    return { value: index2, done: false };\n  if (kind == \"values\")\n    return { value: target[index2], done: false };\n  return { value: [index2, target[index2]], done: false };\n}, \"values\");\nvar values = Iterators.Arguments = Iterators.Array;\naddToUnscopables(\"keys\");\naddToUnscopables(\"values\");\naddToUnscopables(\"entries\");\nif (DESCRIPTORS && values.name !== \"values\")\n  try {\n    defineProperty3(values, \"name\", { value: \"values\" });\n  } catch (error) {\n  }\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\nvar documentCreateElement = documentCreateElement$2;\nvar classList = documentCreateElement(\"span\").classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;\nvar global$3 = global$I;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty = createNonEnumerableProperty$6;\nvar wellKnownSymbol = wellKnownSymbol$i;\nvar ITERATOR = wellKnownSymbol(\"iterator\");\nvar TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\nvar ArrayValues = ArrayIteratorMethods.values;\nvar handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    if (CollectionPrototype[ITERATOR] !== ArrayValues)\n      try {\n        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n      } catch (error) {\n        CollectionPrototype[ITERATOR] = ArrayValues;\n      }\n    if (!CollectionPrototype[TO_STRING_TAG]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME])\n      for (var METHOD_NAME in ArrayIteratorMethods) {\n        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])\n          try {\n            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n          } catch (error) {\n            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n          }\n      }\n  }\n};\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$3[COLLECTION_NAME] && global$3[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\nhandlePrototype(DOMTokenListPrototype, \"DOMTokenList\");\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar global$2 = global$I;\nvar aCallable = aCallable$6;\nvar toObject = toObject$4;\nvar IndexedObject = indexedObject;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$4;\nvar TypeError$1 = global$2.TypeError;\nvar createMethod$1 = function(IS_RIGHT) {\n  return function(that, callbackfn, argumentsLength, memo) {\n    aCallable(callbackfn);\n    var O2 = toObject(that);\n    var self2 = IndexedObject(O2);\n    var length = lengthOfArrayLike$1(O2);\n    var index2 = IS_RIGHT ? length - 1 : 0;\n    var i2 = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2)\n      while (true) {\n        if (index2 in self2) {\n          memo = self2[index2];\n          index2 += i2;\n          break;\n        }\n        index2 += i2;\n        if (IS_RIGHT ? index2 < 0 : length <= index2) {\n          throw TypeError$1(\"Reduce of empty array with no initial value\");\n        }\n      }\n    for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i2)\n      if (index2 in self2) {\n        memo = callbackfn(memo, self2[index2], index2, O2);\n      }\n    return memo;\n  };\n};\nvar arrayReduce = {\n  left: createMethod$1(false),\n  right: createMethod$1(true)\n};\nvar fails$3 = fails$k;\nvar arrayMethodIsStrict$2 = function(METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$3(function() {\n    method.call(null, argument || function() {\n      throw 1;\n    }, 1);\n  });\n};\nvar $$5 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict$1 = arrayMethodIsStrict$2;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\nvar STRICT_METHOD$1 = arrayMethodIsStrict$1(\"reduce\");\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n$$5({ target: \"Array\", proto: true, forced: !STRICT_METHOD$1 || CHROME_BUG }, {\n  reduce: function reduce(callbackfn) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);\n  }\n});\nvar $$4 = _export;\nvar uncurryThis$6 = functionUncurryThis;\nvar getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;\nvar toLength$1 = toLength$6;\nvar toString$3 = toString$9;\nvar notARegExp$1 = notARegexp;\nvar requireObjectCoercible$3 = requireObjectCoercible$a;\nvar correctIsRegExpLogic$1 = correctIsRegexpLogic;\nvar un$EndsWith = uncurryThis$6(\"\".endsWith);\nvar slice = uncurryThis$6(\"\".slice);\nvar min$1 = Math.min;\nvar CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic$1(\"endsWith\");\nvar MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {\n  var descriptor = getOwnPropertyDescriptor2(String.prototype, \"endsWith\");\n  return descriptor && !descriptor.writable;\n}();\n$$4({ target: \"String\", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {\n  endsWith: function endsWith(searchString) {\n    var that = toString$3(requireObjectCoercible$3(this));\n    notARegExp$1(searchString);\n    var endPosition = arguments.length > 1 ? arguments[1] : void 0;\n    var len = that.length;\n    var end = endPosition === void 0 ? len : min$1(toLength$1(endPosition), len);\n    var search = toString$3(searchString);\n    return un$EndsWith ? un$EndsWith(that, search, end) : slice(that, end - search.length, end) === search;\n  }\n});\nvar toPropertyKey = toPropertyKey$3;\nvar definePropertyModule = objectDefineProperty;\nvar createPropertyDescriptor = createPropertyDescriptor$4;\nvar createProperty$1 = function(object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object)\n    definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else\n    object[propertyKey] = value;\n};\nvar global$1 = global$I;\nvar toAbsoluteIndex = toAbsoluteIndex$2;\nvar lengthOfArrayLike = lengthOfArrayLike$4;\nvar createProperty = createProperty$1;\nvar Array$1 = global$1.Array;\nvar max = Math.max;\nvar arraySliceSimple = function(O2, start2, end) {\n  var length = lengthOfArrayLike(O2);\n  var k2 = toAbsoluteIndex(start2, length);\n  var fin = toAbsoluteIndex(end === void 0 ? length : end, length);\n  var result = Array$1(max(fin - k2, 0));\n  for (var n2 = 0; k2 < fin; k2++, n2++)\n    createProperty(result, n2, O2[k2]);\n  result.length = n2;\n  return result;\n};\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis$5 = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar isRegExp = isRegexp;\nvar anObject$1 = anObject$g;\nvar requireObjectCoercible$2 = requireObjectCoercible$a;\nvar speciesConstructor = speciesConstructor$2;\nvar advanceStringIndex = advanceStringIndex$3;\nvar toLength = toLength$6;\nvar toString$2 = toString$9;\nvar getMethod = getMethod$6;\nvar arraySlice = arraySliceSimple;\nvar callRegExpExec = regexpExecAbstract;\nvar regexpExec = regexpExec$3;\nvar stickyHelpers = regexpStickyHelpers;\nvar fails$2 = fails$k;\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\nvar MAX_UINT32 = 4294967295;\nvar min = Math.min;\nvar $push = [].push;\nvar exec = uncurryThis$5(/./.exec);\nvar push = uncurryThis$5($push);\nvar stringSlice = uncurryThis$5(\"\".slice);\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$2(function() {\n  var re2 = /(?:)/;\n  var originalExec = re2.exec;\n  re2.exec = function() {\n    return originalExec.apply(this, arguments);\n  };\n  var result = \"ab\".split(re2);\n  return result.length !== 2 || result[0] !== \"a\" || result[1] !== \"b\";\n});\nfixRegExpWellKnownSymbolLogic(\"split\", function(SPLIT, nativeSplit, maybeCallNative) {\n  var internalSplit;\n  if (\"abbc\".split(/(b)*/)[1] == \"c\" || \"test\".split(/(?:)/, -1).length != 4 || \"ab\".split(/(?:ab)*/).length != 2 || \".\".split(/(.?)(.?)/).length != 4 || \".\".split(/()()/).length > 1 || \"\".split(/.?/).length) {\n    internalSplit = function(separator, limit) {\n      var string = toString$2(requireObjectCoercible$2(this));\n      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0)\n        return [];\n      if (separator === void 0)\n        return [string];\n      if (!isRegExp(separator)) {\n        return call(nativeSplit, string, separator, lim);\n      }\n      var output = [];\n      var flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.unicode ? \"u\" : \"\") + (separator.sticky ? \"y\" : \"\");\n      var lastLastIndex = 0;\n      var separatorCopy = new RegExp(separator.source, flags + \"g\");\n      var match2, lastIndex, lastLength;\n      while (match2 = call(regexpExec, separatorCopy, string)) {\n        lastIndex = separatorCopy.lastIndex;\n        if (lastIndex > lastLastIndex) {\n          push(output, stringSlice(string, lastLastIndex, match2.index));\n          if (match2.length > 1 && match2.index < string.length)\n            apply($push, output, arraySlice(match2, 1));\n          lastLength = match2[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= lim)\n            break;\n        }\n        if (separatorCopy.lastIndex === match2.index)\n          separatorCopy.lastIndex++;\n      }\n      if (lastLastIndex === string.length) {\n        if (lastLength || !exec(separatorCopy, \"\"))\n          push(output, \"\");\n      } else\n        push(output, stringSlice(string, lastLastIndex));\n      return output.length > lim ? arraySlice(output, 0, lim) : output;\n    };\n  } else if (\"0\".split(void 0, 0).length) {\n    internalSplit = function(separator, limit) {\n      return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);\n    };\n  } else\n    internalSplit = nativeSplit;\n  return [\n    function split2(separator, limit) {\n      var O2 = requireObjectCoercible$2(this);\n      var splitter = separator == void 0 ? void 0 : getMethod(separator, SPLIT);\n      return splitter ? call(splitter, separator, O2, limit) : call(internalSplit, toString$2(O2), separator, limit);\n    },\n    function(string, limit) {\n      var rx = anObject$1(this);\n      var S2 = toString$2(string);\n      var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);\n      if (res.done)\n        return res.value;\n      var C2 = speciesConstructor(rx, RegExp);\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? \"i\" : \"\") + (rx.multiline ? \"m\" : \"\") + (rx.unicode ? \"u\" : \"\") + (UNSUPPORTED_Y ? \"g\" : \"y\");\n      var splitter = new C2(UNSUPPORTED_Y ? \"^(?:\" + rx.source + \")\" : rx, flags);\n      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0)\n        return [];\n      if (S2.length === 0)\n        return callRegExpExec(splitter, S2) === null ? [S2] : [];\n      var p5 = 0;\n      var q2 = 0;\n      var A2 = [];\n      while (q2 < S2.length) {\n        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;\n        var z2 = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);\n        var e2;\n        if (z2 === null || (e2 = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p5) {\n          q2 = advanceStringIndex(S2, q2, unicodeMatching);\n        } else {\n          push(A2, stringSlice(S2, p5, q2));\n          if (A2.length === lim)\n            return A2;\n          for (var i2 = 1; i2 <= z2.length - 1; i2++) {\n            push(A2, z2[i2]);\n            if (A2.length === lim)\n              return A2;\n          }\n          q2 = p5 = e2;\n        }\n      }\n      push(A2, stringSlice(S2, p5));\n      return A2;\n    }\n  ];\n}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);\nvar raf$1 = { exports: {} };\nvar performanceNow = { exports: {} };\n(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n  if (typeof performance !== \"undefined\" && performance !== null && performance.now) {\n    performanceNow.exports = function() {\n      return performance.now();\n    };\n  } else if (typeof process !== \"undefined\" && process !== null && process.hrtime) {\n    performanceNow.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    performanceNow.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    performanceNow.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n}).call(commonjsGlobal);\nvar now = performanceNow.exports, root = typeof window === \"undefined\" ? commonjsGlobal : window, vendors = [\"moz\", \"webkit\"], suffix = \"AnimationFrame\", raf = root[\"request\" + suffix], caf = root[\"cancel\" + suffix] || root[\"cancelRequest\" + suffix];\nfor (var i$1 = 0; !raf && i$1 < vendors.length; i$1++) {\n  raf = root[vendors[i$1] + \"Request\" + suffix];\n  caf = root[vendors[i$1] + \"Cancel\" + suffix] || root[vendors[i$1] + \"CancelRequest\" + suffix];\n}\nif (!raf || !caf) {\n  var last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;\n  raf = function(callback) {\n    if (queue.length === 0) {\n      var _now = now(), next = Math.max(0, frameDuration - (_now - last));\n      last = next + _now;\n      setTimeout(function() {\n        var cp = queue.slice(0);\n        queue.length = 0;\n        for (var i2 = 0; i2 < cp.length; i2++) {\n          if (!cp[i2].cancelled) {\n            try {\n              cp[i2].callback(last);\n            } catch (e2) {\n              setTimeout(function() {\n                throw e2;\n              }, 0);\n            }\n          }\n        }\n      }, Math.round(next));\n    }\n    queue.push({\n      handle: ++id,\n      callback,\n      cancelled: false\n    });\n    return id;\n  };\n  caf = function(handle) {\n    for (var i2 = 0; i2 < queue.length; i2++) {\n      if (queue[i2].handle === handle) {\n        queue[i2].cancelled = true;\n      }\n    }\n  };\n}\nraf$1.exports = function(fn) {\n  return raf.call(root, fn);\n};\nraf$1.exports.cancel = function() {\n  caf.apply(root, arguments);\n};\nraf$1.exports.polyfill = function(object) {\n  if (!object) {\n    object = root;\n  }\n  object.requestAnimationFrame = raf;\n  object.cancelAnimationFrame = caf;\n};\nvar requestAnimationFrame$1 = raf$1.exports;\nvar whitespaces$2 = \"\t\\n\\v\\f\\r \\xA0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF\";\nvar uncurryThis$4 = functionUncurryThis;\nvar requireObjectCoercible$1 = requireObjectCoercible$a;\nvar toString$1 = toString$9;\nvar whitespaces$1 = whitespaces$2;\nvar replace = uncurryThis$4(\"\".replace);\nvar whitespace = \"[\" + whitespaces$1 + \"]\";\nvar ltrim = RegExp(\"^\" + whitespace + whitespace + \"*\");\nvar rtrim = RegExp(whitespace + whitespace + \"*$\");\nvar createMethod = function(TYPE) {\n  return function($this) {\n    var string = toString$1(requireObjectCoercible$1($this));\n    if (TYPE & 1)\n      string = replace(string, ltrim, \"\");\n    if (TYPE & 2)\n      string = replace(string, rtrim, \"\");\n    return string;\n  };\n};\nvar stringTrim = {\n  start: createMethod(1),\n  end: createMethod(2),\n  trim: createMethod(3)\n};\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar fails$1 = fails$k;\nvar whitespaces = whitespaces$2;\nvar non = \"\\u200B\\x85\\u180E\";\nvar stringTrimForced = function(METHOD_NAME) {\n  return fails$1(function() {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\nvar $$3 = _export;\nvar $trim = stringTrim.trim;\nvar forcedStringTrimMethod = stringTrimForced;\n$$3({ target: \"String\", proto: true, forced: forcedStringTrimMethod(\"trim\") }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\nvar rgbcolor = function(color_string) {\n  this.ok = false;\n  this.alpha = 1;\n  if (color_string.charAt(0) == \"#\") {\n    color_string = color_string.substr(1, 6);\n  }\n  color_string = color_string.replace(/ /g, \"\");\n  color_string = color_string.toLowerCase();\n  var simple_colors = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"00ffff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"00ffff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dodgerblue: \"1e90ff\",\n    feldspar: \"d19275\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgrey: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslateblue: \"8470ff\",\n    lightslategray: \"778899\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"00ff00\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"ff00ff\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370d8\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"d87093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    rebeccapurple: \"663399\",\n    red: \"ff0000\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    violetred: \"d02090\",\n    wheat: \"f5deb3\",\n    white: \"ffffff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ffff00\",\n    yellowgreen: \"9acd32\"\n  };\n  color_string = simple_colors[color_string] || color_string;\n  var color_defs = [\n    {\n      re: /^rgba\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3}),\\s*((?:\\d?\\.)?\\d)\\)$/,\n      example: [\"rgba(123, 234, 45, 0.8)\", \"rgba(255,234,245,1.0)\"],\n      process: function(bits3) {\n        return [\n          parseInt(bits3[1]),\n          parseInt(bits3[2]),\n          parseInt(bits3[3]),\n          parseFloat(bits3[4])\n        ];\n      }\n    },\n    {\n      re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n      example: [\"rgb(123, 234, 45)\", \"rgb(255,234,245)\"],\n      process: function(bits3) {\n        return [\n          parseInt(bits3[1]),\n          parseInt(bits3[2]),\n          parseInt(bits3[3])\n        ];\n      }\n    },\n    {\n      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n      example: [\"#00ff00\", \"336699\"],\n      process: function(bits3) {\n        return [\n          parseInt(bits3[1], 16),\n          parseInt(bits3[2], 16),\n          parseInt(bits3[3], 16)\n        ];\n      }\n    },\n    {\n      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n      example: [\"#fb0\", \"f0f\"],\n      process: function(bits3) {\n        return [\n          parseInt(bits3[1] + bits3[1], 16),\n          parseInt(bits3[2] + bits3[2], 16),\n          parseInt(bits3[3] + bits3[3], 16)\n        ];\n      }\n    }\n  ];\n  for (var i2 = 0; i2 < color_defs.length; i2++) {\n    var re2 = color_defs[i2].re;\n    var processor = color_defs[i2].process;\n    var bits2 = re2.exec(color_string);\n    if (bits2) {\n      var channels = processor(bits2);\n      this.r = channels[0];\n      this.g = channels[1];\n      this.b = channels[2];\n      if (channels.length > 3) {\n        this.alpha = channels[3];\n      }\n      this.ok = true;\n    }\n  }\n  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;\n  this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;\n  this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;\n  this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;\n  this.toRGB = function() {\n    return \"rgb(\" + this.r + \", \" + this.g + \", \" + this.b + \")\";\n  };\n  this.toRGBA = function() {\n    return \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.alpha + \")\";\n  };\n  this.toHex = function() {\n    var r2 = this.r.toString(16);\n    var g2 = this.g.toString(16);\n    var b2 = this.b.toString(16);\n    if (r2.length == 1)\n      r2 = \"0\" + r2;\n    if (g2.length == 1)\n      g2 = \"0\" + g2;\n    if (b2.length == 1)\n      b2 = \"0\" + b2;\n    return \"#\" + r2 + g2 + b2;\n  };\n  this.getHelpXML = function() {\n    var examples = new Array();\n    for (var i3 = 0; i3 < color_defs.length; i3++) {\n      var example = color_defs[i3].example;\n      for (var j2 = 0; j2 < example.length; j2++) {\n        examples[examples.length] = example[j2];\n      }\n    }\n    for (var sc in simple_colors) {\n      examples[examples.length] = sc;\n    }\n    var xml2 = document.createElement(\"ul\");\n    xml2.setAttribute(\"id\", \"rgbcolor-examples\");\n    for (var i3 = 0; i3 < examples.length; i3++) {\n      try {\n        var list_item = document.createElement(\"li\");\n        var list_color = new RGBColor(examples[i3]);\n        var example_div = document.createElement(\"div\");\n        example_div.style.cssText = \"margin: 3px; border: 1px solid black; background:\" + list_color.toHex() + \"; color:\" + list_color.toHex();\n        example_div.appendChild(document.createTextNode(\"test\"));\n        var list_item_value = document.createTextNode(\" \" + examples[i3] + \" -> \" + list_color.toRGB() + \" -> \" + list_color.toHex());\n        list_item.appendChild(example_div);\n        list_item.appendChild(list_item_value);\n        xml2.appendChild(list_item);\n      } catch (e2) {\n      }\n    }\n    return xml2;\n  };\n};\nvar $$2 = _export;\nvar uncurryThis$3 = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible = requireObjectCoercible$a;\nvar toString2 = toString$9;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\nvar stringIndexOf = uncurryThis$3(\"\".indexOf);\n$$2({ target: \"String\", proto: true, forced: !correctIsRegExpLogic(\"includes\") }, {\n  includes: function includes2(searchString) {\n    return !!~stringIndexOf(toString2(requireObjectCoercible(this)), toString2(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : void 0);\n  }\n});\nvar $$1 = _export;\nvar uncurryThis$2 = functionUncurryThis;\nvar $IndexOf = arrayIncludes.indexOf;\nvar arrayMethodIsStrict = arrayMethodIsStrict$2;\nvar un$IndexOf = uncurryThis$2([].indexOf);\nvar NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;\nvar STRICT_METHOD = arrayMethodIsStrict(\"indexOf\");\n$$1({ target: \"Array\", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {\n  indexOf: function indexOf2(searchElement) {\n    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;\n    return NEGATIVE_ZERO ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);\n  }\n});\nvar classof = classofRaw$1;\nvar isArray$1 = Array.isArray || function isArray(argument) {\n  return classof(argument) == \"Array\";\n};\nvar $ = _export;\nvar uncurryThis$1 = functionUncurryThis;\nvar isArray2 = isArray$1;\nvar un$Reverse = uncurryThis$1([].reverse);\nvar test = [1, 2];\n$({ target: \"Array\", proto: true, forced: String(test) === String(test.reverse()) }, {\n  reverse: function reverse() {\n    if (isArray2(this))\n      this.length = this.length;\n    return un$Reverse(this);\n  }\n});\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar t2 = function(r2, e2) {\n  return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, r3) {\n    t3.__proto__ = r3;\n  } || function(t3, r3) {\n    for (var e3 in r3)\n      Object.prototype.hasOwnProperty.call(r3, e3) && (t3[e3] = r3[e3]);\n  })(r2, e2);\n};\nfunction r(r2, e2) {\n  if (typeof e2 != \"function\" && e2 !== null)\n    throw new TypeError(\"Class extends value \" + String(e2) + \" is not a constructor or null\");\n  function i2() {\n    this.constructor = r2;\n  }\n  t2(r2, e2), r2.prototype = e2 === null ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());\n}\nfunction e(t3) {\n  var r2 = \"\";\n  Array.isArray(t3) || (t3 = [t3]);\n  for (var e2 = 0; e2 < t3.length; e2++) {\n    var i2 = t3[e2];\n    if (i2.type === _.CLOSE_PATH)\n      r2 += \"z\";\n    else if (i2.type === _.HORIZ_LINE_TO)\n      r2 += (i2.relative ? \"h\" : \"H\") + i2.x;\n    else if (i2.type === _.VERT_LINE_TO)\n      r2 += (i2.relative ? \"v\" : \"V\") + i2.y;\n    else if (i2.type === _.MOVE_TO)\n      r2 += (i2.relative ? \"m\" : \"M\") + i2.x + \" \" + i2.y;\n    else if (i2.type === _.LINE_TO)\n      r2 += (i2.relative ? \"l\" : \"L\") + i2.x + \" \" + i2.y;\n    else if (i2.type === _.CURVE_TO)\n      r2 += (i2.relative ? \"c\" : \"C\") + i2.x1 + \" \" + i2.y1 + \" \" + i2.x2 + \" \" + i2.y2 + \" \" + i2.x + \" \" + i2.y;\n    else if (i2.type === _.SMOOTH_CURVE_TO)\n      r2 += (i2.relative ? \"s\" : \"S\") + i2.x2 + \" \" + i2.y2 + \" \" + i2.x + \" \" + i2.y;\n    else if (i2.type === _.QUAD_TO)\n      r2 += (i2.relative ? \"q\" : \"Q\") + i2.x1 + \" \" + i2.y1 + \" \" + i2.x + \" \" + i2.y;\n    else if (i2.type === _.SMOOTH_QUAD_TO)\n      r2 += (i2.relative ? \"t\" : \"T\") + i2.x + \" \" + i2.y;\n    else {\n      if (i2.type !== _.ARC)\n        throw new Error('Unexpected command type \"' + i2.type + '\" at index ' + e2 + \".\");\n      r2 += (i2.relative ? \"a\" : \"A\") + i2.rX + \" \" + i2.rY + \" \" + i2.xRot + \" \" + +i2.lArcFlag + \" \" + +i2.sweepFlag + \" \" + i2.x + \" \" + i2.y;\n    }\n  }\n  return r2;\n}\nfunction i(t3, r2) {\n  var e2 = t3[0], i2 = t3[1];\n  return [e2 * Math.cos(r2) - i2 * Math.sin(r2), e2 * Math.sin(r2) + i2 * Math.cos(r2)];\n}\nfunction a() {\n  for (var t3 = [], r2 = 0; r2 < arguments.length; r2++)\n    t3[r2] = arguments[r2];\n  for (var e2 = 0; e2 < t3.length; e2++)\n    if (typeof t3[e2] != \"number\")\n      throw new Error(\"assertNumbers arguments[\" + e2 + \"] is not a number. \" + typeof t3[e2] + \" == typeof \" + t3[e2]);\n  return true;\n}\nvar n = Math.PI;\nfunction o(t3, r2, e2) {\n  t3.lArcFlag = t3.lArcFlag === 0 ? 0 : 1, t3.sweepFlag = t3.sweepFlag === 0 ? 0 : 1;\n  var a2 = t3.rX, o2 = t3.rY, s2 = t3.x, u2 = t3.y;\n  a2 = Math.abs(t3.rX), o2 = Math.abs(t3.rY);\n  var h2 = i([(r2 - s2) / 2, (e2 - u2) / 2], -t3.xRot / 180 * n), c2 = h2[0], y2 = h2[1], p5 = Math.pow(c2, 2) / Math.pow(a2, 2) + Math.pow(y2, 2) / Math.pow(o2, 2);\n  1 < p5 && (a2 *= Math.sqrt(p5), o2 *= Math.sqrt(p5)), t3.rX = a2, t3.rY = o2;\n  var m2 = Math.pow(a2, 2) * Math.pow(y2, 2) + Math.pow(o2, 2) * Math.pow(c2, 2), O2 = (t3.lArcFlag !== t3.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a2, 2) * Math.pow(o2, 2) - m2) / m2)), l2 = a2 * y2 / o2 * O2, T2 = -o2 * c2 / a2 * O2, v2 = i([l2, T2], t3.xRot / 180 * n);\n  t3.cX = v2[0] + (r2 + s2) / 2, t3.cY = v2[1] + (e2 + u2) / 2, t3.phi1 = Math.atan2((y2 - T2) / o2, (c2 - l2) / a2), t3.phi2 = Math.atan2((-y2 - T2) / o2, (-c2 - l2) / a2), t3.sweepFlag === 0 && t3.phi2 > t3.phi1 && (t3.phi2 -= 2 * n), t3.sweepFlag === 1 && t3.phi2 < t3.phi1 && (t3.phi2 += 2 * n), t3.phi1 *= 180 / n, t3.phi2 *= 180 / n;\n}\nfunction s(t3, r2, e2) {\n  a(t3, r2, e2);\n  var i2 = t3 * t3 + r2 * r2 - e2 * e2;\n  if (0 > i2)\n    return [];\n  if (i2 === 0)\n    return [[t3 * e2 / (t3 * t3 + r2 * r2), r2 * e2 / (t3 * t3 + r2 * r2)]];\n  var n2 = Math.sqrt(i2);\n  return [[(t3 * e2 + r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 - t3 * n2) / (t3 * t3 + r2 * r2)], [(t3 * e2 - r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 + t3 * n2) / (t3 * t3 + r2 * r2)]];\n}\nvar u, h = Math.PI / 180;\nfunction c$1(t3, r2, e2) {\n  return (1 - e2) * t3 + e2 * r2;\n}\nfunction y(t3, r2, e2, i2) {\n  return t3 + Math.cos(i2 / 180 * n) * r2 + Math.sin(i2 / 180 * n) * e2;\n}\nfunction p(t3, r2, e2, i2) {\n  var a2 = 1e-6, n2 = r2 - t3, o2 = e2 - r2, s2 = 3 * n2 + 3 * (i2 - e2) - 6 * o2, u2 = 6 * (o2 - n2), h2 = 3 * n2;\n  return Math.abs(s2) < a2 ? [-h2 / u2] : function(t4, r3, e3) {\n    e3 === void 0 && (e3 = 1e-6);\n    var i3 = t4 * t4 / 4 - r3;\n    if (i3 < -e3)\n      return [];\n    if (i3 <= e3)\n      return [-t4 / 2];\n    var a3 = Math.sqrt(i3);\n    return [-t4 / 2 - a3, -t4 / 2 + a3];\n  }(u2 / s2, h2 / s2, a2);\n}\nfunction m$1(t3, r2, e2, i2, a2) {\n  var n2 = 1 - a2;\n  return t3 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * a2) + e2 * (3 * n2 * a2 * a2) + i2 * (a2 * a2 * a2);\n}\n!function(t3) {\n  function r2() {\n    return u2(function(t4, r3, e3) {\n      return t4.relative && (t4.x1 !== void 0 && (t4.x1 += r3), t4.y1 !== void 0 && (t4.y1 += e3), t4.x2 !== void 0 && (t4.x2 += r3), t4.y2 !== void 0 && (t4.y2 += e3), t4.x !== void 0 && (t4.x += r3), t4.y !== void 0 && (t4.y += e3), t4.relative = false), t4;\n    });\n  }\n  function e2() {\n    var t4 = NaN, r3 = NaN, e3 = NaN, i2 = NaN;\n    return u2(function(a2, n3, o2) {\n      return a2.type & _.SMOOTH_CURVE_TO && (a2.type = _.CURVE_TO, t4 = isNaN(t4) ? n3 : t4, r3 = isNaN(r3) ? o2 : r3, a2.x1 = a2.relative ? n3 - t4 : 2 * n3 - t4, a2.y1 = a2.relative ? o2 - r3 : 2 * o2 - r3), a2.type & _.CURVE_TO ? (t4 = a2.relative ? n3 + a2.x2 : a2.x2, r3 = a2.relative ? o2 + a2.y2 : a2.y2) : (t4 = NaN, r3 = NaN), a2.type & _.SMOOTH_QUAD_TO && (a2.type = _.QUAD_TO, e3 = isNaN(e3) ? n3 : e3, i2 = isNaN(i2) ? o2 : i2, a2.x1 = a2.relative ? n3 - e3 : 2 * n3 - e3, a2.y1 = a2.relative ? o2 - i2 : 2 * o2 - i2), a2.type & _.QUAD_TO ? (e3 = a2.relative ? n3 + a2.x1 : a2.x1, i2 = a2.relative ? o2 + a2.y1 : a2.y1) : (e3 = NaN, i2 = NaN), a2;\n    });\n  }\n  function n2() {\n    var t4 = NaN, r3 = NaN;\n    return u2(function(e3, i2, a2) {\n      if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t4 = isNaN(t4) ? i2 : t4, r3 = isNaN(r3) ? a2 : r3, e3.x1 = e3.relative ? i2 - t4 : 2 * i2 - t4, e3.y1 = e3.relative ? a2 - r3 : 2 * a2 - r3), e3.type & _.QUAD_TO) {\n        t4 = e3.relative ? i2 + e3.x1 : e3.x1, r3 = e3.relative ? a2 + e3.y1 : e3.y1;\n        var n3 = e3.x1, o2 = e3.y1;\n        e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i2) + 2 * n3) / 3, e3.y1 = ((e3.relative ? 0 : a2) + 2 * o2) / 3, e3.x2 = (e3.x + 2 * n3) / 3, e3.y2 = (e3.y + 2 * o2) / 3;\n      } else\n        t4 = NaN, r3 = NaN;\n      return e3;\n    });\n  }\n  function u2(t4) {\n    var r3 = 0, e3 = 0, i2 = NaN, a2 = NaN;\n    return function(n3) {\n      if (isNaN(i2) && !(n3.type & _.MOVE_TO))\n        throw new Error(\"path must start with moveto\");\n      var o2 = t4(n3, r3, e3, i2, a2);\n      return n3.type & _.CLOSE_PATH && (r3 = i2, e3 = a2), n3.x !== void 0 && (r3 = n3.relative ? r3 + n3.x : n3.x), n3.y !== void 0 && (e3 = n3.relative ? e3 + n3.y : n3.y), n3.type & _.MOVE_TO && (i2 = r3, a2 = e3), o2;\n    };\n  }\n  function O2(t4, r3, e3, i2, n3, o2) {\n    return a(t4, r3, e3, i2, n3, o2), u2(function(a2, s2, u3, h2) {\n      var c2 = a2.x1, y2 = a2.x2, p5 = a2.relative && !isNaN(h2), m2 = a2.x !== void 0 ? a2.x : p5 ? 0 : s2, O3 = a2.y !== void 0 ? a2.y : p5 ? 0 : u3;\n      function l3(t5) {\n        return t5 * t5;\n      }\n      a2.type & _.HORIZ_LINE_TO && r3 !== 0 && (a2.type = _.LINE_TO, a2.y = a2.relative ? 0 : u3), a2.type & _.VERT_LINE_TO && e3 !== 0 && (a2.type = _.LINE_TO, a2.x = a2.relative ? 0 : s2), a2.x !== void 0 && (a2.x = a2.x * t4 + O3 * e3 + (p5 ? 0 : n3)), a2.y !== void 0 && (a2.y = m2 * r3 + a2.y * i2 + (p5 ? 0 : o2)), a2.x1 !== void 0 && (a2.x1 = a2.x1 * t4 + a2.y1 * e3 + (p5 ? 0 : n3)), a2.y1 !== void 0 && (a2.y1 = c2 * r3 + a2.y1 * i2 + (p5 ? 0 : o2)), a2.x2 !== void 0 && (a2.x2 = a2.x2 * t4 + a2.y2 * e3 + (p5 ? 0 : n3)), a2.y2 !== void 0 && (a2.y2 = y2 * r3 + a2.y2 * i2 + (p5 ? 0 : o2));\n      var T2 = t4 * i2 - r3 * e3;\n      if (a2.xRot !== void 0 && (t4 !== 1 || r3 !== 0 || e3 !== 0 || i2 !== 1))\n        if (T2 === 0)\n          delete a2.rX, delete a2.rY, delete a2.xRot, delete a2.lArcFlag, delete a2.sweepFlag, a2.type = _.LINE_TO;\n        else {\n          var v2 = a2.xRot * Math.PI / 180, f2 = Math.sin(v2), N2 = Math.cos(v2), x2 = 1 / l3(a2.rX), d2 = 1 / l3(a2.rY), E2 = l3(N2) * x2 + l3(f2) * d2, A2 = 2 * f2 * N2 * (x2 - d2), C2 = l3(f2) * x2 + l3(N2) * d2, M2 = E2 * i2 * i2 - A2 * r3 * i2 + C2 * r3 * r3, R2 = A2 * (t4 * i2 + r3 * e3) - 2 * (E2 * e3 * i2 + C2 * t4 * r3), g2 = E2 * e3 * e3 - A2 * t4 * e3 + C2 * t4 * t4, I2 = (Math.atan2(R2, M2 - g2) + Math.PI) % Math.PI / 2, S2 = Math.sin(I2), L2 = Math.cos(I2);\n          a2.rX = Math.abs(T2) / Math.sqrt(M2 * l3(L2) + R2 * S2 * L2 + g2 * l3(S2)), a2.rY = Math.abs(T2) / Math.sqrt(M2 * l3(S2) - R2 * S2 * L2 + g2 * l3(L2)), a2.xRot = 180 * I2 / Math.PI;\n        }\n      return a2.sweepFlag !== void 0 && 0 > T2 && (a2.sweepFlag = +!a2.sweepFlag), a2;\n    });\n  }\n  function l2() {\n    return function(t4) {\n      var r3 = {};\n      for (var e3 in t4)\n        r3[e3] = t4[e3];\n      return r3;\n    };\n  }\n  t3.ROUND = function(t4) {\n    function r3(r4) {\n      return Math.round(r4 * t4) / t4;\n    }\n    return t4 === void 0 && (t4 = 1e13), a(t4), function(t5) {\n      return t5.x1 !== void 0 && (t5.x1 = r3(t5.x1)), t5.y1 !== void 0 && (t5.y1 = r3(t5.y1)), t5.x2 !== void 0 && (t5.x2 = r3(t5.x2)), t5.y2 !== void 0 && (t5.y2 = r3(t5.y2)), t5.x !== void 0 && (t5.x = r3(t5.x)), t5.y !== void 0 && (t5.y = r3(t5.y)), t5.rX !== void 0 && (t5.rX = r3(t5.rX)), t5.rY !== void 0 && (t5.rY = r3(t5.rY)), t5;\n    };\n  }, t3.TO_ABS = r2, t3.TO_REL = function() {\n    return u2(function(t4, r3, e3) {\n      return t4.relative || (t4.x1 !== void 0 && (t4.x1 -= r3), t4.y1 !== void 0 && (t4.y1 -= e3), t4.x2 !== void 0 && (t4.x2 -= r3), t4.y2 !== void 0 && (t4.y2 -= e3), t4.x !== void 0 && (t4.x -= r3), t4.y !== void 0 && (t4.y -= e3), t4.relative = true), t4;\n    });\n  }, t3.NORMALIZE_HVZ = function(t4, r3, e3) {\n    return t4 === void 0 && (t4 = true), r3 === void 0 && (r3 = true), e3 === void 0 && (e3 = true), u2(function(i2, a2, n3, o2, s2) {\n      if (isNaN(o2) && !(i2.type & _.MOVE_TO))\n        throw new Error(\"path must start with moveto\");\n      return r3 && i2.type & _.HORIZ_LINE_TO && (i2.type = _.LINE_TO, i2.y = i2.relative ? 0 : n3), e3 && i2.type & _.VERT_LINE_TO && (i2.type = _.LINE_TO, i2.x = i2.relative ? 0 : a2), t4 && i2.type & _.CLOSE_PATH && (i2.type = _.LINE_TO, i2.x = i2.relative ? o2 - a2 : o2, i2.y = i2.relative ? s2 - n3 : s2), i2.type & _.ARC && (i2.rX === 0 || i2.rY === 0) && (i2.type = _.LINE_TO, delete i2.rX, delete i2.rY, delete i2.xRot, delete i2.lArcFlag, delete i2.sweepFlag), i2;\n    });\n  }, t3.NORMALIZE_ST = e2, t3.QT_TO_C = n2, t3.INFO = u2, t3.SANITIZE = function(t4) {\n    t4 === void 0 && (t4 = 0), a(t4);\n    var r3 = NaN, e3 = NaN, i2 = NaN, n3 = NaN;\n    return u2(function(a2, o2, s2, u3, h2) {\n      var c2 = Math.abs, y2 = false, p5 = 0, m2 = 0;\n      if (a2.type & _.SMOOTH_CURVE_TO && (p5 = isNaN(r3) ? 0 : o2 - r3, m2 = isNaN(e3) ? 0 : s2 - e3), a2.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a2.relative ? o2 + a2.x2 : a2.x2, e3 = a2.relative ? s2 + a2.y2 : a2.y2) : (r3 = NaN, e3 = NaN), a2.type & _.SMOOTH_QUAD_TO ? (i2 = isNaN(i2) ? o2 : 2 * o2 - i2, n3 = isNaN(n3) ? s2 : 2 * s2 - n3) : a2.type & _.QUAD_TO ? (i2 = a2.relative ? o2 + a2.x1 : a2.x1, n3 = a2.relative ? s2 + a2.y1 : a2.y2) : (i2 = NaN, n3 = NaN), a2.type & _.LINE_COMMANDS || a2.type & _.ARC && (a2.rX === 0 || a2.rY === 0 || !a2.lArcFlag) || a2.type & _.CURVE_TO || a2.type & _.SMOOTH_CURVE_TO || a2.type & _.QUAD_TO || a2.type & _.SMOOTH_QUAD_TO) {\n        var O3 = a2.x === void 0 ? 0 : a2.relative ? a2.x : a2.x - o2, l3 = a2.y === void 0 ? 0 : a2.relative ? a2.y : a2.y - s2;\n        p5 = isNaN(i2) ? a2.x1 === void 0 ? p5 : a2.relative ? a2.x : a2.x1 - o2 : i2 - o2, m2 = isNaN(n3) ? a2.y1 === void 0 ? m2 : a2.relative ? a2.y : a2.y1 - s2 : n3 - s2;\n        var T2 = a2.x2 === void 0 ? 0 : a2.relative ? a2.x : a2.x2 - o2, v2 = a2.y2 === void 0 ? 0 : a2.relative ? a2.y : a2.y2 - s2;\n        c2(O3) <= t4 && c2(l3) <= t4 && c2(p5) <= t4 && c2(m2) <= t4 && c2(T2) <= t4 && c2(v2) <= t4 && (y2 = true);\n      }\n      return a2.type & _.CLOSE_PATH && c2(o2 - u3) <= t4 && c2(s2 - h2) <= t4 && (y2 = true), y2 ? [] : a2;\n    });\n  }, t3.MATRIX = O2, t3.ROTATE = function(t4, r3, e3) {\n    r3 === void 0 && (r3 = 0), e3 === void 0 && (e3 = 0), a(t4, r3, e3);\n    var i2 = Math.sin(t4), n3 = Math.cos(t4);\n    return O2(n3, i2, -i2, n3, r3 - r3 * n3 + e3 * i2, e3 - r3 * i2 - e3 * n3);\n  }, t3.TRANSLATE = function(t4, r3) {\n    return r3 === void 0 && (r3 = 0), a(t4, r3), O2(1, 0, 0, 1, t4, r3);\n  }, t3.SCALE = function(t4, r3) {\n    return r3 === void 0 && (r3 = t4), a(t4, r3), O2(t4, 0, 0, r3, 0, 0);\n  }, t3.SKEW_X = function(t4) {\n    return a(t4), O2(1, 0, Math.atan(t4), 1, 0, 0);\n  }, t3.SKEW_Y = function(t4) {\n    return a(t4), O2(1, Math.atan(t4), 0, 1, 0, 0);\n  }, t3.X_AXIS_SYMMETRY = function(t4) {\n    return t4 === void 0 && (t4 = 0), a(t4), O2(-1, 0, 0, 1, t4, 0);\n  }, t3.Y_AXIS_SYMMETRY = function(t4) {\n    return t4 === void 0 && (t4 = 0), a(t4), O2(1, 0, 0, -1, 0, t4);\n  }, t3.A_TO_C = function() {\n    return u2(function(t4, r3, e3) {\n      return _.ARC === t4.type ? function(t5, r4, e4) {\n        var a2, n3, s2, u3;\n        t5.cX || o(t5, r4, e4);\n        for (var y2 = Math.min(t5.phi1, t5.phi2), p5 = Math.max(t5.phi1, t5.phi2) - y2, m2 = Math.ceil(p5 / 90), O3 = new Array(m2), l3 = r4, T2 = e4, v2 = 0; v2 < m2; v2++) {\n          var f2 = c$1(t5.phi1, t5.phi2, v2 / m2), N2 = c$1(t5.phi1, t5.phi2, (v2 + 1) / m2), x2 = N2 - f2, d2 = 4 / 3 * Math.tan(x2 * h / 4), E2 = [Math.cos(f2 * h) - d2 * Math.sin(f2 * h), Math.sin(f2 * h) + d2 * Math.cos(f2 * h)], A2 = E2[0], C2 = E2[1], M2 = [Math.cos(N2 * h), Math.sin(N2 * h)], R2 = M2[0], g2 = M2[1], I2 = [R2 + d2 * Math.sin(N2 * h), g2 - d2 * Math.cos(N2 * h)], S2 = I2[0], L2 = I2[1];\n          O3[v2] = { relative: t5.relative, type: _.CURVE_TO };\n          var H4 = function(r5, e5) {\n            var a3 = i([r5 * t5.rX, e5 * t5.rY], t5.xRot), n4 = a3[0], o2 = a3[1];\n            return [t5.cX + n4, t5.cY + o2];\n          };\n          a2 = H4(A2, C2), O3[v2].x1 = a2[0], O3[v2].y1 = a2[1], n3 = H4(S2, L2), O3[v2].x2 = n3[0], O3[v2].y2 = n3[1], s2 = H4(R2, g2), O3[v2].x = s2[0], O3[v2].y = s2[1], t5.relative && (O3[v2].x1 -= l3, O3[v2].y1 -= T2, O3[v2].x2 -= l3, O3[v2].y2 -= T2, O3[v2].x -= l3, O3[v2].y -= T2), l3 = (u3 = [O3[v2].x, O3[v2].y])[0], T2 = u3[1];\n        }\n        return O3;\n      }(t4, t4.relative ? 0 : r3, t4.relative ? 0 : e3) : t4;\n    });\n  }, t3.ANNOTATE_ARCS = function() {\n    return u2(function(t4, r3, e3) {\n      return t4.relative && (r3 = 0, e3 = 0), _.ARC === t4.type && o(t4, r3, e3), t4;\n    });\n  }, t3.CLONE = l2, t3.CALCULATE_BOUNDS = function() {\n    var t4 = function(t5) {\n      var r3 = {};\n      for (var e3 in t5)\n        r3[e3] = t5[e3];\n      return r3;\n    }, i2 = r2(), a2 = n2(), h2 = e2(), c2 = u2(function(r3, e3, n3) {\n      var u3 = h2(a2(i2(t4(r3))));\n      function O3(t5) {\n        t5 > c2.maxX && (c2.maxX = t5), t5 < c2.minX && (c2.minX = t5);\n      }\n      function l3(t5) {\n        t5 > c2.maxY && (c2.maxY = t5), t5 < c2.minY && (c2.minY = t5);\n      }\n      if (u3.type & _.DRAWING_COMMANDS && (O3(e3), l3(n3)), u3.type & _.HORIZ_LINE_TO && O3(u3.x), u3.type & _.VERT_LINE_TO && l3(u3.y), u3.type & _.LINE_TO && (O3(u3.x), l3(u3.y)), u3.type & _.CURVE_TO) {\n        O3(u3.x), l3(u3.y);\n        for (var T2 = 0, v2 = p(e3, u3.x1, u3.x2, u3.x); T2 < v2.length; T2++) {\n          0 < (w2 = v2[T2]) && 1 > w2 && O3(m$1(e3, u3.x1, u3.x2, u3.x, w2));\n        }\n        for (var f2 = 0, N2 = p(n3, u3.y1, u3.y2, u3.y); f2 < N2.length; f2++) {\n          0 < (w2 = N2[f2]) && 1 > w2 && l3(m$1(n3, u3.y1, u3.y2, u3.y, w2));\n        }\n      }\n      if (u3.type & _.ARC) {\n        O3(u3.x), l3(u3.y), o(u3, e3, n3);\n        for (var x2 = u3.xRot / 180 * Math.PI, d2 = Math.cos(x2) * u3.rX, E2 = Math.sin(x2) * u3.rX, A2 = -Math.sin(x2) * u3.rY, C2 = Math.cos(x2) * u3.rY, M2 = u3.phi1 < u3.phi2 ? [u3.phi1, u3.phi2] : -180 > u3.phi2 ? [u3.phi2 + 360, u3.phi1 + 360] : [u3.phi2, u3.phi1], R2 = M2[0], g2 = M2[1], I2 = function(t5) {\n          var r4 = t5[0], e4 = t5[1], i3 = 180 * Math.atan2(e4, r4) / Math.PI;\n          return i3 < R2 ? i3 + 360 : i3;\n        }, S2 = 0, L2 = s(A2, -d2, 0).map(I2); S2 < L2.length; S2++) {\n          (w2 = L2[S2]) > R2 && w2 < g2 && O3(y(u3.cX, d2, A2, w2));\n        }\n        for (var H4 = 0, U2 = s(C2, -E2, 0).map(I2); H4 < U2.length; H4++) {\n          var w2;\n          (w2 = U2[H4]) > R2 && w2 < g2 && l3(y(u3.cY, E2, C2, w2));\n        }\n      }\n      return r3;\n    });\n    return c2.minX = 1 / 0, c2.maxX = -1 / 0, c2.minY = 1 / 0, c2.maxY = -1 / 0, c2;\n  };\n}(u || (u = {}));\nvar O, l = function() {\n  function t3() {\n  }\n  return t3.prototype.round = function(t4) {\n    return this.transform(u.ROUND(t4));\n  }, t3.prototype.toAbs = function() {\n    return this.transform(u.TO_ABS());\n  }, t3.prototype.toRel = function() {\n    return this.transform(u.TO_REL());\n  }, t3.prototype.normalizeHVZ = function(t4, r2, e2) {\n    return this.transform(u.NORMALIZE_HVZ(t4, r2, e2));\n  }, t3.prototype.normalizeST = function() {\n    return this.transform(u.NORMALIZE_ST());\n  }, t3.prototype.qtToC = function() {\n    return this.transform(u.QT_TO_C());\n  }, t3.prototype.aToC = function() {\n    return this.transform(u.A_TO_C());\n  }, t3.prototype.sanitize = function(t4) {\n    return this.transform(u.SANITIZE(t4));\n  }, t3.prototype.translate = function(t4, r2) {\n    return this.transform(u.TRANSLATE(t4, r2));\n  }, t3.prototype.scale = function(t4, r2) {\n    return this.transform(u.SCALE(t4, r2));\n  }, t3.prototype.rotate = function(t4, r2, e2) {\n    return this.transform(u.ROTATE(t4, r2, e2));\n  }, t3.prototype.matrix = function(t4, r2, e2, i2, a2, n2) {\n    return this.transform(u.MATRIX(t4, r2, e2, i2, a2, n2));\n  }, t3.prototype.skewX = function(t4) {\n    return this.transform(u.SKEW_X(t4));\n  }, t3.prototype.skewY = function(t4) {\n    return this.transform(u.SKEW_Y(t4));\n  }, t3.prototype.xSymmetry = function(t4) {\n    return this.transform(u.X_AXIS_SYMMETRY(t4));\n  }, t3.prototype.ySymmetry = function(t4) {\n    return this.transform(u.Y_AXIS_SYMMETRY(t4));\n  }, t3.prototype.annotateArcs = function() {\n    return this.transform(u.ANNOTATE_ARCS());\n  }, t3;\n}(), T = function(t3) {\n  return t3 === \" \" || t3 === \"\t\" || t3 === \"\\r\" || t3 === \"\\n\";\n}, v = function(t3) {\n  return \"0\".charCodeAt(0) <= t3.charCodeAt(0) && t3.charCodeAt(0) <= \"9\".charCodeAt(0);\n}, f = function(t3) {\n  function e2() {\n    var r2 = t3.call(this) || this;\n    return r2.curNumber = \"\", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;\n  }\n  return r(e2, t3), e2.prototype.finish = function(t4) {\n    if (t4 === void 0 && (t4 = []), this.parse(\" \", t4), this.curArgs.length !== 0 || !this.canParseCommandOrComma)\n      throw new SyntaxError(\"Unterminated command at the path end.\");\n    return t4;\n  }, e2.prototype.parse = function(t4, r2) {\n    var e3 = this;\n    r2 === void 0 && (r2 = []);\n    for (var i2 = function(t5) {\n      r2.push(t5), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;\n    }, a2 = 0; a2 < t4.length; a2++) {\n      var n2 = t4[a2], o2 = !(this.curCommandType !== _.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== \"0\" && this.curNumber !== \"1\"), s2 = v(n2) && (this.curNumber === \"0\" && n2 === \"0\" || o2);\n      if (!v(n2) || s2)\n        if (n2 !== \"e\" && n2 !== \"E\")\n          if (n2 !== \"-\" && n2 !== \"+\" || !this.curNumberHasExp || this.curNumberHasExpDigits)\n            if (n2 !== \".\" || this.curNumberHasExp || this.curNumberHasDecimal || o2) {\n              if (this.curNumber && this.curCommandType !== -1) {\n                var u2 = Number(this.curNumber);\n                if (isNaN(u2))\n                  throw new SyntaxError(\"Invalid number ending at \" + a2);\n                if (this.curCommandType === _.ARC) {\n                  if (this.curArgs.length === 0 || this.curArgs.length === 1) {\n                    if (0 > u2)\n                      throw new SyntaxError('Expected positive number, got \"' + u2 + '\" at index \"' + a2 + '\"');\n                  } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== \"0\" && this.curNumber !== \"1\")\n                    throw new SyntaxError('Expected a flag, got \"' + this.curNumber + '\" at index \"' + a2 + '\"');\n                }\n                this.curArgs.push(u2), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i2({ type: _.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u2 }) : _.VERT_LINE_TO === this.curCommandType ? i2({ type: _.VERT_LINE_TO, relative: this.curCommandRelative, y: u2 }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i2({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i2({ type: _.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i2({ type: _.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.QUAD_TO ? i2({ type: _.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.ARC && i2({ type: _.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = \"\", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;\n              }\n              if (!T(n2))\n                if (n2 === \",\" && this.canParseCommandOrComma)\n                  this.canParseCommandOrComma = false;\n                else if (n2 !== \"+\" && n2 !== \"-\" && n2 !== \".\")\n                  if (s2)\n                    this.curNumber = n2, this.curNumberHasDecimal = false;\n                  else {\n                    if (this.curArgs.length !== 0)\n                      throw new SyntaxError(\"Unterminated command at index \" + a2 + \".\");\n                    if (!this.canParseCommandOrComma)\n                      throw new SyntaxError('Unexpected character \"' + n2 + '\" at index ' + a2 + \". Command cannot follow comma\");\n                    if (this.canParseCommandOrComma = false, n2 !== \"z\" && n2 !== \"Z\")\n                      if (n2 === \"h\" || n2 === \"H\")\n                        this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = n2 === \"h\";\n                      else if (n2 === \"v\" || n2 === \"V\")\n                        this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = n2 === \"v\";\n                      else if (n2 === \"m\" || n2 === \"M\")\n                        this.curCommandType = _.MOVE_TO, this.curCommandRelative = n2 === \"m\";\n                      else if (n2 === \"l\" || n2 === \"L\")\n                        this.curCommandType = _.LINE_TO, this.curCommandRelative = n2 === \"l\";\n                      else if (n2 === \"c\" || n2 === \"C\")\n                        this.curCommandType = _.CURVE_TO, this.curCommandRelative = n2 === \"c\";\n                      else if (n2 === \"s\" || n2 === \"S\")\n                        this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = n2 === \"s\";\n                      else if (n2 === \"q\" || n2 === \"Q\")\n                        this.curCommandType = _.QUAD_TO, this.curCommandRelative = n2 === \"q\";\n                      else if (n2 === \"t\" || n2 === \"T\")\n                        this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = n2 === \"t\";\n                      else {\n                        if (n2 !== \"a\" && n2 !== \"A\")\n                          throw new SyntaxError('Unexpected character \"' + n2 + '\" at index ' + a2 + \".\");\n                        this.curCommandType = _.ARC, this.curCommandRelative = n2 === \"a\";\n                      }\n                    else\n                      r2.push({ type: _.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;\n                  }\n                else\n                  this.curNumber = n2, this.curNumberHasDecimal = n2 === \".\";\n            } else\n              this.curNumber += n2, this.curNumberHasDecimal = true;\n          else\n            this.curNumber += n2;\n        else\n          this.curNumber += n2, this.curNumberHasExp = true;\n      else\n        this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;\n    }\n    return r2;\n  }, e2.prototype.transform = function(t4) {\n    return Object.create(this, { parse: { value: function(r2, e3) {\n      e3 === void 0 && (e3 = []);\n      for (var i2 = 0, a2 = Object.getPrototypeOf(this).parse.call(this, r2); i2 < a2.length; i2++) {\n        var n2 = a2[i2], o2 = t4(n2);\n        Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);\n      }\n      return e3;\n    } } });\n  }, e2;\n}(l), _ = function(t3) {\n  function i2(r2) {\n    var e2 = t3.call(this) || this;\n    return e2.commands = typeof r2 == \"string\" ? i2.parse(r2) : r2, e2;\n  }\n  return r(i2, t3), i2.prototype.encode = function() {\n    return i2.encode(this.commands);\n  }, i2.prototype.getBounds = function() {\n    var t4 = u.CALCULATE_BOUNDS();\n    return this.transform(t4), t4;\n  }, i2.prototype.transform = function(t4) {\n    for (var r2 = [], e2 = 0, i3 = this.commands; e2 < i3.length; e2++) {\n      var a2 = t4(i3[e2]);\n      Array.isArray(a2) ? r2.push.apply(r2, a2) : r2.push(a2);\n    }\n    return this.commands = r2, this;\n  }, i2.encode = function(t4) {\n    return e(t4);\n  }, i2.parse = function(t4) {\n    var r2 = new f(), e2 = [];\n    return r2.parse(t4, e2), r2.finish(e2), e2;\n  }, i2.CLOSE_PATH = 1, i2.MOVE_TO = 2, i2.HORIZ_LINE_TO = 4, i2.VERT_LINE_TO = 8, i2.LINE_TO = 16, i2.CURVE_TO = 32, i2.SMOOTH_CURVE_TO = 64, i2.QUAD_TO = 128, i2.SMOOTH_QUAD_TO = 256, i2.ARC = 512, i2.LINE_COMMANDS = i2.LINE_TO | i2.HORIZ_LINE_TO | i2.VERT_LINE_TO, i2.DRAWING_COMMANDS = i2.HORIZ_LINE_TO | i2.VERT_LINE_TO | i2.LINE_TO | i2.CURVE_TO | i2.SMOOTH_CURVE_TO | i2.QUAD_TO | i2.SMOOTH_QUAD_TO | i2.ARC, i2;\n}(l), N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);\nvar uncurryThis = functionUncurryThis;\nvar PROPER_FUNCTION_NAME = functionName.PROPER;\nvar redefine = redefine$7.exports;\nvar anObject = anObject$g;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar $toString = toString$9;\nvar fails = fails$k;\nvar regExpFlags = regexpFlags$1;\nvar TO_STRING = \"toString\";\nvar RegExpPrototype = RegExp.prototype;\nvar n$ToString = RegExpPrototype[TO_STRING];\nvar getFlags = uncurryThis(regExpFlags);\nvar NOT_GENERIC = fails(function() {\n  return n$ToString.call({ source: \"a\", flags: \"b\" }) != \"/a/b\";\n});\nvar INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;\nif (NOT_GENERIC || INCORRECT_NAME) {\n  redefine(RegExp.prototype, TO_STRING, function toString3() {\n    var R2 = anObject(this);\n    var p5 = $toString(R2.source);\n    var rf = R2.flags;\n    var f2 = $toString(rf === void 0 && isPrototypeOf(RegExpPrototype, R2) && !(\"flags\" in RegExpPrototype) ? getFlags(R2) : rf);\n    return \"/\" + p5 + \"/\" + f2;\n  }, { unsafe: true });\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function(obj2) {\n      return typeof obj2;\n    };\n  } else {\n    _typeof = function(obj2) {\n      return obj2 && typeof Symbol === \"function\" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? \"symbol\" : typeof obj2;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];\nvar shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];\nfunction getImageDataFromCanvas(canvas, topX, topY, width, height) {\n  if (typeof canvas === \"string\") {\n    canvas = document.getElementById(canvas);\n  }\n  if (!canvas || _typeof(canvas) !== \"object\" || !(\"getContext\" in canvas)) {\n    throw new TypeError(\"Expecting canvas with `getContext` method in processCanvasRGB(A) calls!\");\n  }\n  var context = canvas.getContext(\"2d\");\n  try {\n    return context.getImageData(topX, topY, width, height);\n  } catch (e2) {\n    throw new Error(\"unable to access image data: \" + e2);\n  }\n}\nfunction processCanvasRGBA(canvas, topX, topY, width, height, radius) {\n  if (isNaN(radius) || radius < 1) {\n    return;\n  }\n  radius |= 0;\n  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);\n  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);\n  canvas.getContext(\"2d\").putImageData(imageData, topX, topY);\n}\nfunction processImageDataRGBA(imageData, topX, topY, width, height, radius) {\n  var pixels = imageData.data;\n  var div = 2 * radius + 1;\n  var widthMinus1 = width - 1;\n  var heightMinus1 = height - 1;\n  var radiusPlus1 = radius + 1;\n  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;\n  var stackStart = new BlurStack();\n  var stack = stackStart;\n  var stackEnd;\n  for (var i2 = 1; i2 < div; i2++) {\n    stack = stack.next = new BlurStack();\n    if (i2 === radiusPlus1) {\n      stackEnd = stack;\n    }\n  }\n  stack.next = stackStart;\n  var stackIn = null, stackOut = null, yw = 0, yi = 0;\n  var mulSum = mulTable[radius];\n  var shgSum = shgTable[radius];\n  for (var y2 = 0; y2 < height; y2++) {\n    stack = stackStart;\n    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];\n    for (var _i = 0; _i < radiusPlus1; _i++) {\n      stack.r = pr;\n      stack.g = pg;\n      stack.b = pb;\n      stack.a = pa;\n      stack = stack.next;\n    }\n    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;\n    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {\n      var p5 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);\n      var r2 = pixels[p5], g2 = pixels[p5 + 1], b2 = pixels[p5 + 2], a2 = pixels[p5 + 3];\n      var rbs = radiusPlus1 - _i2;\n      rSum += (stack.r = r2) * rbs;\n      gSum += (stack.g = g2) * rbs;\n      bSum += (stack.b = b2) * rbs;\n      aSum += (stack.a = a2) * rbs;\n      rInSum += r2;\n      gInSum += g2;\n      bInSum += b2;\n      aInSum += a2;\n      stack = stack.next;\n    }\n    stackIn = stackStart;\n    stackOut = stackEnd;\n    for (var x2 = 0; x2 < width; x2++) {\n      var paInitial = aSum * mulSum >> shgSum;\n      pixels[yi + 3] = paInitial;\n      if (paInitial !== 0) {\n        var _a2 = 255 / paInitial;\n        pixels[yi] = (rSum * mulSum >> shgSum) * _a2;\n        pixels[yi + 1] = (gSum * mulSum >> shgSum) * _a2;\n        pixels[yi + 2] = (bSum * mulSum >> shgSum) * _a2;\n      } else {\n        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;\n      }\n      rSum -= rOutSum;\n      gSum -= gOutSum;\n      bSum -= bOutSum;\n      aSum -= aOutSum;\n      rOutSum -= stackIn.r;\n      gOutSum -= stackIn.g;\n      bOutSum -= stackIn.b;\n      aOutSum -= stackIn.a;\n      var _p = x2 + radius + 1;\n      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;\n      rInSum += stackIn.r = pixels[_p];\n      gInSum += stackIn.g = pixels[_p + 1];\n      bInSum += stackIn.b = pixels[_p + 2];\n      aInSum += stackIn.a = pixels[_p + 3];\n      rSum += rInSum;\n      gSum += gInSum;\n      bSum += bInSum;\n      aSum += aInSum;\n      stackIn = stackIn.next;\n      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;\n      rOutSum += _r;\n      gOutSum += _g;\n      bOutSum += _b2;\n      aOutSum += _a3;\n      rInSum -= _r;\n      gInSum -= _g;\n      bInSum -= _b2;\n      aInSum -= _a3;\n      stackOut = stackOut.next;\n      yi += 4;\n    }\n    yw += width;\n  }\n  for (var _x = 0; _x < width; _x++) {\n    yi = _x << 2;\n    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;\n    stack = stackStart;\n    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {\n      stack.r = _pr;\n      stack.g = _pg;\n      stack.b = _pb;\n      stack.a = _pa;\n      stack = stack.next;\n    }\n    var yp = width;\n    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;\n    for (var _i4 = 1; _i4 <= radius; _i4++) {\n      yi = yp + _x << 2;\n      var _rbs = radiusPlus1 - _i4;\n      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;\n      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;\n      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;\n      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;\n      _rInSum += _pr;\n      _gInSum += _pg;\n      _bInSum += _pb;\n      _aInSum += _pa;\n      stack = stack.next;\n      if (_i4 < heightMinus1) {\n        yp += width;\n      }\n    }\n    yi = _x;\n    stackIn = stackStart;\n    stackOut = stackEnd;\n    for (var _y = 0; _y < height; _y++) {\n      var _p2 = yi << 2;\n      pixels[_p2 + 3] = _pa = _aSum * mulSum >> shgSum;\n      if (_pa > 0) {\n        _pa = 255 / _pa;\n        pixels[_p2] = (_rSum * mulSum >> shgSum) * _pa;\n        pixels[_p2 + 1] = (_gSum * mulSum >> shgSum) * _pa;\n        pixels[_p2 + 2] = (_bSum * mulSum >> shgSum) * _pa;\n      } else {\n        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;\n      }\n      _rSum -= _rOutSum;\n      _gSum -= _gOutSum;\n      _bSum -= _bOutSum;\n      _aSum -= _aOutSum;\n      _rOutSum -= stackIn.r;\n      _gOutSum -= stackIn.g;\n      _bOutSum -= stackIn.b;\n      _aOutSum -= stackIn.a;\n      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;\n      _rSum += _rInSum += stackIn.r = pixels[_p2];\n      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];\n      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];\n      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];\n      stackIn = stackIn.next;\n      _rOutSum += _pr = stackOut.r;\n      _gOutSum += _pg = stackOut.g;\n      _bOutSum += _pb = stackOut.b;\n      _aOutSum += _pa = stackOut.a;\n      _rInSum -= _pr;\n      _gInSum -= _pg;\n      _bInSum -= _pb;\n      _aInSum -= _pa;\n      stackOut = stackOut.next;\n      yi += width;\n    }\n  }\n  return imageData;\n}\nvar BlurStack = function BlurStack2() {\n  _classCallCheck(this, BlurStack2);\n  this.r = 0;\n  this.g = 0;\n  this.b = 0;\n  this.a = 0;\n  this.next = null;\n};\nfunction offscreen() {\n  var {\n    DOMParser: DOMParserFallback\n  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n  var preset = {\n    window: null,\n    ignoreAnimation: true,\n    ignoreMouse: true,\n    DOMParser: DOMParserFallback,\n    createCanvas(width, height) {\n      return new OffscreenCanvas(width, height);\n    },\n    createImage(url) {\n      return _asyncToGenerator(function* () {\n        var response = yield fetch(url);\n        var blob = yield response.blob();\n        var img = yield createImageBitmap(blob);\n        return img;\n      })();\n    }\n  };\n  if (typeof DOMParser !== \"undefined\" || typeof DOMParserFallback === \"undefined\") {\n    Reflect.deleteProperty(preset, \"DOMParser\");\n  }\n  return preset;\n}\nfunction node(_ref2) {\n  var {\n    DOMParser: DOMParser2,\n    canvas,\n    fetch: fetch2\n  } = _ref2;\n  return {\n    window: null,\n    ignoreAnimation: true,\n    ignoreMouse: true,\n    DOMParser: DOMParser2,\n    fetch: fetch2,\n    createCanvas: canvas.createCanvas,\n    createImage: canvas.loadImage\n  };\n}\nvar index = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  offscreen,\n  node\n});\nfunction compressSpaces(str) {\n  return str.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\nfunction trimLeft(str) {\n  return str.replace(/^[\\n \\t]+/, \"\");\n}\nfunction trimRight(str) {\n  return str.replace(/[\\n \\t]+$/, \"\");\n}\nfunction toNumbers(str) {\n  var matches = (str || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n  return matches.map(parseFloat);\n}\nvar allUppercase = /^[A-Z-]+$/;\nfunction normalizeAttributeName(name) {\n  if (allUppercase.test(name)) {\n    return name.toLowerCase();\n  }\n  return name;\n}\nfunction parseExternalUrl(url) {\n  var urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url) || [];\n  return urlMatch[2] || urlMatch[3] || urlMatch[4];\n}\nfunction normalizeColor(color2) {\n  if (!color2.startsWith(\"rgb\")) {\n    return color2;\n  }\n  var rgbParts = 3;\n  var normalizedColor = color2.replace(/\\d+(\\.\\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);\n  return normalizedColor;\n}\nvar attributeRegex = /(\\[[^\\]]+\\])/g;\nvar idRegex = /(#[^\\s+>~.[:]+)/g;\nvar classRegex = /(\\.[^\\s+>~.[:]+)/g;\nvar pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nvar pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nvar elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n  var matches = regex.exec(selector);\n  if (!matches) {\n    return [selector, 0];\n  }\n  return [selector.replace(regex, \" \"), matches.length];\n}\nfunction getSelectorSpecificity(selector) {\n  var specificity = [0, 0, 0];\n  var currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \");\n  var delta = 0;\n  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);\n  specificity[1] += delta;\n  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);\n  specificity[0] += delta;\n  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);\n  specificity[1] += delta;\n  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);\n  specificity[2] += delta;\n  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n  specificity[1] += delta;\n  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);\n  specificity[1] += delta;\n  currentSelector = currentSelector.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \");\n  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);\n  specificity[2] += delta;\n  return specificity.join(\"\");\n}\nvar PSEUDO_ZERO = 1e-8;\nfunction vectorMagnitude(v2) {\n  return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2));\n}\nfunction vectorsRatio(u2, v2) {\n  return (u2[0] * v2[0] + u2[1] * v2[1]) / (vectorMagnitude(u2) * vectorMagnitude(v2));\n}\nfunction vectorsAngle(u2, v2) {\n  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v2));\n}\nfunction CB1(t3) {\n  return t3 * t3 * t3;\n}\nfunction CB2(t3) {\n  return 3 * t3 * t3 * (1 - t3);\n}\nfunction CB3(t3) {\n  return 3 * t3 * (1 - t3) * (1 - t3);\n}\nfunction CB4(t3) {\n  return (1 - t3) * (1 - t3) * (1 - t3);\n}\nfunction QB1(t3) {\n  return t3 * t3;\n}\nfunction QB2(t3) {\n  return 2 * t3 * (1 - t3);\n}\nfunction QB3(t3) {\n  return (1 - t3) * (1 - t3);\n}\nclass Property {\n  constructor(document2, name, value) {\n    this.document = document2;\n    this.name = name;\n    this.value = value;\n    this.isNormalizedColor = false;\n  }\n  static empty(document2) {\n    return new Property(document2, \"EMPTY\", \"\");\n  }\n  split() {\n    var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \" \";\n    var {\n      document: document2,\n      name\n    } = this;\n    return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document2, name, value));\n  }\n  hasValue(zeroIsValue) {\n    var {\n      value\n    } = this;\n    return value !== null && value !== \"\" && (zeroIsValue || value !== 0) && typeof value !== \"undefined\";\n  }\n  isString(regexp) {\n    var {\n      value\n    } = this;\n    var result = typeof value === \"string\";\n    if (!result || !regexp) {\n      return result;\n    }\n    return regexp.test(value);\n  }\n  isUrlDefinition() {\n    return this.isString(/^url\\(/);\n  }\n  isPixels() {\n    if (!this.hasValue()) {\n      return false;\n    }\n    var asString2 = this.getString();\n    switch (true) {\n      case asString2.endsWith(\"px\"):\n      case /^[0-9]+$/.test(asString2):\n        return true;\n      default:\n        return false;\n    }\n  }\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  getValue(def) {\n    if (typeof def === \"undefined\" || this.hasValue()) {\n      return this.value;\n    }\n    return def;\n  }\n  getNumber(def) {\n    if (!this.hasValue()) {\n      if (typeof def === \"undefined\") {\n        return 0;\n      }\n      return parseFloat(def);\n    }\n    var {\n      value\n    } = this;\n    var n2 = parseFloat(value);\n    if (this.isString(/%$/)) {\n      n2 /= 100;\n    }\n    return n2;\n  }\n  getString(def) {\n    if (typeof def === \"undefined\" || this.hasValue()) {\n      return typeof this.value === \"undefined\" ? \"\" : String(this.value);\n    }\n    return String(def);\n  }\n  getColor(def) {\n    var color2 = this.getString(def);\n    if (this.isNormalizedColor) {\n      return color2;\n    }\n    this.isNormalizedColor = true;\n    color2 = normalizeColor(color2);\n    this.value = color2;\n    return color2;\n  }\n  getDpi() {\n    return 96;\n  }\n  getRem() {\n    return this.document.rootEmSize;\n  }\n  getEm() {\n    return this.document.emSize;\n  }\n  getUnits() {\n    return this.getString().replace(/[0-9.-]/g, \"\");\n  }\n  getPixels(axisOrIsFontSize) {\n    var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    if (!this.hasValue()) {\n      return 0;\n    }\n    var [axis, isFontSize] = typeof axisOrIsFontSize === \"boolean\" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];\n    var {\n      viewPort\n    } = this.document.screen;\n    switch (true) {\n      case this.isString(/vmin$/):\n        return this.getNumber() / 100 * Math.min(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n      case this.isString(/vmax$/):\n        return this.getNumber() / 100 * Math.max(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n      case this.isString(/vw$/):\n        return this.getNumber() / 100 * viewPort.computeSize(\"x\");\n      case this.isString(/vh$/):\n        return this.getNumber() / 100 * viewPort.computeSize(\"y\");\n      case this.isString(/rem$/):\n        return this.getNumber() * this.getRem();\n      case this.isString(/em$/):\n        return this.getNumber() * this.getEm();\n      case this.isString(/ex$/):\n        return this.getNumber() * this.getEm() / 2;\n      case this.isString(/px$/):\n        return this.getNumber();\n      case this.isString(/pt$/):\n        return this.getNumber() * this.getDpi() * (1 / 72);\n      case this.isString(/pc$/):\n        return this.getNumber() * 15;\n      case this.isString(/cm$/):\n        return this.getNumber() * this.getDpi() / 2.54;\n      case this.isString(/mm$/):\n        return this.getNumber() * this.getDpi() / 25.4;\n      case this.isString(/in$/):\n        return this.getNumber() * this.getDpi();\n      case (this.isString(/%$/) && isFontSize):\n        return this.getNumber() * this.getEm();\n      case this.isString(/%$/):\n        return this.getNumber() * viewPort.computeSize(axis);\n      default: {\n        var n2 = this.getNumber();\n        if (processPercent && n2 < 1) {\n          return n2 * viewPort.computeSize(axis);\n        }\n        return n2;\n      }\n    }\n  }\n  getMilliseconds() {\n    if (!this.hasValue()) {\n      return 0;\n    }\n    if (this.isString(/ms$/)) {\n      return this.getNumber();\n    }\n    return this.getNumber() * 1e3;\n  }\n  getRadians() {\n    if (!this.hasValue()) {\n      return 0;\n    }\n    switch (true) {\n      case this.isString(/deg$/):\n        return this.getNumber() * (Math.PI / 180);\n      case this.isString(/grad$/):\n        return this.getNumber() * (Math.PI / 200);\n      case this.isString(/rad$/):\n        return this.getNumber();\n      default:\n        return this.getNumber() * (Math.PI / 180);\n    }\n  }\n  getDefinition() {\n    var asString2 = this.getString();\n    var name = /#([^)'\"]+)/.exec(asString2);\n    if (name) {\n      name = name[1];\n    }\n    if (!name) {\n      name = asString2;\n    }\n    return this.document.definitions[name];\n  }\n  getFillStyleDefinition(element, opacity2) {\n    var def = this.getDefinition();\n    if (!def) {\n      return null;\n    }\n    if (typeof def.createGradient === \"function\") {\n      return def.createGradient(this.document.ctx, element, opacity2);\n    }\n    if (typeof def.createPattern === \"function\") {\n      if (def.getHrefAttribute().hasValue()) {\n        var patternTransform = def.getAttribute(\"patternTransform\");\n        def = def.getHrefAttribute().getDefinition();\n        if (patternTransform.hasValue()) {\n          def.getAttribute(\"patternTransform\", true).setValue(patternTransform.value);\n        }\n      }\n      return def.createPattern(this.document.ctx, element, opacity2);\n    }\n    return null;\n  }\n  getTextBaseline() {\n    if (!this.hasValue()) {\n      return null;\n    }\n    return Property.textBaselineMapping[this.getString()];\n  }\n  addOpacity(opacity2) {\n    var value = this.getColor();\n    var len = value.length;\n    var commas = 0;\n    for (var i2 = 0; i2 < len; i2++) {\n      if (value[i2] === \",\") {\n        commas++;\n      }\n      if (commas === 3) {\n        break;\n      }\n    }\n    if (opacity2.hasValue() && this.isString() && commas !== 3) {\n      var color2 = new rgbcolor(value);\n      if (color2.ok) {\n        color2.alpha = opacity2.getNumber();\n        value = color2.toRGBA();\n      }\n    }\n    return new Property(this.document, this.name, value);\n  }\n}\nProperty.textBaselineMapping = {\n  \"baseline\": \"alphabetic\",\n  \"before-edge\": \"top\",\n  \"text-before-edge\": \"top\",\n  \"middle\": \"middle\",\n  \"central\": \"middle\",\n  \"after-edge\": \"bottom\",\n  \"text-after-edge\": \"bottom\",\n  \"ideographic\": \"ideographic\",\n  \"alphabetic\": \"alphabetic\",\n  \"hanging\": \"hanging\",\n  \"mathematical\": \"alphabetic\"\n};\nclass ViewPort {\n  constructor() {\n    this.viewPorts = [];\n  }\n  clear() {\n    this.viewPorts = [];\n  }\n  setCurrent(width, height) {\n    this.viewPorts.push({\n      width,\n      height\n    });\n  }\n  removeCurrent() {\n    this.viewPorts.pop();\n  }\n  getCurrent() {\n    var {\n      viewPorts\n    } = this;\n    return viewPorts[viewPorts.length - 1];\n  }\n  get width() {\n    return this.getCurrent().width;\n  }\n  get height() {\n    return this.getCurrent().height;\n  }\n  computeSize(d2) {\n    if (typeof d2 === \"number\") {\n      return d2;\n    }\n    if (d2 === \"x\") {\n      return this.width;\n    }\n    if (d2 === \"y\") {\n      return this.height;\n    }\n    return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n  }\n}\nclass Point {\n  constructor(x2, y2) {\n    this.x = x2;\n    this.y = y2;\n  }\n  static parse(point) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    var [x2 = defaultValue, y2 = defaultValue] = toNumbers(point);\n    return new Point(x2, y2);\n  }\n  static parseScale(scale2) {\n    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    var [x2 = defaultValue, y2 = x2] = toNumbers(scale2);\n    return new Point(x2, y2);\n  }\n  static parsePath(path) {\n    var points = toNumbers(path);\n    var len = points.length;\n    var pathPoints = [];\n    for (var i2 = 0; i2 < len; i2 += 2) {\n      pathPoints.push(new Point(points[i2], points[i2 + 1]));\n    }\n    return pathPoints;\n  }\n  angleTo(point) {\n    return Math.atan2(point.y - this.y, point.x - this.x);\n  }\n  applyTransform(transform2) {\n    var {\n      x: x2,\n      y: y2\n    } = this;\n    var xp = x2 * transform2[0] + y2 * transform2[2] + transform2[4];\n    var yp = x2 * transform2[1] + y2 * transform2[3] + transform2[5];\n    this.x = xp;\n    this.y = yp;\n  }\n}\nclass Mouse {\n  constructor(screen) {\n    this.screen = screen;\n    this.working = false;\n    this.events = [];\n    this.eventElements = [];\n    this.onClick = this.onClick.bind(this);\n    this.onMouseMove = this.onMouseMove.bind(this);\n  }\n  isWorking() {\n    return this.working;\n  }\n  start() {\n    if (this.working) {\n      return;\n    }\n    var {\n      screen,\n      onClick,\n      onMouseMove\n    } = this;\n    var canvas = screen.ctx.canvas;\n    canvas.onclick = onClick;\n    canvas.onmousemove = onMouseMove;\n    this.working = true;\n  }\n  stop() {\n    if (!this.working) {\n      return;\n    }\n    var canvas = this.screen.ctx.canvas;\n    this.working = false;\n    canvas.onclick = null;\n    canvas.onmousemove = null;\n  }\n  hasEvents() {\n    return this.working && this.events.length > 0;\n  }\n  runEvents() {\n    if (!this.working) {\n      return;\n    }\n    var {\n      screen: document2,\n      events: events2,\n      eventElements\n    } = this;\n    var {\n      style: style2\n    } = document2.ctx.canvas;\n    if (style2) {\n      style2.cursor = \"\";\n    }\n    events2.forEach((_ref2, i2) => {\n      var {\n        run: run2\n      } = _ref2;\n      var element = eventElements[i2];\n      while (element) {\n        run2(element);\n        element = element.parent;\n      }\n    });\n    this.events = [];\n    this.eventElements = [];\n  }\n  checkPath(element, ctx) {\n    if (!this.working || !ctx) {\n      return;\n    }\n    var {\n      events: events2,\n      eventElements\n    } = this;\n    events2.forEach((_ref2, i2) => {\n      var {\n        x: x2,\n        y: y2\n      } = _ref2;\n      if (!eventElements[i2] && ctx.isPointInPath && ctx.isPointInPath(x2, y2)) {\n        eventElements[i2] = element;\n      }\n    });\n  }\n  checkBoundingBox(element, boundingBox) {\n    if (!this.working || !boundingBox) {\n      return;\n    }\n    var {\n      events: events2,\n      eventElements\n    } = this;\n    events2.forEach((_ref3, i2) => {\n      var {\n        x: x2,\n        y: y2\n      } = _ref3;\n      if (!eventElements[i2] && boundingBox.isPointInBox(x2, y2)) {\n        eventElements[i2] = element;\n      }\n    });\n  }\n  mapXY(x2, y2) {\n    var {\n      window: window2,\n      ctx\n    } = this.screen;\n    var point = new Point(x2, y2);\n    var element = ctx.canvas;\n    while (element) {\n      point.x -= element.offsetLeft;\n      point.y -= element.offsetTop;\n      element = element.offsetParent;\n    }\n    if (window2.scrollX) {\n      point.x += window2.scrollX;\n    }\n    if (window2.scrollY) {\n      point.y += window2.scrollY;\n    }\n    return point;\n  }\n  onClick(event) {\n    var {\n      x: x2,\n      y: y2\n    } = this.mapXY(event.clientX, event.clientY);\n    this.events.push({\n      type: \"onclick\",\n      x: x2,\n      y: y2,\n      run(eventTarget) {\n        if (eventTarget.onClick) {\n          eventTarget.onClick();\n        }\n      }\n    });\n  }\n  onMouseMove(event) {\n    var {\n      x: x2,\n      y: y2\n    } = this.mapXY(event.clientX, event.clientY);\n    this.events.push({\n      type: \"onmousemove\",\n      x: x2,\n      y: y2,\n      run(eventTarget) {\n        if (eventTarget.onMouseMove) {\n          eventTarget.onMouseMove();\n        }\n      }\n    });\n  }\n}\nvar defaultWindow = typeof window !== \"undefined\" ? window : null;\nvar defaultFetch$1 = typeof fetch !== \"undefined\" ? fetch.bind(void 0) : null;\nclass Screen {\n  constructor(ctx) {\n    var {\n      fetch: fetch2 = defaultFetch$1,\n      window: window2 = defaultWindow\n    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    this.ctx = ctx;\n    this.FRAMERATE = 30;\n    this.MAX_VIRTUAL_PIXELS = 3e4;\n    this.CLIENT_WIDTH = 800;\n    this.CLIENT_HEIGHT = 600;\n    this.viewPort = new ViewPort();\n    this.mouse = new Mouse(this);\n    this.animations = [];\n    this.waits = [];\n    this.frameDuration = 0;\n    this.isReadyLock = false;\n    this.isFirstRender = true;\n    this.intervalId = null;\n    this.window = window2;\n    this.fetch = fetch2;\n  }\n  wait(checker) {\n    this.waits.push(checker);\n  }\n  ready() {\n    if (!this.readyPromise) {\n      return Promise.resolve();\n    }\n    return this.readyPromise;\n  }\n  isReady() {\n    if (this.isReadyLock) {\n      return true;\n    }\n    var isReadyLock = this.waits.every((_2) => _2());\n    if (isReadyLock) {\n      this.waits = [];\n      if (this.resolveReady) {\n        this.resolveReady();\n      }\n    }\n    this.isReadyLock = isReadyLock;\n    return isReadyLock;\n  }\n  setDefaults(ctx) {\n    ctx.strokeStyle = \"rgba(0,0,0,0)\";\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 4;\n  }\n  setViewBox(_ref2) {\n    var {\n      document: document2,\n      ctx,\n      aspectRatio,\n      width,\n      desiredWidth,\n      height,\n      desiredHeight,\n      minX = 0,\n      minY = 0,\n      refX,\n      refY,\n      clip = false,\n      clipX = 0,\n      clipY = 0\n    } = _ref2;\n    var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, \"\");\n    var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(\" \");\n    var align = aspectRatioAlign || \"xMidYMid\";\n    var meetOrSlice = aspectRatioMeetOrSlice || \"meet\";\n    var scaleX = width / desiredWidth;\n    var scaleY = height / desiredHeight;\n    var scaleMin = Math.min(scaleX, scaleY);\n    var scaleMax = Math.max(scaleX, scaleY);\n    var finalDesiredWidth = desiredWidth;\n    var finalDesiredHeight = desiredHeight;\n    if (meetOrSlice === \"meet\") {\n      finalDesiredWidth *= scaleMin;\n      finalDesiredHeight *= scaleMin;\n    }\n    if (meetOrSlice === \"slice\") {\n      finalDesiredWidth *= scaleMax;\n      finalDesiredHeight *= scaleMax;\n    }\n    var refXProp = new Property(document2, \"refX\", refX);\n    var refYProp = new Property(document2, \"refY\", refY);\n    var hasRefs = refXProp.hasValue() && refYProp.hasValue();\n    if (hasRefs) {\n      ctx.translate(-scaleMin * refXProp.getPixels(\"x\"), -scaleMin * refYProp.getPixels(\"y\"));\n    }\n    if (clip) {\n      var scaledClipX = scaleMin * clipX;\n      var scaledClipY = scaleMin * clipY;\n      ctx.beginPath();\n      ctx.moveTo(scaledClipX, scaledClipY);\n      ctx.lineTo(width, scaledClipY);\n      ctx.lineTo(width, height);\n      ctx.lineTo(scaledClipX, height);\n      ctx.closePath();\n      ctx.clip();\n    }\n    if (!hasRefs) {\n      var isMeetMinY = meetOrSlice === \"meet\" && scaleMin === scaleY;\n      var isSliceMaxY = meetOrSlice === \"slice\" && scaleMax === scaleY;\n      var isMeetMinX = meetOrSlice === \"meet\" && scaleMin === scaleX;\n      var isSliceMaxX = meetOrSlice === \"slice\" && scaleMax === scaleX;\n      if (align.startsWith(\"xMid\") && (isMeetMinY || isSliceMaxY)) {\n        ctx.translate(width / 2 - finalDesiredWidth / 2, 0);\n      }\n      if (align.endsWith(\"YMid\") && (isMeetMinX || isSliceMaxX)) {\n        ctx.translate(0, height / 2 - finalDesiredHeight / 2);\n      }\n      if (align.startsWith(\"xMax\") && (isMeetMinY || isSliceMaxY)) {\n        ctx.translate(width - finalDesiredWidth, 0);\n      }\n      if (align.endsWith(\"YMax\") && (isMeetMinX || isSliceMaxX)) {\n        ctx.translate(0, height - finalDesiredHeight);\n      }\n    }\n    switch (true) {\n      case align === \"none\":\n        ctx.scale(scaleX, scaleY);\n        break;\n      case meetOrSlice === \"meet\":\n        ctx.scale(scaleMin, scaleMin);\n        break;\n      case meetOrSlice === \"slice\":\n        ctx.scale(scaleMax, scaleMax);\n        break;\n    }\n    ctx.translate(-minX, -minY);\n  }\n  start(element) {\n    var {\n      enableRedraw = false,\n      ignoreMouse = false,\n      ignoreAnimation = false,\n      ignoreDimensions = false,\n      ignoreClear = false,\n      forceRedraw,\n      scaleWidth,\n      scaleHeight,\n      offsetX,\n      offsetY\n    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var {\n      FRAMERATE,\n      mouse\n    } = this;\n    var frameDuration = 1e3 / FRAMERATE;\n    this.frameDuration = frameDuration;\n    this.readyPromise = new Promise((resolve2) => {\n      this.resolveReady = resolve2;\n    });\n    if (this.isReady()) {\n      this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n    }\n    if (!enableRedraw) {\n      return;\n    }\n    var now2 = Date.now();\n    var then2 = now2;\n    var delta = 0;\n    var tick = () => {\n      now2 = Date.now();\n      delta = now2 - then2;\n      if (delta >= frameDuration) {\n        then2 = now2 - delta % frameDuration;\n        if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n          this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n          mouse.runEvents();\n        }\n      }\n      this.intervalId = requestAnimationFrame$1(tick);\n    };\n    if (!ignoreMouse) {\n      mouse.start();\n    }\n    this.intervalId = requestAnimationFrame$1(tick);\n  }\n  stop() {\n    if (this.intervalId) {\n      requestAnimationFrame$1.cancel(this.intervalId);\n      this.intervalId = null;\n    }\n    this.mouse.stop();\n  }\n  shouldUpdate(ignoreAnimation, forceRedraw) {\n    if (!ignoreAnimation) {\n      var {\n        frameDuration\n      } = this;\n      var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);\n      if (shouldUpdate) {\n        return true;\n      }\n    }\n    if (typeof forceRedraw === \"function\" && forceRedraw()) {\n      return true;\n    }\n    if (!this.isReadyLock && this.isReady()) {\n      return true;\n    }\n    if (this.mouse.hasEvents()) {\n      return true;\n    }\n    return false;\n  }\n  render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n    var {\n      CLIENT_WIDTH,\n      CLIENT_HEIGHT,\n      viewPort,\n      ctx,\n      isFirstRender\n    } = this;\n    var canvas = ctx.canvas;\n    viewPort.clear();\n    if (canvas.width && canvas.height) {\n      viewPort.setCurrent(canvas.width, canvas.height);\n    } else {\n      viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);\n    }\n    var widthStyle = element.getStyle(\"width\");\n    var heightStyle = element.getStyle(\"height\");\n    if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== \"number\" && typeof scaleHeight !== \"number\")) {\n      if (widthStyle.hasValue()) {\n        canvas.width = widthStyle.getPixels(\"x\");\n        if (canvas.style) {\n          canvas.style.width = \"\".concat(canvas.width, \"px\");\n        }\n      }\n      if (heightStyle.hasValue()) {\n        canvas.height = heightStyle.getPixels(\"y\");\n        if (canvas.style) {\n          canvas.style.height = \"\".concat(canvas.height, \"px\");\n        }\n      }\n    }\n    var cWidth = canvas.clientWidth || canvas.width;\n    var cHeight = canvas.clientHeight || canvas.height;\n    if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n      cWidth = widthStyle.getPixels(\"x\");\n      cHeight = heightStyle.getPixels(\"y\");\n    }\n    viewPort.setCurrent(cWidth, cHeight);\n    if (typeof offsetX === \"number\") {\n      element.getAttribute(\"x\", true).setValue(offsetX);\n    }\n    if (typeof offsetY === \"number\") {\n      element.getAttribute(\"y\", true).setValue(offsetY);\n    }\n    if (typeof scaleWidth === \"number\" || typeof scaleHeight === \"number\") {\n      var viewBox = toNumbers(element.getAttribute(\"viewBox\").getString());\n      var xRatio = 0;\n      var yRatio = 0;\n      if (typeof scaleWidth === \"number\") {\n        var _widthStyle = element.getStyle(\"width\");\n        if (_widthStyle.hasValue()) {\n          xRatio = _widthStyle.getPixels(\"x\") / scaleWidth;\n        } else if (!isNaN(viewBox[2])) {\n          xRatio = viewBox[2] / scaleWidth;\n        }\n      }\n      if (typeof scaleHeight === \"number\") {\n        var _heightStyle = element.getStyle(\"height\");\n        if (_heightStyle.hasValue()) {\n          yRatio = _heightStyle.getPixels(\"y\") / scaleHeight;\n        } else if (!isNaN(viewBox[3])) {\n          yRatio = viewBox[3] / scaleHeight;\n        }\n      }\n      if (!xRatio) {\n        xRatio = yRatio;\n      }\n      if (!yRatio) {\n        yRatio = xRatio;\n      }\n      element.getAttribute(\"width\", true).setValue(scaleWidth);\n      element.getAttribute(\"height\", true).setValue(scaleHeight);\n      var transformStyle = element.getStyle(\"transform\", true, true);\n      transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1 / xRatio, \", \").concat(1 / yRatio, \")\"));\n    }\n    if (!ignoreClear) {\n      ctx.clearRect(0, 0, cWidth, cHeight);\n    }\n    element.render(ctx);\n    if (isFirstRender) {\n      this.isFirstRender = false;\n    }\n  }\n}\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nvar {\n  defaultFetch\n} = Screen;\nvar DefaultDOMParser = typeof DOMParser !== \"undefined\" ? DOMParser : null;\nclass Parser {\n  constructor() {\n    var {\n      fetch: fetch2 = defaultFetch,\n      DOMParser: DOMParser2 = DefaultDOMParser\n    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.fetch = fetch2;\n    this.DOMParser = DOMParser2;\n  }\n  parse(resource) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (resource.startsWith(\"<\")) {\n        return _this.parseFromString(resource);\n      }\n      return _this.load(resource);\n    })();\n  }\n  parseFromString(xml2) {\n    var parser = new this.DOMParser();\n    try {\n      return this.checkDocument(parser.parseFromString(xml2, \"image/svg+xml\"));\n    } catch (err) {\n      return this.checkDocument(parser.parseFromString(xml2, \"text/xml\"));\n    }\n  }\n  checkDocument(document2) {\n    var parserError = document2.getElementsByTagName(\"parsererror\")[0];\n    if (parserError) {\n      throw new Error(parserError.textContent);\n    }\n    return document2;\n  }\n  load(url) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var response = yield _this2.fetch(url);\n      var xml2 = yield response.text();\n      return _this2.parseFromString(xml2);\n    })();\n  }\n}\nclass Translate {\n  constructor(_2, point) {\n    this.type = \"translate\";\n    this.point = null;\n    this.point = Point.parse(point);\n  }\n  apply(ctx) {\n    var {\n      x: x2,\n      y: y2\n    } = this.point;\n    ctx.translate(x2 || 0, y2 || 0);\n  }\n  unapply(ctx) {\n    var {\n      x: x2,\n      y: y2\n    } = this.point;\n    ctx.translate(-1 * x2 || 0, -1 * y2 || 0);\n  }\n  applyToPoint(point) {\n    var {\n      x: x2,\n      y: y2\n    } = this.point;\n    point.applyTransform([1, 0, 0, 1, x2 || 0, y2 || 0]);\n  }\n}\nclass Rotate {\n  constructor(document2, rotate2, transformOrigin2) {\n    this.type = \"rotate\";\n    this.angle = null;\n    this.originX = null;\n    this.originY = null;\n    this.cx = 0;\n    this.cy = 0;\n    var numbers = toNumbers(rotate2);\n    this.angle = new Property(document2, \"angle\", numbers[0]);\n    this.originX = transformOrigin2[0];\n    this.originY = transformOrigin2[1];\n    this.cx = numbers[1] || 0;\n    this.cy = numbers[2] || 0;\n  }\n  apply(ctx) {\n    var {\n      cx,\n      cy,\n      originX,\n      originY,\n      angle: angle2\n    } = this;\n    var tx = cx + originX.getPixels(\"x\");\n    var ty = cy + originY.getPixels(\"y\");\n    ctx.translate(tx, ty);\n    ctx.rotate(angle2.getRadians());\n    ctx.translate(-tx, -ty);\n  }\n  unapply(ctx) {\n    var {\n      cx,\n      cy,\n      originX,\n      originY,\n      angle: angle2\n    } = this;\n    var tx = cx + originX.getPixels(\"x\");\n    var ty = cy + originY.getPixels(\"y\");\n    ctx.translate(tx, ty);\n    ctx.rotate(-1 * angle2.getRadians());\n    ctx.translate(-tx, -ty);\n  }\n  applyToPoint(point) {\n    var {\n      cx,\n      cy,\n      angle: angle2\n    } = this;\n    var rad = angle2.getRadians();\n    point.applyTransform([\n      1,\n      0,\n      0,\n      1,\n      cx || 0,\n      cy || 0\n    ]);\n    point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);\n    point.applyTransform([\n      1,\n      0,\n      0,\n      1,\n      -cx || 0,\n      -cy || 0\n    ]);\n  }\n}\nclass Scale {\n  constructor(_2, scale2, transformOrigin2) {\n    this.type = \"scale\";\n    this.scale = null;\n    this.originX = null;\n    this.originY = null;\n    var scaleSize = Point.parseScale(scale2);\n    if (scaleSize.x === 0 || scaleSize.y === 0) {\n      scaleSize.x = PSEUDO_ZERO;\n      scaleSize.y = PSEUDO_ZERO;\n    }\n    this.scale = scaleSize;\n    this.originX = transformOrigin2[0];\n    this.originY = transformOrigin2[1];\n  }\n  apply(ctx) {\n    var {\n      scale: {\n        x: x2,\n        y: y2\n      },\n      originX,\n      originY\n    } = this;\n    var tx = originX.getPixels(\"x\");\n    var ty = originY.getPixels(\"y\");\n    ctx.translate(tx, ty);\n    ctx.scale(x2, y2 || x2);\n    ctx.translate(-tx, -ty);\n  }\n  unapply(ctx) {\n    var {\n      scale: {\n        x: x2,\n        y: y2\n      },\n      originX,\n      originY\n    } = this;\n    var tx = originX.getPixels(\"x\");\n    var ty = originY.getPixels(\"y\");\n    ctx.translate(tx, ty);\n    ctx.scale(1 / x2, 1 / y2 || x2);\n    ctx.translate(-tx, -ty);\n  }\n  applyToPoint(point) {\n    var {\n      x: x2,\n      y: y2\n    } = this.scale;\n    point.applyTransform([x2 || 0, 0, 0, y2 || 0, 0, 0]);\n  }\n}\nclass Matrix {\n  constructor(_2, matrix2, transformOrigin2) {\n    this.type = \"matrix\";\n    this.matrix = [];\n    this.originX = null;\n    this.originY = null;\n    this.matrix = toNumbers(matrix2);\n    this.originX = transformOrigin2[0];\n    this.originY = transformOrigin2[1];\n  }\n  apply(ctx) {\n    var {\n      originX,\n      originY,\n      matrix: matrix2\n    } = this;\n    var tx = originX.getPixels(\"x\");\n    var ty = originY.getPixels(\"y\");\n    ctx.translate(tx, ty);\n    ctx.transform(matrix2[0], matrix2[1], matrix2[2], matrix2[3], matrix2[4], matrix2[5]);\n    ctx.translate(-tx, -ty);\n  }\n  unapply(ctx) {\n    var {\n      originX,\n      originY,\n      matrix: matrix2\n    } = this;\n    var a2 = matrix2[0];\n    var b2 = matrix2[2];\n    var c2 = matrix2[4];\n    var d2 = matrix2[1];\n    var e2 = matrix2[3];\n    var f2 = matrix2[5];\n    var g2 = 0;\n    var h2 = 0;\n    var i2 = 1;\n    var det = 1 / (a2 * (e2 * i2 - f2 * h2) - b2 * (d2 * i2 - f2 * g2) + c2 * (d2 * h2 - e2 * g2));\n    var tx = originX.getPixels(\"x\");\n    var ty = originY.getPixels(\"y\");\n    ctx.translate(tx, ty);\n    ctx.transform(det * (e2 * i2 - f2 * h2), det * (f2 * g2 - d2 * i2), det * (c2 * h2 - b2 * i2), det * (a2 * i2 - c2 * g2), det * (b2 * f2 - c2 * e2), det * (c2 * d2 - a2 * f2));\n    ctx.translate(-tx, -ty);\n  }\n  applyToPoint(point) {\n    point.applyTransform(this.matrix);\n  }\n}\nclass Skew extends Matrix {\n  constructor(document2, skew, transformOrigin2) {\n    super(document2, skew, transformOrigin2);\n    this.type = \"skew\";\n    this.angle = null;\n    this.angle = new Property(document2, \"angle\", skew);\n  }\n}\nclass SkewX extends Skew {\n  constructor(document2, skew, transformOrigin2) {\n    super(document2, skew, transformOrigin2);\n    this.type = \"skewX\";\n    this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];\n  }\n}\nclass SkewY extends Skew {\n  constructor(document2, skew, transformOrigin2) {\n    super(document2, skew, transformOrigin2);\n    this.type = \"skewY\";\n    this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];\n  }\n}\nfunction parseTransforms(transform2) {\n  return compressSpaces(transform2).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform2) {\n  var [type, value] = transform2.split(\"(\");\n  return [type.trim(), value.trim().replace(\")\", \"\")];\n}\nclass Transform {\n  constructor(document2, transform2, transformOrigin2) {\n    this.document = document2;\n    this.transforms = [];\n    var data2 = parseTransforms(transform2);\n    data2.forEach((transform3) => {\n      if (transform3 === \"none\") {\n        return;\n      }\n      var [type, value] = parseTransform(transform3);\n      var TransformType = Transform.transformTypes[type];\n      if (typeof TransformType !== \"undefined\") {\n        this.transforms.push(new TransformType(this.document, value, transformOrigin2));\n      }\n    });\n  }\n  static fromElement(document2, element) {\n    var transformStyle = element.getStyle(\"transform\", false, true);\n    var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle(\"transform-origin\", false, true).split();\n    var transformOrigin2 = [transformOriginXProperty, transformOriginYProperty];\n    if (transformStyle.hasValue()) {\n      return new Transform(document2, transformStyle.getString(), transformOrigin2);\n    }\n    return null;\n  }\n  apply(ctx) {\n    var {\n      transforms: transforms2\n    } = this;\n    var len = transforms2.length;\n    for (var i2 = 0; i2 < len; i2++) {\n      transforms2[i2].apply(ctx);\n    }\n  }\n  unapply(ctx) {\n    var {\n      transforms: transforms2\n    } = this;\n    var len = transforms2.length;\n    for (var i2 = len - 1; i2 >= 0; i2--) {\n      transforms2[i2].unapply(ctx);\n    }\n  }\n  applyToPoint(point) {\n    var {\n      transforms: transforms2\n    } = this;\n    var len = transforms2.length;\n    for (var i2 = 0; i2 < len; i2++) {\n      transforms2[i2].applyToPoint(point);\n    }\n  }\n}\nTransform.transformTypes = {\n  translate: Translate,\n  rotate: Rotate,\n  scale: Scale,\n  matrix: Matrix,\n  skewX: SkewX,\n  skewY: SkewY\n};\nclass Element$1 {\n  constructor(document2, node2) {\n    var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    this.document = document2;\n    this.node = node2;\n    this.captureTextNodes = captureTextNodes;\n    this.attributes = {};\n    this.styles = {};\n    this.stylesSpecificity = {};\n    this.animationFrozen = false;\n    this.animationFrozenValue = \"\";\n    this.parent = null;\n    this.children = [];\n    if (!node2 || node2.nodeType !== 1) {\n      return;\n    }\n    Array.from(node2.attributes).forEach((attribute) => {\n      var nodeName = normalizeAttributeName(attribute.nodeName);\n      this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);\n    });\n    this.addStylesFromStyleDefinition();\n    if (this.getAttribute(\"style\").hasValue()) {\n      var styles = this.getAttribute(\"style\").getString().split(\";\").map((_2) => _2.trim());\n      styles.forEach((style2) => {\n        if (!style2) {\n          return;\n        }\n        var [name, value] = style2.split(\":\").map((_2) => _2.trim());\n        this.styles[name] = new Property(document2, name, value);\n      });\n    }\n    var {\n      definitions\n    } = document2;\n    var id = this.getAttribute(\"id\");\n    if (id.hasValue()) {\n      if (!definitions[id.getString()]) {\n        definitions[id.getString()] = this;\n      }\n    }\n    Array.from(node2.childNodes).forEach((childNode) => {\n      if (childNode.nodeType === 1) {\n        this.addChild(childNode);\n      } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n        var textNode = document2.createTextNode(childNode);\n        if (textNode.getText().length > 0) {\n          this.addChild(textNode);\n        }\n      }\n    });\n  }\n  getAttribute(name) {\n    var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    var attr = this.attributes[name];\n    if (!attr && createIfNotExists) {\n      var _attr = new Property(this.document, name, \"\");\n      this.attributes[name] = _attr;\n      return _attr;\n    }\n    return attr || Property.empty(this.document);\n  }\n  getHrefAttribute() {\n    for (var key in this.attributes) {\n      if (key === \"href\" || key.endsWith(\":href\")) {\n        return this.attributes[key];\n      }\n    }\n    return Property.empty(this.document);\n  }\n  getStyle(name) {\n    var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    var style2 = this.styles[name];\n    if (style2) {\n      return style2;\n    }\n    var attr = this.getAttribute(name);\n    if (attr !== null && attr !== void 0 && attr.hasValue()) {\n      this.styles[name] = attr;\n      return attr;\n    }\n    if (!skipAncestors) {\n      var {\n        parent\n      } = this;\n      if (parent) {\n        var parentStyle = parent.getStyle(name);\n        if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {\n          return parentStyle;\n        }\n      }\n    }\n    if (createIfNotExists) {\n      var _style = new Property(this.document, name, \"\");\n      this.styles[name] = _style;\n      return _style;\n    }\n    return style2 || Property.empty(this.document);\n  }\n  render(ctx) {\n    if (this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\") {\n      return;\n    }\n    ctx.save();\n    if (this.getStyle(\"mask\").hasValue()) {\n      var mask = this.getStyle(\"mask\").getDefinition();\n      if (mask) {\n        this.applyEffects(ctx);\n        mask.apply(ctx, this);\n      }\n    } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n      var filter = this.getStyle(\"filter\").getDefinition();\n      if (filter) {\n        this.applyEffects(ctx);\n        filter.apply(ctx, this);\n      }\n    } else {\n      this.setContext(ctx);\n      this.renderChildren(ctx);\n      this.clearContext(ctx);\n    }\n    ctx.restore();\n  }\n  setContext(_2) {\n  }\n  applyEffects(ctx) {\n    var transform2 = Transform.fromElement(this.document, this);\n    if (transform2) {\n      transform2.apply(ctx);\n    }\n    var clipPathStyleProp = this.getStyle(\"clip-path\", false, true);\n    if (clipPathStyleProp.hasValue()) {\n      var clip = clipPathStyleProp.getDefinition();\n      if (clip) {\n        clip.apply(ctx);\n      }\n    }\n  }\n  clearContext(_2) {\n  }\n  renderChildren(ctx) {\n    this.children.forEach((child) => {\n      child.render(ctx);\n    });\n  }\n  addChild(childNode) {\n    var child = childNode instanceof Element$1 ? childNode : this.document.createElement(childNode);\n    child.parent = this;\n    if (!Element$1.ignoreChildTypes.includes(child.type)) {\n      this.children.push(child);\n    }\n  }\n  matchesSelector(selector) {\n    var {\n      node: node2\n    } = this;\n    if (typeof node2.matches === \"function\") {\n      return node2.matches(selector);\n    }\n    var styleClasses = node2.getAttribute(\"class\");\n    if (!styleClasses || styleClasses === \"\") {\n      return false;\n    }\n    return styleClasses.split(\" \").some((styleClass) => \".\".concat(styleClass) === selector);\n  }\n  addStylesFromStyleDefinition() {\n    var {\n      styles,\n      stylesSpecificity\n    } = this.document;\n    for (var selector in styles) {\n      if (!selector.startsWith(\"@\") && this.matchesSelector(selector)) {\n        var style2 = styles[selector];\n        var specificity = stylesSpecificity[selector];\n        if (style2) {\n          for (var name in style2) {\n            var existingSpecificity = this.stylesSpecificity[name];\n            if (typeof existingSpecificity === \"undefined\") {\n              existingSpecificity = \"000\";\n            }\n            if (specificity >= existingSpecificity) {\n              this.styles[name] = style2[name];\n              this.stylesSpecificity[name] = specificity;\n            }\n          }\n        }\n      }\n    }\n  }\n  removeStyles(element, ignoreStyles) {\n    var toRestore = ignoreStyles.reduce((toRestore2, name) => {\n      var styleProp = element.getStyle(name);\n      if (!styleProp.hasValue()) {\n        return toRestore2;\n      }\n      var value = styleProp.getString();\n      styleProp.setValue(\"\");\n      return [...toRestore2, [name, value]];\n    }, []);\n    return toRestore;\n  }\n  restoreStyles(element, styles) {\n    styles.forEach((_ref2) => {\n      var [name, value] = _ref2;\n      element.getStyle(name, true).setValue(value);\n    });\n  }\n}\nElement$1.ignoreChildTypes = [\"title\"];\nclass UnknownElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n  }\n}\nfunction wrapFontFamily(fontFamily2) {\n  var trimmed = fontFamily2.trim();\n  return /^('|\")/.test(trimmed) ? trimmed : '\"'.concat(trimmed, '\"');\n}\nfunction prepareFontFamily(fontFamily2) {\n  return typeof process === \"undefined\" ? fontFamily2 : fontFamily2.trim().split(\",\").map(wrapFontFamily).join(\",\");\n}\nfunction prepareFontStyle(fontStyle2) {\n  if (!fontStyle2) {\n    return \"\";\n  }\n  var targetFontStyle = fontStyle2.trim().toLowerCase();\n  switch (targetFontStyle) {\n    case \"normal\":\n    case \"italic\":\n    case \"oblique\":\n    case \"inherit\":\n    case \"initial\":\n    case \"unset\":\n      return targetFontStyle;\n    default:\n      if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n        return targetFontStyle;\n      }\n      return \"\";\n  }\n}\nfunction prepareFontWeight(fontWeight2) {\n  if (!fontWeight2) {\n    return \"\";\n  }\n  var targetFontWeight = fontWeight2.trim().toLowerCase();\n  switch (targetFontWeight) {\n    case \"normal\":\n    case \"bold\":\n    case \"lighter\":\n    case \"bolder\":\n    case \"inherit\":\n    case \"initial\":\n    case \"unset\":\n      return targetFontWeight;\n    default:\n      if (/^[\\d.]+$/.test(targetFontWeight)) {\n        return targetFontWeight;\n      }\n      return \"\";\n  }\n}\nclass Font {\n  constructor(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit) {\n    var inheritFont = inherit ? typeof inherit === \"string\" ? Font.parse(inherit) : inherit : {};\n    this.fontFamily = fontFamily2 || inheritFont.fontFamily;\n    this.fontSize = fontSize2 || inheritFont.fontSize;\n    this.fontStyle = fontStyle2 || inheritFont.fontStyle;\n    this.fontWeight = fontWeight2 || inheritFont.fontWeight;\n    this.fontVariant = fontVariant2 || inheritFont.fontVariant;\n  }\n  static parse() {\n    var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    var inherit = arguments.length > 1 ? arguments[1] : void 0;\n    var fontStyle2 = \"\";\n    var fontVariant2 = \"\";\n    var fontWeight2 = \"\";\n    var fontSize2 = \"\";\n    var fontFamily2 = \"\";\n    var parts = compressSpaces(font).trim().split(\" \");\n    var set2 = {\n      fontSize: false,\n      fontStyle: false,\n      fontWeight: false,\n      fontVariant: false\n    };\n    parts.forEach((part) => {\n      switch (true) {\n        case (!set2.fontStyle && Font.styles.includes(part)):\n          if (part !== \"inherit\") {\n            fontStyle2 = part;\n          }\n          set2.fontStyle = true;\n          break;\n        case (!set2.fontVariant && Font.variants.includes(part)):\n          if (part !== \"inherit\") {\n            fontVariant2 = part;\n          }\n          set2.fontStyle = true;\n          set2.fontVariant = true;\n          break;\n        case (!set2.fontWeight && Font.weights.includes(part)):\n          if (part !== \"inherit\") {\n            fontWeight2 = part;\n          }\n          set2.fontStyle = true;\n          set2.fontVariant = true;\n          set2.fontWeight = true;\n          break;\n        case !set2.fontSize:\n          if (part !== \"inherit\") {\n            [fontSize2] = part.split(\"/\");\n          }\n          set2.fontStyle = true;\n          set2.fontVariant = true;\n          set2.fontWeight = true;\n          set2.fontSize = true;\n          break;\n        default:\n          if (part !== \"inherit\") {\n            fontFamily2 += part;\n          }\n      }\n    });\n    return new Font(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit);\n  }\n  toString() {\n    return [\n      prepareFontStyle(this.fontStyle),\n      this.fontVariant,\n      prepareFontWeight(this.fontWeight),\n      this.fontSize,\n      prepareFontFamily(this.fontFamily)\n    ].join(\" \").trim();\n  }\n}\nFont.styles = \"normal|italic|oblique|inherit\";\nFont.variants = \"normal|small-caps|inherit\";\nFont.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\nclass BoundingBox {\n  constructor() {\n    var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;\n    var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;\n    var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;\n    var y2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.addPoint(x1, y1);\n    this.addPoint(x2, y2);\n  }\n  get x() {\n    return this.x1;\n  }\n  get y() {\n    return this.y1;\n  }\n  get width() {\n    return this.x2 - this.x1;\n  }\n  get height() {\n    return this.y2 - this.y1;\n  }\n  addPoint(x2, y2) {\n    if (typeof x2 !== \"undefined\") {\n      if (isNaN(this.x1) || isNaN(this.x2)) {\n        this.x1 = x2;\n        this.x2 = x2;\n      }\n      if (x2 < this.x1) {\n        this.x1 = x2;\n      }\n      if (x2 > this.x2) {\n        this.x2 = x2;\n      }\n    }\n    if (typeof y2 !== \"undefined\") {\n      if (isNaN(this.y1) || isNaN(this.y2)) {\n        this.y1 = y2;\n        this.y2 = y2;\n      }\n      if (y2 < this.y1) {\n        this.y1 = y2;\n      }\n      if (y2 > this.y2) {\n        this.y2 = y2;\n      }\n    }\n  }\n  addX(x2) {\n    this.addPoint(x2, null);\n  }\n  addY(y2) {\n    this.addPoint(null, y2);\n  }\n  addBoundingBox(boundingBox) {\n    if (!boundingBox) {\n      return;\n    }\n    var {\n      x1,\n      y1,\n      x2,\n      y2\n    } = boundingBox;\n    this.addPoint(x1, y1);\n    this.addPoint(x2, y2);\n  }\n  sumCubic(t3, p0, p12, p22, p32) {\n    return Math.pow(1 - t3, 3) * p0 + 3 * Math.pow(1 - t3, 2) * t3 * p12 + 3 * (1 - t3) * Math.pow(t3, 2) * p22 + Math.pow(t3, 3) * p32;\n  }\n  bezierCurveAdd(forX, p0, p12, p22, p32) {\n    var b2 = 6 * p0 - 12 * p12 + 6 * p22;\n    var a2 = -3 * p0 + 9 * p12 - 9 * p22 + 3 * p32;\n    var c2 = 3 * p12 - 3 * p0;\n    if (a2 === 0) {\n      if (b2 === 0) {\n        return;\n      }\n      var t3 = -c2 / b2;\n      if (0 < t3 && t3 < 1) {\n        if (forX) {\n          this.addX(this.sumCubic(t3, p0, p12, p22, p32));\n        } else {\n          this.addY(this.sumCubic(t3, p0, p12, p22, p32));\n        }\n      }\n      return;\n    }\n    var b2ac = Math.pow(b2, 2) - 4 * c2 * a2;\n    if (b2ac < 0) {\n      return;\n    }\n    var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a2);\n    if (0 < t1 && t1 < 1) {\n      if (forX) {\n        this.addX(this.sumCubic(t1, p0, p12, p22, p32));\n      } else {\n        this.addY(this.sumCubic(t1, p0, p12, p22, p32));\n      }\n    }\n    var t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a2);\n    if (0 < t22 && t22 < 1) {\n      if (forX) {\n        this.addX(this.sumCubic(t22, p0, p12, p22, p32));\n      } else {\n        this.addY(this.sumCubic(t22, p0, p12, p22, p32));\n      }\n    }\n  }\n  addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n    this.addPoint(p0x, p0y);\n    this.addPoint(p3x, p3y);\n    this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n    this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n  }\n  addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n    var cp1x = p0x + 2 / 3 * (p1x - p0x);\n    var cp1y = p0y + 2 / 3 * (p1y - p0y);\n    var cp2x = cp1x + 1 / 3 * (p2x - p0x);\n    var cp2y = cp1y + 1 / 3 * (p2y - p0y);\n    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n  }\n  isPointInBox(x2, y2) {\n    var {\n      x1,\n      y1,\n      x2: x22,\n      y2: y22\n    } = this;\n    return x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;\n  }\n}\nclass PathParser extends _ {\n  constructor(path) {\n    super(path.replace(/([+\\-.])\\s+/gm, \"$1\").replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\"));\n    this.control = null;\n    this.start = null;\n    this.current = null;\n    this.command = null;\n    this.commands = this.commands;\n    this.i = -1;\n    this.previousCommand = null;\n    this.points = [];\n    this.angles = [];\n  }\n  reset() {\n    this.i = -1;\n    this.command = null;\n    this.previousCommand = null;\n    this.start = new Point(0, 0);\n    this.control = new Point(0, 0);\n    this.current = new Point(0, 0);\n    this.points = [];\n    this.angles = [];\n  }\n  isEnd() {\n    var {\n      i: i2,\n      commands\n    } = this;\n    return i2 >= commands.length - 1;\n  }\n  next() {\n    var command = this.commands[++this.i];\n    this.previousCommand = this.command;\n    this.command = command;\n    return command;\n  }\n  getPoint() {\n    var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"x\";\n    var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"y\";\n    var point = new Point(this.command[xProp], this.command[yProp]);\n    return this.makeAbsolute(point);\n  }\n  getAsControlPoint(xProp, yProp) {\n    var point = this.getPoint(xProp, yProp);\n    this.control = point;\n    return point;\n  }\n  getAsCurrentPoint(xProp, yProp) {\n    var point = this.getPoint(xProp, yProp);\n    this.current = point;\n    return point;\n  }\n  getReflectedControlPoint() {\n    var previousCommand = this.previousCommand.type;\n    if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {\n      return this.current;\n    }\n    var {\n      current: {\n        x: cx,\n        y: cy\n      },\n      control: {\n        x: ox,\n        y: oy\n      }\n    } = this;\n    var point = new Point(2 * cx - ox, 2 * cy - oy);\n    return point;\n  }\n  makeAbsolute(point) {\n    if (this.command.relative) {\n      var {\n        x: x2,\n        y: y2\n      } = this.current;\n      point.x += x2;\n      point.y += y2;\n    }\n    return point;\n  }\n  addMarker(point, from, priorTo) {\n    var {\n      points,\n      angles\n    } = this;\n    if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n      angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n    }\n    this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n  }\n  addMarkerAngle(point, angle2) {\n    this.points.push(point);\n    this.angles.push(angle2);\n  }\n  getMarkerPoints() {\n    return this.points;\n  }\n  getMarkerAngles() {\n    var {\n      angles\n    } = this;\n    var len = angles.length;\n    for (var i2 = 0; i2 < len; i2++) {\n      if (!angles[i2]) {\n        for (var j2 = i2 + 1; j2 < len; j2++) {\n          if (angles[j2]) {\n            angles[i2] = angles[j2];\n            break;\n          }\n        }\n      }\n    }\n    return angles;\n  }\n}\nclass RenderedElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.modifiedEmSizeStack = false;\n  }\n  calculateOpacity() {\n    var opacity2 = 1;\n    var element = this;\n    while (element) {\n      var opacityStyle = element.getStyle(\"opacity\", false, true);\n      if (opacityStyle.hasValue(true)) {\n        opacity2 *= opacityStyle.getNumber();\n      }\n      element = element.parent;\n    }\n    return opacity2;\n  }\n  setContext(ctx) {\n    var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    if (!fromMeasure) {\n      var fillStyleProp = this.getStyle(\"fill\");\n      var fillOpacityStyleProp = this.getStyle(\"fill-opacity\");\n      var strokeStyleProp = this.getStyle(\"stroke\");\n      var strokeOpacityProp = this.getStyle(\"stroke-opacity\");\n      if (fillStyleProp.isUrlDefinition()) {\n        var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n        if (fillStyle) {\n          ctx.fillStyle = fillStyle;\n        }\n      } else if (fillStyleProp.hasValue()) {\n        if (fillStyleProp.getString() === \"currentColor\") {\n          fillStyleProp.setValue(this.getStyle(\"color\").getColor());\n        }\n        var _fillStyle = fillStyleProp.getColor();\n        if (_fillStyle !== \"inherit\") {\n          ctx.fillStyle = _fillStyle === \"none\" ? \"rgba(0,0,0,0)\" : _fillStyle;\n        }\n      }\n      if (fillOpacityStyleProp.hasValue()) {\n        var _fillStyle2 = new Property(this.document, \"fill\", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n        ctx.fillStyle = _fillStyle2;\n      }\n      if (strokeStyleProp.isUrlDefinition()) {\n        var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n        if (strokeStyle) {\n          ctx.strokeStyle = strokeStyle;\n        }\n      } else if (strokeStyleProp.hasValue()) {\n        if (strokeStyleProp.getString() === \"currentColor\") {\n          strokeStyleProp.setValue(this.getStyle(\"color\").getColor());\n        }\n        var _strokeStyle = strokeStyleProp.getString();\n        if (_strokeStyle !== \"inherit\") {\n          ctx.strokeStyle = _strokeStyle === \"none\" ? \"rgba(0,0,0,0)\" : _strokeStyle;\n        }\n      }\n      if (strokeOpacityProp.hasValue()) {\n        var _strokeStyle2 = new Property(this.document, \"stroke\", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n        ctx.strokeStyle = _strokeStyle2;\n      }\n      var strokeWidthStyleProp = this.getStyle(\"stroke-width\");\n      if (strokeWidthStyleProp.hasValue()) {\n        var newLineWidth = strokeWidthStyleProp.getPixels();\n        ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;\n      }\n      var strokeLinecapStyleProp = this.getStyle(\"stroke-linecap\");\n      var strokeLinejoinStyleProp = this.getStyle(\"stroke-linejoin\");\n      var strokeMiterlimitProp = this.getStyle(\"stroke-miterlimit\");\n      var strokeDasharrayStyleProp = this.getStyle(\"stroke-dasharray\");\n      var strokeDashoffsetProp = this.getStyle(\"stroke-dashoffset\");\n      if (strokeLinecapStyleProp.hasValue()) {\n        ctx.lineCap = strokeLinecapStyleProp.getString();\n      }\n      if (strokeLinejoinStyleProp.hasValue()) {\n        ctx.lineJoin = strokeLinejoinStyleProp.getString();\n      }\n      if (strokeMiterlimitProp.hasValue()) {\n        ctx.miterLimit = strokeMiterlimitProp.getNumber();\n      }\n      if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== \"none\") {\n        var gaps = toNumbers(strokeDasharrayStyleProp.getString());\n        if (typeof ctx.setLineDash !== \"undefined\") {\n          ctx.setLineDash(gaps);\n        } else if (typeof ctx.webkitLineDash !== \"undefined\") {\n          ctx.webkitLineDash = gaps;\n        } else if (typeof ctx.mozDash !== \"undefined\" && !(gaps.length === 1 && gaps[0] === 0)) {\n          ctx.mozDash = gaps;\n        }\n        var offset2 = strokeDashoffsetProp.getPixels();\n        if (typeof ctx.lineDashOffset !== \"undefined\") {\n          ctx.lineDashOffset = offset2;\n        } else if (typeof ctx.webkitLineDashOffset !== \"undefined\") {\n          ctx.webkitLineDashOffset = offset2;\n        } else if (typeof ctx.mozDashOffset !== \"undefined\") {\n          ctx.mozDashOffset = offset2;\n        }\n      }\n    }\n    this.modifiedEmSizeStack = false;\n    if (typeof ctx.font !== \"undefined\") {\n      var fontStyleProp = this.getStyle(\"font\");\n      var fontStyleStyleProp = this.getStyle(\"font-style\");\n      var fontVariantStyleProp = this.getStyle(\"font-variant\");\n      var fontWeightStyleProp = this.getStyle(\"font-weight\");\n      var fontSizeStyleProp = this.getStyle(\"font-size\");\n      var fontFamilyStyleProp = this.getStyle(\"font-family\");\n      var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : \"\", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n      fontStyleStyleProp.setValue(font.fontStyle);\n      fontVariantStyleProp.setValue(font.fontVariant);\n      fontWeightStyleProp.setValue(font.fontWeight);\n      fontSizeStyleProp.setValue(font.fontSize);\n      fontFamilyStyleProp.setValue(font.fontFamily);\n      ctx.font = font.toString();\n      if (fontSizeStyleProp.isPixels()) {\n        this.document.emSize = fontSizeStyleProp.getPixels();\n        this.modifiedEmSizeStack = true;\n      }\n    }\n    if (!fromMeasure) {\n      this.applyEffects(ctx);\n      ctx.globalAlpha = this.calculateOpacity();\n    }\n  }\n  clearContext(ctx) {\n    super.clearContext(ctx);\n    if (this.modifiedEmSizeStack) {\n      this.document.popEmSize();\n    }\n  }\n}\nclass PathElement extends RenderedElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"path\";\n    this.pathParser = null;\n    this.pathParser = new PathParser(this.getAttribute(\"d\").getString());\n  }\n  path(ctx) {\n    var {\n      pathParser\n    } = this;\n    var boundingBox = new BoundingBox();\n    pathParser.reset();\n    if (ctx) {\n      ctx.beginPath();\n    }\n    while (!pathParser.isEnd()) {\n      switch (pathParser.next().type) {\n        case PathParser.MOVE_TO:\n          this.pathM(ctx, boundingBox);\n          break;\n        case PathParser.LINE_TO:\n          this.pathL(ctx, boundingBox);\n          break;\n        case PathParser.HORIZ_LINE_TO:\n          this.pathH(ctx, boundingBox);\n          break;\n        case PathParser.VERT_LINE_TO:\n          this.pathV(ctx, boundingBox);\n          break;\n        case PathParser.CURVE_TO:\n          this.pathC(ctx, boundingBox);\n          break;\n        case PathParser.SMOOTH_CURVE_TO:\n          this.pathS(ctx, boundingBox);\n          break;\n        case PathParser.QUAD_TO:\n          this.pathQ(ctx, boundingBox);\n          break;\n        case PathParser.SMOOTH_QUAD_TO:\n          this.pathT(ctx, boundingBox);\n          break;\n        case PathParser.ARC:\n          this.pathA(ctx, boundingBox);\n          break;\n        case PathParser.CLOSE_PATH:\n          this.pathZ(ctx, boundingBox);\n          break;\n      }\n    }\n    return boundingBox;\n  }\n  getBoundingBox(_2) {\n    return this.path();\n  }\n  getMarkers() {\n    var {\n      pathParser\n    } = this;\n    var points = pathParser.getMarkerPoints();\n    var angles = pathParser.getMarkerAngles();\n    var markers = points.map((point, i2) => [point, angles[i2]]);\n    return markers;\n  }\n  renderChildren(ctx) {\n    this.path(ctx);\n    this.document.screen.mouse.checkPath(this, ctx);\n    var fillRuleStyleProp = this.getStyle(\"fill-rule\");\n    if (ctx.fillStyle !== \"\") {\n      if (fillRuleStyleProp.getString(\"inherit\") !== \"inherit\") {\n        ctx.fill(fillRuleStyleProp.getString());\n      } else {\n        ctx.fill();\n      }\n    }\n    if (ctx.strokeStyle !== \"\") {\n      if (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\") {\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.stroke();\n        ctx.restore();\n      } else {\n        ctx.stroke();\n      }\n    }\n    var markers = this.getMarkers();\n    if (markers) {\n      var markersLastIndex = markers.length - 1;\n      var markerStartStyleProp = this.getStyle(\"marker-start\");\n      var markerMidStyleProp = this.getStyle(\"marker-mid\");\n      var markerEndStyleProp = this.getStyle(\"marker-end\");\n      if (markerStartStyleProp.isUrlDefinition()) {\n        var marker = markerStartStyleProp.getDefinition();\n        var [point, angle2] = markers[0];\n        marker.render(ctx, point, angle2);\n      }\n      if (markerMidStyleProp.isUrlDefinition()) {\n        var _marker = markerMidStyleProp.getDefinition();\n        for (var i2 = 1; i2 < markersLastIndex; i2++) {\n          var [_point, _angle] = markers[i2];\n          _marker.render(ctx, _point, _angle);\n        }\n      }\n      if (markerEndStyleProp.isUrlDefinition()) {\n        var _marker2 = markerEndStyleProp.getDefinition();\n        var [_point2, _angle2] = markers[markersLastIndex];\n        _marker2.render(ctx, _point2, _angle2);\n      }\n    }\n  }\n  static pathM(pathParser) {\n    var point = pathParser.getAsCurrentPoint();\n    pathParser.start = pathParser.current;\n    return {\n      point\n    };\n  }\n  pathM(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      point\n    } = PathElement.pathM(pathParser);\n    var {\n      x: x2,\n      y: y2\n    } = point;\n    pathParser.addMarker(point);\n    boundingBox.addPoint(x2, y2);\n    if (ctx) {\n      ctx.moveTo(x2, y2);\n    }\n  }\n  static pathL(pathParser) {\n    var {\n      current\n    } = pathParser;\n    var point = pathParser.getAsCurrentPoint();\n    return {\n      current,\n      point\n    };\n  }\n  pathL(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      current,\n      point\n    } = PathElement.pathL(pathParser);\n    var {\n      x: x2,\n      y: y2\n    } = point;\n    pathParser.addMarker(point, current);\n    boundingBox.addPoint(x2, y2);\n    if (ctx) {\n      ctx.lineTo(x2, y2);\n    }\n  }\n  static pathH(pathParser) {\n    var {\n      current,\n      command\n    } = pathParser;\n    var point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n    pathParser.current = point;\n    return {\n      current,\n      point\n    };\n  }\n  pathH(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      current,\n      point\n    } = PathElement.pathH(pathParser);\n    var {\n      x: x2,\n      y: y2\n    } = point;\n    pathParser.addMarker(point, current);\n    boundingBox.addPoint(x2, y2);\n    if (ctx) {\n      ctx.lineTo(x2, y2);\n    }\n  }\n  static pathV(pathParser) {\n    var {\n      current,\n      command\n    } = pathParser;\n    var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n    pathParser.current = point;\n    return {\n      current,\n      point\n    };\n  }\n  pathV(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      current,\n      point\n    } = PathElement.pathV(pathParser);\n    var {\n      x: x2,\n      y: y2\n    } = point;\n    pathParser.addMarker(point, current);\n    boundingBox.addPoint(x2, y2);\n    if (ctx) {\n      ctx.lineTo(x2, y2);\n    }\n  }\n  static pathC(pathParser) {\n    var {\n      current\n    } = pathParser;\n    var point = pathParser.getPoint(\"x1\", \"y1\");\n    var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n    var currentPoint = pathParser.getAsCurrentPoint();\n    return {\n      current,\n      point,\n      controlPoint,\n      currentPoint\n    };\n  }\n  pathC(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      current,\n      point,\n      controlPoint,\n      currentPoint\n    } = PathElement.pathC(pathParser);\n    pathParser.addMarker(currentPoint, controlPoint, point);\n    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    if (ctx) {\n      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n  }\n  static pathS(pathParser) {\n    var {\n      current\n    } = pathParser;\n    var point = pathParser.getReflectedControlPoint();\n    var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n    var currentPoint = pathParser.getAsCurrentPoint();\n    return {\n      current,\n      point,\n      controlPoint,\n      currentPoint\n    };\n  }\n  pathS(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      current,\n      point,\n      controlPoint,\n      currentPoint\n    } = PathElement.pathS(pathParser);\n    pathParser.addMarker(currentPoint, controlPoint, point);\n    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    if (ctx) {\n      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n  }\n  static pathQ(pathParser) {\n    var {\n      current\n    } = pathParser;\n    var controlPoint = pathParser.getAsControlPoint(\"x1\", \"y1\");\n    var currentPoint = pathParser.getAsCurrentPoint();\n    return {\n      current,\n      controlPoint,\n      currentPoint\n    };\n  }\n  pathQ(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      current,\n      controlPoint,\n      currentPoint\n    } = PathElement.pathQ(pathParser);\n    pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    if (ctx) {\n      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n  }\n  static pathT(pathParser) {\n    var {\n      current\n    } = pathParser;\n    var controlPoint = pathParser.getReflectedControlPoint();\n    pathParser.control = controlPoint;\n    var currentPoint = pathParser.getAsCurrentPoint();\n    return {\n      current,\n      controlPoint,\n      currentPoint\n    };\n  }\n  pathT(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      current,\n      controlPoint,\n      currentPoint\n    } = PathElement.pathT(pathParser);\n    pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    if (ctx) {\n      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n  }\n  static pathA(pathParser) {\n    var {\n      current,\n      command\n    } = pathParser;\n    var {\n      rX,\n      rY,\n      xRot,\n      lArcFlag,\n      sweepFlag\n    } = command;\n    var xAxisRotation = xRot * (Math.PI / 180);\n    var currentPoint = pathParser.getAsCurrentPoint();\n    var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);\n    var l2 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n    if (l2 > 1) {\n      rX *= Math.sqrt(l2);\n      rY *= Math.sqrt(l2);\n    }\n    var s2 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n    if (isNaN(s2)) {\n      s2 = 0;\n    }\n    var cpp = new Point(s2 * rX * currp.y / rY, s2 * -rY * currp.x / rX);\n    var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);\n    var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);\n    var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];\n    var v2 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];\n    var ad = vectorsAngle(u2, v2);\n    if (vectorsRatio(u2, v2) <= -1) {\n      ad = Math.PI;\n    }\n    if (vectorsRatio(u2, v2) >= 1) {\n      ad = 0;\n    }\n    return {\n      currentPoint,\n      rX,\n      rY,\n      sweepFlag,\n      xAxisRotation,\n      centp,\n      a1,\n      ad\n    };\n  }\n  pathA(ctx, boundingBox) {\n    var {\n      pathParser\n    } = this;\n    var {\n      currentPoint,\n      rX,\n      rY,\n      sweepFlag,\n      xAxisRotation,\n      centp,\n      a1,\n      ad\n    } = PathElement.pathA(pathParser);\n    var dir = 1 - sweepFlag ? 1 : -1;\n    var ah = a1 + dir * (ad / 2);\n    var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n    pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n    pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n    boundingBox.addPoint(currentPoint.x, currentPoint.y);\n    if (ctx && !isNaN(a1) && !isNaN(ad)) {\n      var r2 = rX > rY ? rX : rY;\n      var sx = rX > rY ? 1 : rX / rY;\n      var sy = rX > rY ? rY / rX : 1;\n      ctx.translate(centp.x, centp.y);\n      ctx.rotate(xAxisRotation);\n      ctx.scale(sx, sy);\n      ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));\n      ctx.scale(1 / sx, 1 / sy);\n      ctx.rotate(-xAxisRotation);\n      ctx.translate(-centp.x, -centp.y);\n    }\n  }\n  static pathZ(pathParser) {\n    pathParser.current = pathParser.start;\n  }\n  pathZ(ctx, boundingBox) {\n    PathElement.pathZ(this.pathParser);\n    if (ctx) {\n      if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n        ctx.closePath();\n      }\n    }\n  }\n}\nclass GlyphElement extends PathElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"glyph\";\n    this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n    this.unicode = this.getAttribute(\"unicode\").getString();\n    this.arabicForm = this.getAttribute(\"arabic-form\").getString();\n  }\n}\nclass TextElement extends RenderedElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, new.target === TextElement ? true : captureTextNodes);\n    this.type = \"text\";\n    this.x = 0;\n    this.y = 0;\n    this.measureCache = -1;\n  }\n  setContext(ctx) {\n    var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    super.setContext(ctx, fromMeasure);\n    var textBaseline = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n    if (textBaseline) {\n      ctx.textBaseline = textBaseline;\n    }\n  }\n  initializeCoordinates(ctx) {\n    this.x = this.getAttribute(\"x\").getPixels(\"x\");\n    this.y = this.getAttribute(\"y\").getPixels(\"y\");\n    var dxAttr = this.getAttribute(\"dx\");\n    var dyAttr = this.getAttribute(\"dy\");\n    if (dxAttr.hasValue()) {\n      this.x += dxAttr.getPixels(\"x\");\n    }\n    if (dyAttr.hasValue()) {\n      this.y += dyAttr.getPixels(\"y\");\n    }\n    this.x += this.getAnchorDelta(ctx, this, 0);\n  }\n  getBoundingBox(ctx) {\n    if (this.type !== \"text\") {\n      return this.getTElementBoundingBox(ctx);\n    }\n    this.initializeCoordinates(ctx);\n    var boundingBox = null;\n    this.children.forEach((_2, i2) => {\n      var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i2);\n      if (!boundingBox) {\n        boundingBox = childBoundingBox;\n      } else {\n        boundingBox.addBoundingBox(childBoundingBox);\n      }\n    });\n    return boundingBox;\n  }\n  getFontSize() {\n    var {\n      document: document2,\n      parent\n    } = this;\n    var inheritFontSize = Font.parse(document2.ctx.font).fontSize;\n    var fontSize2 = parent.getStyle(\"font-size\").getNumber(inheritFontSize);\n    return fontSize2;\n  }\n  getTElementBoundingBox(ctx) {\n    var fontSize2 = this.getFontSize();\n    return new BoundingBox(this.x, this.y - fontSize2, this.x + this.measureText(ctx), this.y);\n  }\n  getGlyph(font, text2, i2) {\n    var char = text2[i2];\n    var glyph = null;\n    if (font.isArabic) {\n      var len = text2.length;\n      var prevChar = text2[i2 - 1];\n      var nextChar = text2[i2 + 1];\n      var arabicForm = \"isolated\";\n      if ((i2 === 0 || prevChar === \" \") && i2 < len - 2 && nextChar !== \" \") {\n        arabicForm = \"terminal\";\n      }\n      if (i2 > 0 && prevChar !== \" \" && i2 < len - 2 && nextChar !== \" \") {\n        arabicForm = \"medial\";\n      }\n      if (i2 > 0 && prevChar !== \" \" && (i2 === len - 1 || nextChar === \" \")) {\n        arabicForm = \"initial\";\n      }\n      if (typeof font.glyphs[char] !== \"undefined\") {\n        var maybeGlyph = font.glyphs[char];\n        glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];\n      }\n    } else {\n      glyph = font.glyphs[char];\n    }\n    if (!glyph) {\n      glyph = font.missingGlyph;\n    }\n    return glyph;\n  }\n  getText() {\n    return \"\";\n  }\n  getTextFromNode(node2) {\n    var textNode = node2 || this.node;\n    var childNodes = Array.from(textNode.parentNode.childNodes);\n    var index2 = childNodes.indexOf(textNode);\n    var lastIndex = childNodes.length - 1;\n    var text2 = compressSpaces(textNode.textContent || \"\");\n    if (index2 === 0) {\n      text2 = trimLeft(text2);\n    }\n    if (index2 === lastIndex) {\n      text2 = trimRight(text2);\n    }\n    return text2;\n  }\n  renderChildren(ctx) {\n    if (this.type !== \"text\") {\n      this.renderTElementChildren(ctx);\n      return;\n    }\n    this.initializeCoordinates(ctx);\n    this.children.forEach((_2, i2) => {\n      this.renderChild(ctx, this, this, i2);\n    });\n    var {\n      mouse\n    } = this.document.screen;\n    if (mouse.isWorking()) {\n      mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n    }\n  }\n  renderTElementChildren(ctx) {\n    var {\n      document: document2,\n      parent\n    } = this;\n    var renderText = this.getText();\n    var customFont = parent.getStyle(\"font-family\").getDefinition();\n    if (customFont) {\n      var {\n        unitsPerEm\n      } = customFont.fontFace;\n      var ctxFont = Font.parse(document2.ctx.font);\n      var fontSize2 = parent.getStyle(\"font-size\").getNumber(ctxFont.fontSize);\n      var fontStyle2 = parent.getStyle(\"font-style\").getString(ctxFont.fontStyle);\n      var scale2 = fontSize2 / unitsPerEm;\n      var text2 = customFont.isRTL ? renderText.split(\"\").reverse().join(\"\") : renderText;\n      var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n      var len = text2.length;\n      for (var i2 = 0; i2 < len; i2++) {\n        var glyph = this.getGlyph(customFont, text2, i2);\n        ctx.translate(this.x, this.y);\n        ctx.scale(scale2, -scale2);\n        var lw = ctx.lineWidth;\n        ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize2;\n        if (fontStyle2 === \"italic\") {\n          ctx.transform(1, 0, 0.4, 1, 0, 0);\n        }\n        glyph.render(ctx);\n        if (fontStyle2 === \"italic\") {\n          ctx.transform(1, 0, -0.4, 1, 0, 0);\n        }\n        ctx.lineWidth = lw;\n        ctx.scale(1 / scale2, -1 / scale2);\n        ctx.translate(-this.x, -this.y);\n        this.x += fontSize2 * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n        if (typeof dx[i2] !== \"undefined\" && !isNaN(dx[i2])) {\n          this.x += dx[i2];\n        }\n      }\n      return;\n    }\n    var {\n      x: x2,\n      y: y2\n    } = this;\n    if (ctx.fillStyle) {\n      ctx.fillText(renderText, x2, y2);\n    }\n    if (ctx.strokeStyle) {\n      ctx.strokeText(renderText, x2, y2);\n    }\n  }\n  getAnchorDelta(ctx, parent, startI) {\n    var textAnchor = this.getStyle(\"text-anchor\").getString(\"start\");\n    if (textAnchor !== \"start\") {\n      var {\n        children\n      } = parent;\n      var len = children.length;\n      var child = null;\n      var width = 0;\n      for (var i2 = startI; i2 < len; i2++) {\n        child = children[i2];\n        if (i2 > startI && child.getAttribute(\"x\").hasValue() || child.getAttribute(\"text-anchor\").hasValue()) {\n          break;\n        }\n        width += child.measureTextRecursive(ctx);\n      }\n      return -1 * (textAnchor === \"end\" ? width : width / 2);\n    }\n    return 0;\n  }\n  adjustChildCoordinates(ctx, textParent, parent, i2) {\n    var child = parent.children[i2];\n    if (typeof child.measureText !== \"function\") {\n      return child;\n    }\n    ctx.save();\n    child.setContext(ctx, true);\n    var xAttr = child.getAttribute(\"x\");\n    var yAttr = child.getAttribute(\"y\");\n    var dxAttr = child.getAttribute(\"dx\");\n    var dyAttr = child.getAttribute(\"dy\");\n    var textAnchor = child.getAttribute(\"text-anchor\").getString(\"start\");\n    if (i2 === 0 && child.type !== \"textNode\") {\n      if (!xAttr.hasValue()) {\n        xAttr.setValue(textParent.getAttribute(\"x\").getValue(\"0\"));\n      }\n      if (!yAttr.hasValue()) {\n        yAttr.setValue(textParent.getAttribute(\"y\").getValue(\"0\"));\n      }\n      if (!dxAttr.hasValue()) {\n        dxAttr.setValue(textParent.getAttribute(\"dx\").getValue(\"0\"));\n      }\n      if (!dyAttr.hasValue()) {\n        dyAttr.setValue(textParent.getAttribute(\"dy\").getValue(\"0\"));\n      }\n    }\n    if (xAttr.hasValue()) {\n      child.x = xAttr.getPixels(\"x\") + textParent.getAnchorDelta(ctx, parent, i2);\n      if (textAnchor !== \"start\") {\n        var width = child.measureTextRecursive(ctx);\n        child.x += -1 * (textAnchor === \"end\" ? width : width / 2);\n      }\n      if (dxAttr.hasValue()) {\n        child.x += dxAttr.getPixels(\"x\");\n      }\n    } else {\n      if (textAnchor !== \"start\") {\n        var _width = child.measureTextRecursive(ctx);\n        textParent.x += -1 * (textAnchor === \"end\" ? _width : _width / 2);\n      }\n      if (dxAttr.hasValue()) {\n        textParent.x += dxAttr.getPixels(\"x\");\n      }\n      child.x = textParent.x;\n    }\n    textParent.x = child.x + child.measureText(ctx);\n    if (yAttr.hasValue()) {\n      child.y = yAttr.getPixels(\"y\");\n      if (dyAttr.hasValue()) {\n        child.y += dyAttr.getPixels(\"y\");\n      }\n    } else {\n      if (dyAttr.hasValue()) {\n        textParent.y += dyAttr.getPixels(\"y\");\n      }\n      child.y = textParent.y;\n    }\n    textParent.y = child.y;\n    child.clearContext(ctx);\n    ctx.restore();\n    return child;\n  }\n  getChildBoundingBox(ctx, textParent, parent, i2) {\n    var child = this.adjustChildCoordinates(ctx, textParent, parent, i2);\n    if (typeof child.getBoundingBox !== \"function\") {\n      return null;\n    }\n    var boundingBox = child.getBoundingBox(ctx);\n    if (!boundingBox) {\n      return null;\n    }\n    child.children.forEach((_2, i3) => {\n      var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i3);\n      boundingBox.addBoundingBox(childBoundingBox);\n    });\n    return boundingBox;\n  }\n  renderChild(ctx, textParent, parent, i2) {\n    var child = this.adjustChildCoordinates(ctx, textParent, parent, i2);\n    child.render(ctx);\n    child.children.forEach((_2, i3) => {\n      textParent.renderChild(ctx, textParent, child, i3);\n    });\n  }\n  measureTextRecursive(ctx) {\n    var width = this.children.reduce((width2, child) => width2 + child.measureTextRecursive(ctx), this.measureText(ctx));\n    return width;\n  }\n  measureText(ctx) {\n    var {\n      measureCache\n    } = this;\n    if (~measureCache) {\n      return measureCache;\n    }\n    var renderText = this.getText();\n    var measure = this.measureTargetText(ctx, renderText);\n    this.measureCache = measure;\n    return measure;\n  }\n  measureTargetText(ctx, targetText) {\n    if (!targetText.length) {\n      return 0;\n    }\n    var {\n      parent\n    } = this;\n    var customFont = parent.getStyle(\"font-family\").getDefinition();\n    if (customFont) {\n      var fontSize2 = this.getFontSize();\n      var text2 = customFont.isRTL ? targetText.split(\"\").reverse().join(\"\") : targetText;\n      var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n      var len = text2.length;\n      var _measure = 0;\n      for (var i2 = 0; i2 < len; i2++) {\n        var glyph = this.getGlyph(customFont, text2, i2);\n        _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize2 / customFont.fontFace.unitsPerEm;\n        if (typeof dx[i2] !== \"undefined\" && !isNaN(dx[i2])) {\n          _measure += dx[i2];\n        }\n      }\n      return _measure;\n    }\n    if (!ctx.measureText) {\n      return targetText.length * 10;\n    }\n    ctx.save();\n    this.setContext(ctx, true);\n    var {\n      width: measure\n    } = ctx.measureText(targetText);\n    this.clearContext(ctx);\n    ctx.restore();\n    return measure;\n  }\n}\nclass TSpanElement extends TextElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, new.target === TSpanElement ? true : captureTextNodes);\n    this.type = \"tspan\";\n    this.text = this.children.length > 0 ? \"\" : this.getTextFromNode();\n  }\n  getText() {\n    return this.text;\n  }\n}\nclass TextNode extends TSpanElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"textNode\";\n  }\n}\nclass SVGElement extends RenderedElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"svg\";\n    this.root = false;\n  }\n  setContext(ctx) {\n    var _this$node$parentNode;\n    var {\n      document: document2\n    } = this;\n    var {\n      screen,\n      window: window2\n    } = document2;\n    var canvas = ctx.canvas;\n    screen.setDefaults(ctx);\n    if (canvas.style && typeof ctx.font !== \"undefined\" && window2 && typeof window2.getComputedStyle !== \"undefined\") {\n      ctx.font = window2.getComputedStyle(canvas).getPropertyValue(\"font\");\n      var fontSizeProp = new Property(document2, \"fontSize\", Font.parse(ctx.font).fontSize);\n      if (fontSizeProp.hasValue()) {\n        document2.rootEmSize = fontSizeProp.getPixels(\"y\");\n        document2.emSize = document2.rootEmSize;\n      }\n    }\n    if (!this.getAttribute(\"x\").hasValue()) {\n      this.getAttribute(\"x\", true).setValue(0);\n    }\n    if (!this.getAttribute(\"y\").hasValue()) {\n      this.getAttribute(\"y\", true).setValue(0);\n    }\n    var {\n      width,\n      height\n    } = screen.viewPort;\n    if (!this.getStyle(\"width\").hasValue()) {\n      this.getStyle(\"width\", true).setValue(\"100%\");\n    }\n    if (!this.getStyle(\"height\").hasValue()) {\n      this.getStyle(\"height\", true).setValue(\"100%\");\n    }\n    if (!this.getStyle(\"color\").hasValue()) {\n      this.getStyle(\"color\", true).setValue(\"black\");\n    }\n    var refXAttr = this.getAttribute(\"refX\");\n    var refYAttr = this.getAttribute(\"refY\");\n    var viewBoxAttr = this.getAttribute(\"viewBox\");\n    var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n    var clip = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\";\n    var minX = 0;\n    var minY = 0;\n    var clipX = 0;\n    var clipY = 0;\n    if (viewBox) {\n      minX = viewBox[0];\n      minY = viewBox[1];\n    }\n    if (!this.root) {\n      width = this.getStyle(\"width\").getPixels(\"x\");\n      height = this.getStyle(\"height\").getPixels(\"y\");\n      if (this.type === \"marker\") {\n        clipX = minX;\n        clipY = minY;\n        minX = 0;\n        minY = 0;\n      }\n    }\n    screen.viewPort.setCurrent(width, height);\n    if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", false, true).hasValue() && !this.getStyle(\"transform-origin\", false, true).hasValue()) {\n      this.getStyle(\"transform-origin\", true, true).setValue(\"50% 50%\");\n    }\n    super.setContext(ctx);\n    ctx.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\"));\n    if (viewBox) {\n      width = viewBox[2];\n      height = viewBox[3];\n    }\n    document2.setViewBox({\n      ctx,\n      aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n      width: screen.viewPort.width,\n      desiredWidth: width,\n      height: screen.viewPort.height,\n      desiredHeight: height,\n      minX,\n      minY,\n      refX: refXAttr.getValue(),\n      refY: refYAttr.getValue(),\n      clip,\n      clipX,\n      clipY\n    });\n    if (viewBox) {\n      screen.viewPort.removeCurrent();\n      screen.viewPort.setCurrent(width, height);\n    }\n  }\n  clearContext(ctx) {\n    super.clearContext(ctx);\n    this.document.screen.viewPort.removeCurrent();\n  }\n  resize(width) {\n    var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;\n    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    var widthAttr = this.getAttribute(\"width\", true);\n    var heightAttr = this.getAttribute(\"height\", true);\n    var viewBoxAttr = this.getAttribute(\"viewBox\");\n    var styleAttr = this.getAttribute(\"style\");\n    var originWidth = widthAttr.getNumber(0);\n    var originHeight = heightAttr.getNumber(0);\n    if (preserveAspectRatio) {\n      if (typeof preserveAspectRatio === \"string\") {\n        this.getAttribute(\"preserveAspectRatio\", true).setValue(preserveAspectRatio);\n      } else {\n        var preserveAspectRatioAttr = this.getAttribute(\"preserveAspectRatio\");\n        if (preserveAspectRatioAttr.hasValue()) {\n          preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n        }\n      }\n    }\n    widthAttr.setValue(width);\n    heightAttr.setValue(height);\n    if (!viewBoxAttr.hasValue()) {\n      viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n    }\n    if (styleAttr.hasValue()) {\n      var widthStyle = this.getStyle(\"width\");\n      var heightStyle = this.getStyle(\"height\");\n      if (widthStyle.hasValue()) {\n        widthStyle.setValue(\"\".concat(width, \"px\"));\n      }\n      if (heightStyle.hasValue()) {\n        heightStyle.setValue(\"\".concat(height, \"px\"));\n      }\n    }\n  }\n}\nclass RectElement extends PathElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"rect\";\n  }\n  path(ctx) {\n    var x2 = this.getAttribute(\"x\").getPixels(\"x\");\n    var y2 = this.getAttribute(\"y\").getPixels(\"y\");\n    var width = this.getStyle(\"width\", false, true).getPixels(\"x\");\n    var height = this.getStyle(\"height\", false, true).getPixels(\"y\");\n    var rxAttr = this.getAttribute(\"rx\");\n    var ryAttr = this.getAttribute(\"ry\");\n    var rx = rxAttr.getPixels(\"x\");\n    var ry = ryAttr.getPixels(\"y\");\n    if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n      ry = rx;\n    }\n    if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n      rx = ry;\n    }\n    rx = Math.min(rx, width / 2);\n    ry = Math.min(ry, height / 2);\n    if (ctx) {\n      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n      ctx.beginPath();\n      if (height > 0 && width > 0) {\n        ctx.moveTo(x2 + rx, y2);\n        ctx.lineTo(x2 + width - rx, y2);\n        ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y2, x2 + width, y2 + ry - KAPPA * ry, x2 + width, y2 + ry);\n        ctx.lineTo(x2 + width, y2 + height - ry);\n        ctx.bezierCurveTo(x2 + width, y2 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y2 + height, x2 + width - rx, y2 + height);\n        ctx.lineTo(x2 + rx, y2 + height);\n        ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y2 + height, x2, y2 + height - ry + KAPPA * ry, x2, y2 + height - ry);\n        ctx.lineTo(x2, y2 + ry);\n        ctx.bezierCurveTo(x2, y2 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y2, x2 + rx, y2);\n        ctx.closePath();\n      }\n    }\n    return new BoundingBox(x2, y2, x2 + width, y2 + height);\n  }\n  getMarkers() {\n    return null;\n  }\n}\nclass CircleElement extends PathElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"circle\";\n  }\n  path(ctx) {\n    var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n    var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n    var r2 = this.getAttribute(\"r\").getPixels();\n    if (ctx && r2 > 0) {\n      ctx.beginPath();\n      ctx.arc(cx, cy, r2, 0, Math.PI * 2, false);\n      ctx.closePath();\n    }\n    return new BoundingBox(cx - r2, cy - r2, cx + r2, cy + r2);\n  }\n  getMarkers() {\n    return null;\n  }\n}\nclass EllipseElement extends PathElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"ellipse\";\n  }\n  path(ctx) {\n    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n    var rx = this.getAttribute(\"rx\").getPixels(\"x\");\n    var ry = this.getAttribute(\"ry\").getPixels(\"y\");\n    var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n    var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n    if (ctx && rx > 0 && ry > 0) {\n      ctx.beginPath();\n      ctx.moveTo(cx + rx, cy);\n      ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n      ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n      ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n      ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n      ctx.closePath();\n    }\n    return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n  }\n  getMarkers() {\n    return null;\n  }\n}\nclass LineElement extends PathElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"line\";\n  }\n  getPoints() {\n    return [new Point(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")), new Point(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))];\n  }\n  path(ctx) {\n    var [{\n      x: x0,\n      y: y0\n    }, {\n      x: x1,\n      y: y1\n    }] = this.getPoints();\n    if (ctx) {\n      ctx.beginPath();\n      ctx.moveTo(x0, y0);\n      ctx.lineTo(x1, y1);\n    }\n    return new BoundingBox(x0, y0, x1, y1);\n  }\n  getMarkers() {\n    var [p0, p12] = this.getPoints();\n    var a2 = p0.angleTo(p12);\n    return [[p0, a2], [p12, a2]];\n  }\n}\nclass PolylineElement extends PathElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"polyline\";\n    this.points = [];\n    this.points = Point.parsePath(this.getAttribute(\"points\").getString());\n  }\n  path(ctx) {\n    var {\n      points\n    } = this;\n    var [{\n      x: x0,\n      y: y0\n    }] = points;\n    var boundingBox = new BoundingBox(x0, y0);\n    if (ctx) {\n      ctx.beginPath();\n      ctx.moveTo(x0, y0);\n    }\n    points.forEach((_ref2) => {\n      var {\n        x: x2,\n        y: y2\n      } = _ref2;\n      boundingBox.addPoint(x2, y2);\n      if (ctx) {\n        ctx.lineTo(x2, y2);\n      }\n    });\n    return boundingBox;\n  }\n  getMarkers() {\n    var {\n      points\n    } = this;\n    var lastIndex = points.length - 1;\n    var markers = [];\n    points.forEach((point, i2) => {\n      if (i2 === lastIndex) {\n        return;\n      }\n      markers.push([point, point.angleTo(points[i2 + 1])]);\n    });\n    if (markers.length > 0) {\n      markers.push([points[points.length - 1], markers[markers.length - 1][1]]);\n    }\n    return markers;\n  }\n}\nclass PolygonElement extends PolylineElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"polygon\";\n  }\n  path(ctx) {\n    var boundingBox = super.path(ctx);\n    var [{\n      x: x2,\n      y: y2\n    }] = this.points;\n    if (ctx) {\n      ctx.lineTo(x2, y2);\n      ctx.closePath();\n    }\n    return boundingBox;\n  }\n}\nclass PatternElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"pattern\";\n  }\n  createPattern(ctx, _2, parentOpacityProp) {\n    var width = this.getStyle(\"width\").getPixels(\"x\", true);\n    var height = this.getStyle(\"height\").getPixels(\"y\", true);\n    var patternSvg = new SVGElement(this.document, null);\n    patternSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n    patternSvg.attributes.width = new Property(this.document, \"width\", \"\".concat(width, \"px\"));\n    patternSvg.attributes.height = new Property(this.document, \"height\", \"\".concat(height, \"px\"));\n    patternSvg.attributes.transform = new Property(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue());\n    patternSvg.children = this.children;\n    var patternCanvas = this.document.createCanvas(width, height);\n    var patternCtx = patternCanvas.getContext(\"2d\");\n    var xAttr = this.getAttribute(\"x\");\n    var yAttr = this.getAttribute(\"y\");\n    if (xAttr.hasValue() && yAttr.hasValue()) {\n      patternCtx.translate(xAttr.getPixels(\"x\", true), yAttr.getPixels(\"y\", true));\n    }\n    if (parentOpacityProp.hasValue()) {\n      this.styles[\"fill-opacity\"] = parentOpacityProp;\n    } else {\n      Reflect.deleteProperty(this.styles, \"fill-opacity\");\n    }\n    for (var x2 = -1; x2 <= 1; x2++) {\n      for (var y2 = -1; y2 <= 1; y2++) {\n        patternCtx.save();\n        patternSvg.attributes.x = new Property(this.document, \"x\", x2 * patternCanvas.width);\n        patternSvg.attributes.y = new Property(this.document, \"y\", y2 * patternCanvas.height);\n        patternSvg.render(patternCtx);\n        patternCtx.restore();\n      }\n    }\n    var pattern = ctx.createPattern(patternCanvas, \"repeat\");\n    return pattern;\n  }\n}\nclass MarkerElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"marker\";\n  }\n  render(ctx, point, angle2) {\n    if (!point) {\n      return;\n    }\n    var {\n      x: x2,\n      y: y2\n    } = point;\n    var orient = this.getAttribute(\"orient\").getString(\"auto\");\n    var markerUnits = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n    ctx.translate(x2, y2);\n    if (orient === \"auto\") {\n      ctx.rotate(angle2);\n    }\n    if (markerUnits === \"strokeWidth\") {\n      ctx.scale(ctx.lineWidth, ctx.lineWidth);\n    }\n    ctx.save();\n    var markerSvg = new SVGElement(this.document, null);\n    markerSvg.type = this.type;\n    markerSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n    markerSvg.attributes.refX = new Property(this.document, \"refX\", this.getAttribute(\"refX\").getValue());\n    markerSvg.attributes.refY = new Property(this.document, \"refY\", this.getAttribute(\"refY\").getValue());\n    markerSvg.attributes.width = new Property(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue());\n    markerSvg.attributes.height = new Property(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue());\n    markerSvg.attributes.overflow = new Property(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue());\n    markerSvg.attributes.fill = new Property(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\"));\n    markerSvg.attributes.stroke = new Property(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\"));\n    markerSvg.children = this.children;\n    markerSvg.render(ctx);\n    ctx.restore();\n    if (markerUnits === \"strokeWidth\") {\n      ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n    }\n    if (orient === \"auto\") {\n      ctx.rotate(-angle2);\n    }\n    ctx.translate(-x2, -y2);\n  }\n}\nclass DefsElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"defs\";\n  }\n  render() {\n  }\n}\nclass GElement extends RenderedElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"g\";\n  }\n  getBoundingBox(ctx) {\n    var boundingBox = new BoundingBox();\n    this.children.forEach((child) => {\n      boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n    });\n    return boundingBox;\n  }\n}\nclass GradientElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.attributesToInherit = [\"gradientUnits\"];\n    this.stops = [];\n    var {\n      stops,\n      children\n    } = this;\n    children.forEach((child) => {\n      if (child.type === \"stop\") {\n        stops.push(child);\n      }\n    });\n  }\n  getGradientUnits() {\n    return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n  }\n  createGradient(ctx, element, parentOpacityProp) {\n    var stopsContainer = this;\n    if (this.getHrefAttribute().hasValue()) {\n      stopsContainer = this.getHrefAttribute().getDefinition();\n      this.inheritStopContainer(stopsContainer);\n    }\n    var {\n      stops\n    } = stopsContainer;\n    var gradient = this.getGradient(ctx, element);\n    if (!gradient) {\n      return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n    }\n    stops.forEach((stop) => {\n      gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));\n    });\n    if (this.getAttribute(\"gradientTransform\").hasValue()) {\n      var {\n        document: document2\n      } = this;\n      var {\n        MAX_VIRTUAL_PIXELS,\n        viewPort\n      } = document2.screen;\n      var [rootView] = viewPort.viewPorts;\n      var rect = new RectElement(document2, null);\n      rect.attributes.x = new Property(document2, \"x\", -MAX_VIRTUAL_PIXELS / 3);\n      rect.attributes.y = new Property(document2, \"y\", -MAX_VIRTUAL_PIXELS / 3);\n      rect.attributes.width = new Property(document2, \"width\", MAX_VIRTUAL_PIXELS);\n      rect.attributes.height = new Property(document2, \"height\", MAX_VIRTUAL_PIXELS);\n      var group = new GElement(document2, null);\n      group.attributes.transform = new Property(document2, \"transform\", this.getAttribute(\"gradientTransform\").getValue());\n      group.children = [rect];\n      var patternSvg = new SVGElement(document2, null);\n      patternSvg.attributes.x = new Property(document2, \"x\", 0);\n      patternSvg.attributes.y = new Property(document2, \"y\", 0);\n      patternSvg.attributes.width = new Property(document2, \"width\", rootView.width);\n      patternSvg.attributes.height = new Property(document2, \"height\", rootView.height);\n      patternSvg.children = [group];\n      var patternCanvas = document2.createCanvas(rootView.width, rootView.height);\n      var patternCtx = patternCanvas.getContext(\"2d\");\n      patternCtx.fillStyle = gradient;\n      patternSvg.render(patternCtx);\n      return patternCtx.createPattern(patternCanvas, \"no-repeat\");\n    }\n    return gradient;\n  }\n  inheritStopContainer(stopsContainer) {\n    this.attributesToInherit.forEach((attributeToInherit) => {\n      if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n        this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n      }\n    });\n  }\n  addParentOpacity(parentOpacityProp, color2) {\n    if (parentOpacityProp.hasValue()) {\n      var colorProp = new Property(this.document, \"color\", color2);\n      return colorProp.addOpacity(parentOpacityProp).getColor();\n    }\n    return color2;\n  }\n}\nclass LinearGradientElement extends GradientElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"linearGradient\";\n    this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n  }\n  getGradient(ctx, element) {\n    var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n    var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n    if (isBoundingBoxUnits && !boundingBox) {\n      return null;\n    }\n    if (!this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue()) {\n      this.getAttribute(\"x1\", true).setValue(0);\n      this.getAttribute(\"y1\", true).setValue(0);\n      this.getAttribute(\"x2\", true).setValue(1);\n      this.getAttribute(\"y2\", true).setValue(0);\n    }\n    var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\");\n    var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\");\n    var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\");\n    var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n    if (x1 === x2 && y1 === y2) {\n      return null;\n    }\n    return ctx.createLinearGradient(x1, y1, x2, y2);\n  }\n}\nclass RadialGradientElement extends GradientElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"radialGradient\";\n    this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n  }\n  getGradient(ctx, element) {\n    var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n    var boundingBox = element.getBoundingBox(ctx);\n    if (isBoundingBoxUnits && !boundingBox) {\n      return null;\n    }\n    if (!this.getAttribute(\"cx\").hasValue()) {\n      this.getAttribute(\"cx\", true).setValue(\"50%\");\n    }\n    if (!this.getAttribute(\"cy\").hasValue()) {\n      this.getAttribute(\"cy\", true).setValue(\"50%\");\n    }\n    if (!this.getAttribute(\"r\").hasValue()) {\n      this.getAttribute(\"r\", true).setValue(\"50%\");\n    }\n    var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\");\n    var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\");\n    var fx = cx;\n    var fy = cy;\n    if (this.getAttribute(\"fx\").hasValue()) {\n      fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\");\n    }\n    if (this.getAttribute(\"fy\").hasValue()) {\n      fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\");\n    }\n    var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels();\n    var fr = this.getAttribute(\"fr\").getPixels();\n    return ctx.createRadialGradient(fx, fy, fr, cx, cy, r2);\n  }\n}\nclass StopElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"stop\";\n    var offset2 = Math.max(0, Math.min(1, this.getAttribute(\"offset\").getNumber()));\n    var stopOpacity = this.getStyle(\"stop-opacity\");\n    var stopColor = this.getStyle(\"stop-color\", true);\n    if (stopColor.getString() === \"\") {\n      stopColor.setValue(\"#000\");\n    }\n    if (stopOpacity.hasValue()) {\n      stopColor = stopColor.addOpacity(stopOpacity);\n    }\n    this.offset = offset2;\n    this.color = stopColor.getColor();\n  }\n}\nclass AnimateElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"animate\";\n    this.duration = 0;\n    this.initialValue = null;\n    this.initialUnits = \"\";\n    this.removed = false;\n    this.frozen = false;\n    document2.screen.animations.push(this);\n    this.begin = this.getAttribute(\"begin\").getMilliseconds();\n    this.maxDuration = this.begin + this.getAttribute(\"dur\").getMilliseconds();\n    this.from = this.getAttribute(\"from\");\n    this.to = this.getAttribute(\"to\");\n    this.values = new Property(document2, \"values\", null);\n    var valuesAttr = this.getAttribute(\"values\");\n    if (valuesAttr.hasValue()) {\n      this.values.setValue(valuesAttr.getString().split(\";\"));\n    }\n  }\n  getProperty() {\n    var attributeType = this.getAttribute(\"attributeType\").getString();\n    var attributeName = this.getAttribute(\"attributeName\").getString();\n    if (attributeType === \"CSS\") {\n      return this.parent.getStyle(attributeName, true);\n    }\n    return this.parent.getAttribute(attributeName, true);\n  }\n  calcValue() {\n    var {\n      initialUnits\n    } = this;\n    var {\n      progress,\n      from,\n      to\n    } = this.getProgress();\n    var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n    if (initialUnits === \"%\") {\n      newValue *= 100;\n    }\n    return \"\".concat(newValue).concat(initialUnits);\n  }\n  update(delta) {\n    var {\n      parent\n    } = this;\n    var prop = this.getProperty();\n    if (!this.initialValue) {\n      this.initialValue = prop.getString();\n      this.initialUnits = prop.getUnits();\n    }\n    if (this.duration > this.maxDuration) {\n      var fill = this.getAttribute(\"fill\").getString(\"remove\");\n      if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") {\n        this.duration = 0;\n      } else if (fill === \"freeze\" && !this.frozen) {\n        this.frozen = true;\n        parent.animationFrozen = true;\n        parent.animationFrozenValue = prop.getString();\n      } else if (fill === \"remove\" && !this.removed) {\n        this.removed = true;\n        prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n        return true;\n      }\n      return false;\n    }\n    this.duration += delta;\n    var updated = false;\n    if (this.begin < this.duration) {\n      var newValue = this.calcValue();\n      var typeAttr = this.getAttribute(\"type\");\n      if (typeAttr.hasValue()) {\n        var type = typeAttr.getString();\n        newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n      }\n      prop.setValue(newValue);\n      updated = true;\n    }\n    return updated;\n  }\n  getProgress() {\n    var {\n      document: document2,\n      values: values2\n    } = this;\n    var result = {\n      progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n    };\n    if (values2.hasValue()) {\n      var p5 = result.progress * (values2.getValue().length - 1);\n      var lb = Math.floor(p5);\n      var ub = Math.ceil(p5);\n      result.from = new Property(document2, \"from\", parseFloat(values2.getValue()[lb]));\n      result.to = new Property(document2, \"to\", parseFloat(values2.getValue()[ub]));\n      result.progress = (p5 - lb) / (ub - lb);\n    } else {\n      result.from = this.from;\n      result.to = this.to;\n    }\n    return result;\n  }\n}\nclass AnimateColorElement extends AnimateElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"animateColor\";\n  }\n  calcValue() {\n    var {\n      progress,\n      from,\n      to\n    } = this.getProgress();\n    var colorFrom = new rgbcolor(from.getColor());\n    var colorTo = new rgbcolor(to.getColor());\n    if (colorFrom.ok && colorTo.ok) {\n      var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n      var g2 = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n      var b2 = colorFrom.b + (colorTo.b - colorFrom.b) * progress;\n      return \"rgb(\".concat(Math.floor(r2), \", \").concat(Math.floor(g2), \", \").concat(Math.floor(b2), \")\");\n    }\n    return this.getAttribute(\"from\").getColor();\n  }\n}\nclass AnimateTransformElement extends AnimateElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"animateTransform\";\n  }\n  calcValue() {\n    var {\n      progress,\n      from,\n      to\n    } = this.getProgress();\n    var transformFrom = toNumbers(from.getString());\n    var transformTo = toNumbers(to.getString());\n    var newValue = transformFrom.map((from2, i2) => {\n      var to2 = transformTo[i2];\n      return from2 + (to2 - from2) * progress;\n    }).join(\" \");\n    return newValue;\n  }\n}\nclass FontElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"font\";\n    this.glyphs = {};\n    this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n    var {\n      definitions\n    } = document2;\n    var {\n      children\n    } = this;\n    for (var child of children) {\n      switch (child.type) {\n        case \"font-face\": {\n          this.fontFace = child;\n          var fontFamilyStyle = child.getStyle(\"font-family\");\n          if (fontFamilyStyle.hasValue()) {\n            definitions[fontFamilyStyle.getString()] = this;\n          }\n          break;\n        }\n        case \"missing-glyph\":\n          this.missingGlyph = child;\n          break;\n        case \"glyph\": {\n          var glyph = child;\n          if (glyph.arabicForm) {\n            this.isRTL = true;\n            this.isArabic = true;\n            if (typeof this.glyphs[glyph.unicode] === \"undefined\") {\n              this.glyphs[glyph.unicode] = {};\n            }\n            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;\n          } else {\n            this.glyphs[glyph.unicode] = glyph;\n          }\n          break;\n        }\n      }\n    }\n  }\n  render() {\n  }\n}\nclass FontFaceElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"font-face\";\n    this.ascent = this.getAttribute(\"ascent\").getNumber();\n    this.descent = this.getAttribute(\"descent\").getNumber();\n    this.unitsPerEm = this.getAttribute(\"units-per-em\").getNumber();\n  }\n}\nclass MissingGlyphElement extends PathElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"missing-glyph\";\n    this.horizAdvX = 0;\n  }\n}\nclass TRefElement extends TextElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"tref\";\n  }\n  getText() {\n    var element = this.getHrefAttribute().getDefinition();\n    if (element) {\n      var firstChild = element.children[0];\n      if (firstChild) {\n        return firstChild.getText();\n      }\n    }\n    return \"\";\n  }\n}\nclass AElement extends TextElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"a\";\n    var {\n      childNodes\n    } = node2;\n    var firstChild = childNodes[0];\n    var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);\n    this.hasText = hasText;\n    this.text = hasText ? this.getTextFromNode(firstChild) : \"\";\n  }\n  getText() {\n    return this.text;\n  }\n  renderChildren(ctx) {\n    if (this.hasText) {\n      super.renderChildren(ctx);\n      var {\n        document: document2,\n        x: x2,\n        y: y2\n      } = this;\n      var {\n        mouse\n      } = document2.screen;\n      var fontSize2 = new Property(document2, \"fontSize\", Font.parse(document2.ctx.font).fontSize);\n      if (mouse.isWorking()) {\n        mouse.checkBoundingBox(this, new BoundingBox(x2, y2 - fontSize2.getPixels(\"y\"), x2 + this.measureText(ctx), y2));\n      }\n    } else if (this.children.length > 0) {\n      var g2 = new GElement(this.document, null);\n      g2.children = this.children;\n      g2.parent = this;\n      g2.render(ctx);\n    }\n  }\n  onClick() {\n    var {\n      window: window2\n    } = this.document;\n    if (window2) {\n      window2.open(this.getHrefAttribute().getString());\n    }\n  }\n  onMouseMove() {\n    var ctx = this.document.ctx;\n    ctx.canvas.style.cursor = \"pointer\";\n  }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys3 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly)\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    keys3.push.apply(keys3, symbols);\n  }\n  return keys3;\n}\nfunction _objectSpread$2(target) {\n  for (var i2 = 1; i2 < arguments.length; i2++) {\n    var source = arguments[i2] != null ? arguments[i2] : {};\n    if (i2 % 2) {\n      ownKeys$2(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nclass TextPathElement extends TextElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"textPath\";\n    this.textWidth = 0;\n    this.textHeight = 0;\n    this.pathLength = -1;\n    this.glyphInfo = null;\n    this.letterSpacingCache = [];\n    this.measuresCache = /* @__PURE__ */ new Map([[\"\", 0]]);\n    var pathElement = this.getHrefAttribute().getDefinition();\n    this.text = this.getTextFromNode();\n    this.dataArray = this.parsePathData(pathElement);\n  }\n  getText() {\n    return this.text;\n  }\n  path(ctx) {\n    var {\n      dataArray\n    } = this;\n    if (ctx) {\n      ctx.beginPath();\n    }\n    dataArray.forEach((_ref2) => {\n      var {\n        type,\n        points\n      } = _ref2;\n      switch (type) {\n        case PathParser.LINE_TO:\n          if (ctx) {\n            ctx.lineTo(points[0], points[1]);\n          }\n          break;\n        case PathParser.MOVE_TO:\n          if (ctx) {\n            ctx.moveTo(points[0], points[1]);\n          }\n          break;\n        case PathParser.CURVE_TO:\n          if (ctx) {\n            ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n          }\n          break;\n        case PathParser.QUAD_TO:\n          if (ctx) {\n            ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n          }\n          break;\n        case PathParser.ARC: {\n          var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;\n          var r2 = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          if (ctx) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs));\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          }\n          break;\n        }\n        case PathParser.CLOSE_PATH:\n          if (ctx) {\n            ctx.closePath();\n          }\n          break;\n      }\n    });\n  }\n  renderChildren(ctx) {\n    this.setTextData(ctx);\n    ctx.save();\n    var textDecoration = this.parent.getStyle(\"text-decoration\").getString();\n    var fontSize2 = this.getFontSize();\n    var {\n      glyphInfo\n    } = this;\n    var fill = ctx.fillStyle;\n    if (textDecoration === \"underline\") {\n      ctx.beginPath();\n    }\n    glyphInfo.forEach((glyph, i2) => {\n      var {\n        p0,\n        p1: p12,\n        rotation,\n        text: partialText\n      } = glyph;\n      ctx.save();\n      ctx.translate(p0.x, p0.y);\n      ctx.rotate(rotation);\n      if (ctx.fillStyle) {\n        ctx.fillText(partialText, 0, 0);\n      }\n      if (ctx.strokeStyle) {\n        ctx.strokeText(partialText, 0, 0);\n      }\n      ctx.restore();\n      if (textDecoration === \"underline\") {\n        if (i2 === 0) {\n          ctx.moveTo(p0.x, p0.y + fontSize2 / 8);\n        }\n        ctx.lineTo(p12.x, p12.y + fontSize2 / 5);\n      }\n    });\n    if (textDecoration === \"underline\") {\n      ctx.lineWidth = fontSize2 / 20;\n      ctx.strokeStyle = fill;\n      ctx.stroke();\n      ctx.closePath();\n    }\n    ctx.restore();\n  }\n  getLetterSpacingAt() {\n    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n    return this.letterSpacingCache[idx] || 0;\n  }\n  findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c2, charI) {\n    var offset2 = inputOffset;\n    var glyphWidth = this.measureText(ctx, c2);\n    if (c2 === \" \" && anchor === \"justify\" && textFullWidth < fullPathWidth) {\n      glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n    }\n    if (charI > -1) {\n      offset2 += this.getLetterSpacingAt(charI);\n    }\n    var splineStep = this.textHeight / 20;\n    var p0 = this.getEquidistantPointOnPath(offset2, splineStep, 0);\n    var p12 = this.getEquidistantPointOnPath(offset2 + glyphWidth, splineStep, 0);\n    var segment = {\n      p0,\n      p1: p12\n    };\n    var rotation = p0 && p12 ? Math.atan2(p12.y - p0.y, p12.x - p0.x) : 0;\n    if (dy) {\n      var dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n      var dyY = Math.cos(-rotation) * dy;\n      segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {\n        x: p0.x + dyX,\n        y: p0.y + dyY\n      });\n      segment.p1 = _objectSpread$2(_objectSpread$2({}, p12), {}, {\n        x: p12.x + dyX,\n        y: p12.y + dyY\n      });\n    }\n    offset2 += glyphWidth;\n    return {\n      offset: offset2,\n      segment,\n      rotation\n    };\n  }\n  measureText(ctx, text2) {\n    var {\n      measuresCache\n    } = this;\n    var targetText = text2 || this.getText();\n    if (measuresCache.has(targetText)) {\n      return measuresCache.get(targetText);\n    }\n    var measure = this.measureTargetText(ctx, targetText);\n    measuresCache.set(targetText, measure);\n    return measure;\n  }\n  setTextData(ctx) {\n    if (this.glyphInfo) {\n      return;\n    }\n    var renderText = this.getText();\n    var chars2 = renderText.split(\"\");\n    var spacesNumber = renderText.split(\" \").length - 1;\n    var dx = this.parent.getAttribute(\"dx\").split().map((_2) => _2.getPixels(\"x\"));\n    var dy = this.parent.getAttribute(\"dy\").getPixels(\"y\");\n    var anchor = this.parent.getStyle(\"text-anchor\").getString(\"start\");\n    var thisSpacing = this.getStyle(\"letter-spacing\");\n    var parentSpacing = this.parent.getStyle(\"letter-spacing\");\n    var letterSpacing2 = 0;\n    if (!thisSpacing.hasValue() || thisSpacing.getValue() === \"inherit\") {\n      letterSpacing2 = parentSpacing.getPixels();\n    } else if (thisSpacing.hasValue()) {\n      if (thisSpacing.getValue() !== \"initial\" && thisSpacing.getValue() !== \"unset\") {\n        letterSpacing2 = thisSpacing.getPixels();\n      }\n    }\n    var letterSpacingCache = [];\n    var textLen = renderText.length;\n    this.letterSpacingCache = letterSpacingCache;\n    for (var i2 = 0; i2 < textLen; i2++) {\n      letterSpacingCache.push(typeof dx[i2] !== \"undefined\" ? dx[i2] : letterSpacing2);\n    }\n    var dxSum = letterSpacingCache.reduce((acc, cur, i3) => i3 === 0 ? 0 : acc + cur || 0, 0);\n    var textWidth = this.measureText(ctx);\n    var textFullWidth = Math.max(textWidth + dxSum, 0);\n    this.textWidth = textWidth;\n    this.textHeight = this.getFontSize();\n    this.glyphInfo = [];\n    var fullPathWidth = this.getPathLength();\n    var startOffset = this.getStyle(\"startOffset\").getNumber(0) * fullPathWidth;\n    var offset2 = 0;\n    if (anchor === \"middle\" || anchor === \"center\") {\n      offset2 = -textFullWidth / 2;\n    }\n    if (anchor === \"end\" || anchor === \"right\") {\n      offset2 = -textFullWidth;\n    }\n    offset2 += startOffset;\n    chars2.forEach((char, i3) => {\n      var {\n        offset: nextOffset,\n        segment,\n        rotation\n      } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset2, dy, char, i3);\n      offset2 = nextOffset;\n      if (!segment.p0 || !segment.p1) {\n        return;\n      }\n      this.glyphInfo.push({\n        text: chars2[i3],\n        p0: segment.p0,\n        p1: segment.p1,\n        rotation\n      });\n    });\n  }\n  parsePathData(path) {\n    this.pathLength = -1;\n    if (!path) {\n      return [];\n    }\n    var pathCommands = [];\n    var {\n      pathParser\n    } = path;\n    pathParser.reset();\n    while (!pathParser.isEnd()) {\n      var {\n        current\n      } = pathParser;\n      var startX = current ? current.x : 0;\n      var startY = current ? current.y : 0;\n      var command = pathParser.next();\n      var nextCommandType = command.type;\n      var points = [];\n      switch (command.type) {\n        case PathParser.MOVE_TO:\n          this.pathM(pathParser, points);\n          break;\n        case PathParser.LINE_TO:\n          nextCommandType = this.pathL(pathParser, points);\n          break;\n        case PathParser.HORIZ_LINE_TO:\n          nextCommandType = this.pathH(pathParser, points);\n          break;\n        case PathParser.VERT_LINE_TO:\n          nextCommandType = this.pathV(pathParser, points);\n          break;\n        case PathParser.CURVE_TO:\n          this.pathC(pathParser, points);\n          break;\n        case PathParser.SMOOTH_CURVE_TO:\n          nextCommandType = this.pathS(pathParser, points);\n          break;\n        case PathParser.QUAD_TO:\n          this.pathQ(pathParser, points);\n          break;\n        case PathParser.SMOOTH_QUAD_TO:\n          nextCommandType = this.pathT(pathParser, points);\n          break;\n        case PathParser.ARC:\n          points = this.pathA(pathParser);\n          break;\n        case PathParser.CLOSE_PATH:\n          PathElement.pathZ(pathParser);\n          break;\n      }\n      if (command.type !== PathParser.CLOSE_PATH) {\n        pathCommands.push({\n          type: nextCommandType,\n          points,\n          start: {\n            x: startX,\n            y: startY\n          },\n          pathLength: this.calcLength(startX, startY, nextCommandType, points)\n        });\n      } else {\n        pathCommands.push({\n          type: PathParser.CLOSE_PATH,\n          points: [],\n          pathLength: 0\n        });\n      }\n    }\n    return pathCommands;\n  }\n  pathM(pathParser, points) {\n    var {\n      x: x2,\n      y: y2\n    } = PathElement.pathM(pathParser).point;\n    points.push(x2, y2);\n  }\n  pathL(pathParser, points) {\n    var {\n      x: x2,\n      y: y2\n    } = PathElement.pathL(pathParser).point;\n    points.push(x2, y2);\n    return PathParser.LINE_TO;\n  }\n  pathH(pathParser, points) {\n    var {\n      x: x2,\n      y: y2\n    } = PathElement.pathH(pathParser).point;\n    points.push(x2, y2);\n    return PathParser.LINE_TO;\n  }\n  pathV(pathParser, points) {\n    var {\n      x: x2,\n      y: y2\n    } = PathElement.pathV(pathParser).point;\n    points.push(x2, y2);\n    return PathParser.LINE_TO;\n  }\n  pathC(pathParser, points) {\n    var {\n      point,\n      controlPoint,\n      currentPoint\n    } = PathElement.pathC(pathParser);\n    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n  }\n  pathS(pathParser, points) {\n    var {\n      point,\n      controlPoint,\n      currentPoint\n    } = PathElement.pathS(pathParser);\n    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    return PathParser.CURVE_TO;\n  }\n  pathQ(pathParser, points) {\n    var {\n      controlPoint,\n      currentPoint\n    } = PathElement.pathQ(pathParser);\n    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n  }\n  pathT(pathParser, points) {\n    var {\n      controlPoint,\n      currentPoint\n    } = PathElement.pathT(pathParser);\n    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    return PathParser.QUAD_TO;\n  }\n  pathA(pathParser) {\n    var {\n      rX,\n      rY,\n      sweepFlag,\n      xAxisRotation,\n      centp,\n      a1,\n      ad\n    } = PathElement.pathA(pathParser);\n    if (sweepFlag === 0 && ad > 0) {\n      ad -= 2 * Math.PI;\n    }\n    if (sweepFlag === 1 && ad < 0) {\n      ad += 2 * Math.PI;\n    }\n    return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];\n  }\n  calcLength(x2, y2, commandType, points) {\n    var len = 0;\n    var p12 = null;\n    var p22 = null;\n    var t3 = 0;\n    switch (commandType) {\n      case PathParser.LINE_TO:\n        return this.getLineLength(x2, y2, points[0], points[1]);\n      case PathParser.CURVE_TO:\n        len = 0;\n        p12 = this.getPointOnCubicBezier(0, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);\n        for (t3 = 0.01; t3 <= 1; t3 += 0.01) {\n          p22 = this.getPointOnCubicBezier(t3, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);\n          len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);\n          p12 = p22;\n        }\n        return len;\n      case PathParser.QUAD_TO:\n        len = 0;\n        p12 = this.getPointOnQuadraticBezier(0, x2, y2, points[0], points[1], points[2], points[3]);\n        for (t3 = 0.01; t3 <= 1; t3 += 0.01) {\n          p22 = this.getPointOnQuadraticBezier(t3, x2, y2, points[0], points[1], points[2], points[3]);\n          len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);\n          p12 = p22;\n        }\n        return len;\n      case PathParser.ARC: {\n        len = 0;\n        var start2 = points[4];\n        var dTheta = points[5];\n        var end = points[4] + dTheta;\n        var inc = Math.PI / 180;\n        if (Math.abs(start2 - end) < inc) {\n          inc = Math.abs(start2 - end);\n        }\n        p12 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start2, 0);\n        if (dTheta < 0) {\n          for (t3 = start2 - inc; t3 > end; t3 -= inc) {\n            p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);\n            len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);\n            p12 = p22;\n          }\n        } else {\n          for (t3 = start2 + inc; t3 < end; t3 += inc) {\n            p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);\n            len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);\n            p12 = p22;\n          }\n        }\n        p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n        len += this.getLineLength(p12.x, p12.y, p22.x, p22.y);\n        return len;\n      }\n    }\n    return 0;\n  }\n  getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n    var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;\n    var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;\n    var m2 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n    var run2 = Math.sqrt(dist * dist / (1 + m2 * m2));\n    if (p2x < p1x) {\n      run2 *= -1;\n    }\n    var rise = m2 * run2;\n    var pt2 = null;\n    if (p2x === p1x) {\n      pt2 = {\n        x: fromX,\n        y: fromY + rise\n      };\n    } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m2) {\n      pt2 = {\n        x: fromX + run2,\n        y: fromY + rise\n      };\n    } else {\n      var ix = 0;\n      var iy = 0;\n      var len = this.getLineLength(p1x, p1y, p2x, p2y);\n      if (len < PSEUDO_ZERO) {\n        return null;\n      }\n      var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n      u2 /= len * len;\n      ix = p1x + u2 * (p2x - p1x);\n      iy = p1y + u2 * (p2y - p1y);\n      var pRise = this.getLineLength(fromX, fromY, ix, iy);\n      var pRun = Math.sqrt(dist * dist - pRise * pRise);\n      run2 = Math.sqrt(pRun * pRun / (1 + m2 * m2));\n      if (p2x < p1x) {\n        run2 *= -1;\n      }\n      rise = m2 * run2;\n      pt2 = {\n        x: ix + run2,\n        y: iy + rise\n      };\n    }\n    return pt2;\n  }\n  getPointOnPath(distance2) {\n    var fullLen = this.getPathLength();\n    var cumulativePathLength = 0;\n    var p5 = null;\n    if (distance2 < -5e-5 || distance2 - 5e-5 > fullLen) {\n      return null;\n    }\n    var {\n      dataArray\n    } = this;\n    for (var command of dataArray) {\n      if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance2)) {\n        cumulativePathLength += command.pathLength;\n        continue;\n      }\n      var delta = distance2 - cumulativePathLength;\n      var currentT = 0;\n      switch (command.type) {\n        case PathParser.LINE_TO:\n          p5 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n          break;\n        case PathParser.ARC: {\n          var start2 = command.points[4];\n          var dTheta = command.points[5];\n          var end = command.points[4] + dTheta;\n          currentT = start2 + delta / command.pathLength * dTheta;\n          if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n            break;\n          }\n          p5 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n          break;\n        }\n        case PathParser.CURVE_TO:\n          currentT = delta / command.pathLength;\n          if (currentT > 1) {\n            currentT = 1;\n          }\n          p5 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n          break;\n        case PathParser.QUAD_TO:\n          currentT = delta / command.pathLength;\n          if (currentT > 1) {\n            currentT = 1;\n          }\n          p5 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n          break;\n      }\n      if (p5) {\n        return p5;\n      }\n      break;\n    }\n    return null;\n  }\n  getLineLength(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  getPathLength() {\n    if (this.pathLength === -1) {\n      this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);\n    }\n    return this.pathLength;\n  }\n  getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n    var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n    var y2 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n    return {\n      x: x2,\n      y: y2\n    };\n  }\n  getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n    var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n    var y2 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n    return {\n      x: x2,\n      y: y2\n    };\n  }\n  getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n    var cosPsi = Math.cos(psi);\n    var sinPsi = Math.sin(psi);\n    var pt2 = {\n      x: rx * Math.cos(theta),\n      y: ry * Math.sin(theta)\n    };\n    return {\n      x: cx + (pt2.x * cosPsi - pt2.y * sinPsi),\n      y: cy + (pt2.x * sinPsi + pt2.y * cosPsi)\n    };\n  }\n  buildEquidistantCache(inputStep, inputPrecision) {\n    var fullLen = this.getPathLength();\n    var precision = inputPrecision || 0.25;\n    var step = inputStep || fullLen / 100;\n    if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n      this.equidistantCache = {\n        step,\n        precision,\n        points: []\n      };\n      var s2 = 0;\n      for (var l2 = 0; l2 <= fullLen; l2 += precision) {\n        var p0 = this.getPointOnPath(l2);\n        var p12 = this.getPointOnPath(l2 + precision);\n        if (!p0 || !p12) {\n          continue;\n        }\n        s2 += this.getLineLength(p0.x, p0.y, p12.x, p12.y);\n        if (s2 >= step) {\n          this.equidistantCache.points.push({\n            x: p0.x,\n            y: p0.y,\n            distance: l2\n          });\n          s2 -= step;\n        }\n      }\n    }\n  }\n  getEquidistantPointOnPath(targetDistance, step, precision) {\n    this.buildEquidistantCache(step, precision);\n    if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {\n      return null;\n    }\n    var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n    return this.equidistantCache.points[idx] || null;\n  }\n}\nvar dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass ImageElement extends RenderedElement {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"image\";\n    this.loaded = false;\n    var href = this.getHrefAttribute().getString();\n    if (!href) {\n      return;\n    }\n    var isSvg = href.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(href);\n    document2.images.push(this);\n    if (!isSvg) {\n      void this.loadImage(href);\n    } else {\n      void this.loadSvg(href);\n    }\n    this.isSvg = isSvg;\n  }\n  loadImage(href) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        var image2 = yield _this.document.createImage(href);\n        _this.image = image2;\n      } catch (err) {\n        console.error('Error while loading image \"'.concat(href, '\":'), err);\n      }\n      _this.loaded = true;\n    })();\n  }\n  loadSvg(href) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var match2 = dataUriRegex.exec(href);\n      if (match2) {\n        var data2 = match2[5];\n        if (match2[4] === \"base64\") {\n          _this2.image = atob(data2);\n        } else {\n          _this2.image = decodeURIComponent(data2);\n        }\n      } else {\n        try {\n          var response = yield _this2.document.fetch(href);\n          var svg2 = yield response.text();\n          _this2.image = svg2;\n        } catch (err) {\n          console.error('Error while loading image \"'.concat(href, '\":'), err);\n        }\n      }\n      _this2.loaded = true;\n    })();\n  }\n  renderChildren(ctx) {\n    var {\n      document: document2,\n      image: image2,\n      loaded\n    } = this;\n    var x2 = this.getAttribute(\"x\").getPixels(\"x\");\n    var y2 = this.getAttribute(\"y\").getPixels(\"y\");\n    var width = this.getStyle(\"width\").getPixels(\"x\");\n    var height = this.getStyle(\"height\").getPixels(\"y\");\n    if (!loaded || !image2 || !width || !height) {\n      return;\n    }\n    ctx.save();\n    ctx.translate(x2, y2);\n    if (this.isSvg) {\n      var subDocument = document2.canvg.forkString(ctx, this.image, {\n        ignoreMouse: true,\n        ignoreAnimation: true,\n        ignoreDimensions: true,\n        ignoreClear: true,\n        offsetX: 0,\n        offsetY: 0,\n        scaleWidth: width,\n        scaleHeight: height\n      });\n      subDocument.document.documentElement.parent = this;\n      void subDocument.render();\n    } else {\n      var _image = this.image;\n      document2.setViewBox({\n        ctx,\n        aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n        width,\n        desiredWidth: _image.width,\n        height,\n        desiredHeight: _image.height\n      });\n      if (this.loaded) {\n        if (typeof _image.complete === \"undefined\" || _image.complete) {\n          ctx.drawImage(_image, 0, 0);\n        }\n      }\n    }\n    ctx.restore();\n  }\n  getBoundingBox() {\n    var x2 = this.getAttribute(\"x\").getPixels(\"x\");\n    var y2 = this.getAttribute(\"y\").getPixels(\"y\");\n    var width = this.getStyle(\"width\").getPixels(\"x\");\n    var height = this.getStyle(\"height\").getPixels(\"y\");\n    return new BoundingBox(x2, y2, x2 + width, y2 + height);\n  }\n}\nclass SymbolElement extends RenderedElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"symbol\";\n  }\n  render(_2) {\n  }\n}\nclass SVGFontLoader {\n  constructor(document2) {\n    this.document = document2;\n    this.loaded = false;\n    document2.fonts.push(this);\n  }\n  load(fontFamily2, url) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        var {\n          document: document2\n        } = _this;\n        var svgDocument = yield document2.canvg.parser.load(url);\n        var fonts = svgDocument.getElementsByTagName(\"font\");\n        Array.from(fonts).forEach((fontNode) => {\n          var font = document2.createElement(fontNode);\n          document2.definitions[fontFamily2] = font;\n        });\n      } catch (err) {\n        console.error('Error while loading font \"'.concat(url, '\":'), err);\n      }\n      _this.loaded = true;\n    })();\n  }\n}\nclass StyleElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"style\";\n    var css = compressSpaces(Array.from(node2.childNodes).map((_2) => _2.textContent).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\").replace(/@import.*;/g, \"\"));\n    var cssDefs = css.split(\"}\");\n    cssDefs.forEach((_2) => {\n      var def = _2.trim();\n      if (!def) {\n        return;\n      }\n      var cssParts = def.split(\"{\");\n      var cssClasses = cssParts[0].split(\",\");\n      var cssProps = cssParts[1].split(\";\");\n      cssClasses.forEach((_3) => {\n        var cssClass = _3.trim();\n        if (!cssClass) {\n          return;\n        }\n        var props = document2.styles[cssClass] || {};\n        cssProps.forEach((cssProp) => {\n          var prop = cssProp.indexOf(\":\");\n          var name = cssProp.substr(0, prop).trim();\n          var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n          if (name && value) {\n            props[name] = new Property(document2, name, value);\n          }\n        });\n        document2.styles[cssClass] = props;\n        document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n        if (cssClass === \"@font-face\") {\n          var fontFamily2 = props[\"font-family\"].getString().replace(/\"|'/g, \"\");\n          var srcs = props.src.getString().split(\",\");\n          srcs.forEach((src) => {\n            if (src.indexOf('format(\"svg\")') > 0) {\n              var url = parseExternalUrl(src);\n              if (url) {\n                void new SVGFontLoader(document2).load(fontFamily2, url);\n              }\n            }\n          });\n        }\n      });\n    });\n  }\n}\nStyleElement.parseExternalUrl = parseExternalUrl;\nclass UseElement extends RenderedElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"use\";\n  }\n  setContext(ctx) {\n    super.setContext(ctx);\n    var xAttr = this.getAttribute(\"x\");\n    var yAttr = this.getAttribute(\"y\");\n    if (xAttr.hasValue()) {\n      ctx.translate(xAttr.getPixels(\"x\"), 0);\n    }\n    if (yAttr.hasValue()) {\n      ctx.translate(0, yAttr.getPixels(\"y\"));\n    }\n  }\n  path(ctx) {\n    var {\n      element\n    } = this;\n    if (element) {\n      element.path(ctx);\n    }\n  }\n  renderChildren(ctx) {\n    var {\n      document: document2,\n      element\n    } = this;\n    if (element) {\n      var tempSvg = element;\n      if (element.type === \"symbol\") {\n        tempSvg = new SVGElement(document2, null);\n        tempSvg.attributes.viewBox = new Property(document2, \"viewBox\", element.getAttribute(\"viewBox\").getString());\n        tempSvg.attributes.preserveAspectRatio = new Property(document2, \"preserveAspectRatio\", element.getAttribute(\"preserveAspectRatio\").getString());\n        tempSvg.attributes.overflow = new Property(document2, \"overflow\", element.getAttribute(\"overflow\").getString());\n        tempSvg.children = element.children;\n        element.styles.opacity = new Property(document2, \"opacity\", this.calculateOpacity());\n      }\n      if (tempSvg.type === \"svg\") {\n        var widthStyle = this.getStyle(\"width\", false, true);\n        var heightStyle = this.getStyle(\"height\", false, true);\n        if (widthStyle.hasValue()) {\n          tempSvg.attributes.width = new Property(document2, \"width\", widthStyle.getString());\n        }\n        if (heightStyle.hasValue()) {\n          tempSvg.attributes.height = new Property(document2, \"height\", heightStyle.getString());\n        }\n      }\n      var oldParent = tempSvg.parent;\n      tempSvg.parent = this;\n      tempSvg.render(ctx);\n      tempSvg.parent = oldParent;\n    }\n  }\n  getBoundingBox(ctx) {\n    var {\n      element\n    } = this;\n    if (element) {\n      return element.getBoundingBox(ctx);\n    }\n    return null;\n  }\n  elementTransform() {\n    var {\n      document: document2,\n      element\n    } = this;\n    return Transform.fromElement(document2, element);\n  }\n  get element() {\n    if (!this.cachedElement) {\n      this.cachedElement = this.getHrefAttribute().getDefinition();\n    }\n    return this.cachedElement;\n  }\n}\nfunction imGet(img, x2, y2, width, _height, rgba) {\n  return img[y2 * width * 4 + x2 * 4 + rgba];\n}\nfunction imSet(img, x2, y2, width, _height, rgba, val) {\n  img[y2 * width * 4 + x2 * 4 + rgba] = val;\n}\nfunction m(matrix2, i2, v2) {\n  var mi = matrix2[i2];\n  return mi * v2;\n}\nfunction c(a2, m1, m2, m3) {\n  return m1 + Math.cos(a2) * m2 + Math.sin(a2) * m3;\n}\nclass FeColorMatrixElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"feColorMatrix\";\n    var matrix2 = toNumbers(this.getAttribute(\"values\").getString());\n    switch (this.getAttribute(\"type\").getString(\"matrix\")) {\n      case \"saturate\": {\n        var s2 = matrix2[0];\n        matrix2 = [0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n        break;\n      }\n      case \"hueRotate\": {\n        var a2 = matrix2[0] * Math.PI / 180;\n        matrix2 = [c(a2, 0.213, 0.787, -0.213), c(a2, 0.715, -0.715, -0.715), c(a2, 0.072, -0.072, 0.928), 0, 0, c(a2, 0.213, -0.213, 0.143), c(a2, 0.715, 0.285, 0.14), c(a2, 0.072, -0.072, -0.283), 0, 0, c(a2, 0.213, -0.213, -0.787), c(a2, 0.715, -0.715, 0.715), c(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n        break;\n      }\n      case \"luminanceToAlpha\":\n        matrix2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];\n        break;\n    }\n    this.matrix = matrix2;\n    this.includeOpacity = this.getAttribute(\"includeOpacity\").hasValue();\n  }\n  apply(ctx, _x, _y, width, height) {\n    var {\n      includeOpacity,\n      matrix: matrix2\n    } = this;\n    var srcData = ctx.getImageData(0, 0, width, height);\n    for (var y2 = 0; y2 < height; y2++) {\n      for (var x2 = 0; x2 < width; x2++) {\n        var r2 = imGet(srcData.data, x2, y2, width, height, 0);\n        var g2 = imGet(srcData.data, x2, y2, width, height, 1);\n        var b2 = imGet(srcData.data, x2, y2, width, height, 2);\n        var a2 = imGet(srcData.data, x2, y2, width, height, 3);\n        var nr = m(matrix2, 0, r2) + m(matrix2, 1, g2) + m(matrix2, 2, b2) + m(matrix2, 3, a2) + m(matrix2, 4, 1);\n        var ng = m(matrix2, 5, r2) + m(matrix2, 6, g2) + m(matrix2, 7, b2) + m(matrix2, 8, a2) + m(matrix2, 9, 1);\n        var nb = m(matrix2, 10, r2) + m(matrix2, 11, g2) + m(matrix2, 12, b2) + m(matrix2, 13, a2) + m(matrix2, 14, 1);\n        var na = m(matrix2, 15, r2) + m(matrix2, 16, g2) + m(matrix2, 17, b2) + m(matrix2, 18, a2) + m(matrix2, 19, 1);\n        if (includeOpacity) {\n          nr = 0;\n          ng = 0;\n          nb = 0;\n          na *= a2 / 255;\n        }\n        imSet(srcData.data, x2, y2, width, height, 0, nr);\n        imSet(srcData.data, x2, y2, width, height, 1, ng);\n        imSet(srcData.data, x2, y2, width, height, 2, nb);\n        imSet(srcData.data, x2, y2, width, height, 3, na);\n      }\n    }\n    ctx.clearRect(0, 0, width, height);\n    ctx.putImageData(srcData, 0, 0);\n  }\n}\nclass MaskElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"mask\";\n  }\n  apply(ctx, element) {\n    var {\n      document: document2\n    } = this;\n    var x2 = this.getAttribute(\"x\").getPixels(\"x\");\n    var y2 = this.getAttribute(\"y\").getPixels(\"y\");\n    var width = this.getStyle(\"width\").getPixels(\"x\");\n    var height = this.getStyle(\"height\").getPixels(\"y\");\n    if (!width && !height) {\n      var boundingBox = new BoundingBox();\n      this.children.forEach((child) => {\n        boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n      });\n      x2 = Math.floor(boundingBox.x1);\n      y2 = Math.floor(boundingBox.y1);\n      width = Math.floor(boundingBox.width);\n      height = Math.floor(boundingBox.height);\n    }\n    var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n    var maskCanvas = document2.createCanvas(x2 + width, y2 + height);\n    var maskCtx = maskCanvas.getContext(\"2d\");\n    document2.screen.setDefaults(maskCtx);\n    this.renderChildren(maskCtx);\n    new FeColorMatrixElement(document2, {\n      nodeType: 1,\n      childNodes: [],\n      attributes: [{\n        nodeName: \"type\",\n        value: \"luminanceToAlpha\"\n      }, {\n        nodeName: \"includeOpacity\",\n        value: \"true\"\n      }]\n    }).apply(maskCtx, 0, 0, x2 + width, y2 + height);\n    var tmpCanvas = document2.createCanvas(x2 + width, y2 + height);\n    var tmpCtx = tmpCanvas.getContext(\"2d\");\n    document2.screen.setDefaults(tmpCtx);\n    element.render(tmpCtx);\n    tmpCtx.globalCompositeOperation = \"destination-in\";\n    tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, \"no-repeat\");\n    tmpCtx.fillRect(0, 0, x2 + width, y2 + height);\n    ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, \"no-repeat\");\n    ctx.fillRect(0, 0, x2 + width, y2 + height);\n    this.restoreStyles(element, ignoredStyles);\n  }\n  render(_2) {\n  }\n}\nMaskElement.ignoreStyles = [\"mask\", \"transform\", \"clip-path\"];\nvar noop = () => {\n};\nclass ClipPathElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"clipPath\";\n  }\n  apply(ctx) {\n    var {\n      document: document2\n    } = this;\n    var contextProto = Reflect.getPrototypeOf(ctx);\n    var {\n      beginPath,\n      closePath\n    } = ctx;\n    if (contextProto) {\n      contextProto.beginPath = noop;\n      contextProto.closePath = noop;\n    }\n    Reflect.apply(beginPath, ctx, []);\n    this.children.forEach((child) => {\n      if (typeof child.path === \"undefined\") {\n        return;\n      }\n      var transform2 = typeof child.elementTransform !== \"undefined\" ? child.elementTransform() : null;\n      if (!transform2) {\n        transform2 = Transform.fromElement(document2, child);\n      }\n      if (transform2) {\n        transform2.apply(ctx);\n      }\n      child.path(ctx);\n      if (contextProto) {\n        contextProto.closePath = closePath;\n      }\n      if (transform2) {\n        transform2.unapply(ctx);\n      }\n    });\n    Reflect.apply(closePath, ctx, []);\n    ctx.clip();\n    if (contextProto) {\n      contextProto.beginPath = beginPath;\n      contextProto.closePath = closePath;\n    }\n  }\n  render(_2) {\n  }\n}\nclass FilterElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"filter\";\n  }\n  apply(ctx, element) {\n    var {\n      document: document2,\n      children\n    } = this;\n    var boundingBox = element.getBoundingBox(ctx);\n    if (!boundingBox) {\n      return;\n    }\n    var px = 0;\n    var py = 0;\n    children.forEach((child) => {\n      var efd = child.extraFilterDistance || 0;\n      px = Math.max(px, efd);\n      py = Math.max(py, efd);\n    });\n    var width = Math.floor(boundingBox.width);\n    var height = Math.floor(boundingBox.height);\n    var tmpCanvasWidth = width + 2 * px;\n    var tmpCanvasHeight = height + 2 * py;\n    if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n      return;\n    }\n    var x2 = Math.floor(boundingBox.x);\n    var y2 = Math.floor(boundingBox.y);\n    var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n    var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n    var tmpCtx = tmpCanvas.getContext(\"2d\");\n    document2.screen.setDefaults(tmpCtx);\n    tmpCtx.translate(-x2 + px, -y2 + py);\n    element.render(tmpCtx);\n    children.forEach((child) => {\n      if (typeof child.apply === \"function\") {\n        child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n      }\n    });\n    ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y2 - py, tmpCanvasWidth, tmpCanvasHeight);\n    this.restoreStyles(element, ignoredStyles);\n  }\n  render(_2) {\n  }\n}\nFilterElement.ignoreStyles = [\"filter\", \"transform\", \"clip-path\"];\nclass FeDropShadowElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"feDropShadow\";\n    this.addStylesFromStyleDefinition();\n  }\n  apply(_2, _x, _y, _width, _height) {\n  }\n}\nclass FeMorphologyElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"feMorphology\";\n  }\n  apply(_2, _x, _y, _width, _height) {\n  }\n}\nclass FeCompositeElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"feComposite\";\n  }\n  apply(_2, _x, _y, _width, _height) {\n  }\n}\nclass FeGaussianBlurElement extends Element$1 {\n  constructor(document2, node2, captureTextNodes) {\n    super(document2, node2, captureTextNodes);\n    this.type = \"feGaussianBlur\";\n    this.blurRadius = Math.floor(this.getAttribute(\"stdDeviation\").getNumber());\n    this.extraFilterDistance = this.blurRadius;\n  }\n  apply(ctx, x2, y2, width, height) {\n    var {\n      document: document2,\n      blurRadius\n    } = this;\n    var body = document2.window ? document2.window.document.body : null;\n    var canvas = ctx.canvas;\n    canvas.id = document2.getUniqueId();\n    if (body) {\n      canvas.style.display = \"none\";\n      body.appendChild(canvas);\n    }\n    processCanvasRGBA(canvas, x2, y2, width, height, blurRadius);\n    if (body) {\n      body.removeChild(canvas);\n    }\n  }\n}\nclass TitleElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"title\";\n  }\n}\nclass DescElement extends Element$1 {\n  constructor() {\n    super(...arguments);\n    this.type = \"desc\";\n  }\n}\nvar elements = {\n  \"svg\": SVGElement,\n  \"rect\": RectElement,\n  \"circle\": CircleElement,\n  \"ellipse\": EllipseElement,\n  \"line\": LineElement,\n  \"polyline\": PolylineElement,\n  \"polygon\": PolygonElement,\n  \"path\": PathElement,\n  \"pattern\": PatternElement,\n  \"marker\": MarkerElement,\n  \"defs\": DefsElement,\n  \"linearGradient\": LinearGradientElement,\n  \"radialGradient\": RadialGradientElement,\n  \"stop\": StopElement,\n  \"animate\": AnimateElement,\n  \"animateColor\": AnimateColorElement,\n  \"animateTransform\": AnimateTransformElement,\n  \"font\": FontElement,\n  \"font-face\": FontFaceElement,\n  \"missing-glyph\": MissingGlyphElement,\n  \"glyph\": GlyphElement,\n  \"text\": TextElement,\n  \"tspan\": TSpanElement,\n  \"tref\": TRefElement,\n  \"a\": AElement,\n  \"textPath\": TextPathElement,\n  \"image\": ImageElement,\n  \"g\": GElement,\n  \"symbol\": SymbolElement,\n  \"style\": StyleElement,\n  \"use\": UseElement,\n  \"mask\": MaskElement,\n  \"clipPath\": ClipPathElement,\n  \"filter\": FilterElement,\n  \"feDropShadow\": FeDropShadowElement,\n  \"feMorphology\": FeMorphologyElement,\n  \"feComposite\": FeCompositeElement,\n  \"feColorMatrix\": FeColorMatrixElement,\n  \"feGaussianBlur\": FeGaussianBlurElement,\n  \"title\": TitleElement,\n  \"desc\": DescElement\n};\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys3 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly)\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    keys3.push.apply(keys3, symbols);\n  }\n  return keys3;\n}\nfunction _objectSpread$1(target) {\n  for (var i2 = 1; i2 < arguments.length; i2++) {\n    var source = arguments[i2] != null ? arguments[i2] : {};\n    if (i2 % 2) {\n      ownKeys$1(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction createCanvas(width, height) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n}\nfunction createImage(_x) {\n  return _createImage.apply(this, arguments);\n}\nfunction _createImage() {\n  _createImage = _asyncToGenerator(function* (src) {\n    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    var image2 = document.createElement(\"img\");\n    if (anonymousCrossOrigin) {\n      image2.crossOrigin = \"Anonymous\";\n    }\n    return new Promise((resolve2, reject2) => {\n      image2.onload = () => {\n        resolve2(image2);\n      };\n      image2.onerror = (_event, _source, _lineno, _colno, error) => {\n        reject2(error);\n      };\n      image2.src = src;\n    });\n  });\n  return _createImage.apply(this, arguments);\n}\nclass Document {\n  constructor(canvg) {\n    var {\n      rootEmSize = 12,\n      emSize = 12,\n      createCanvas: createCanvas2 = Document.createCanvas,\n      createImage: createImage2 = Document.createImage,\n      anonymousCrossOrigin\n    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    this.canvg = canvg;\n    this.definitions = {};\n    this.styles = {};\n    this.stylesSpecificity = {};\n    this.images = [];\n    this.fonts = [];\n    this.emSizeStack = [];\n    this.uniqueId = 0;\n    this.screen = canvg.screen;\n    this.rootEmSize = rootEmSize;\n    this.emSize = emSize;\n    this.createCanvas = createCanvas2;\n    this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);\n    this.screen.wait(this.isImagesLoaded.bind(this));\n    this.screen.wait(this.isFontsLoaded.bind(this));\n  }\n  bindCreateImage(createImage2, anonymousCrossOrigin) {\n    if (typeof anonymousCrossOrigin === \"boolean\") {\n      return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === \"boolean\" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);\n    }\n    return createImage2;\n  }\n  get window() {\n    return this.screen.window;\n  }\n  get fetch() {\n    return this.screen.fetch;\n  }\n  get ctx() {\n    return this.screen.ctx;\n  }\n  get emSize() {\n    var {\n      emSizeStack\n    } = this;\n    return emSizeStack[emSizeStack.length - 1];\n  }\n  set emSize(value) {\n    var {\n      emSizeStack\n    } = this;\n    emSizeStack.push(value);\n  }\n  popEmSize() {\n    var {\n      emSizeStack\n    } = this;\n    emSizeStack.pop();\n  }\n  getUniqueId() {\n    return \"canvg\".concat(++this.uniqueId);\n  }\n  isImagesLoaded() {\n    return this.images.every((_2) => _2.loaded);\n  }\n  isFontsLoaded() {\n    return this.fonts.every((_2) => _2.loaded);\n  }\n  createDocumentElement(document2) {\n    var documentElement = this.createElement(document2.documentElement);\n    documentElement.root = true;\n    documentElement.addStylesFromStyleDefinition();\n    this.documentElement = documentElement;\n    return documentElement;\n  }\n  createElement(node2) {\n    var elementType = node2.nodeName.replace(/^[^:]+:/, \"\");\n    var ElementType = Document.elementTypes[elementType];\n    if (typeof ElementType !== \"undefined\") {\n      return new ElementType(this, node2);\n    }\n    return new UnknownElement(this, node2);\n  }\n  createTextNode(node2) {\n    return new TextNode(this, node2);\n  }\n  setViewBox(config) {\n    this.screen.setViewBox(_objectSpread$1({\n      document: this\n    }, config));\n  }\n}\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\nfunction ownKeys2(object, enumerableOnly) {\n  var keys3 = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly)\n      symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    keys3.push.apply(keys3, symbols);\n  }\n  return keys3;\n}\nfunction _objectSpread(target) {\n  for (var i2 = 1; i2 < arguments.length; i2++) {\n    var source = arguments[i2] != null ? arguments[i2] : {};\n    if (i2 % 2) {\n      ownKeys2(Object(source), true).forEach(function(key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys2(Object(source)).forEach(function(key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nclass Canvg {\n  constructor(ctx, svg2) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    this.parser = new Parser(options);\n    this.screen = new Screen(ctx, options);\n    this.options = options;\n    var document2 = new Document(this, options);\n    var documentElement = document2.createDocumentElement(svg2);\n    this.document = document2;\n    this.documentElement = documentElement;\n  }\n  static from(ctx, svg2) {\n    var _arguments = arguments;\n    return _asyncToGenerator(function* () {\n      var options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};\n      var parser = new Parser(options);\n      var svgDocument = yield parser.parse(svg2);\n      return new Canvg(ctx, svgDocument, options);\n    })();\n  }\n  static fromString(ctx, svg2) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var parser = new Parser(options);\n    var svgDocument = parser.parseFromString(svg2);\n    return new Canvg(ctx, svgDocument, options);\n  }\n  fork(ctx, svg2) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return Canvg.from(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));\n  }\n  forkString(ctx, svg2) {\n    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return Canvg.fromString(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));\n  }\n  ready() {\n    return this.screen.ready();\n  }\n  isReady() {\n    return this.screen.isReady();\n  }\n  render() {\n    var _arguments2 = arguments, _this = this;\n    return _asyncToGenerator(function* () {\n      var options = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};\n      _this.start(_objectSpread({\n        enableRedraw: true,\n        ignoreAnimation: true,\n        ignoreMouse: true\n      }, options));\n      yield _this.ready();\n      _this.stop();\n    })();\n  }\n  start() {\n    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    var {\n      documentElement,\n      screen,\n      options: baseOptions\n    } = this;\n    screen.start(documentElement, _objectSpread(_objectSpread({\n      enableRedraw: true\n    }, baseOptions), options));\n  }\n  stop() {\n    this.screen.stop();\n  }\n  resize(width) {\n    var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;\n    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    this.documentElement.resize(width, height, preserveAspectRatio);\n  }\n}\nvar index_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  \"default\": Canvg,\n  AElement,\n  AnimateColorElement,\n  AnimateElement,\n  AnimateTransformElement,\n  BoundingBox,\n  CB1,\n  CB2,\n  CB3,\n  CB4,\n  Canvg,\n  CircleElement,\n  ClipPathElement,\n  DefsElement,\n  DescElement,\n  Document,\n  Element: Element$1,\n  EllipseElement,\n  FeColorMatrixElement,\n  FeCompositeElement,\n  FeDropShadowElement,\n  FeGaussianBlurElement,\n  FeMorphologyElement,\n  FilterElement,\n  Font,\n  FontElement,\n  FontFaceElement,\n  GElement,\n  GlyphElement,\n  GradientElement,\n  ImageElement,\n  LineElement,\n  LinearGradientElement,\n  MarkerElement,\n  MaskElement,\n  Matrix,\n  MissingGlyphElement,\n  Mouse,\n  PSEUDO_ZERO,\n  Parser,\n  PathElement,\n  PathParser,\n  PatternElement,\n  Point,\n  PolygonElement,\n  PolylineElement,\n  Property,\n  QB1,\n  QB2,\n  QB3,\n  RadialGradientElement,\n  RectElement,\n  RenderedElement,\n  Rotate,\n  SVGElement,\n  SVGFontLoader,\n  Scale,\n  Screen,\n  Skew,\n  SkewX,\n  SkewY,\n  StopElement,\n  StyleElement,\n  SymbolElement,\n  TRefElement,\n  TSpanElement,\n  TextElement,\n  TextPathElement,\n  TitleElement,\n  Transform,\n  Translate,\n  UnknownElement,\n  UseElement,\n  ViewPort,\n  compressSpaces,\n  getSelectorSpecificity,\n  normalizeAttributeName,\n  normalizeColor,\n  parseExternalUrl,\n  presets: index,\n  toNumbers,\n  trimLeft,\n  trimRight,\n  vectorMagnitude,\n  vectorsAngle,\n  vectorsRatio\n}, Symbol.toStringTag, { value: \"Module\" }));\n\n\n\n//# sourceURL=webpack://web-dashboard/./node_modules/vue3-openlayers/dist/vue3-openlayers.es.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;